<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jackson Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jackson Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jackson">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jackson Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jackson Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/25/picture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/25/picture/" class="post-title-link" itemprop="url">picture</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-25 21:11:50 / Modified: 21:29:12" itemprop="dateCreated datePublished" datetime="2020-04-25T21:11:50-05:00">2020-04-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/2020/04/25/picture/mengxiaowang/blog/source/_posts/picture/a.jpg" alt="a"></p>
<p>welcome</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/25/linux%E5%9F%BA%E7%A1%802/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/25/linux%E5%9F%BA%E7%A1%802/" class="post-title-link" itemprop="url">linux基础（19-35集）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-25 16:41:07 / Modified: 21:04:04" itemprop="dateCreated datePublished" datetime="2020-04-25T16:41:07-05:00">2020-04-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="linux-100集"><a href="#linux-100集" class="headerlink" title="linux 100集"></a>linux 100集</h1><h2 id="P19-22-文件和目录（ls常用选项）"><a href="#P19-22-文件和目录（ls常用选项）" class="headerlink" title="P19-22 文件和目录（ls常用选项）"></a>P19-22 文件和目录（ls常用选项）</h2><p>自动不全：tab键</p>
<p>查看曾经用过命令：上下光标键，退出选择用ctrl+c</p>
<p>ls命令扩展：</p>
<p>最常用，.开头的文件为隐藏文件，需要-a才可以打开， ls -a才可以显示出来</p>
<p>.表示当前目录 </p>
<p>..表示上级目录， cd ..返回上一个目录</p>
<p>ls -l以列表方式显示文件详细信息</p>
<p>ls -h配合-l以人性化方式显示文件大小（文件大小用k，m表示，而不是byte，人易读）：ls -l -h或者 ls -lh</p>
<p>所以可以ls -alh</p>
<p>drw… 这里d是目录</p>
<h2 id="P23-文件和目录（ls常用通配符）"><a href="#P23-文件和目录（ls常用通配符）" class="headerlink" title="P23 文件和目录（ls常用通配符）"></a>P23 文件和目录（ls常用通配符）</h2><p>*：任意个数字符(0或多个)</p>
<p>？：任意一个字符，至少一个（只一个，不可为0）</p>
<p>[]:可匹配字符组任意一个</p>
<p>ls功能： 列出非目录的文件项，然后是每一个目录中的“可显示”文件（可理解为ls命令将本目录向下展开两级）</p>
<p>ls用法：ls  [参数]  [目录名]</p>
<p>​    （如过要显示当前目录的文件可不加目录名）</p>
<p>ls常用参数</p>
<p>   -a 显示所有文件，包含隐藏文件</p>
<p>   -A 显示所有文件，包含隐藏文件，但不包含.及..</p>
<p> -l  显示为long format（长格式），列出文件的类型、权限、链接数、owner、group、大 小，时间，名字</p>
<p>   -R  </p>
<p>   -d 不展开目录，只显示目录自身，一般与-l配合使用以显示目录自身的属性信息（只显示当前目录的内容）</p>
<p>   -1 数字1，成列显示内容</p>
<p>   -S 以文件大小排序显示，默认从大到小 -r后，从小到大</p>
<p>   -U 按存放顺序排序显示</p>
<p>   -X 按扩展名的首字母来排序</p>
<p>   -t  按mtime排序（先显示时间最近的）</p>
<p>   -ul  按atime排序（先显示时间最近的）</p>
<p>   -ct  按ctime排序（先显示时间最近的）</p>
<p>​     补充：</p>
<p>关于时间戳：</p>
<p>​     atime  访问时间</p>
<p>​     mtime 数据修改时间 （写入，修改数据mtime改变，mtime改变ctime必改变）</p>
<p>​     ctime  元数据修改时间 （修改权限的时候只有ctime改变）</p>
<p>​     可过“stat 文件路径”查看全部时间戳</p>
<p><strong>扩展**</strong>: 如何通过ls只显示指定格式的文件**</p>
<p>首先我们要了解什么是文件名通配符</p>
<p>Shell提供了一套完整的字符串模式匹配规则，或者称之为元字符，当s h e l l遇到上述字符时，就会把它们当作特殊字符，而不是文件名中的普通字符，这样用户就可以用它们来匹配相应的文件名，我理解这可以称为通配符。</p>
<p>常用通配符：</p>
<p>* 匹配0或多个任意字符</p>
<p>? 匹配任意1个字符</p>
<p>[  ]  当中括号内为几个确定字符时，表示匹配括号内任意一个字符，当中括号内为一个范围时表示匹配这个范围中的任意一个字符（中括号表示的是一个范围，匹配的是一个字符）</p>
<p>例：</p>
<p> [ab46e] 表示是a,b,4,6,e中的任意一个字符</p>
<p> [a-z] 表示aAbBcC……z（Linux中的默认编码顺序是一个小写字母一个大写字母即aAbBcC…..Z）</p>
<p>​     [A-Z] 表示AbBcC……Z</p>
<p>​    [a- Z] 表示所有大小写字母</p>
<p>​    [^ae] 表示即不是a也不是e的其他任意单一字符</p>
<p>[:lower:] 表示一个小写字母 </p>
<p>[:upper:] 表示一个大写字母</p>
<p>[:alpha:] 表示一个大小写字母 等同于[a-Z]</p>
<p>[:digit:]  表示任意一个数字 等同于[0-9]</p>
<p>[:alnum:] 表示任意一个字母或数字 等于[a-Z0-9]或[[:digit:][:alpha:]]</p>
<p>[:blank:]：一个水平空白字符</p>
<p>[:space:]：一个水平或垂直空白字符（文件名不可能包含回车，故此处使用与[:blank:]：效果相同）</p>
<p>通过ls命令和通配符查找指定格式的文件：</p>
<p> 格式：ls  [参数]  [目录名][通配符]</p>
<p>以下是一些例子：</p>
<p>\1. 查找/usr/share/man 目录下以m开头且以一个数字加x结尾的文件</p>
<p>命令：ls  -d  /usr/share/man/m*[0-9]x</p>
<p>运行结果：</p>
<p> <img src="https://images2018.cnblogs.com/blog/1440488/201807/1440488-20180714174106974-1962045890.png" alt="img"></p>
<p>解释：-d 只展开一级目录</p>
<p>   /usr/share/man/  目录路径</p>
<p> m*[0-9]x  m表示以m开头，[0-9]x表示以数字加x结尾,因为对文件的中间没</p>
<p>有加以限制所以用<em>代替中间部分，</em>表示任意个数的任意字符</p>
<p>\2. 查找root下的隐藏文件和目录</p>
<p>   命令： ls  -d  /root/.*</p>
<p>   运行结果：</p>
<p><img src="https://images2018.cnblogs.com/blog/1440488/201807/1440488-20180714174309686-515187362.png" alt="img"></p>
<p>解释：-d 只展开一级目录</p>
<p>   /root 目录路径</p>
<p>   因为Linux下以“.”开头的文件是隐藏文件，所以用“.”加上“*”来表示隐藏文件</p>
<p>\3. 查找/etc下所有以k开头，以一个小写字母结尾，且中间出现至少一位数字的文件</p>
<p>​    命令：ls  -d  /etc/k<em>[0-9]</em>[[:lower:]]</p>
<p>​    运行结果：</p>
<p> <img src="https://images2018.cnblogs.com/blog/1440488/201807/1440488-20180714174409329-147595255.png" alt="img"></p>
<p>解释：-d 只展开一级目录 </p>
<p>   /etc 目录路径</p>
<p>​    k表示以k开头，[0-9]表示一个数字，[[:lower:]]表示一个小写字母，因为[:lower:]表示为小写字母，也就是abcdefg…z，所以在[:lower:]外面加</p>
<p>   上[ ]以表示在这写子母中取任意一个，因为只规定了开头和结尾，对中间只要求至少出现一位数字，所以中间用*[0-9]*来表示</p>
<h2 id="P25-文件和目录（cd常用选项）"><a href="#P25-文件和目录（cd常用选项）" class="headerlink" title="P25 文件和目录（cd常用选项）"></a>P25 文件和目录（cd常用选项）</h2><p>cd </p>
<p>跳入test目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com]#cd testDir&#x2F;</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#ls</span><br><span class="line">file1  file2  file3</span><br></pre></td></tr></table></figure>

<p>跳至上层目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#cd ..</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com]#ls</span><br><span class="line">testDir</span><br></pre></td></tr></table></figure>

<p>跳至上上层目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#cd ..&#x2F;..&#x2F;</span><br><span class="line">[root@&#x2F;root]#ls</span><br></pre></td></tr></table></figure>

<p>跳入用户主目录: cd ~或者cd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#ls</span><br><span class="line">file1  file2  file3</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#cd ~&#x2F;</span><br><span class="line">[root@&#x2F;root]#pwd</span><br><span class="line">&#x2F;root</span><br></pre></td></tr></table></figure>

<p>使用绝对路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@&#x2F;root]#cd &#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#ls</span><br><span class="line">file1  file2  file3</span><br></pre></td></tr></table></figure>

<p>使用环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@&#x2F;root]#cd $TEST_PATH</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#ls</span><br><span class="line">file1  file2  file3</span><br></pre></td></tr></table></figure>

<p>跳入上次使用目录: cd -, 可以在最近两次工作目录间切换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@&#x2F;root]#pwd</span><br><span class="line">&#x2F;root</span><br><span class="line">[root@&#x2F;root]#cd -</span><br><span class="line">&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#</span><br></pre></td></tr></table></figure>

<h2 id="P26-文件和目录（相对路径绝对路径）"><a href="#P26-文件和目录（相对路径绝对路径）" class="headerlink" title="P26 文件和目录（相对路径绝对路径）"></a>P26 文件和目录（相对路径绝对路径）</h2><ul>
<li>绝对路径：路径的写法一定是由根目录 / 写起的，例如 /usr/local/mysql</li>
<li>相对路径：路径的写法不是由根目录 / 写起的，例如 首先用户进入到 /home，然后再进入到test，执行的命令为 “#cd /home,#cd test”。此时用户所在的路径为 /home/test。第一个cd命令后紧跟/home，前面有斜杠；而第二个cd命令后紧跟test，前面没有斜杠。<strong>这个test是相对于/home目录来讲的，所以称为相对路径</strong>。</li>
</ul>
<h2 id="P27-文件和目录（mkdir和touch）"><a href="#P27-文件和目录（mkdir和touch）" class="headerlink" title="P27 文件和目录（mkdir和touch）"></a>P27 文件和目录（mkdir和touch）</h2><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p>
<p>ls -l 可以显示档案的时间记录。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数说明</strong>：</li>
<li>a 改变档案的读取时间记录。</li>
<li>m 改变档案的修改时间记录。</li>
<li>c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。</li>
<li>f 不使用，是为了与其他 unix 系统的相容性而保留。</li>
<li>r 使用参考档的时间记录，与 –file 的效果一样。</li>
<li>d 设定时间与日期，可以使用各种不同的格式。</li>
<li>t 设定档案的时间记录，格式与 date 指令相同。</li>
<li>–no-create 不会建立新档案。</li>
<li>–help 列出指令格式。</li>
<li>–version 列出版本讯息。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用指令”touch”修改文件”testfile”的时间属性为当前系统时间，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch testfile                #修改文件的时间属性</span><br></pre></td></tr></table></figure>

<p>首先，使用ls命令查看testfile文件的属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#原来文件的修改时间为16:09  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile</span><br></pre></td></tr></table></figure>

<p>执行指令”touch”修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch testfile                #修改文件时间属性为当前系统时间  </span><br><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#修改后文件的时间属性为当前系统时间  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile</span><br></pre></td></tr></table></figure>

<p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch file            #创建一个名为“file”的新的空白文件</span><br></pre></td></tr></table></figure>

<p>Linux mkdir命令用于建立名称为 dirName 之子目录。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-p] dirName</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-p 确保目录名称存在，不存在的就建一个。</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>在工作目录下，建立一个名为 AAA 的子目录 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir AAA</span><br></pre></td></tr></table></figure>

<p>在工作目录下的 BBB 目录中，建立一个名为 Test 的子目录。 若 BBB 目录原本不存在，则建立一个。（注：本例若不加 -p，且原本 BBB目录不存在，则产生错误。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p BBB&#x2F;Test</span><br></pre></td></tr></table></figure>

<p>linux中文件目录不可以重名</p>
<h2 id="P28-文件和目录（rm）"><a href="#P28-文件和目录（rm）" class="headerlink" title="P28 文件和目录（rm）"></a>P28 文件和目录（rm）</h2><p>rm删除的不能恢复。Linux rm命令用于删除一个文件或者目录。</p>
<p>rm也可以使用通配符。</p>
<p>格式化电脑：rm -rf *</p>
<p>所有数据全部删除。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [options] name...</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-i 删除前逐一询问确认。</li>
<li>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。（没有此文件也可以删除，不会报错）</li>
<li>-r 将目录及以下之档案亦逐一删除。（不加无法删目录）（用递归方法）</li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>删除文件可以直接使用rm命令，若删除目录则必须配合选项”-r”，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># rm  test.txt </span><br><span class="line">rm：是否删除 一般文件 &quot;test.txt&quot;? y  </span><br><span class="line"># rm  homework  </span><br><span class="line">rm: 无法删除目录&quot;homework&quot;: 是一个目录  </span><br><span class="line"># rm  -r  homework  </span><br><span class="line">rm：是否删除 目录 &quot;homework&quot;? y</span><br></pre></td></tr></table></figure>

<p>删除当前目录下的所有文件及目录，命令行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm  -r  *</span><br></pre></td></tr></table></figure>

<p>文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/25/linux%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/25/linux%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">linux基础（1-18集）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-25 14:07:36 / Modified: 16:52:52" itemprop="dateCreated datePublished" datetime="2020-04-25T14:07:36-05:00">2020-04-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="linux-100集"><a href="#linux-100集" class="headerlink" title="linux 100集"></a>linux 100集</h1><h2 id="P3：操作系统作用"><a href="#P3：操作系统作用" class="headerlink" title="P3：操作系统作用"></a>P3：操作系统作用</h2><p>操作系统作用：1. 直接操作硬件 2把操作硬件的代码封装成一个个系统调用，供其他使用。</p>
<p>操作系统，与硬件交互。操作系统作用：操作系统位于底层硬件与用户之间，是两者沟通的桥梁。用户可以通过操作系统的用户界面，输入命令。操作系统则对命令进行解释，驱动硬件设备，实现用户要求。以现代标准而言，一个标准PC的操作系统应该提供以下的功能：</p>
<p>1、进程管理。又称处理器管理，其主要任务是对处理器的时间进行合理分配、对处理器的运行实施有效的管理。</p>
<p>2、存储器管理。由于多道程序共享内存资源，所以存储器管理的主要任务是对存储器进行分配、保护和扩充。</p>
<p>3、设备管理。根据确定的设备分配原则对设备进行分配，使设备与主机能够并行工作，为用户提供良好的设备使用界面。</p>
<p>4、文件管理。有效地管理文件的存储空间，合理地组织和管理文件系统，为文件访问和文件保护提供更有效的方法及手段。</p>
<p>5、用户接口。用户操作计算机的界面称为用户接口（或用户界面），通过用户接口，用户只需进行简单操作，就能实现复杂的应用处理。</p>
<p>例：听音乐，把硬盘中文件加载内存，然后声卡对音频数据解码，然后解码后数据给音响。这些都是操作系统做的。</p>
<h2 id="P4-10：历史简介"><a href="#P4-10：历史简介" class="headerlink" title="P4-10：历史简介"></a>P4-10：历史简介</h2><p>桌面操作系统：Windows（用户多，安全性较差，稳定性较差），Linux（应用软件少）， macOS（开发人员用）</p>
<p>服务器操作系统：Linux（安全，稳定，免费，占有率高，一般公司服务器都是Linux）（维护机房计算机，在远程维护），Windows Server（微软付费的，占有率低）</p>
<p>嵌入式操作系统：Linux（）</p>
<p>系统设备操作系统：iOS，Android</p>
<p>虚拟机：通过软件模拟具有完整硬件系统功能的，运行在一个完全隔离环境中的完整计算机系统。</p>
<p>Ken Thompson, 1969运行space travel，用汇编写了Unix原型，老爷子后来用B语言写了Unix</p>
<p>Dennis M.Ritchie发明了c语言，然后两个人一起重写了Unix。</p>
<p>unix version7 后unix不在开源源代码，因为ken老爷子喜欢走后门，让贝尔实验室很不爽。</p>
<p>Linux出现了，Linus老爷子来了，用GNU的bash当开发环境，gcc做compiler，编写了linux内核。</p>
<p>Linux两个版本：内核版本和发行版本。</p>
<p><u>终端命令</u>调系统调用，<u>系统调用</u>与硬件交互。</p>
<p>内核版本：kernel，Linux内核：内核只有一个<br>        linux内核是一种开放源码的操作系统，由Linux Torvalds负责维护，提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。</p>
<p>Linux发行版：<br>        linux发行版基于linux内核源码，将Linux系统的内核与外围实用程序(Utilities)软件和文档包装起来，并提供一些系统安装界面和系统配置、设定与管理工具，就构成了一种发行版本(distribution)，Linux的发行版本其实就是Linux核心再加上外围的实用程序组成的一个大软件包。</p>
<p>linux主要发行版：</p>
<p>Fedora Core、Debian、Mandrake、Ubuntu、Red Hat Linux、SuSE、Linux Mint、Gentoo、CentOS、</p>
<h2 id="P11：Linux文件目录"><a href="#P11：Linux文件目录" class="headerlink" title="P11：Linux文件目录"></a>P11：Linux文件目录</h2><p>windows每个驱动器都有根目录，前身是单用户操作系统</p>
<p>unix/linux是多用户操作系统，ubuntu目录：</p>
<p>/是根目录：/bin, /etc, /home, /lib, /usr</p>
<p>在/home中有/python, /laowang, 在这两个用户中都有/Desktop, /Documents, /Downloads, 各人各家，不会干扰别人。linux没有盘符概念</p>
<p>/bin: /usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。</p>
<p>/boot：放置linux系统启动时用到的一些文件。/boot/vmlinuz 为 linux 的内核文件，以及 /boot/gurb。建议单独分区，分区大小100M即可</p>
<p>/dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。</p>
<p>/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d修改配置文件之前记得备份。</p>
<p>注：/etc/X11 存放与 x windows 有关的设置。</p>
<p>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，<del>表示当前用户的家目录，</del>edu 表示用户 edu 的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据</p>
<p>/lib: /usr/lib: /usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为 /lib/modules。</p>
<p>/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。如加载硬盘于 /disk 中，此目录下就会自动产生目录 /disk/lost+found</p>
<p>/mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。</p>
<p>/opt：给主机额外安装软件所摆放的目录。如：FC4使用的Fedora 社群开发软件，如果想要自行安装新的 KDE 桌面软件，可以将该软件安装在该目录下。以前的 Linux 系统中，习惯放置在 /usr/local 目录下</p>
<p>/proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。</p>
<p>/root：系统管理员root的家目录，系统第一个启动的分区为 /，所以最好将 /root和 /放置在一个分区下。</p>
<p>/sbin: /usr/sbin: /usr/local/sbin：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能”查看”而不能设置和使用。</p>
<p>/tmp：一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下</p>
<p>/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。</p>
<p>/usr：应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录，使用 man ls 时会查询 /usr/share/man/man1/ls.1.gz 的内容建议单独分区，设置较大的磁盘空间</p>
<p>/var：放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。建议单独分区，设置较大的磁盘空间</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h3><p>Linux 对数据文件(<em>.mp3、</em>.bmp)，程序文件(<em>.c、</em>.h、*.o)，设备文件（LCD、触摸屏、鼠标），网络文件( socket ) 等的管理都抽象为文件，使用统一的方式方法管理。</p>
<p>文件分类：</p>
<p>1）普通文件( 数据文件 )</p>
<p>普通文件是用于存放数据、程序等信息的文件，一般都长期地存放在外存储器（磁盘）中。普通文件又分为文本文件和二进制文件。</p>
<p>2）目录文件</p>
<p>目录文件是文件系统中一个目录所包含的目录项所组成的文件。</p>
<p>3）设备文件</p>
<p>设备文件是用于为操作系统与设备提供连接的一种文件。在Linux系统中将设备作为文件来处理，操作设备就像是操作普通文件一样。每一个设备对应一个设备文件，存放在 /dev 目录中。</p>
<p>5）链接文件</p>
<p>似于 windows 下的快捷方式，链接又可以分为软链接（符号链接）和硬链接。</p>
<p>6）管道文件</p>
<p>管道文件主要用于在进程间传递数据的一种特殊文件。</p>
<p>7）套接口文件</p>
<p>主要用于不同计算机间网络通信的一种特殊文件。</p>
<p><strong>【常见目录说明】</strong></p>
<table>
<thead>
<tr>
<th>目录</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>/bin</td>
<td>存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里。</td>
</tr>
<tr>
<td>/etc</td>
<td>存放系统管理和配置文件</td>
</tr>
<tr>
<td>/home</td>
<td>存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示</td>
</tr>
<tr>
<td>/usr</td>
<td>用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。/usr/x11r6 存放x window的目录/usr/bin 众多的应用程序  /usr/sbin 超级用户的一些管理程序  /usr/doc linux文档  /usr/include linux下开发和编译应用程序所需要的头文件  /usr/lib 常用的动态链接库和软件包的配置文件  /usr/man 帮助文档  /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里  /usr/local/bin 本地增加的命令  /usr/local/lib 本地增加的库</td>
</tr>
<tr>
<td>/opt</td>
<td>额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。</td>
</tr>
<tr>
<td>/proc</td>
<td>虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。</td>
</tr>
<tr>
<td>/root</td>
<td>超级用户（系统管理员）的主目录（特权阶级^o^）</td>
</tr>
<tr>
<td>/sbin</td>
<td>存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。</td>
</tr>
<tr>
<td>/dev</td>
<td>用于存放设备文件。</td>
</tr>
<tr>
<td>/mnt</td>
<td>系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。</td>
</tr>
<tr>
<td>/boot</td>
<td>存放用于系统引导时使用的各种文件</td>
</tr>
<tr>
<td>/lib</td>
<td>存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。</td>
</tr>
<tr>
<td>/tmp</td>
<td>用于存放各种临时文件，是公用的临时文件存储点。</td>
</tr>
<tr>
<td>/var</td>
<td>用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。</td>
</tr>
<tr>
<td>/lost+found</td>
<td>这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里</td>
</tr>
</tbody></table>
<h2 id="P13-17-LInux终端命令"><a href="#P13-17-LInux终端命令" class="headerlink" title="P13-17.LInux终端命令"></a>P13-17.LInux终端命令</h2><p>terminal放大字体：ctrl + shift + =；缩小字体： ctrl + -</p>
<p>linux常用命令：ls, pwd, cd, touch, mkdir, rm, clear.</p>
<p>对应：list, print work directory, change directory, touch(创建文件，例如java，txt文件), mkdir(创建目录)马克directory，clear（清屏), rmdir(删除目录)</p>
<p>终端命令格式：command [options] [parameter]</p>
<p>Linux中的rm －r 和rm －R区别为：用途不同道、范围不同、数量不同。</p>
<p>一、用途不同</p>
<p>1、rm －r ：rm －r 只能用于删除文件，不能用于删除文件夹。</p>
<p>2、rm －R：rm －R既能用于删除文件，也能用于删除文件夹。</p>
<p>二、范围不同内</p>
<p>1、rm －容r ：rm －r的删除范围是删除当前输入位置的文件。</p>
<p>2、rm －R：rm －R的删除范围是删除当前输入的目录文件夹里文件及其子目录里的文件。</p>
<p><strong>系统信息</strong><br>arch 显示机器的处理器架构<br>uname -m 显示机器的处理器架构<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS </p>
<p><strong>关机 (系统的关机、重启以及登出 )</strong><br>shutdown -h now 关闭系统<br>init 0 关闭系统<br>telinit 0 关闭系统<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启<br>reboot 重启<br>logout 注销 </p>
<p><strong>文件和目录</strong><br>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构<br>lstree 显示文件和目录由根目录开始的树形结构<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录 </p>
<p>cp -r dir1 dir2 复制一个目录及子目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) </p>
<p><strong>文件搜索</strong><br>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径 </p>
<p><strong>挂载一个文件系统</strong><br>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 </p>
<p><strong>磁盘空间</strong><br>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </p>
<p><strong>用户和群组</strong><br>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 </p>
<p><strong>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong><br>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位 </p>
<p><strong>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong><br>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性 </p>
<p><strong>打包和压缩文件</strong><br>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包 </p>
<p><strong>RPM 包 - （Fedora, Redhat及类似系统）</strong><br>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 </p>
<p><strong>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</strong><br>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件 </p>
<p><strong>DEB 包 (Debian, Ubuntu 以及类似系统)</strong><br>dpkg -i package.deb 安装/更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 </p>
<p><strong>APT 软件工具 (Debian, Ubuntu 以及类似系统)</strong><br>apt-get install package_name 安装/更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 </p>
<p><strong>查看文件内容</strong><br>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容 </p>
<p><strong>文本处理</strong><br>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行<br>sed ‘/ <em>#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ *$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 </p>
<p><strong>字符设置和文件格式转换</strong><br>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>recode -l | more 显示所有允许的转换格式 </p>
<p><strong>文件系统分析</strong><br>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 </p>
<p><strong>初始化一个文件系统</strong><br>mkfs /dev/hda1 在hda1分区创建一个文件系统<br>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>fdformat -n /dev/fd0 格式化一个软盘<br>mkswap /dev/hda3 创建一个swap文件系统 </p>
<p><strong>SWAP文件系统</strong><br>mkswap /dev/hda3 创建一个swap文件系统<br>swapon /dev/hda3 启用一个新的swap文件系统<br>swapon /dev/hda2 /dev/hdb3 启用两个swap分区 </p>
<p><strong>备份</strong><br>dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份<br>dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份<br>restore -if /tmp/home0.bak 还原一个交互式备份<br>rsync -rogpav –delete /home /tmp 同步两边的目录<br>rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync<br>rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作<br>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>find /home/user1 -name ‘<em>.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>find /var/log -name ‘</em>.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 </p>
<p><strong>光盘</strong><br>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>cdrecord –scanbus 扫描总线以识别scsi通道<br>dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD </p>
<p><strong>网络 - （以太网和WIFI无线</strong>）<br>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>dhclient eth0 以dhcp模式启用 ‘eth0’<br>route -n show routing table<br>route add -net 0/0 gw IP_Gateway configura default gateway<br>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’<br>route del 0/0 gw IP_gateway remove static route<br>echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing<br>hostname show hostname of system<br>host <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>ip link show show link status of all interfaces<br>mii-tool eth0 show link status of ‘eth0’<br>ethtool eth0 show statistics of network card ‘eth0’<br>netstat -tup show all active network connections and their PID<br>netstat -tupl show all network services listening on the system and their PID<br>tcpdump tcp port 80 show all HTTP traffic<br>iwlist scan show wireless networks<br>iwconfig eth1 show configuration of a wireless network card<br>hostname show hostname<br>host <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>whois <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup on Whois database </p>
<p><strong>JPS工具</strong></p>
<p>jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。</p>
<p>  我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。</p>
<p>   <strong>使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。</strong></p>
<p><strong>jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path.</strong></p>
<p>$&gt; <strong>jps</strong><br>23991 Jps<br>23789 BossMain<br>23651 Resin</p>
<p>比较常用的参数：</p>
<p><strong>-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数</strong><br>$&gt; <strong>jps -q</strong><br>28680<br>23789<br>23651</p>
<p><strong>-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null</strong></p>
<p>$&gt; <strong>jps -m</strong><br>28715 Jps -m<br>23789 BossMain<br>23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log</p>
<p><strong>-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名</strong></p>
<p>$&gt; <strong>jps -l</strong><br>28729 sun.tools.jps.Jps<br>23789 com.asiainfo.aimc.bossbi.BossMain<br>23651 com.caucho.server.resin.Resin</p>
<p><strong>-v 输出传递给JVM的参数</strong></p>
<p>$&gt; <strong>jps -v</strong><br>23789 BossMain<br>28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd</p>
<p>k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m<br>23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -</p>
<p>Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl</p>
<p><strong>sudo jps看到的进程数量最全</strong></p>
<p><strong>jps 192.168.0.77</strong></p>
<p><strong>列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099</strong></p>
<p><strong>（前提是远程服务器提供jstatd服务）</strong></p>
<p><strong>注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。</strong></p>
<h2 id="P18"><a href="#P18" class="headerlink" title="P18"></a>P18</h2><p>查阅命令帮助信息，command –help, man command.</p>
<p>系统中会有单独的man文件，命令百<br>man term<br>等同于<br>less [manpath]/term.X[.gz] // X为1-8中的数，视term而定<br>就是说，如果系统没有安装对度应man文件，哪怕term命令完全正常，知man term都没结果（同样，只要安装了man文件，哪怕没term命令，也可以得到道一大堆东西）。内<br>而–help参数将会显示可执行程序自带的信息，这些信容息是嵌入到程序本身的（所以–help信息较简短）。man是在系统安装的时候安装了狠制多的文档，可以在系统的目录doc下找到，如果软件有配套的页面，就可以使用man来查找，<br>而 help是软件编写百人员在编写的时候提供了内置的查询参数，查询的参数在程序里度面。也就是说man查询的结果是在程序外面，而help 查询出来的内容在程序里面。</p>
<p>man是一个详细的介绍，help是一个命令选项的简单介绍</p>
<p>man的用法：man    -&gt;&gt;manual    ###man是手册缩写<br>man man            #####查看man命令的帮助<br>man passwd        ###查看passwd命令的帮助</p>
<p>man的级别<br>1    系统命令<br>2    系统接口<br>3    函数库<br>4    特殊文件，比如设备文件<br>5    文件<br>6    游戏<br>7    系统的软件包<br>8    系统管理命令<br>9    内核</p>
<p>man 5 passwd    ##查看/etc/passwd文件的帮助<br>man 1 passwd    ##查看passwd命令的帮助，1可以省略</p>
<p>man页面的快捷方式<br>上下键            ##向上或向下一行<br>pageup|pagedown        ##向下一个屏幕或者向上一个屏幕<br>d|u            ##向下或者向上半个屏幕<br>G|gg            ##跳转页面到man最下面或最上面<br>/关键字            ##搜索关键字，关键字会高亮显示，n向下匹配，N向上<br>q            ##退出帮助页面</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday06/" class="post-title-link" itemprop="url">带你学c带你飞day06</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 21:06:25" itemprop="dateCreated datePublished" datetime="2020-04-20T21:06:25-05:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday05/" class="post-title-link" itemprop="url">带你学c带你飞day05</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 21:06:21" itemprop="dateCreated datePublished" datetime="2020-04-20T21:06:21-05:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday04/" class="post-title-link" itemprop="url">带你学c带你飞day04</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 21:06:18" itemprop="dateCreated datePublished" datetime="2020-04-20T21:06:18-05:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday03/" class="post-title-link" itemprop="url">带你学c带你飞day03</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 21:06:14" itemprop="dateCreated datePublished" datetime="2020-04-20T21:06:14-05:00">2020-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-25 09:35:30" itemprop="dateModified" datetime="2020-04-25T09:35:30-05:00">2020-04-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P21"><a href="#P21" class="headerlink" title="P21"></a>P21</h2><p>内存地址存数据</p>
<p>在C语言中，指针的使用非常广泛，因为使用指针往往可以生成更高效、更紧凑的代码。总的来说，使用指针有如下好处：</p>
<p>1）指针的使用使得不同区域的代码可以轻易的共享内存数据，这样可以使程序更为快速高效；</p>
<p>2）C语言中一些复杂的数据结构往往需要使用指针来构建，如链表、二叉树等；</p>
<p>3）C语言是传值调用，而有些操作传值调用是无法完成的，如通过被调函数修改调用函数的对象，但是这种操作可以由指针来完成，而且并不违背传值调用。</p>
<p><strong>3.1 声明并初始化一个指针</strong></p>
<p>　　指针其实就是一个变量，指针的声明方式与一般的变量声明方式没太大区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int *p;        &#x2F;&#x2F; 声明一个 int 类型的指针 p</span><br><span class="line">char *p        &#x2F;&#x2F; 声明一个 char 类型的指针 p</span><br><span class="line">int *arr[10]   &#x2F;&#x2F; 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向 int 类型对象的指针</span><br><span class="line">int (*arr)[10] &#x2F;&#x2F; 声明一个数组指针，该指针指向一个 int 类型的一维数组</span><br><span class="line">int **p;       &#x2F;&#x2F; 声明一个指针 p ，该指针指向一个 int 类型的指针</span><br></pre></td></tr></table></figure>

<p>　　指针的声明比普通变量的声明多了一个一元运算符 “<em>”。运算符 “</em>” 是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。在上述的声明中： p 是一个指针，保存着一个地址，该地址指向内存中的一个变量； *p 则会访问这个地址所指向的变量。</p>
<p>　　声明一个指针变量并不会自动分配任何内存。在对指针进行间接访问之前，指针必须进行初始化：或是使他指向现有的内存，或者给他动态分配内存，否则我们并不知道指针指向哪儿，这将是一个很严重的问题，稍后会讨论这个问题。初始化操作如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 方法1：使指针指向现有的内存 *&#x2F;</span><br><span class="line">int x &#x3D; 1;</span><br><span class="line">int *p &#x3D; &amp;x;　　&#x2F;&#x2F; 指针 p 被初始化，指向变量 x ，其中取地址符 &amp; 用于产生操作数内存地址</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法2：动态分配内存给指针 *&#x2F;</span><br><span class="line">int *p;</span><br><span class="line">p &#x3D; (int *)malloc(sizeof(int) * 10);　　　　&#x2F;&#x2F; malloc 函数用于动态分配内存</span><br><span class="line">free(p);　　　　&#x2F;&#x2F; free 函数用于释放一块已经分配的内存，常与 malloc 函数一起使用，要使用这两个函数需要头文件 stdlib.h</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　指针的初始化实际上就是给指针一个合法的地址，让程序能够清楚地知道指针指向哪儿。</p>
<p><strong>3.2 未初始化和非法的指针</strong> </p>
<p>　　 如果一个指针没有被初始化，那么程序就不知道它指向哪里。它可能指向一个非法地址，这时，程序会报错，在 Linux 上，错误类型是 Segmentation fault（core dumped），提醒我们段违例或内存错误。它也可能指向一个合法地址，实际上，这种情况更严重，你的程序或许能正常运行，但是这个没有被初始化的指针所指向的那个位置的值将会被修改，而你并无意去修改它。用一个例子简单的演示一下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int *p;</span><br><span class="line">    *p &#x3D; 1;</span><br><span class="line">    printf(&quot;%d\n&quot;,*p);</span><br><span class="line"></span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　这个程序可以编译通过，但是运行的话会报错，报错信息如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180917175256031-967973584.png" alt="img"></p>
<p>　　要想使这个程序运行起来，需要先对指针 p 进行初始化：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int x &#x3D; 1;  </span><br><span class="line">    int *p &#x3D; &amp;x;</span><br><span class="line">    printf(&quot;%d\n&quot;,*p);</span><br><span class="line">　  *p &#x3D; 2;</span><br><span class="line">    printf(&quot;%d\n&quot;,*p);</span><br><span class="line"></span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　这段代码的输出结果如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180917212250007-280056505.png" alt="img"> </p>
<p>　　可以看到，对指针进行初始化后，便可以正常对指针进行赋值了。 </p>
<p><strong>3.3 NULL指针</strong></p>
<p>　　<strong>NULL 指针是一个特殊的指针变量，表示不指向任何东西</strong>。可以通过给一个指针赋一个零值来生成一个 NULL 指针。 </p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int *p &#x3D; NULL;</span><br><span class="line">    printf(&quot;p的地址为%d\n&quot;,p);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;***************</span><br><span class="line"> * 程序输出：</span><br><span class="line"> * p的地址为0</span><br><span class="line">***************&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　可以看到指针指向内存地址0。在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是为操作系统保留的。但是，内存地址 0 有一个特别重要的意义，它表明改指针不指向一个可访问的内存位置。</p>
<p><strong>四、指针的运算</strong></p>
<p>　　C 指针的算术运算只限于两种形式：</p>
<p>1） 指针 +/- 整数 ：</p>
<p>　　 可以对指针变量 p 进行 p++、p–、p + i 等操作，所得结果也是一个指针，只是指针所指向的内存地址相比于 p 所指的内存地址前进或者后退了 i 个操作数。用一张图来说明一下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180921154218407-1813012241.png" alt="img"></p>
<p>　　在上图中，10000000等是内存地址的十六进制表示（数值是假定的），p 是一个 int 类型的指针，指向内存地址 0x10000008 处。则 p++ 将指向与 p 相邻的下一个内存地址，由于 int 型数据占 4 个字节，因此 p++ 所指的内存地址为 1000000b。其余类推。不过要注意的是，这种运算并不会改变指针变量 p 自身的地址，只是改变了它所指向的地址。举个例子：</p>
<p>2）指针 - 指针</p>
<p>　　只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。两个指针相减的结果的类型是 ptrdiff_t，它是一种有符号整数类型。减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位），因为减法运算的结果将除以数组元素类型的长度。举个例子：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[10] &#x3D; &#123;1,2,3,4,5,6,7,8,9,0&#125;;</span><br><span class="line">    int sub;</span><br><span class="line">    int *p1 &#x3D; &amp;a[2];</span><br><span class="line">    int *p2 &#x3D; &amp;a[8];</span><br><span class="line"></span><br><span class="line">    sub &#x3D; p2-p1;                                                                            </span><br><span class="line">    printf(&quot;%d\n&quot;,sub);　　　　&#x2F;&#x2F; 输出结果为 6</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>五、指针与数组</strong></p>
<p>　　在C语言中，指针与数组之间的关系十分密切。实际上，许多可以用数组完成的工作都可以使用指针来完成。一般来说，用指针编写的程序比用数组编写的程序执行速度快，但另一方面，用指针实现的程序理解起来稍微困难一些。</p>
<p><strong>5.1 指针与数组的关系</strong></p>
<p>　　我们先声明一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[10];        &#x2F;&#x2F; 声明一个int类型的数组，这个数组有10个元素</span><br></pre></td></tr></table></figure>

<p>　　我们可以用 a[0]、a[1]、…、a[9] 来表示这个数组中的10个元素，这10个元素是存储在一段连续相邻的内存区域中的。</p>
<p>　　接下来，我们再声明一个指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p;           &#x2F;&#x2F; 声明一个int类型的指针变量</span><br></pre></td></tr></table></figure>

<p>　　 p 是一个指针变量，指向内存中的一个区域。如果我们对指针 p 做如下的初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; &amp;a[0];        &#x2F;&#x2F; 对指针进行初始化，p将指向数组 a 的第 1 个元素 a[0]</span><br></pre></td></tr></table></figure>

<p>　　我们知道，对指针进行自增操作会让指针指向与当前元素相邻的下一个元素，即 <em>(p + 1) 将指向 a[1] ；同样的， <em>(p + i) 将指向 a[i] 。因此，我们可以使用该指针来遍历数组 a[10] 的所有元素。可以看到，数组下标与指针运算之间的关系是一一对应的。而根据定义，</em></em>数组类型的变量或表达式的值是该数组第 1 个元素的地址**，且数组名所代表的的就是该数组第 1 个元素的地址，故，上述赋值语句可以直接写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; a;        &#x2F;&#x2F; a 为数组名，代表该数组最开始的一个元素的地址</span><br></pre></td></tr></table></figure>

<p>　　很显然，<strong>一个通过数组和下标实现的表达式可以等价地通过指针及其偏移量来实现</strong>，这就是数组和指针的互通之处。但有一点要明确的是，数组和指针并不是完全等价，<em>指针是一个变量，而数组名不是变量，它数组中第 1 个元素的地址</em>，数组可以看做是一个用于保存变量的容器。更直接的方法，我们可以直接看二者的地址，并不一样：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;                                                                          </span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    int x[10] &#x3D; &#123;1,2,3,4,5,6,7,8,9,0&#125;;</span><br><span class="line">    int *p &#x3D; x;</span><br><span class="line">    printf(&quot;x的地址为：%p\n&quot;,x);</span><br><span class="line">    printf(&quot;x[0]的地址为：%p\n&quot;,&amp;x[0]);</span><br><span class="line">    printf(&quot;p的地址为：%p\n&quot;,&amp;p);　　　　　　&#x2F;&#x2F; 打印指针 p 的地址，并不是指针所指向的地方的地址</span><br><span class="line"></span><br><span class="line">    p +&#x3D; 2;</span><br><span class="line">    printf(&quot;*(p+2)的值为：%d\n&quot;,*p);　　　　&#x2F;&#x2F; 输出结果为 3，*(p+2)指向了 x[2]</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　结果如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180918160417548-189120951.png" alt="img"></p>
<p>　　可以看到， x 的值与 x[0] 的地址是一样的，也就是说数组名即为数组中第 1 个元素的地址。实际上，打印 &amp;x 后发现，x 的地址也是这个值。而 x 的地址与指针变量 p 的地址是不一样的。故而数组和指针并不能完全等价。</p>
<p>（笔者注：上述输出结果是在 centos7 64bit 的环境下使用 gcc 编译器得到的，可以看到地址是一个12位的十六进制数，转换成二进制是48位，也就是说寻址空间有 256TB，但是笔者的电脑只有 8GB 内存，猜测是不是由于 linux 系统开启了内存分页机制，这里寻址的是虚拟地址？另外，在Windows下使用 vs2015 编译运行的话，则输出结果是一个 8位的十六进制数，也就是32位二进制，寻址空间为 4GB） </p>
<p><strong>5.2 指针数组</strong></p>
<p>　　指针是一个变量，而数组是用于存储变量的容器，因此，指针也可以像其他变量一样存储在数组中，也就是指针数组。 <strong>指针数组是一个数组，数组中的每一个元素都是指针</strong>。声明一个指针数组的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p[10];    &#x2F;&#x2F; 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向int类型的指针</span><br></pre></td></tr></table></figure>

<p>　　在上述声明中，由于 [] 的优先级比 * 高，故 p 先与 [] 结合，成为一个数组 p[]；再由 int * 指明这是一个 int 类型的指针数组，数组中的元素都是 int 类型的指针。数组的第 i 个元素是 <em>p[i]，而 *</em>p[i] 是一个指针**。由于指针数组中存放着多个指针，操作灵活，在一些需要操作大量数据的程序中使用，可以使程序更灵活快速。</p>
<p><strong>5.3 数组指针</strong></p>
<p>　　<strong>数组指针是一个指针，它指向一个数组</strong>。声明一个数组指针的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*p)[10];        &#x2F;&#x2F; 声明一个数组指针 p ，该指针指向一个数组</span><br></pre></td></tr></table></figure>

<p>　　由于 () 的优先级最高，所以 p 是一个指针，指向一个 int 类型的一维数组，这个一维数组的长度是 10，这也是指针 p 的步长。也就是说，执行 p+1 时，p 要跨过 n 个 int 型数据的长度。数组指针与二维数组联系密切，可以用数组指针来指向一个二维数组，如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int arr[2][3] &#x3D; &#123;1,2,3,4,5,6&#125;;               &#x2F;&#x2F; 定义一个二维数组并初始化</span><br><span class="line">    int (*p)[3];                                 &#x2F;&#x2F; 定义一个数组指针，指针指向一个含有3个元素的一维数组</span><br><span class="line"></span><br><span class="line">    p &#x3D; arr;                                     &#x2F;&#x2F; 将二维数组的首地址赋给 p，此时 p 指向 arr[0] 或 &amp;arr[0][0]</span><br><span class="line">    printf(&quot;%d\n&quot;,(*p)[0]);　　　　　　　　　　　　  &#x2F;&#x2F; 输出结果为 1</span><br><span class="line">    p++;　　　　　　　　　　　　　　　　　　　　　　　　 &#x2F;&#x2F; 对 p 进行算术运算，此时 p 将指向二维数组的下一行的首地址，即 &amp;arr[1][0]</span><br><span class="line">    printf(&quot;%d\n&quot;,(*p)[1]);                      &#x2F;&#x2F; 输出结果为5</span><br><span class="line"></span><br><span class="line">    return 0;                                                                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>六、指针与结构</strong></p>
<p><strong>6.1 简单介绍一下结构</strong></p>
<p>　　结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。由于结构将一组相关的变量看做一个单元而不是各自独立的实体，因此结构有助于组织复杂的数据，特别是在大型的程序中。声明一个结构的方式如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct message&#123;　　　　　　      &#x2F;&#x2F; 声明一个结构 message</span><br><span class="line">    char name[10];             &#x2F;&#x2F; 成员</span><br><span class="line">    int age;</span><br><span class="line">    int score;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct message s_message;　　　　 &#x2F;&#x2F; 类型定义符 typedef</span><br><span class="line"></span><br><span class="line">s_message mess &#x3D; &#123;&quot;tongye&quot;,23,83&#125;;　　　　&#x2F;&#x2F; 声明一个 struct message 类型的变量 mess,并对其进行初始化　</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line">&#x2F;* 另一种更简便的声明方法 *&#x2F;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">　　char name[10];</span><br><span class="line">　　int age;</span><br><span class="line">　　int score;</span><br><span class="line">&#125;message;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　可以使用 <strong>结构名.成员</strong> 的方式来访问结构中的成员，如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">　　printf(&quot;%s\n&quot;,mess.name);　　　　&#x2F;&#x2F; 输出结果：tongye</span><br><span class="line">　　printf(&quot;%d\n&quot;,mess.age);　　　　 &#x2F;&#x2F; 输出结果：23</span><br><span class="line"></span><br><span class="line">　　return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>6.2 结构指针</strong>　</p>
<p>　　结构指针是指向结构的指针，以上面的结构为例，可以这样定义一个结构指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s_message *p;        &#x2F;&#x2F; 声明一个结构指针 p ，该指针指向一个 s_message 类型的结构</span><br><span class="line">*p &#x3D; &amp;mess;　　　　　　&#x2F;&#x2F; 对结构指针的初始化与普通指针一样，也是使用取地址符 &amp;</span><br></pre></td></tr></table></figure>

<p>　　C语言中使用 -&gt; 操作符来访问结构指针的成员，举个例子：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char name[10];</span><br><span class="line">    int age;</span><br><span class="line">    int score;  </span><br><span class="line">&#125;message;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    message mess &#x3D; &#123;&quot;tongye&quot;,23,83&#125;;</span><br><span class="line">    message *p &#x3D; &amp;mess;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%s\n&quot;,p-&gt;name);　　　　　　&#x2F;&#x2F; 输出结果为：tongye</span><br><span class="line">    printf(&quot;%d\n&quot;,p-&gt;score);         &#x2F;&#x2F; 输出结果为：83</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>七、指针与函数</strong></p>
<p>　　<strong>C语言的所有参数均是以“传值调用”的方式进行传递的</strong>，这意味着函数将获得参数值的一份拷贝。这样，函数可以放心修改这个拷贝值，而不必担心会修改调用程序实际传递给它的参数。 </p>
<p><strong>7.1 指针作为函数的参数</strong></p>
<p>　　传值调用的好处是是被调函数不会改变调用函数传过来的值，可以放心修改。但是有时候需要被调函数回传一个值给调用函数，这样的话，传值调用就无法做到。为了解决这个问题，可以使用传指针调用。<strong>指针参数使得被调函数能够访问和修改主调函数中对象的值。</strong>用一个例子来说明：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">void swap1(int a,int b)　　　　　　  &#x2F;&#x2F; 参数为普通的 int 变量</span><br><span class="line">&#123;</span><br><span class="line">　　int temp;</span><br><span class="line">　　temp &#x3D; a;</span><br><span class="line">　　a &#x3D; b;</span><br><span class="line">　　b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap2(int *a,int *b)　　　　　　&#x2F;&#x2F; 参数为指针，接受调用函数传递过来的变量地址作为参数，对所指地址处的内容进行操作</span><br><span class="line">&#123;</span><br><span class="line">　　int temp;　　　　                &#x2F;&#x2F; 最终结果是，地址本身并没有改变，但是这一地址所对应的内存段中的内容发生了变化，即x,y的值发生了变化</span><br><span class="line">　　temp &#x3D; *a;</span><br><span class="line">　　*a &#x3D; *b;</span><br><span class="line">　　*b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">　　int x &#x3D; 1,y &#x3D; 2;</span><br><span class="line">　　swap1(x,y);                     &#x2F;&#x2F; 将 x,y 的值本身作为参数传递给了被调函数</span><br><span class="line">　　printf(&quot;%d %5d\n&quot;,x,y);         &#x2F;&#x2F; 输出结果为：1     2</span><br><span class="line"></span><br><span class="line">　　swap(&amp;x,&amp;y);                    &#x2F;&#x2F; 将 x,y 的地址作为参数传递给了被调函数，传递过去的也是一个值，与传值调用不冲突</span><br><span class="line">　　printf(&quot;%d %5d\n&quot;,x,y);         &#x2F;&#x2F; 输出结果为：2     1</span><br><span class="line">　　return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>7.2 指向函数的指针</strong></p>
<p>　　在C语言中，函数本身不是变量，但是可以定义指向函数的指针，也称作函数指针，函数指针指向函数的入口地址。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。 声明一个函数指针的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 （* 指针变量名）（[形参列表]）;</span><br><span class="line"></span><br><span class="line">int (*pointer)(int *,int *);        &#x2F;&#x2F; 声明一个函数指针</span><br></pre></td></tr></table></figure>

<p>　　上述代码声明了一个函数指针 pointer ，该指针指向一个函数，函数具有两个 int * 类型的参数，且返回值类型为 int。下面的代码演示了函数指针的用法：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line"></span><br><span class="line">int str_comp(const char *m,const char *n);                             &#x2F;&#x2F; 声明一个函数 str_comp，该函数有两个 const char 类型的指针，函数的返回值为 int 类型</span><br><span class="line">void comp(char *a,char *b,int (*prr)(const char *,const char*));       &#x2F;&#x2F; 声明一个函数 comp ,注意该函数的第三个参数，是一个函数指针</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char str1[20];      &#x2F;&#x2F; 声明一个字符数组</span><br><span class="line">    char str2[20];</span><br><span class="line">    int (*p)(const char *,const char *) &#x3D; str_comp;　　　　　　　　　　　 &#x2F;&#x2F; 声明并初始化一个函数指针，该指针所指向的函数有两个 const char 类型的指针，且返回值为 int 类型</span><br><span class="line">    gets(str1);         &#x2F;&#x2F; 使用 gets() 函数从 I&#x2F;O 读取一行字符串</span><br><span class="line">    gets(str2);</span><br><span class="line">    comp(str1,str2,p);  &#x2F;&#x2F; 函数指针 p 作为参数传给 comp 函数</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int str_comp(const char *m,const char *n)</span><br><span class="line">&#123;</span><br><span class="line">　　 &#x2F;&#x2F; 库函数 strcmp 用于比较两个字符串，其原型是： int strcmp(const char *s1,const char *s2);</span><br><span class="line">    if(strcmp(m,n) &#x3D;&#x3D; 0) </span><br><span class="line">        return 0;</span><br><span class="line">    else</span><br><span class="line">        return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 函数 comp 接受一个函数指针作为它的第三个参数 *&#x2F;</span><br><span class="line">void comp(char *a,char *b,int (*prr)(const char *,const char*))</span><br><span class="line">&#123;</span><br><span class="line">    if((*prr)(a,b) &#x3D;&#x3D; 0)</span><br><span class="line">        printf(&quot;str1 &#x3D; str2\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;str1 !&#x3D; str2\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　这段代码的功能是从键盘读取两行字符串（长度不超过20），判断二者是否相等。</p>
<p>　　注意，声明一个函数指针时，() 不能漏掉，否则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p(void *,void*);</span><br></pre></td></tr></table></figure>

<p>　　这表明 p 是一个函数，该函数返回一个指向 int 类型的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a=<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> *pa=&amp;a;</span><br></pre></td></tr></table></figure>

<p>指针长度：以前是16位地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就占8个字节。</p>
<p>避免访问未初始化指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a; *a=<span class="number">123</span>;<span class="comment">//野指针</span></span><br></pre></td></tr></table></figure>

<h2 id="P22"><a href="#P22" class="headerlink" title="P22"></a>P22</h2><p>&amp;取值操作符</p>
<p>数组名就是地址信息，也是第一个元素的地址。</p>
<p>当指针指向数组元素是，可以对指针变量进行加减运算。指针加一指向下一个元素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday02/" class="post-title-link" itemprop="url">带你学c带你飞day02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-20 21:06:09 / Modified: 22:35:12" itemprop="dateCreated datePublished" datetime="2020-04-20T21:06:09-05:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P11"><a href="#P11" class="headerlink" title="P11"></a>P11</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);<span class="comment">//地址</span></span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"true"</span>);<span class="comment">//这样缩进可以</span></span><br><span class="line"><span class="keyword">if</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P12"><a href="#P12" class="headerlink" title="P12"></a>P12</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量表达式<span class="number">1</span>：语句或代码块；</span><br><span class="line">	<span class="keyword">case</span> ...</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">	<span class="keyword">default</span>: 语句或代码块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line">  <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span>: <span class="built_in">printf</span>(<span class="string">"hi"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'B'</span>: <span class="built_in">printf</span>(<span class="string">"hey"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">"hello"</span>); </span><br><span class="line">    <span class="keyword">break</span>;<span class="comment">//不加break会导致所有case都输出了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(has = <span class="string">"a"</span>)&#123;&#125;<span class="comment">//永远对，所以应该 ==</span></span><br></pre></td></tr></table></figure>

<h2 id="P13"><a href="#P13" class="headerlink" title="P13"></a>P13</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">()</span></span>;<span class="comment">//读取下一个字符</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>()&#123;&#125;<span class="comment">//判断后循环</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>()；<span class="comment">//先循环在判断，while后面有语句</span></span><br></pre></td></tr></table></figure>

<h2 id="P14"><a href="#P14" class="headerlink" title="P14"></a>P14</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环初始;循环结束;循环条件)&#123;&#125;</span><br><span class="line"><span class="built_in">_Bool</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, <span class="keyword">int</span> j=<span class="number">0</span>;i&lt;j;i++,j++)&#123;&#125;<span class="comment">//也可以</span></span><br><span class="line">若想 <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">10</span>;<span class="comment">//则需 gcc -std=c99 test.c &amp;&amp; ./a.out</span></span><br></pre></td></tr></table></figure>

<h2 id="P15"><a href="#P15" class="headerlink" title="P15"></a>P15</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> 在<span class="built_in">printf</span>中是%lld</span><br><span class="line">  <span class="keyword">break</span>跳出当前循环，<span class="keyword">continue</span>直接进入下一次循环</span><br></pre></td></tr></table></figure>

<h2 id="P16"><a href="#P16" class="headerlink" title="P16"></a>P16</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">5</span>, j;</span><br><span class="line">j=++i;<span class="comment">//i=6=j</span></span><br><span class="line">i=<span class="number">5</span>;</span><br><span class="line">j=i++;<span class="comment">//i=6,j=5</span></span><br><span class="line"><span class="comment">//i++先把值给j，再加加</span></span><br><span class="line"><span class="comment">//多语句，逗号表达式</span></span><br><span class="line"><span class="comment">/* 语法：表达式1，...表达式n</span></span><br><span class="line"><span class="comment">表达式从左到右计算</span></span><br><span class="line"><span class="comment">	逗号表达式作为一个整体，值为最后一个表达式也就是n的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">a=(b=<span class="number">3</span>, (c=b+<span class="number">4</span>) +<span class="number">5</span>)<span class="comment">//a=12</span></span><br><span class="line">exp1 ? exp2:exp3  <span class="comment">//if exp1==true , exp2, else: exp3</span></span><br><span class="line"><span class="comment">//goto 跳到标签</span></span><br><span class="line">  <span class="keyword">goto</span> A;<span class="comment">//谨慎用goto</span></span><br><span class="line">  A: <span class="built_in">printf</span>(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="P17"><a href="#P17" class="headerlink" title="P17"></a>P17</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组 类型 数组名[元素个数]</span></span><br><span class="line"><span class="comment">/*数组不能动态定义</span></span><br><span class="line"><span class="comment">int 自动初始化为0，最好手动初始化，要不然栈内空间会错误赋值，可能。</span></span><br><span class="line"><span class="comment">int a[5]=&#123;[2]=2,[3]=3&#125;;//这样可以</span></span><br><span class="line"><span class="comment">sizeof(a);//计算数组内存大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="P18"><a href="#P18" class="headerlink" title="P18"></a>P18</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态数组</span></span><br><span class="line">c99, c支持可变长数组，数组长度在运行时才被决定</span><br><span class="line">  新编译， 在数组越界不会出现错误，好像</span><br></pre></td></tr></table></figure>

<h2 id="P19"><a href="#P19" class="headerlink" title="P19"></a>P19</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">字符串数组定义：</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[]=&#123;<span class="string">"ab"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[]=<span class="string">"ab"</span>;</span><br><span class="line">字符串处理函数：&lt;<span class="built_in">string</span>.h&gt;内</span><br><span class="line">  <span class="built_in">strcat</span>：连接字符串</span><br><span class="line">  <span class="built_in">strcmp</span>:比较字符串</span><br><span class="line">  <span class="built_in">strcpy</span>:拷贝字符串</span><br><span class="line">  <span class="built_in">strlen</span>:获取长度</span><br><span class="line">  <span class="built_in">strncat</span>(str1,str2,<span class="number">5</span>):（以下<span class="number">3</span>个受限，功能一样）<span class="comment">//str2拷贝5个字符到str1</span></span><br><span class="line">  <span class="built_in">strcmp</span>:</span><br><span class="line">  <span class="built_in">strncpy</span>:</span><br><span class="line"><span class="keyword">sizeof</span>(str);<span class="comment">//n</span></span><br><span class="line"><span class="built_in">strlen</span>(str);<span class="comment">//n-1, 因为strlen不包括那个\n，sizeof包括</span></span><br></pre></td></tr></table></figure>

<h3 id="1-字符串基础"><a href="#1-字符串基础" class="headerlink" title="1 字符串基础"></a>1 字符串基础</h3><p>字符串是一种重要的数据类型，有零个或多个字符组成的有限串行。</p>
<p>定义子串: 串中任意个连续的字符组成的子序列，并规定空串是任意串的子串，任意串也是其自身的子串，如字符串”adereegfb”中它本身、空串、诸如”ader”连续的字符串都是它的子串。子序列则不要求字符连续，但顺序要与主串保持一致，若有”abcd”与”ad”则两者的最长公共子序列为”ad”。在动态规划中计算最长公共子序列和最长公共子串中一定要能区分这两个概念!</p>
<p>在C语言中并没有显示的字符串类型，它有如下两种风格的字符串：</p>
<ul>
<li>字符串常量: 以双引号扩起来的字符序列，规定所有的字符串常量都由编译器自动在末尾添加一个空字符</li>
<li>字符数组: 末尾添加了’\0’的字符数组，一般需要显示在末尾添加空字符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char c1[]&#x3D;&#123;&#39;c&#39;,&#39;+&#39;,&#39;+&#39;&#125;; &#x2F;&#x2F;末尾没有空字符</span><br><span class="line">char c2[]&#x3D;&#123;&#39;c&#39;,&#39;+&#39;,&#39;+&#39;，&#39;\0&#39;&#125;; &#x2F;&#x2F;末尾显示添加空字符</span><br><span class="line">char c3&#x3D;&quot;c++&quot;; &#x2F;&#x2F;末尾自动添加空字符</span><br></pre></td></tr></table></figure>

<p>注意到通过字符数组初始化和字符串常量初始化并不完全相同的。因为字符串常量包含一个额外的空字符用于结束字符串，用它来初始化创建数组时，末尾会自动添加空字符。所以c1的长度是3，后两者的长度是4，并且字符数组c2和c3都被称为C风格字符串，而字符数组c1不是C风格字符串。</p>
<p>规定C风格的字符串都是以NULL空字符(‘\0’)作为终结符结尾。由于它是字符串的终止符，但它本身并不是字符串的一部分，所以字符串的长度并不包括NULL字节，如strlen函数。而且C标准库中提供的各种字符串处理函数都要求提供的字符串或字符数组必须以空字符结束，否则会出现不可预料的结果。如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char c[]&#x3D;&#123;&#39;c&#39;,&#39;+&#39;,&#39;+&#39;&#125;;</span><br><span class="line">printf(&quot;%d\n&quot;,strlen(c)); &#x2F;&#x2F;结果输出为6，这是不正确的</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-标准库中的字符串处理函数"><a href="#2-标准库中的字符串处理函数" class="headerlink" title="2 标准库中的字符串处理函数"></a>2 标准库中的字符串处理函数</h3><p>C标准库中头文件<code>定义了两组字符串函数(C++中用</code>表示)。</p>
<ul>
<li>第一组函数的名字以str开头，它主要处理以’\0’结尾的字符串，所以字符串内部不能包含任何’\0’字符。</li>
<li>第二组函数的名字以mem开头，主要考虑非字符串内部含有零值的情形，它能够处理任意的字节序列，操作与字符串函数类似</li>
<li>除了memmove函数外，其他函数都没定义重叠对象间的行为</li>
</ul>
<p>为了提高程序在不同机器上的移植性，利用typedef定义新类型名，即<code>typedef unsigned int size_t</code>。 程序员必须要保证目标字符数组的空间能够足以存放结果字符串(有可能存在字符数组溢出的危险)</p>
<ul>
<li>字符串处理类</li>
</ul>
<p>如下表为字符串处理函数说明，变量s,t的类型是<code>char *</code>, cs和ct的类型是<code>const char *</code>;n的类型为<code>size_t</code>,c的类型为<code>int</code>。</p>
<p><img src="https://images0.cnblogs.com/blog2015/678327/201507/311507392043956.png" alt="img"></p>
<ul>
<li>内存操作类</li>
</ul>
<p>按照字节数组的方式操作对象，提供一个高效的函数接口(提供字节流的访问)。其中s,t类型是<code>void *</code> ， cs，ct的类型是<code>const void *</code>; n类型为<code>size_t</code>，c类型为<code>int</code>。</p>
<p><img src="https://images0.cnblogs.com/blog2015/678327/201507/311507530171602.png" alt="img"></p>
<p>总结起来，头文件&lt; string.h&gt;实现了如下函数：</p>
<ul>
<li>长度计算、长度不受限和受限的复制、连接和比较版本的函数</li>
<li>基础字符串查找(查找一个字符、一组字符和匹配一个子串)、高级字符串查找（查找子串前缀位置、返回token标记）</li>
<li>处理任意字节序列的内存操作如复制、比较、查找和初始化等函数</li>
</ul>
<h2 id="P20"><a href="#P20" class="headerlink" title="P20"></a>P20</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组矩阵</span></span><br><span class="line">和一维数组一样</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9E/" class="post-title-link" itemprop="url">带你学c带你飞（day1）小甲鱼视频</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-20 15:59:53 / Modified: 17:23:04" itemprop="dateCreated datePublished" datetime="2020-04-20T15:59:53-05:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P1"><a href="#P1" class="headerlink" title="P1"></a>P1</h2><p>打广告</p>
<h2 id="P2"><a href="#P2" class="headerlink" title="P2"></a>P2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.所有的 C 语言程序都需要包含 main() 函数。 代码从 main() 函数开始执行。</span><br><span class="line"></span><br><span class="line">2.&#x2F;* ... *&#x2F; 用于注释说明。</span><br><span class="line"></span><br><span class="line">3.printf() 用于格式化输出到屏幕。printf() 函数在 &quot;stdio.h&quot; 头文件中声明。</span><br><span class="line"></span><br><span class="line">4.stdio.h 是一个头文件 (标准输入输出头文件) , #include 是一个预处理命令，用来引入头文件。 当编译器遇到 printf() 函数时，如果没有找到 stdio.h 头文件，会发生编译错误。</span><br><span class="line"></span><br><span class="line">5.return 0; 语句用于表示退出程序。</span><br></pre></td></tr></table></figure>

<h2 id="P3"><a href="#P3" class="headerlink" title="P3"></a>P3</h2><p>打印 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">print</span>\</span><br><span class="line">f(<span class="string">"hi"</span>&#125;)<span class="comment">//反斜杠表示读下一行开头，可以运行，换行符\n;</span></span><br></pre></td></tr></table></figure>

<h2 id="p4"><a href="#p4" class="headerlink" title="p4"></a>p4</h2><p>变量名：英文字母数字，下划线组成，开头必须是字母下划线。</p>
<p>c有32个关键字</p>
<p>第一类：数 据类型关键 字</p>
<p>A基本数据类 型（5个）：</p>
<p>void： 声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果。</p>
<p>char： 字符型类型数据，属于整型数据的一种。</p>
<p>int： 整型数据，通常为编译器指定的机器字长。</p>
<p>float： 单精度浮点型数据，属于浮点数据的一种，小数点后保存6位。</p>
<p>double： 双精度浮点型数据，属于浮点数据的一种，比float保存的精度高，小数点后保存15/16位。</p>
<p>B类型修饰关 键字（4个）：</p>
<p>short ：修饰int，短整型数据，可省略被修饰的int。 </p>
<p>long ：修饰int，长整形数据，可省略被修饰的int。 </p>
<p>signed ：修饰整型数据，有符号数据类型。 </p>
<p>unsigned： 修饰整型数据，无符号数据类型。</p>
<p>C复杂类型关 键字（5个）：</p>
<p>struct ：结构体声明。 </p>
<p>union ：共用体声明。 </p>
<p>enum ：枚举声明。 </p>
<p>typedef ：声明类型别名。 </p>
<p>sizeof ：得到特定类型或特定类型变量的大小。</p>
<p>D存储级别关 键字（6个）：</p>
<p>auto ：指定为自动变量，由编译器自动分配及释放。通常在栈上分配。 </p>
<p>static ：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部。 </p>
<p>register ：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通 过寄存器而不是堆栈传递参数。 </p>
<p>extern ：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的。 </p>
<p>const ：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改 </p>
<p>volatile ：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存 中取得该变量的值。</p>
<p>第二类：流 程控制关键 字</p>
<p>A跳转结构（4 个）：</p>
<p>return ：用在函数体中，返回特定值（或者是void值，即不返回值）。 </p>
<p>continue： 结束当前循环，开始下一轮循环。 </p>
<p>break ：跳出当前循环或switch结构。 </p>
<p>goto ：无条件跳转语句。</p>
<p>B分支结构（5 个）：</p>
<p>if ：条件语句。 </p>
<p>else： 条件语句否定分支（与if连用）。 </p>
<p>switch： 开关语句（多重分支语句）。 </p>
<p>case ：开关语句中的分支标记。 </p>
<p>default： 开关语句中的“其他”分治，可选。</p>
<p>C循环结构（3 个）：</p>
<p>for ：for循环结构，for(1;2;3)4;的执行顺序为1-&gt;2-&gt;4-&gt;3-&gt;2…循环，其中2为循环条件。 </p>
<p>do：do循环结构，do 1 while(2);的执行顺序是1-&gt;2-&gt;1…循环，2为循环条件。 </p>
<p>while： while循环结构，while(1) 2;的执行顺序是1-&gt;2-&gt;1…循环，1为循环条件， 以上循环语句，当循环条件 表达式为真则继续循环，为假则跳出循环。</p>
<p>c99新增5个关键字</p>
<p>1、<strong>inline</strong>关键字用来定义一个类的内联函数，引入它的主要原因是用它替代C中表达式形式的宏定义</p>
<p>引入原因：C语言是一个效率很高的语言，这种宏定义在形式及使用上像一个函数，但它使用预处理器实现，没有了<strong>参数压栈，代码生成</strong>等一系列的操作</p>
<p>2、<strong>restrict</strong>关键字只用于限定指针；该关键字用于告知编译器，所有修改该指针所指向内容的操作全部都是基于(base on)该指针的，即不存在其它进行修改操作的途径；这样的后果是帮助编译器进行更好的代码优化，生成更有效率的汇编代码。</p>
<p>3、<strong>_Bool</strong>关键字是用于表示布尔值。包含标准头文件 stdbool.h 后，我们可以用 bool 代替 _Bool ，true 代替 1 ，false 代替 0 。</p>
<p>4、<strong>_Complex</strong>and<strong>_Imaginary</strong>关键字</p>
<p>C99标准中定义的复数类型如下：float_Complex; float_Imaginary; double_Complex; double_Imaginary; long double_Complex; long double_Imaginary.</p>
<p>头文件中定义了complex和imaginary宏,并将它们扩展为_Complex和_Imaginary,因此在编写新的应用程序时,应该使用头文件中的complex和imaginary宏。</p>
<p><strong>C语言32个关键字（C99新增5个、C11新增7个）</strong></p>
<p>按年份起始：</p>
<p><strong>auto break case char const continue default do</strong> <strong>double else enum extern float for goto if</strong> <strong>int long register return short signed sizeof static</strong> <strong>struct switch typedef union unsigned void volatile while</strong>1999年12月16日，ISO推出了C99标准，该标准新增了5个C语言关键字：</p>
<p>inline restrict _Bool _Complex _Imaginary2011年12月8日，ISO发布C语言的新标准C11，该标准新增了7个C语言关键字：</p>
<p>_Alignas _Alignof _Atomic _Static_assert _Noreturn _Thread_local _Generic</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%d<span class="comment">//int</span></span><br><span class="line">%c<span class="comment">//char</span></span><br><span class="line">%<span class="number">11.9</span><span class="comment">//11位，小数点后9位</span></span><br><span class="line">gcc test.c -o test &amp;&amp; ./test <span class="comment">//这个-o可以改a.out为你想要的名字， 用&amp;&amp;可以合并编译运行两个阶段，而/ 的意思：目录级别分隔符</span></span><br><span class="line">. 的意思：当前目录</span><br><span class="line">./a 的意思就是：当前目录下文件名为“a”的文件。</span><br><span class="line">Linux中还有 .. 代表上抄级目录</span><br></pre></td></tr></table></figure>

<h2 id="P5"><a href="#P5" class="headerlink" title="P5"></a>P5</h2><p>字符常量单引号，字符串常量双引号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义, 标识符全大写，宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 标识符 常量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.1415926535</span></span><br></pre></td></tr></table></figure>

<p>C++ 语言可以用const 来定义常量，也可以用#define 来定义常量。但是前者比后者有更多的优点：<br>（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。<br>（2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。规则5-2-1：在C++ 程序中只使用const 常量而不使用宏常量，即const 常量完全取代宏常量。</p>
<p>2.实现机制</p>
<p>宏是预处理命令，即在预编译阶段进行字节替换。const常量是变量，在执行时const定义的只读变量在程序运行过程中只有一份拷贝（因为它是全局的只读变量，存放在静态存储区的只读数据区。根据c/c++语法，当你声明该量为常量，即告诉程序和编译器，你不希望此量被修改。 程序的实现，为了保护常量，特将常量都放在受保护的静态存储区内。凡是试图修改这个区域内的值，都将被视为非法，并报错。 这不能理解为凡是字符串都是放在静态存储区域的。这个跟数据类型没有关系，而是这个量是变量还是常量的问题。例如，一个字符串变量就是可以被修改的。 这种静态存储区域的保护机制是由编译器实现的，而非存储该值的内存的电器属性。换言之，实质上内存永远都可以被用户随意修改，只是编译器给用户的代码注入了一些自己的保护代码，通过软件手段将这段内存软保护起来。这种保护在汇编级别可以轻松突破，其保护也就无效了。）。</p>
<p>3.用法区别</p>
<p>define宏定义和const常变量区别：<br>1.define是宏定义，程序在预处理阶段将用define定义的内容进行了替换。因此程序运行时，常量表中并没有用define定义的常量，系统不为它分配内存。const定义的常量，在程序运行时在常量表中，系统为它分配内存。<br>2.define定义的常量，预处理时只是直接进行了替换。所以编译时不能进行数据类型检验。const定义的常量，在编译时进行严格的类型检验，可以避免出错。3.define定义表达式时要注意“边缘效应”，例如如下定义：<br>#define N 2+3 //我们预想的N值是5，我们这样使用N，int a = N/2; //我们预想的a的值是2.5，可实际上a的值是3.5原因在于在预处理阶段，编译器将 a = N/2处理成了 a = 2+3/2；这就是宏定义的字符串替换的“边缘效应”因此要如下定义：#define N (2+3)。const定义表达式没有上述问题。const定义的常量叫做常变量原因有二：const定义常量像变量一样检查类型；const可以在任何地方定义常量，编译器对它的处理过程与变量相似，只是分配内存的地方不同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串常量， <span class="string">'\0'</span>遇到这个会知道字符串结束了</span><br></pre></td></tr></table></figure>



<h2 id="P6"><a href="#P6" class="headerlink" title="P6"></a>P6</h2><p>C语言数据类型的分类方式如下：</p>
<ul>
<li>基本类型<ul>
<li>标准整数类型，以及扩充的整数类型</li>
<li>实数浮点类型，以及复数浮点类型</li>
</ul>
</li>
<li>枚举类型</li>
<li>void类型</li>
<li>派生类型<ul>
<li>指针类型</li>
<li>数组类型</li>
<li>结构类型</li>
</ul>
</li>
<li>联合类型</li>
<li>函数类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(a);<span class="comment">//return size of a</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span>);<span class="comment">//return 4单位是字节</span></span><br></pre></td></tr></table></figure>

<p>objective-c 中的BOOL 实际上是一种对带符号的字符类型（signed char）的类型定义（typedef），它使用8位的存储空间。通过#define指令把YES定义为1，NO定义为0。</p>
<p>C99标准定义了一个新的关键字_Bool，提供了布尔类内型。以前，C程序员总是使用自己的方法定义布尔类型。0表示false，非0表示true。</p>
<p>可能使用char类型表示一个布尔类型，也可能使用int类型表示一个布尔类型。</p>
<p>1、类型不同百 :  BOOL为int型 , bool为布尔型  </p>
<p>2、长度不同 : bool只有一个字节 , BOOL长度视实际环境来定，一般可认为是4个字节 </p>
<p>3、取值不同 :bool取值false和true，是0和1的区别； false可以代表0，但true有很多种，并非度只有1。  </p>
<p>4、bool表示布尔型变量，也就是逻辑型变量的定义符，以英国数学家、布尔代数的奠基人乔治·布尔（George Boole）命名。</p>
<p>总结bool是true，false，而_Bool is 0,1 但是都是1字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign <span class="keyword">unsigned</span><span class="comment">//带符号不带符号，如果不用会引发栈溢出栈泄露</span></span><br></pre></td></tr></table></figure>

<h2 id="P7"><a href="#P7" class="headerlink" title="P7"></a>P7</h2><p>printf是输出一个字符串，putchar输出一个char。</p>
<p>printf格式字符：</p>
<table>
<thead>
<tr>
<th>打印格式</th>
<th>对应数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>int</td>
<td>接受整数值并将它表示为有符号的十进制整数</td>
</tr>
<tr>
<td>%hd</td>
<td>short int</td>
<td>短整数</td>
</tr>
<tr>
<td>%hu</td>
<td>unsigned short</td>
<td>无符号短整数</td>
</tr>
<tr>
<td>%o</td>
<td>unsigned int</td>
<td>无符号8进制整数</td>
</tr>
<tr>
<td>%u</td>
<td>unsigned int</td>
<td>无符号10进制整数</td>
</tr>
<tr>
<td>%x,%X</td>
<td>unsigned int</td>
<td>无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF</td>
</tr>
<tr>
<td>%f</td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td>%lf</td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td>%e,%E</td>
<td>double</td>
<td>科学计数法表示的数，此处”e”的大小写代表在输出时用的”e”的大小写</td>
</tr>
<tr>
<td>%c</td>
<td>char</td>
<td>字符型。可以把输入的数字按照ASCII码相应转换’对应的字符</td>
</tr>
<tr>
<td>%s</td>
<td>char *</td>
<td>字符串。输出字符串中的字符直至字符串中的空字符（字符串以’\0‘结尾，这个’\0’即空字符）</td>
</tr>
<tr>
<td>%p</td>
<td>void *</td>
<td>以16进制形式输出指针</td>
</tr>
<tr>
<td>%%</td>
<td>%</td>
<td>输出一个百分号</td>
</tr>
</tbody></table>
<p> %d  整形 int</p>
<p> %f  浮点型 float</p>
<p> %c  字符型  char </p>
<p> %hd 短整型  short</p>
<p> %ld  长整形  long</p>
<p> %lld  长长整形  long long </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1b</span>it=<span class="number">8</span> bytes</span><br><span class="line"><span class="built_in">pow</span>(a,b)<span class="comment">//#include &lt;math.h&gt;,一般打印需要&lt;stdio.h&gt;, a的b次方</span></span><br><span class="line">gcc -lm test.c &amp;&amp; ./a.out<span class="comment">// warning:overflow in implicit constant conversion</span></span><br><span class="line">  unsign <span class="keyword">int</span> 用%u，sign <span class="keyword">int</span>用%d</span><br></pre></td></tr></table></figure>

<p>使用math.h中声明的库函数还有一点特殊之处，gcc命令行必须加-lm选项，因为数学函数位于libm.so库文件中（这些库文件通常位于/lib目录下），-lm选项告诉编译器，我们程序中用到的数学函数要到这个库文件里找。本书用到的大部分库函数（例如printf）位于libc.so库文件中，使用libc.so中的库函数在编译时不需要加-lc选项，当然加了也不算错，因为这个选项是gcc的默认选项。</p>
<p>  C标准主要由两部分组成，一部分描述C的语法，另一部分描述C标准库。C标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型 声明和宏定义。要在一个平台上支持C语言，不仅要实现C编译器，还要实现C标准库，这样的实现才算符合C标准。不符合C标准的实现也是存在的，例如很多单 片机的C语言开发工具中只有C编译器而没有完整的C标准库。</p>
<p>在Linux平台上最广泛使用的C函数库是glibc，其中包括C标准库的实现。几乎所有C程序都要调用glibc的库函数，所以glibc是Linux平台C程序运行的基础。glibc提供一组头文件和一组库文件，最基本、最常用的C标准库函数和系统函数在libc.so库文件中，几乎所有C程序的运行都依赖于libc.so，有些做数学计算的C程序依赖于libm.so，以后我们还会看到多线程的C程序依赖于libpthread.so。以后我说libc时专指libc.so这个库文件，而说glibc时指的是glibc提供的所有库文件。</p>
<h3 id="1-原码"><a href="#1-原码" class="headerlink" title="1. 原码"></a>1. 原码</h3><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p>
<blockquote>
<p>[+1]原 = 0000 0001</p>
<p>[-1]原 = 1000 0001</p>
</blockquote>
<p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p>
<blockquote>
<p>[1111 1111 , 0111 1111]</p>
</blockquote>
<p>即</p>
<blockquote>
<p>[-127 , 127]</p>
</blockquote>
<p>原码是人脑最容易理解和计算的表示方式.</p>
<h3 id="2-反码"><a href="#2-反码" class="headerlink" title="2. 反码"></a>2. 反码</h3><p>反码的表示方法是:</p>
<p>正数的反码是其本身</p>
<p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反</p>
<p>[-1] = [10000001]原 = [11111110]反</p>
</blockquote>
<p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p>
<h3 id="3-补码"><a href="#3-补码" class="headerlink" title="3. 补码"></a>3. 补码</h3><p>补码的表示方法是:</p>
<p>正数的补码就是其本身</p>
<p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p>
<h2 id="P8"><a href="#P8" class="headerlink" title="P8"></a>P8</h2><p>字符用ASCII字符表写的，常用的ascii: 空格的ASCII码值为32；数字0到9的ASCII码值分别为48到57；大写字母“A”到“Z”的ASCII码值分别为65到90；小写字母“a”到“z”的ASCII码值分别为97到到122。</p>
<p>字符类型是特殊的整型，ascii有0-255个字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="number">170</span>；<span class="comment">//这是正数，若不用unsigned，则是负数</span></span><br></pre></td></tr></table></figure>

<p>字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[length];<span class="comment">//0 to length-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经典问题</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">2</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hi\n"</span>);<span class="comment">//会出现错误，因为字符数组a没有\0,改法： char a[3]=&#123;'a','b'，'\0'&#125;;</span></span><br><span class="line"><span class="keyword">char</span> a[]=<span class="string">"hi"</span>;<span class="comment">//字符串常量</span></span><br></pre></td></tr></table></figure>

<h2 id="P9"><a href="#P9" class="headerlink" title="P9"></a>P9</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>/<span class="number">3</span>=<span class="number">1</span></span><br><span class="line"><span class="number">5</span>%<span class="number">3</span>=<span class="number">2</span></span><br><span class="line"><span class="number">5.0</span>%<span class="number">3.0</span><span class="comment">//出错</span></span><br><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line"> <span class="number">1</span>+<span class="number">2.0</span>;<span class="comment">//-&gt;1.0+2.0</span></span><br><span class="line"> <span class="number">1</span>+(<span class="keyword">int</span>)<span class="number">2.0</span>;<span class="comment">//-&gt;3 </span></span><br><span class="line"><span class="number">1</span>+(<span class="keyword">int</span>)<span class="number">1.8</span>;<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h2 id="P10"><a href="#P10" class="headerlink" title="P10"></a>P10</h2><p>关系表达式返回0，1</p>
<p>c语言中没有true，false，只有1，0</p>
<p>c和java一样采用短路与和短路或</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E4%B9%8Bc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E4%B9%8Bc/" class="post-title-link" itemprop="url">小甲鱼之c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-19 16:01:44 / Modified: 16:30:59" itemprop="dateCreated datePublished" datetime="2020-04-19T16:01:44-05:00">2020-04-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P1-C-和OO思想"><a href="#P1-C-和OO思想" class="headerlink" title="P1:C++和OO思想"></a>P1:C++和OO思想</h2><p>经典面向对象java 一样封装继承多态</p>
<h2 id="P2-P4-从小程序说起"><a href="#P2-P4-从小程序说起" class="headerlink" title="P2-P4:从小程序说起"></a>P2-P4:从小程序说起</h2><p>1.类，异常，对象都是c++特有的</p>
<ol start="2">
<li><p>整形数组求和：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">addArray</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n)</span></span>;<span class="comment">//在main用前需要声明</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> data[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">size</span>=<span class="keyword">sizeof</span>(data)/<span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"data size: %ld\n"</span>,<span class="keyword">sizeof</span>(data));<span class="comment">//不要用%d，c99报错</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"answer :%d\n"</span>,addArray(data,<span class="built_in">size</span>));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">addArray</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"data size: %ld\n"</span>,<span class="keyword">sizeof</span>(<span class="built_in">array</span>));</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">       sum+=<span class="built_in">array</span>[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/*data size: 40</span></span><br><span class="line"><span class="comment">   data size: 8</span></span><br><span class="line"><span class="comment">   answer :45</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++版本</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jackson</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jackson</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
