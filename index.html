<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jackson Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jackson Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jackson">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jackson Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jackson Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/python400%E9%9B%864/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/python400%E9%9B%864/" class="post-title-link" itemprop="url">python400集4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 15:09:31" itemprop="dateCreated datePublished" datetime="2020-04-29T15:09:31-05:00">2020-04-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/python400%E9%9B%863/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/python400%E9%9B%863/" class="post-title-link" itemprop="url">python400集3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 15:09:28" itemprop="dateCreated datePublished" datetime="2020-04-29T15:09:28-05:00">2020-04-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/python400%E9%9B%862/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/python400%E9%9B%862/" class="post-title-link" itemprop="url">python400集2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 15:09:25" itemprop="dateCreated datePublished" datetime="2020-04-29T15:09:25-05:00">2020-04-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/python400%E9%9B%861/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/python400%E9%9B%861/" class="post-title-link" itemprop="url">python400集1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-29 15:09:21 / Modified: 16:25:10" itemprop="dateCreated datePublished" datetime="2020-04-29T15:09:21-05:00">2020-04-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="python基础入门"><a href="#python基础入门" class="headerlink" title="python基础入门"></a>python基础入门</h1><h2 id="python入门"><a href="#python入门" class="headerlink" title="python入门"></a>python入门</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h3><ol>
<li><p>(1)  行注释</p>
<p>每行注释前加#号。当解释器看到#，则忽略这一行#后面的内容</p>
</li>
<li><p>(2)  段注释</p>
<p>使用三个连续单引号(‘’’)。当解释看到’’’，则会扫描到下一个’’’，然后忽略他们</p>
</li>
</ol>
<p>之间的内容。</p>
<h3 id="2-行连接符"><a href="#2-行连接符" class="headerlink" title="2.行连接符"></a>2.行连接符</h3><p><strong>使用\行连接符</strong></p>
<p>一行程序长度是没有限制的，但是为了可读性更强，通常将一行比较长的程序分为多行。这 是，我们可以使用\行连接符，把它放在行结束的地方。Python 解释器仍然将它们解释为同 一行。</p>
<p>&gt;&gt;&gt;  a = [10,20,30,40,\ 50,60,70,\</p>
<p>​        80,90,100]</p>
<h3 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h3><p><strong>Python 中，一切皆对象。</strong>每个对象由:标识(identity)、类型(type)、value(值)</p>
<p>组成。</p>
<ol>
<li><p>标识用于唯一标识对象，通常对应于对象在计算机内存中的地址。使用内置函数 id(obj) 可返回对象 obj 的标识。</p>
</li>
<li><p>类型用于表示对象存储的“数据”的类型。类型可以限制对象的取值范围以及可执行的 操作。可以使用 type(obj)获得对象的所属类型。</p>
</li>
<li><p>值表示对象所存储的数据的信息。使用 print(obj)可以直接打印出值。</p>
</li>
</ol>
<p><strong>对象的本质就是:一个内存块，拥有特定的值，支持特定类型的相关操作。</strong></p>
<p>源码:</p>
<p>&gt;&gt;&gt; a = 3<br> &gt;&gt;&gt; a<br> 3<br> &gt;&gt;&gt; id(3) 1531372336<br> &gt;&gt;&gt; type(3) &lt;class ‘int’&gt;<br> &gt;&gt;&gt; b = “我爱你” &gt;&gt;&gt; id(a) 1531372336</p>
<p>&gt;&gt;&gt; type(a) &lt;class ‘int’&gt; &gt;&gt;&gt; print(a) 3</p>
<p>&gt;&gt;&gt; id(b) 46806816 &gt;&gt;&gt; type(b) &lt;class ‘str’&gt;</p>
<p><strong>引用</strong></p>
<p>在 Python 中，变量也称为:对象的引用。因为，变量存储的就是对象的地址。 变量通过地址引用了“对象”。</p>
<p>变量位于:栈内存(压栈出栈等细节，后续再介绍)。 对象位于:堆内存。</p>
<p><strong>·Python 是动态类型语言</strong></p>
<p>变量不需要显式声明类型。根据变量引用的对象，Python 解释器自动确定数据类型。</p>
<p><strong>·Python 是强类型语言</strong></p>
<p>每个对象都有数据类型，只支持该类型支持的操作。</p>
<h3 id="4-python标识符规则"><a href="#4-python标识符规则" class="headerlink" title="4.python标识符规则"></a>4.python标识符规则</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>模块和包名</td>
<td>全小写字母，尽量简单。若多个单词之间用 下划线</td>
<td>math, os, sys</td>
</tr>
<tr>
<td>函数名</td>
<td>全小写字母，多个单词之间用下划线隔开</td>
<td>phone, my_name</td>
</tr>
<tr>
<td>类名</td>
<td>首字母大写，采用驼峰原则。多个单词时， 每个单词第一个字母大写，其余部分小写</td>
<td>MyPhone 、 MyClass 、 Phone</td>
</tr>
<tr>
<td>常量名</td>
<td>全大写字母，多个单词使用下划线隔开</td>
<td>SPEED、MAX_SPEED</td>
</tr>
</tbody></table>
<h3 id="5-变量声明赋值"><a href="#5-变量声明赋值" class="headerlink" title="5.变量声明赋值"></a>5.变量声明赋值</h3><p>变量的声明和赋值用于将一个变量绑定到一个对象上，格式如下: 变量名 = 表达式</p>
<p>最简单的表达式就是字面量。比如:a = 123 。 运行过程中，解释器先运行右边的表达式， 生成一个代表表达式运算结果的对象;然后，将这个对象地址赋值给左边的变量。</p>
<p><strong>变量在使用前必须先被初始化(先被赋值)</strong>，否则出现NameError</p>
<p>可以通过 del 语句删除不在使用的变量。</p>
<p>如果对象没有变量引用，就会被垃圾回收器回收，清空内存空间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;pyshell#20&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; x</span><br><span class="line">NameError: name <span class="string">'x'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>

<p><strong>链式赋值</strong></p>
<p>链式赋值用于同一个对象赋值给多个变量。 x=y=123 相当于:x=123; y=123</p>
<p><strong>系列解包赋值</strong></p>
<p>系列数据赋值给对应相同个数的变量(个数必须保持一致) &gt;&gt;&gt; a,b,c=4,5,6 相当于:a=4;b=5;c=6</p>
<p>使用系列解包赋值实现变量交换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a,b&#x3D;1,2 </span><br><span class="line">&gt;&gt;&gt; a,b&#x3D;b,a </span><br><span class="line">&gt;&gt;&gt; print(a,b) </span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<p>Python 不支持常量，即没有语法规则限制改变一个常量的值。我们只能约定常量的命名规 则，以及在程序的逻辑上不对常量的值作出修改。（bug，其实可以改，所以说还是java好啊）</p>
<h3 id="6-数据类型"><a href="#6-数据类型" class="headerlink" title="6.数据类型"></a>6.数据类型</h3><p><strong>使用 int()实现类型转换:</strong>：其他类型转int</p>
<p>python有自动转型，小转大，int+float自动转float</p>
<p>最大整数是googol，也就是Google最初的名字，googol = 10**100</p>
<p>类似于 int()，我们也可以使用 float()将其他类型转化成浮点数。</p>
<p>round(value)可以返回四舍五入的值 注:但不会改变原有值，而是产生新的值</p>
<p>运算符+、-、<em>，/、//、*</em>和%和赋值符=结合可以构成“增强型赋值运算符”。</p>
<p>注意:“+=”中间不能加空格!</p>
<p>python 中可以通过 time.time() 获得当前时刻，返回的值是以秒为单位，带微秒 (1/1000 毫秒)精度的浮点值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import time</span><br><span class="line">&gt;&gt;&gt; b &#x3D; int(time.time())</span><br><span class="line">&gt;&gt;&gt; totalMinutes &#x3D; b&#x2F;60</span><br><span class="line">&gt;&gt;&gt; totalMinutes &#x3D; b&#x2F;&#x2F;60</span><br><span class="line">&gt;&gt;&gt; totalHours &#x3D; totalMinutes&#x2F;&#x2F;60</span><br><span class="line">&gt;&gt;&gt; totalDays &#x3D; totalHours&#x2F;&#x2F;24</span><br><span class="line">&gt;&gt;&gt; totalYears &#x3D; totalDays&#x2F;&#x2F;365</span><br></pre></td></tr></table></figure>

<p>Python2 中没有布尔值，直接用数字 0 表示 False,用数字 1 表示 True。（类似c）<br> Python3 中，把 True 和 False 定义成了关键字，但他们的本质还是 1 和 0，甚至可以和数 字相加。</p>
<p>同一运算符用于比较两个对象的存储单元，实际比较的是对象的地址。</p>
<p>is;is 是判断两个标识符是不是引用同一个对象</p>
<p>is not：is not 是判断两个标识符是不是引用不同对象</p>
<p>is 与 == 区别:<br> is 用于判断两个变量引用对象是否为同一个，既比较对象的地址。</p>
<p>== 用于判断引用变量引用对象的值是否相等，默认调用对象的 <strong>eq</strong>()方法。</p>
<h4 id="Python-仅仅对比较小的整数对象进行缓存-范围为-5-256-缓存起来，而并非是所有整数对-象。需要注意的是，这仅仅是在命令行中执行，而在-Pycharm-或者保存为文件执行，结果是不一样-的，这是因为解释器做了一部分优化-范围是-5-任意正整数-。"><a href="#Python-仅仅对比较小的整数对象进行缓存-范围为-5-256-缓存起来，而并非是所有整数对-象。需要注意的是，这仅仅是在命令行中执行，而在-Pycharm-或者保存为文件执行，结果是不一样-的，这是因为解释器做了一部分优化-范围是-5-任意正整数-。" class="headerlink" title="Python 仅仅对比较小的整数对象进行缓存(范围为[-5, 256])缓存起来，而并非是所有整数对 象。需要注意的是，这仅仅是在命令行中执行，而在 Pycharm 或者保存为文件执行，结果是不一样 的，这是因为解释器做了一部分优化(范围是[-5,任意正整数])。"></a>Python 仅仅对比较小的整数对象进行缓存(范围为[-5, 256])缓存起来，而并非是所有整数对 象。需要注意的是，这仅仅是在命令行中执行，而在 Pycharm 或者保存为文件执行，结果是不一样 的，这是因为解释器做了一部分优化(范围是[-5,任意正整数])。</h4><table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
<tr>
<td><strong>·总结</strong></td>
</tr>
<tr>
<td>1、is 比较两个对象的 id 值是否相等，是否指向同一个内存地址;</td>
</tr>
<tr>
<td>2、== 比较的是两个对象的内容是否相等，值是否相等;</td>
</tr>
<tr>
<td>3、小整数对象[-5,256]在全局解释器范围内被放入缓存供重复使用;</td>
</tr>
<tr>
<td>4、is 运算符比 == 效率高，在变量和 None 进行比较时，应该使用 is。</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; 1000</span><br><span class="line">&gt;&gt;&gt; b &#x3D; 1000</span><br><span class="line">&gt;&gt;&gt; a &#x3D;&#x3D; b </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a is b </span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; id(a) 46764560 </span><br><span class="line">&gt;&gt;&gt; id(b) 46765216 </span><br><span class="line">&gt;&gt;&gt; c &#x3D; 10 </span><br><span class="line">&gt;&gt;&gt; d &#x3D; 10 </span><br><span class="line">&gt;&gt;&gt; c is d </span><br><span class="line">True#和整数缓存有关，类似java</span><br><span class="line">&gt;&gt;&gt; id(c) 1388831648 </span><br><span class="line">&gt;&gt;&gt; id(d) 1388831648</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="与-C-和-JAVA-不一样，Python-不支持自增-和自减-–"><a href="#与-C-和-JAVA-不一样，Python-不支持自增-和自减-–" class="headerlink" title="与 C 和 JAVA 不一样，Python 不支持自增(++)和自减(–)"></a>与 C 和 JAVA 不一样，Python 不支持自增(++)和自减(–)</h4><h3 id="7。字符串"><a href="#7。字符串" class="headerlink" title="7。字符串"></a>7。字符串</h3><p>字符串的本质是:字符序列。Python 的字符串是不可变的，我们无法对原字符串做任 何修改。但，可以将字符串的一部分复制到新创建的字符串，达到“看起来修改”的效果。</p>
<p>Python 不支持单字符类型，单字符也是作为一个字符串使用的。</p>
<p>Python3 直接支持 Unicode，可以表示世界上任何书面语言的字符。Python3 的字符 默认就是 16 位 Unicode 编码，ASCII 码是 Unicode 编码的子集。</p>
<p>使用内置函数 ord()可以把字符转换成对应的 Unicode 码; 使用内置函数 chr()可以把十进制数字转换成对应的字符。</p>
<p>连续三个单引号或三个双引号，可以帮助我们创建多行字符串。例如: </p>
<p>resume = ‘’’ name=”gaoqi”<br> company=”sxt” age=18<br> lover=”Tom”‘’’</p>
<p>&gt;&gt;&gt; print(resume) </p>
<p>name=”gaoqi”</p>
<p>company=”sxt” age=18 lover=”Tom”</p>
<p>转义字符： 我们可以使用“\+特殊字符”，实现某些难以用字符表示的效果</p>
<p>我们前面调用 print 时，会自动打印一个换行符。有时，我们不想换行，不想自动添加换行 符。我们可以自己通过参数 end = “任意字符串”。实现末尾添加任何内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;sxt&quot;,end&#x3D;&#39; &#39;) </span><br><span class="line">print(&quot;sxt&quot;,end&#x3D;&#39;##&#39;) </span><br><span class="line">print(&quot;sxt&quot;)</span><br><span class="line">运行结果:</span><br><span class="line">sxt sxt##sxt</span><br></pre></td></tr></table></figure>

<p>我们可以使用 input()从控制台读取键盘输入的内容。</p>
<p>当我们调用 print()函数时，解释器自动调用了 str()将非字符串的对象转成了字符串。</p>
<p>字符串的本质就是字符序列，我们可以通过在字符串后面添加[]，在[]里面指定偏移量， 可以提取该位置的单个字符。</p>
<p>正向搜索:<br> 最左侧第一个字符，偏移量是 0，第二个偏移量是 1，以此类推。直到 len(str)-1</p>
<p>为止。 反向搜索:</p>
<p>最右侧第一个字符，偏移量是-1，倒数第二个偏移量是-2，以此类推，直到-len(str) 为止。</p>
<p>字符串不可改变。但是，我们确实有时候需要替换某些字符。这时，只能通过创建新的字符 串来实现。</p>
<p>使用replace</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;&quot;alfjoashoa&quot;</span><br><span class="line">a&#x3D;a.replace(&quot;a&quot;,&quot;替换字&quot;)</span><br></pre></td></tr></table></figure>

<p>切片 slice 操作可以让我们快速的提取子字符串。标准格式为: [起始偏移量 start:终止偏移量 end:步长 step]</p>
<p>典型操作(三个量为正数的情况)如下:</p>
<table>
<thead>
<tr>
<th>操作和说明</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>[:] 提取整个字符串</td>
<td>“abcdef”[:]</td>
<td>“abcdef”</td>
</tr>
<tr>
<td>[start:]从 start 索引开始到结尾</td>
<td>“abcdef”[2:]</td>
<td>“cdef”</td>
</tr>
<tr>
<td>[:end]从头开始知道 end-1</td>
<td>“abcdef”[:2]</td>
<td>“ab”</td>
</tr>
<tr>
<td>[start:end]从 start 到 end-1</td>
<td>“abcdef”[2:4]</td>
<td>“cd”</td>
</tr>
<tr>
<td>[start​：end:step]从 start 提取到 end-1，步长是 step</td>
<td>“abcdef”[1:5:2]</td>
<td>“bd”</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其他操作(三个量为负数)的情况:</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>“abcdefghijklmnopqrstuv wxyz”[-3:]</td>
<td>倒数三个</td>
<td>“xyz”</td>
</tr>
<tr>
<td>“abcdefghijklmnopqrstuv wxyz”[-8:-3]</td>
<td>倒数第八个到倒数第 三个(包头不包尾)</td>
<td>‘stuvw’</td>
</tr>
<tr>
<td>“abcdefghijklmnopqrstuv wxyz”[::-1]</td>
<td>步长为负，从右到左 反向提取</td>
<td>‘zyxwvutsrqpon mlkjihgfedcba’</td>
</tr>
</tbody></table>
<p><strong>split()分割和 join()合并</strong></p>
<p>split()可以基于指定分隔符将字符串分隔成多个子字符串(存储到列表中)。如果不指定分隔 符，则默认使用空白字符(换行符/空格/制表符)。示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;to be or not to be&quot; </span><br><span class="line">&gt;&gt;&gt; a.split()</span><br><span class="line">[&#39;to&#39;, &#39;be&#39;, &#39;or&#39;, &#39;not&#39;, &#39;to&#39;, &#39;be&#39;] </span><br><span class="line">&gt;&gt;&gt; a.split(&#39;be&#39;)</span><br><span class="line">[&#39;to &#39;, &#39; or not to &#39;, &#39;&#39;]</span><br></pre></td></tr></table></figure>

<p>join()的作用和 split()作用刚好相反，用于将一系列子字符串连接起来。示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [&#39;sxt&#39;,&#39;sxt100&#39;,&#39;sxt200&#39;]</span><br><span class="line">&gt;&gt;&gt; &#39;*&#39;.join(a)</span><br><span class="line">&#39;sxt*sxt100*sxt200&#39;</span><br></pre></td></tr></table></figure>

<p><strong>拼接字符串要点:</strong></p>
<p>使用字符串拼接符+，会生成新的字符串对象，因此不推荐使用+来拼接字符串。推荐 使用 join 函数，因为 join 函数在拼接字符串之前会计算所有字符串的长度，然后逐一拷贝， 仅新建一次对象。</p>
<p><strong>字符串驻留:</strong>仅保存一份相同且不可变字符串的方法，不同的值被存放在字符串驻留池中。 Python 支持字符串驻留机制，对于符合标识符规则的字符串(仅包含下划线(_)、字母 和数字)会启用字符串驻留机制驻留机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;abd_33&quot;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; &quot;abd_33&quot;</span><br><span class="line">&gt;&gt;&gt; a is b </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; c &#x3D; &quot;dd#&quot;</span><br><span class="line">&gt;&gt;&gt; d &#x3D; &quot;dd#&quot;</span><br><span class="line">&gt;&gt;&gt; c is d </span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; str1 &#x3D; &quot;aa&quot;</span><br><span class="line">&gt;&gt;&gt; str2 &#x3D; &quot;bb&quot;</span><br><span class="line">&gt;&gt;&gt; str1+str2 is &quot;aabb&quot;</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; str1+str2 &#x3D;&#x3D; &quot;aabb&quot; </span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p><strong>字符串比较和同一性</strong></p>
<p>我们可以直接使用==,!=对字符串进行比较，是否含有相同的字符。<br> 我们使用 is / not is，判断两个对象是否同一个对象。比较的是对象的地址，即 id(obj1)是 否和 id(obj2)相等。</p>
<h3 id="字符串常用方法汇总"><a href="#字符串常用方法汇总" class="headerlink" title="字符串常用方法汇总"></a><strong>字符串常用方法汇总</strong></h3><p><strong>常用查找方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;&quot;akhfahglwaejiorhsdlhgkld&quot;</span><br><span class="line">len(a)#返回长度</span><br><span class="line">a.startswith(&#39;a&#39;)#以指定字符串开头</span><br><span class="line">a.endswith(&#39;d&#39;)#以指定字符串结尾</span><br><span class="line">a.find(&#39;k&#39;)#第一次出现指定字符串的位置</span><br><span class="line">a.rfind(&#39;d&#39;)#最后一次出现指定字符串的位置</span><br><span class="line">a.count(&#39;ad&#39;)#指定字符串出现几次</span><br><span class="line">a.isalnum()#所有字符全是字母数字</span><br></pre></td></tr></table></figure>

<p><strong>去除首尾信息</strong></p>
<p>我们可以通过 strip()去除字符串首尾指定信息。通过 lstrip()去除字符串左边指定信息， rstrip()去除字符串右边指定信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;*s*x*t*&quot;.strip(&quot;*&quot;) </span><br><span class="line">&#39;s*x*t&#39;</span><br><span class="line">&gt;&gt;&gt; &quot;*s*x*t*&quot;.lstrip(&quot;*&quot;) </span><br><span class="line">&#39;s*x*t*&#39;</span><br><span class="line">&gt;&gt;&gt; &quot;*s*x*t*&quot;.rstrip(&quot;*&quot;) </span><br><span class="line">&#39;*s*x*t&#39;</span><br><span class="line">&gt;&gt;&gt; &quot; sxt &quot;.strip() </span><br><span class="line">&#39;sxt&#39;</span><br></pre></td></tr></table></figure>

<p><strong>大小写转换</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>a.capitalize()</td>
<td>产生新的字符串,首字母 大写</td>
<td></td>
</tr>
<tr>
<td>a.title()</td>
<td>产生新的字符串,每个单 词都首字母大写</td>
<td></td>
</tr>
<tr>
<td>a.upper()</td>
<td>产生新的字符串,所有字 符全转成大写</td>
<td></td>
</tr>
<tr>
<td>a.lower()</td>
<td>产生新的字符串,所有字 符全转成小写</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>a.swapcase()</th>
<th>产生新的,所有字母大小 写转换</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>格式排版</strong></p>
<p>center()、ljust()、rjust()这三个函数用于对字符串实现排版。示例如下: &gt;&gt;&gt; a=”SXT”<br> &gt;&gt;&gt; a.center(10,”*”)<br> ‘<strong><em>SXT*</em></strong>‘</p>
<p>&gt;&gt;&gt; a.center(10)<br> ‘ SXT ‘<br> &gt;&gt;&gt; a.ljust(10,”*”) ‘SXT<strong>***</strong>‘</p>
<p><strong>其他方法</strong></p>
<p>\1. isalnum() 是否为字母或数字<br> \2. isalpha() 检测字符串是否只由字母组成(含汉字)。 3. isdigit() 检测字符串是否只由数字组成。<br> \4. isspace() 检测是否为空白符<br> \5. isupper() 是否为大写字母<br> \6. islower() 是否为小写字母</p>
<p><strong>字符串的格式化</strong> </p>
<p><strong>format()基本用法</strong></p>
<p>Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的 功能。<br> 基本语法是通过 {} 和 : 来代替以前的 % 。</p>
<p>format 函数可以接受不限个参数，位置可以不按顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;名字是:&#123;0&#125;,年龄是:&#123;1&#125;&quot; </span><br><span class="line">&gt;&gt;&gt; a.format(&quot;高淇&quot;,18) </span><br><span class="line">&#39;名字是:高淇,年龄是:18&#39;</span><br><span class="line">&gt;&gt;&gt; a.format(&quot;高希希&quot;,6) </span><br><span class="line">&#39;名字是:高希希,年龄是:6&#39;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; &quot;名字是:&#123;0&#125;，年龄是&#123;1&#125;。&#123;0&#125;是个好小伙&quot; </span><br><span class="line">&gt;&gt;&gt; b.format(&quot;高淇&quot;,18)</span><br><span class="line">&#39;名字是:高淇，年龄是 18。高淇是个好小伙&#39;</span><br><span class="line">&gt;&gt;&gt; c &#x3D; &quot;名字是&#123;name&#125;，年龄是&#123;age&#125;&quot;</span><br><span class="line">&gt;&gt;&gt; c.format(age&#x3D;19,name&#x3D;&#39;高淇&#39;) </span><br><span class="line">&#39;名字是高淇，年龄是 19&#39;#我们可以通过&#123;索引&#125;&#x2F;&#123;参数名&#125;，直接映射参数值，实现对字符串的格式化，非常方便。</span><br></pre></td></tr></table></figure>

<p><strong>填充与对齐</strong></p>
<p>填充常跟对齐一起使用 ^、&lt;、&gt;分别是居中、左对齐、右对齐，后面带宽度</p>
<p>:号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;:*&gt;8&#125;&quot;.format(&quot;245&quot;)</span><br><span class="line">&#39;*****245&#39;</span><br></pre></td></tr></table></figure>



<p>浮点数通过 f，整数通过 d 进行需要的格式化。案例如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;我是&#123;0&#125;，我的存款有&#123;1:.2f&#125;&quot;</span><br><span class="line"></span><br><span class="line"> &gt;&gt;&gt; a.format(&quot;高淇&quot;,3888.234342) </span><br><span class="line"> &#39;我是高淇，我的存款有 3888.23&#39;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>数字</th>
<th>格式</th>
<th>输出</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>3.1415926</td>
<td>{:.2f}</td>
<td>3.14</td>
<td>保留小数点后两位</td>
</tr>
<tr>
<td>3.1415926</td>
<td>{:+.2f}</td>
<td>3.14</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>2.71828</td>
<td>{:.0f}</td>
<td>3</td>
<td>不带小数</td>
</tr>
<tr>
<td>5</td>
<td>{:0&gt;2d}</td>
<td>05</td>
<td>数字补零 (填充左边, 宽度为 2)</td>
</tr>
<tr>
<td>5</td>
<td>{:x&lt;4d}</td>
<td>5xxx</td>
<td>数字补 x (填充右边, 宽度为 4)</td>
</tr>
<tr>
<td>10</td>
<td>{:x&lt;4d}</td>
<td>10xx</td>
<td>数字补 x (填充右边, 宽度为 4)</td>
</tr>
<tr>
<td>1000000</td>
<td>{:,}</td>
<td>1,000,000</td>
<td>以逗号分隔的数字格式</td>
</tr>
<tr>
<td>0.25</td>
<td>{:.2%}</td>
<td>25.00%</td>
<td>百分比格式</td>
</tr>
<tr>
<td>1000000000</td>
<td>{:.2e}</td>
<td>1.00E+09</td>
<td>指数记法</td>
</tr>
<tr>
<td>13</td>
<td>{:10d}</td>
<td>13</td>
<td>右对齐 (默认, 宽度为 10)</td>
</tr>
<tr>
<td>13</td>
<td>{:&lt;10d}</td>
<td>13</td>
<td>左对齐 (宽度为 10)</td>
</tr>
<tr>
<td>13</td>
<td>{:^10d}</td>
<td>13</td>
<td>中间对齐 (宽度为 10)</td>
</tr>
</tbody></table>
<p><strong>可变字符串</strong></p>
<p>在 Python 中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，智 能创建新的字符串对象。但是，经常我们确实需要原地修改字符串，可以使用 io.StringIO 对象或 array 模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import io</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &quot;hello, sxt&quot;</span><br><span class="line">&gt;&gt;&gt; sio &#x3D; io.StringIO(s)</span><br><span class="line">&gt;&gt;&gt; sio</span><br><span class="line">&lt;_io.StringIO object at 0x02F462B0&gt; &gt;&gt;&gt; sio.getvalue()</span><br><span class="line">&#39;hello, sxt&#39;</span><br><span class="line">&gt;&gt;&gt; sio.seek(7)</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; sio.write(&quot;g&quot;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; sio.getvalue()</span><br><span class="line">&#39;hello, gxt&#39;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/ssh%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/ssh%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">ssh，scp详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-29 10:36:17 / Modified: 10:56:59" itemprop="dateCreated datePublished" datetime="2020-04-29T10:36:17-05:00">2020-04-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用"><a href="#教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用" class="headerlink" title="教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用"></a>教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用</h1><h2 id="教你玩转ssh"><a href="#教你玩转ssh" class="headerlink" title="教你玩转ssh"></a>教你玩转ssh</h2><p>ssh， secure shell，远程登录服务器，机器的一种命令。</p>
<p>此教程仅适合mac，unix，linux系统，windows系统请使用PuTTy 等软件进行操作。</p>
<h3 id="1-先在本机生成rsa密钥对"><a href="#1-先在本机生成rsa密钥对" class="headerlink" title="1.先在本机生成rsa密钥对"></a>1.先在本机生成rsa密钥对</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<h3 id="2-然后一路enter，不要设置密码"><a href="#2-然后一路enter，不要设置密码" class="headerlink" title="2.然后一路enter，不要设置密码"></a>2.然后一路enter，不要设置密码</h3><p>本机 .ssh 隐藏目录中会多几个文件，</p>
<p>authorized-keys    config        id_rsa        id_rsa.pub    known_hosts</p>
<p>其中id_rsa.pub是你的公钥，id_rsa是私钥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi config</span><br><span class="line">#点i进入insert模式,按照各人信息填入，school是你想要的快捷名，以后无需输入ip和用户名了，ip是远程服务器ip</span><br><span class="line">Host school</span><br><span class="line">	HostName ip address</span><br><span class="line">	User username</span><br><span class="line">	Port portnumber</span><br></pre></td></tr></table></figure>

<h3 id="3-然后开始免密操作，很简单，mac需要homebrew"><a href="#3-然后开始免密操作，很简单，mac需要homebrew" class="headerlink" title="3.然后开始免密操作，很简单，mac需要homebrew"></a>3.然后开始免密操作，很简单，mac需要homebrew</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ssh-copy-id</span><br></pre></td></tr></table></figure>

<p>然后，主要此处school是你的快捷名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id school</span><br></pre></td></tr></table></figure>

<p>这是最简单的操作，或者手动把你的公钥复制到远程服务器~/.ssh/authorized_keys中。</p>
<h2 id="教你玩会scp"><a href="#教你玩会scp" class="headerlink" title="教你玩会scp"></a>教你玩会scp</h2><p>ssh就这么简单，既然如此简单，我们顺便提一下scp。</p>
<p>scp就是安全传输文件的命令，</p>
<p>scp没有那么多小技巧，唯一就是要注意路径怎么写，要用绝对路径，最好不要相对路径。</p>
<p>还有就是目录需要加-r</p>
<p>. 表示当前目录</p>
<p>~表示家目录</p>
<p>/表示根目录</p>
<p>了解以上3个即可帮你灵活使用scp了，记住，unix类的操作系统都是树形管理文件的，而不是windows分区形（其实我也不了解）</p>
<p>下面我们开始了解scp命令</p>
<h3 id="1、从本地复制到远程"><a href="#1、从本地复制到远程" class="headerlink" title="1、从本地复制到远程"></a>1、从本地复制到远程</h3><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_username@remote_ip:remote_file </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_ip:remote_file</span><br></pre></td></tr></table></figure>



<ul>
<li>第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名； </li>
<li>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；</li>
</ul>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3 </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3</span><br></pre></td></tr></table></figure>

<p>复制目录命令格式： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp -r local_folder remote_ip:remote_folder</span><br></pre></td></tr></table></figure>

<ul>
<li>第1个指定了用户名，命令执行后需要再输入密码；</li>
<li>第2个没有指定用户名，命令执行后需要输入用户名和密码；</li>
</ul>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; </span><br><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;</span><br></pre></td></tr></table></figure>

<p>上面命令将本地 music 目录复制到远程 others 目录下。</p>
<h3 id="2、从远程复制到本地"><a href="#2、从远程复制到本地" class="headerlink" title="2、从远程复制到本地"></a>2、从远程复制到本地</h3><p>从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例 </p>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 </span><br><span class="line">scp -r www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; &#x2F;home&#x2F;space&#x2F;music&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>1.如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#scp 命令使用端口号 4588</span><br><span class="line">scp -P 4588 remote@www.runoob.com:&#x2F;usr&#x2F;local&#x2F;sin.sh &#x2F;home&#x2F;administrator</span><br></pre></td></tr></table></figure>

<p>2.使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/27/crawlerblog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/27/crawlerblog/" class="post-title-link" itemprop="url">crawlerblog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-27 16:24:44 / Modified: 16:42:23" itemprop="dateCreated datePublished" datetime="2020-04-27T16:24:44-05:00">2020-04-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：[<a href="https://www.zhihu.com/search?type=content&amp;q=%20%E7%88%AC%E8%99%AB%E6%80%8E%E4%B9%88%E5%AD%A6]" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=%20%E7%88%AC%E8%99%AB%E6%80%8E%E4%B9%88%E5%AD%A6]</a>(<a href="https://www.zhihu.com/search?type=content&amp;q=" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=</a> 爬虫怎么学)</p>
<p>博客：<a href="https://cuiqingcai.com/947.html" target="_blank" rel="noopener">https://cuiqingcai.com/947.html</a></p>
<h1 id="python爬虫入门"><a href="#python爬虫入门" class="headerlink" title="python爬虫入门"></a>python爬虫入门</h1><h2 id="1-爬虫基础了解"><a href="#1-爬虫基础了解" class="headerlink" title="1.爬虫基础了解"></a>1.爬虫基础了解</h2><h3 id="1-什么是爬虫"><a href="#1-什么是爬虫" class="headerlink" title="1.什么是爬虫"></a>1.什么是爬虫</h3><p>爬虫，即网络爬虫，大家可以理解为在网络上爬行的一直蜘蛛，互联网就比作一张大网，而爬虫便是在这张网上爬来爬去的蜘蛛咯，如果它遇到资源，那么它就会抓取下来。想抓取什么？这个由你来控制它咯。</p>
<p>比如它在抓取一个网页，在这个网中他发现了一条道路，其实就是指向网页的超链接，那么它就可以爬到另一张网上来获取数据。这样，整个连在一起的大网对这之蜘蛛来说触手可及，分分钟爬下来不是事儿。</p>
<h3 id="2-浏览网页的过程"><a href="#2-浏览网页的过程" class="headerlink" title="2.浏览网页的过程"></a>2.浏览网页的过程</h3><p>在用户浏览网页的过程中，我们可能会看到许多好看的图片，比如 <a href="http://image.baidu.com/" target="_blank" rel="noopener">http://image.baidu.com/</a> ，我们会看到几张的图片以及百度搜索框，这个过程其实就是用户输入网址之后，经过DNS服务器，找到服务器主机，向服务器发出一个请求，服务器经过解析之后，发送给用户的浏览器 HTML、JS、CSS 等文件，浏览器解析出来，用户便可以看到形形色色的图片了。</p>
<p>因此，用户看到的网页实质是由 HTML 代码构成的，爬虫爬来的便是这些内容，通过分析和过滤这些 HTML 代码，实现对图片、文字等资源的获取。</p>
<h3 id="3-URL的含义"><a href="#3-URL的含义" class="headerlink" title="3.URL的含义"></a>3.URL的含义</h3><p>URL，即统一资源定位符，也就是我们说的网址，统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p>
<blockquote>
<p>URL的格式由三部分组成：<br>①第一部分是协议(或称为服务方式)。<br>②第二部分是存有该资源的主机IP地址(有时也包括端口号)。<br>③第三部分是主机资源的具体地址，如目录和文件名等。</p>
</blockquote>
<p>爬虫爬取数据时必须要有一个目标的URL才可以获取数据，因此，它是爬虫获取数据的基本依据，准确理解它的含义对爬虫学习有很大帮助。</p>
<h2 id="2-Urllib库基本使用"><a href="#2-Urllib库基本使用" class="headerlink" title="2. Urllib库基本使用"></a>2. Urllib库基本使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib2</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">response = urllib2.urlopen(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">print(response.read())</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> urlopen(url, data, timeout)</span><br><span class="line"></span><br><span class="line">第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。</span><br><span class="line"></span><br><span class="line">第二三个参数是可以不传送的，data默认为空<span class="literal">None</span>，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT</span><br><span class="line"></span><br><span class="line">第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> print response.read()</span><br><span class="line">response对象有一个read方法，可以返回获取到的网页内容。</span><br><span class="line">如果不加read直接打印会是什么？</span><br><span class="line">&lt;addinfourl at 139728495260376 whose fp &#x3D; &lt;socket._fileobject **object** at 0x7f1513fb3ad0&gt;&gt;</span><br><span class="line">直接打印出了该对象的描述，所以记得一定要加read方法</span><br></pre></td></tr></table></figure>

<h3 id="构造Request"><a href="#构造Request" class="headerlink" title="构造Request"></a>构造Request</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib2</span><br><span class="line"> </span><br><span class="line">request = urllib2.Request(<span class="string">"http://www.baidu.com"</span>)<span class="comment">#推荐这样书写，因为在构建请求时还需要加入好多内容，通过构建一个request，服务器响应请求得到应答，这样显得逻辑上清晰明确。</span></span><br><span class="line">response = urllib2.urlopen(request)</span><br><span class="line">print(response.read())</span><br></pre></td></tr></table></figure>

<h3 id="POST和GET数据传送"><a href="#POST和GET数据传送" class="headerlink" title="POST和GET数据传送"></a>POST和GET数据传送</h3><p>上面的程序演示了最基本的网页抓取，不过，现在大多数网站都是动态网页，需要你动态地传递参数给它，它做出对应的响应。所以，在访问时，我们需要传递数据给它。</p>
<p>GET方式是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。POST则不会在网址上显示所有的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/27/crawler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/27/crawler/" class="post-title-link" itemprop="url">crawler爬虫</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-27 10:10:38 / Modified: 11:05:18" itemprop="dateCreated datePublished" datetime="2020-04-27T10:10:38-05:00">2020-04-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="爬虫入门"><a href="#爬虫入门" class="headerlink" title="爬虫入门"></a>爬虫入门</h2><p>pip3 install requests selenium beautifulsoup4 pyquery pymysql pymongo redis flask django jupyter</p>
<p>安装各种库，安装MongoDB，redis，anaconda，pycharm，Python3</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#带参数get请求</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.get(<span class="string">'https://httpbin.org/get?name=jackson&amp;age=100'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.text)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=&#123;<span class="string">'name'</span>:<span class="string">'ap'</span>,<span class="string">'age'</span>:<span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.get(<span class="string">'https://httpbin.org/get'</span>,params=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#解析json</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.get(<span class="string">'https://httpbin.org/get'</span>,params=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.json)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.loads(response.text))<span class="comment">#以上两个打印一样</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(response.json()))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">#获取二进制数据,可以保持图片视频</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.get(<span class="string">"https://github.com/favicon.ico"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(response.text),type(response.content))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt; &lt;<span class="title">class</span> '<span class="title">bytes</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(response.text)</span>#一堆乱码</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(response.content)</span>#一堆16进制数字</span></span><br><span class="line"><span class="class">#保存二进制图片视频</span></span><br><span class="line">&gt;&gt;&gt; response=requests.get("https://github.com/favicon.ico")</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'favicon.ico'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:<span class="comment">#命名为favicoc</span></span><br><span class="line"><span class="meta">... </span>    f.write(response.content)</span><br><span class="line"><span class="meta">... </span>    f.close()</span><br><span class="line"><span class="comment">#添加headers</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>headers=&#123;<span class="string">'User-Agent'</span>:<span class="string">'。。。一堆码读出来的'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.get(<span class="string">"https://www.zhihu.com/explore"</span>,headers=headers)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#基本post请求</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=&#123;<span class="string">'name'</span>:<span class="string">'ap'</span>,<span class="string">'age'</span>:<span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.post(<span class="string">'https://httpbin.org/post'</span>,data=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.text)</span><br><span class="line"><span class="comment">#headers post,报表表单</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=&#123;<span class="string">'name'</span>:<span class="string">'ap'</span>,<span class="string">'age'</span>:<span class="number">99</span>&#125;</span><br><span class="line">headers=&#123;<span class="string">'User-Agent'</span>:<span class="string">'。。。一堆码读出来的'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.post(<span class="string">"https://httpbin.org/post"</span>,data=data,headers=headers)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.json())</span><br><span class="line"></span><br><span class="line"><span class="comment">#response属性</span></span><br></pre></td></tr></table></figure>

<p>#找headers <a href="https://mkyong.com/computer-tips/how-to-view-http-headers-in-google-chrome/" target="_blank" rel="noopener">https://mkyong.com/computer-tips/how-to-view-http-headers-in-google-chrome/</a></p>
<p>找到最下面的User-Agent: Mozilla 。。。</p>
<h2 id="看到python非常全资料-python3爬虫实战-课时09"><a href="#看到python非常全资料-python3爬虫实战-课时09" class="headerlink" title="看到python非常全资料/python3爬虫实战/课时09"></a>看到python非常全资料/python3爬虫实战/课时09</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/26/linux5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/26/linux5/" class="post-title-link" itemprop="url">linux基础（81-100集）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 21:50:33 / Modified: 23:27:03" itemprop="dateCreated datePublished" datetime="2020-04-26T21:50:33-05:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P81-87（系统信息）"><a href="#P81-87（系统信息）" class="headerlink" title="P81-87（系统信息）"></a>P81-87（系统信息）</h2><h3 id="01-时间和日期"><a href="#01-时间和日期" class="headerlink" title="01.时间和日期"></a>01.时间和日期</h3><p>​    date：查看系统日期</p>
<p>​    cal：calendar查看日历，-y选项可以查看一年日历</p>
<h3 id="02-磁盘信息"><a href="#02-磁盘信息" class="headerlink" title="02.磁盘信息"></a>02.磁盘信息</h3><p>​    df -h：disk free显示磁盘剩余空间</p>
<p>​    du -h[目录名]：disk usage显示目录下文件大小（-h以人性化方式显示文件大小）</p>
<p>​    /看根目录</p>
<h3 id="03-进程信息"><a href="#03-进程信息" class="headerlink" title="03. 进程信息"></a>03. 进程信息</h3><p>当前正在执行的一个程序是进程</p>
<p>​    ps aux：process status查看进程的详细状况</p>
<p>​    top：动态显示运行中的进程并且排序</p>
<p>​    kill [-9] 进程代号：终止指定代号进程，-9是强制终止</p>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>Linux ps命令用于显示当前进程 (process) 的状态。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [options] [--help]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义</li>
<li>-A 列出所有的行程</li>
<li>-w 显示加宽可以显示较多的资讯</li>
<li>-au 显示较详细的资讯</li>
<li>-aux 显示所有包含其他使用者的行程（</li>
<li>au(x) 输出格式 :（常用）</li>
<li>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</li>
<li>USER: 行程拥有者</li>
<li>PID: pid</li>
<li>%CPU: 占用的 CPU 使用率</li>
<li>%MEM: 占用的记忆体使用率</li>
<li>VSZ: 占用的虚拟记忆体大小</li>
<li>RSS: 占用的记忆体大小</li>
<li>TTY: 终端的次要装置号码 (minor device number of tty)</li>
<li>STAT: 该行程的状态:</li>
<li>D: 无法中断的休眠状态 (通常 IO 的进程)</li>
<li>R: 正在执行中</li>
<li>S: 静止状态</li>
<li>T: 暂停执行</li>
<li>Z: 不存在但暂时无法消除</li>
<li>W: 没有足够的记忆体分页可分配</li>
<li>&lt;: 高优先序的行程</li>
<li>N: 低优先序的行程</li>
<li>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)</li>
<li>START: 行程开始时间</li>
<li>TIME: 执行的时间</li>
<li>COMMAND:所执行的指令</li>
<li>x：显示没有控制终端的进程（会显示很多）</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># ps -A 显示进程信息</span><br><span class="line">PID TTY     TIME CMD</span><br><span class="line">  1 ?    00:00:02 init</span><br><span class="line">  2 ?    00:00:00 kthreadd</span><br><span class="line">  3 ?    00:00:00 migration&#x2F;0</span><br><span class="line">  4 ?    00:00:00 ksoftirqd&#x2F;0</span><br><span class="line">  5 ?    00:00:00 watchdog&#x2F;0</span><br><span class="line">  6 ?    00:00:00 events&#x2F;0</span><br><span class="line">  7 ?    00:00:00 cpuset</span><br><span class="line">  8 ?    00:00:00 khelper</span><br><span class="line">  9 ?    00:00:00 netns</span><br><span class="line">  10 ?    00:00:00 async&#x2F;mgr</span><br><span class="line">  11 ?    00:00:00 pm</span><br><span class="line">  12 ?    00:00:00 sync_supers</span><br><span class="line">  13 ?    00:00:00 bdi-default</span><br><span class="line">  14 ?    00:00:00 kintegrityd&#x2F;0</span><br><span class="line">  15 ?    00:00:02 kblockd&#x2F;0</span><br><span class="line">  16 ?    00:00:00 kacpid</span><br><span class="line">  17 ?    00:00:00 kacpi_notify</span><br><span class="line">  18 ?    00:00:00 kacpi_hotplug</span><br><span class="line">  19 ?    00:00:27 ata&#x2F;0</span><br><span class="line">……省略部分结果</span><br><span class="line">30749 pts&#x2F;0  00:00:15 gedit</span><br><span class="line">30886 ?    00:01:10 qtcreator.bin</span><br><span class="line">30894 ?    00:00:00 qtcreator.bin </span><br><span class="line">31160 ?    00:00:00 dhclient</span><br><span class="line">31211 ?    00:00:00 aptd</span><br><span class="line">31302 ?    00:00:00 sshd</span><br><span class="line">31374 pts&#x2F;2  00:00:00 bash</span><br><span class="line">31396 pts&#x2F;2  00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>显示指定用户信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># ps -u root &#x2F;&#x2F;显示root进程用户信息</span><br><span class="line"> PID TTY     TIME CMD</span><br><span class="line">  1 ?    00:00:02 init</span><br><span class="line">  2 ?    00:00:00 kthreadd</span><br><span class="line">  3 ?    00:00:00 migration&#x2F;0</span><br><span class="line">  4 ?    00:00:00 ksoftirqd&#x2F;0</span><br><span class="line">  5 ?    00:00:00 watchdog&#x2F;0</span><br><span class="line">  6 ?    00:00:00 events&#x2F;0</span><br><span class="line">  7 ?    00:00:00 cpuset</span><br><span class="line">  8 ?    00:00:00 khelper</span><br><span class="line">  9 ?    00:00:00 netns</span><br><span class="line">  10 ?    00:00:00 async&#x2F;mgr</span><br><span class="line">  11 ?    00:00:00 pm</span><br><span class="line">  12 ?    00:00:00 sync_supers</span><br><span class="line">  13 ?    00:00:00 bdi-default</span><br><span class="line">  14 ?    00:00:00 kintegrityd&#x2F;0</span><br><span class="line">  15 ?    00:00:02 kblockd&#x2F;0</span><br><span class="line">  16 ?    00:00:00 kacpid</span><br><span class="line">……省略部分结果</span><br><span class="line">30487 ?    00:00:06 gnome-terminal</span><br><span class="line">30488 ?    00:00:00 gnome-pty-helpe</span><br><span class="line">30489 pts&#x2F;0  00:00:00 bash</span><br><span class="line">30670 ?    00:00:00 debconf-communi </span><br><span class="line">30749 pts&#x2F;0  00:00:15 gedit</span><br><span class="line">30886 ?    00:01:10 qtcreator.bin</span><br><span class="line">30894 ?    00:00:00 qtcreator.bin </span><br><span class="line">31160 ?    00:00:00 dhclient</span><br><span class="line">31211 ?    00:00:00 aptd</span><br><span class="line">31302 ?    00:00:00 sshd</span><br><span class="line">31374 pts&#x2F;2  00:00:00 bash</span><br><span class="line">31397 pts&#x2F;2  00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>显示所有进程信息，连同命令行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># ps -ef &#x2F;&#x2F;显示所有命令，连带命令行</span><br><span class="line">UID    PID PPID C STIME TTY     TIME CMD</span><br><span class="line">root     1   0 0 10:22 ?    00:00:02 &#x2F;sbin&#x2F;init</span><br><span class="line">root     2   0 0 10:22 ?    00:00:00 [kthreadd]</span><br><span class="line">root     3   2 0 10:22 ?    00:00:00 [migration&#x2F;0]</span><br><span class="line">root     4   2 0 10:22 ?    00:00:00 [ksoftirqd&#x2F;0]</span><br><span class="line">root     5   2 0 10:22 ?    00:00:00 [watchdog&#x2F;0]</span><br><span class="line">root     6   2 0 10:22 ?    &#x2F;usr&#x2F;lib&#x2F;NetworkManager</span><br><span class="line">……省略部分结果</span><br><span class="line">root   31302 2095 0 17:42 ?    00:00:00 sshd: root@pts&#x2F;2 </span><br><span class="line">root   31374 31302 0 17:42 pts&#x2F;2  00:00:00 -bash</span><br><span class="line">root   31400   1 0 17:46 ?    00:00:00 &#x2F;usr&#x2F;bin&#x2F;python &#x2F;usr&#x2F;sbin&#x2F;aptd</span><br><span class="line">root   31407 31374 0 17:48 pts&#x2F;2  00:00:00 ps -ef</span><br></pre></td></tr></table></figure>

<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>（Linux top命令用于实时显示 process 的动态。（好玩哪）</p>
<p>使用权限：所有使用者。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s</li>
<li>q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行</li>
<li>c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来</li>
<li>s : 安全模式，将交谈式指令取消, 避免潜在的危机</li>
<li>i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程</li>
<li>n : 更新的次数，完成后将会退出 top</li>
<li>b : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>显示进程信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># top</span><br></pre></td></tr></table></figure>

<p>显示完整命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># top -c</span><br></pre></td></tr></table></figure>

<p>以批处理模式显示程序信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># top -b</span><br></pre></td></tr></table></figure>

<p>以累积模式显示程序信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># top -S</span><br></pre></td></tr></table></figure>

<p>设置信息更新次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top -n 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;表示更新两次后终止更新显示</span><br></pre></td></tr></table></figure>

<p>设置信息更新时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># top -d 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;表示更新周期为3秒</span><br></pre></td></tr></table></figure>

<p>显示指定的进程信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># top -p 139</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示进程号为139的进程信息，CPU、内存占用率等</span><br></pre></td></tr></table></figure>

<p>显示更新十次后退出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -n 10</span><br></pre></td></tr></table></figure>

<p>使用者将不能利用交谈式指令来对行程下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -s</span><br></pre></td></tr></table></figure>

<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>Linux kill命令用于删除执行中的程序或工作。</p>
<p>kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或jobs指令查看。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [-s &lt;信息名称或编号&gt;][程序]　或　kill [-l &lt;信息编号&gt;]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-l &lt;信息编号&gt; 　若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称。</li>
<li>-s &lt;信息名称或编号&gt; 　指定要送出的信息。</li>
<li>[程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。</li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>杀死进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kill 12345</span><br></pre></td></tr></table></figure>

<p>强制杀死进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kill -KILL 123456</span><br></pre></td></tr></table></figure>

<p>发送SIGHUP信号，可以使用一下信号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kill -HUP pid</span><br></pre></td></tr></table></figure>

<p>彻底杀死进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kill -9 123456</span><br></pre></td></tr></table></figure>

<p>显示信号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># kill -l</span><br><span class="line">1) SIGHUP     2) SIGINT     3) SIGQUIT     4) SIGILL     5) SIGTRAP</span><br><span class="line">6) SIGABRT     7) SIGBUS     8) SIGFPE     9) SIGKILL    10) SIGUSR1</span><br><span class="line">11) SIGSEGV    12) SIGUSR2    13) SIGPIPE    14) SIGALRM    15) SIGTERM</span><br><span class="line">16) SIGSTKFLT    17) SIGCHLD    18) SIGCONT    19) SIGSTOP    20) SIGTSTP</span><br><span class="line">21) SIGTTIN    22) SIGTTOU    23) SIGURG    24) SIGXCPU    25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM    27) SIGPROF    28) SIGWINCH    29) SIGIO    30) SIGPWR</span><br><span class="line">31) SIGSYS    34) SIGRTMIN    35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9    44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1    64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>杀死指定用户所有进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#kill -9 $(ps -ef | grep hnlinux) &#x2F;&#x2F;方法一 过滤出hnlinux用户进程 </span><br><span class="line">#kill -u hnlinux &#x2F;&#x2F;方法二</span><br></pre></td></tr></table></figure>

<h2 id="P88-92（其他命令）"><a href="#P88-92（其他命令）" class="headerlink" title="P88-92（其他命令）"></a>P88-92（其他命令）</h2><h3 id="1-查找文件"><a href="#1-查找文件" class="headerlink" title="1.查找文件"></a>1.查找文件</h3><p>​    find</p>
<p>Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find   path   -option   [   -print ]   [ -exec   -ok   command ]   &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong> :</p>
<p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p>
<p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</p>
<p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p>
<p>-amin n : 在过去 n 分钟内被读取过</p>
<p>-anewer file : 比文件 file 更晚被读取过的文件</p>
<p>-atime n : 在过去n天内被读取过的文件</p>
<p>-cmin n : 在过去 n 分钟内被修改过</p>
<p>-cnewer file :比文件 file 更新的文件</p>
<p>-ctime n : 在过去n天内被修改过的文件</p>
<p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p>
<p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p>
<p>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写（常用）</p>
<p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。</p>
<p>d: 目录</p>
<p>c: 字型装置文件</p>
<p>b: 区块装置文件</p>
<p>p: 具名贮列</p>
<p>f: 一般文件</p>
<p>l: 符号连结</p>
<p>s: socket</p>
<p>-pid n : process id 是 n 的文件</p>
<p>你可以使用 ( ) 将运算式分隔，并使用下列运算。</p>
<p>exp1 -and exp2</p>
<p>! expr</p>
<p>-not expr</p>
<p>exp1 -or exp2</p>
<p>exp1, exp2</p>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>将目前目录及其子目录下所有延伸档名是 c 的文件列出来。（经典）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -name &quot;*.c&quot;</span><br></pre></td></tr></table></figure>

<p>将目前目录其其下子目录中所有一般文件列出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -type f</span><br></pre></td></tr></table></figure>

<p>将目前目录及其子目录下所有最近 20 天内更新过的文件列出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -ctime -20</span><br></pre></td></tr></table></figure>

<p>查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find &#x2F;var&#x2F;log -type f -mtime +7 -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -type f -perm 644 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find &#x2F; -type f -size 0 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h3 id="2-软链接（类似快捷方式）"><a href="#2-软链接（类似快捷方式）" class="headerlink" title="2. 软链接（类似快捷方式）"></a>2. 软链接（类似快捷方式）</h3><p>ln -s 被链接的源文件 起的文件名</p>
<p>ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。这个命令最常用的参数是-s,具体用法是：ln -s 源文件 目标文件。当 我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的 目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>
<p>例如：ln -s /bin/less /usr/local/bin/less </p>
<p>-s 是代号（symbolic）的意思。 </p>
<p>这 里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接又软链接 和硬链接两种，软链接就是ln -s ** *<em>,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln *</em> **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。<br>如果你用ls察看一个目录时，发现有的文件后面有一个@的符号，那就是一个用ln命令生成的文件，用ls -l命令去察看，就可以看到显示的link的路径了。 </p>
<p>不加-s是硬链接，ls -l可以查看硬链接数</p>
<p>ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同不的链接，这个命令最常用的参数是-s，具体用法是：ln –s 源文件 目标文件。<br>　　当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。例如：ln –s /bin/less /usr/local/bin/less<br>　　-s 是代号（symbolic）的意思。<br>　　这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接又 软链接和硬链接两种，软链接就是ln –s ** *<em>，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln *</em> **，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。<br>　　如果你用ls察看一个目录时，发现有的文件后面有一个@的符号，那就是一个用ln命令生成的文件，用ls –l命令去察看，就可以看到显示的link的路径了。<br>　　指令详细说明<br>　　指令名称 : ln<br>　　使用权限 : 所有使用者<br>　　使用方式 : ln [options] source dist，其中 option 的格式为 :<br>　　[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}]<br>　　[–help] [–version] [–]<br>　　说明 : Linux/Unix 档案系统中，有所谓的连结(link)，我们可以将其视为档案的别名，而连结又可分为两种 : 硬连结(hard link)与软连结(symbolic link)，硬连结的意思是一个档案可以有多个名称，而软连结的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬连结是存在同一个档 案系统中，而软连结却可以跨越不同的档案系统。<br>　　ln source dist 是产生一个连结(dist)到 source，至于使用硬连结或软链结则由参数决定。<br>　　不论是硬连结或软链结都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p>
<p>Linux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。</p>
<p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [参数][源文件或目录][目标文件或目录]</span><br></pre></td></tr></table></figure>

<p>其中参数的格式为</p>
<p>[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}]</p>
<p>[–help] [–version] [–]</p>
<p><strong>命令功能</strong> :<br>Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。</p>
<p>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p>
<p><strong>软链接</strong>：（用绝对路径）</p>
<ul>
<li>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</li>
<li>2.软链接可以 跨文件系统 ，硬链接不可以</li>
<li>3.软链接可以对一个不存在的文件名进行链接</li>
<li>4.软链接可以对目录进行链接</li>
</ul>
<p><strong>硬链接</strong>：</p>
<ul>
<li>1.硬链接，以文件副本的形式存在。但不占用实际空间。</li>
<li>2.不允许给目录创建硬链接</li>
<li>3.硬链接只有在同一个文件系统中才能创建</li>
</ul>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p><strong>必要参数</strong>：</p>
<ul>
<li>-b 删除，覆盖以前建立的链接</li>
<li>-d 允许超级用户制作目录的硬链接</li>
<li>-f 强制执行</li>
<li>-i 交互模式，文件存在则提示用户是否覆盖</li>
<li>-n 把符号链接视为一般目录</li>
<li>-s 软链接(符号链接)（常用）</li>
<li>-v 显示详细的处理过程</li>
</ul>
<p><strong>选择参数</strong>：</p>
<ul>
<li>-S “-S&lt;字尾备份字符串&gt; “或 “–suffix=&lt;字尾备份字符串&gt;”</li>
<li>-V “-V&lt;备份方式&gt;”或”–version-control=&lt;备份方式&gt;”</li>
<li>–help 显示帮助信息</li>
<li>–version 显示版本信息</li>
</ul>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>给文件创建软链接，为log2013.log文件创建软链接link2013，如果log2013.log丢失，link2013将失效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s log2013.log link2013</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ll</span><br><span class="line">-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log</span><br><span class="line">[root@localhost test]# ln -s log2013.log link2013</span><br><span class="line">[root@localhost test]# ll</span><br><span class="line">lrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -&gt; log2013.log</span><br><span class="line">-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log</span><br></pre></td></tr></table></figure>

<p>给文件创建硬链接，为log2013.log创建硬链接ln2013，log2013.log与ln2013的各项属性相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln log2013.log ln2013</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ll</span><br><span class="line">lrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -&gt; log2013.log</span><br><span class="line">-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log</span><br><span class="line">[root@localhost test]# ln log2013.log ln2013</span><br><span class="line">[root@localhost test]# ll</span><br><span class="line">lrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -&gt; log2013.log</span><br><span class="line">-rw-r--r-- 2 root bin      61 11-13 06:03 ln2013</span><br><span class="line">-rw-r--r-- 2 root bin      61 11-13 06:03 log2013.log</span><br></pre></td></tr></table></figure>

<h2 id="P93（软链接硬链接）"><a href="#P93（软链接硬链接）" class="headerlink" title="P93（软链接硬链接）"></a>P93（软链接硬链接）</h2><p>linux中文件名和文件数据分开存储</p>
<p>删除文件，软链接自动删除，文件数据自动删除，硬链接不会删除，文件数据还可以硬链接读取，几乎不会用硬链接。</p>
<h2 id="P94-97打包压缩"><a href="#P94-97打包压缩" class="headerlink" title="P94-97打包压缩"></a>P94-97打包压缩</h2><p>windows中：rar</p>
<p>mac中：zip</p>
<p>linux：tar.gz</p>
<p>Linux tar命令用于备份文件。</p>
<p>tar是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p>
<p>tar -cvf 打包文件.tar 被打包文件/路径… #打包</p>
<p>tar -xvf 打包文件.tar#解压</p>
<h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b &lt;区块数目&gt;][-C &lt;目的目录&gt;][-f &lt;备份文件&gt;][-F &lt;Script文件&gt;][-K &lt;文件&gt;][-L &lt;媒体容量&gt;][-N &lt;日期时间&gt;][-T &lt;范本文件&gt;][-V &lt;卷册名称&gt;][-X &lt;范本文件&gt;][-&lt;设备编号&gt;&lt;存储密度&gt;][--after-date&#x3D;&lt;日期时间&gt;][--atime-preserve][--backuup&#x3D;&lt;备份方式&gt;][--checkpoint][--concatenate][--confirmation][--delete][--exclude&#x3D;&lt;范本样式&gt;][--force-local][--group&#x3D;&lt;群组名称&gt;][--help][--ignore-failed-read][--new-volume-script&#x3D;&lt;Script文件&gt;][--newer-mtime][--no-recursion][--null][--numeric-owner][--owner&#x3D;&lt;用户名称&gt;][--posix][--erve][--preserve-order][--preserve-permissions][--record-size&#x3D;&lt;区块数目&gt;][--recursive-unlink][--remove-files][--rsh-command&#x3D;&lt;执行指令&gt;][--same-owner][--suffix&#x3D;&lt;备份字尾字符串&gt;][--totals][--use-compress-program&#x3D;&lt;执行指令&gt;][--version][--volno-file&#x3D;&lt;编号文件&gt;][文件或目录...]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-A或–catenate 新增文件到已存在的备份文件。</li>
<li>-b&lt;区块数目&gt;或–blocking-factor=&lt;区块数目&gt; 设置每笔记录的区块数目，每个区块大小为12Bytes。</li>
<li>-B或–read-full-records 读取数据时重设区块大小。</li>
<li>-c或–create 建立新的备份文件。</li>
<li>-C&lt;目的目录&gt;或–directory=&lt;目的目录&gt; 切换到指定的目录。</li>
<li>-d或–diff或–compare 对比备份文件内和文件系统上的文件的差异。</li>
<li>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt; 指定备份文件。</li>
<li>-F&lt;Script文件&gt;或–info-script=&lt;Script文件&gt; 每次更换磁带时，就执行指定的Script文件。</li>
<li>-g或–listed-incremental 处理GNU格式的大量备份。</li>
<li>-G或–incremental 处理旧的GNU格式的大量备份。</li>
<li>-h或–dereference 不建立符号连接，直接复制该连接所指向的原始文件。</li>
<li>-i或–ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。</li>
<li>-k或–keep-old-files 解开备份文件时，不覆盖已有的文件。</li>
<li>-K&lt;文件&gt;或–starting-file=&lt;文件&gt; 从指定的文件开始还原。</li>
<li>-l或–one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。</li>
<li>-L&lt;媒体容量&gt;或-tape-length=&lt;媒体容量&gt; 设置存放每体的容量，单位以1024 Bytes计算。</li>
<li>-m或–modification-time 还原文件时，不变更文件的更改时间。</li>
<li>-M或–multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li>
<li>-N&lt;日期格式&gt;或–newer=&lt;日期时间&gt; 只将较指定日期更新的文件保存到备份文件里。</li>
<li>-o或–old-archive或–portability 将资料写入备份文件时使用V7格式。</li>
<li>-O或–stdout 把从备份文件里还原的文件输出到标准输出设备。</li>
<li>-p或–same-permissions 用原来的文件权限还原文件。</li>
<li>-P或–absolute-names 文件名使用绝对名称，不移除文件名称前的”/“号。</li>
<li>-r或–append 新增文件到已存在的备份文件的结尾部分。</li>
<li>-R或–block-number 列出每个信息在备份文件中的区块编号。</li>
<li>-s或–same-order 还原文件的顺序和备份文件内的存放顺序相同。</li>
<li>-S或–sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。</li>
<li>-t或–list 列出备份文件的内容。</li>
<li>-T&lt;范本文件&gt;或–files-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。</li>
<li>-u或–update 仅置换较备份文件内的文件更新的文件。</li>
<li>-U或–unlink-first 解开压缩文件还原文件之前，先解除文件的连接。</li>
<li>-v或–verbose 显示指令执行过程。</li>
<li>-V&lt;卷册名称&gt;或–label=&lt;卷册名称&gt; 建立使用指定的卷册名称的备份文件。</li>
<li>-w或–interactive 遭遇问题时先询问用户。</li>
<li>-W或–verify 写入备份文件后，确认文件正确无误。</li>
<li>-x或–extract或–get 从备份文件中还原文件。</li>
<li>-X&lt;范本文件&gt;或–exclude-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。</li>
<li>-z或–gzip或–ungzip 通过gzip指令处理备份文件。</li>
<li>-Z或–compress或–uncompress 通过compress指令处理备份文件。</li>
<li>-&lt;设备编号&gt;&lt;存储密度&gt; 设置备份用的外围设备编号及存放数据的密度。</li>
<li>–after-date=&lt;日期时间&gt; 此参数的效果和指定”-N”参数相同。</li>
<li>–atime-preserve 不变更文件的存取时间。</li>
<li>–backup=&lt;备份方式&gt;或–backup 移除文件前先进行备份。</li>
<li>–checkpoint 读取备份文件时列出目录名称。</li>
<li>–concatenate 此参数的效果和指定”-A”参数相同。</li>
<li>–confirmation 此参数的效果和指定”-w”参数相同。</li>
<li>–delete 从备份文件中删除指定的文件。</li>
<li>–exclude=&lt;范本样式&gt; 排除符合范本样式的文件。</li>
<li>–group=&lt;群组名称&gt; 把加入设备文件中的文件的所属群组设成指定的群组。</li>
<li>–help 在线帮助。</li>
<li>–ignore-failed-read 忽略数据读取错误，不中断程序的执行。</li>
<li>–new-volume-script=&lt;Script文件&gt; 此参数的效果和指定”-F”参数相同。</li>
<li>–newer-mtime 只保存更改过的文件。</li>
<li>–no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</li>
<li>–null 从null设备读取文件名称。</li>
<li>–numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。</li>
<li>–owner=&lt;用户名称&gt; 把加入备份文件中的文件的拥有者设成指定的用户。</li>
<li>–posix 将数据写入备份文件时使用POSIX格式。</li>
<li>–preserve 此参数的效果和指定”-ps”参数相同。</li>
<li>–preserve-order 此参数的效果和指定”-A”参数相同。</li>
<li>–preserve-permissions 此参数的效果和指定”-p”参数相同。</li>
<li>–record-size=&lt;区块数目&gt; 此参数的效果和指定”-b”参数相同。</li>
<li>–recursive-unlink 解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</li>
<li>–remove-files 文件加入备份文件后，就将其删除。</li>
<li>–rsh-command=&lt;执行指令&gt; 设置要在远端主机上执行的指令，以取代rsh指令。</li>
<li>–same-owner 尝试以相同的文件拥有者还原文件。</li>
<li>–suffix=&lt;备份字尾字符串&gt; 移除文件前先行备份。</li>
<li>–totals 备份文件建立后，列出文件大小。</li>
<li>–use-compress-program=&lt;执行指令&gt; 通过指定的指令处理备份文件。</li>
<li>–version 显示版本信息。</li>
<li>–volno-file=&lt;编号文件&gt; 使用指定文件内的编号取代预设的卷册编号。</li>
</ul>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>压缩文件 非打包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># touch a.c       </span><br><span class="line"># tar -czvf test.tar.gz a.c   &#x2F;&#x2F;压缩 a.c文件为test.tar.gz</span><br><span class="line">a.c</span><br></pre></td></tr></table></figure>

<p>列出压缩文件内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># tar -tzvf test.tar.gz </span><br><span class="line">-rw-r--r-- root&#x2F;root     0 2010-05-24 16:51:59 a.c</span><br></pre></td></tr></table></figure>

<p>解压文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># tar -xzvf test.tar.gz </span><br><span class="line">a.c</span><br></pre></td></tr></table></figure>

<p>Linux 常用的压缩与解压缩命令有：tar、gzip、gunzip、bzip2、bunzip2、compress 、uncompress、 zip、 unzip、rar、unrar 等。</p>
<hr>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>最常用的打包命令是 tar，使用 tar 程序打出来的包我们常称为 tar 包，tar 包文件的命令通常都是以 .tar 结尾的。生成 tar 包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲 tar 命令的基本用法。</p>
<p>tar 命令的选项有很多(用 man tar 可以查看到)，但常用的就那么几个选项，下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -cf all.tar *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件打成一个名为 all.tar 的包。-c 是表示产生新的包，-f 指定包的文件名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -rf all.tar *.gif</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .gif 的文件增加到 all.tar 的包里面去，-r 是表示增加文件的意思。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -uf all.tar logo.gif</span><br></pre></td></tr></table></figure>

<p>这条命令是更新原来 tar 包 all.tar 中 logo.gif 文件，-u 是表示更新文件的意思。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -tf all.tar</span><br></pre></td></tr></table></figure>

<p>这条命令是列出 all.tar 包中所有文件，-t 是列出文件的意思。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -xf all.tar</span><br></pre></td></tr></table></figure>

<p>这条命令是解出 all.tar 包中所有文件，-x 是解开的意思。</p>
<p>以上就是 tar 的最基本的用法。为了方便用户在打包解包的同时可以压缩或解压文件，tar 提供了一种特殊的功能。这就是 tar 可以在打包或解包的同时调用其它的压缩程序，比如调用 gzip、bzip2 等。</p>
<h3 id="1-tar调用"><a href="#1-tar调用" class="headerlink" title="1) tar调用"></a>1) tar调用</h3><p>gzip 是 GNU 组织开发的一个压缩程序，.gz 结尾的文件就是 gzip 压缩的结果。与 gzip 相对的解压程序是 gunzip。tar 中使用 -z 这个参数来调用gzip。下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -czf all.tar.gz *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件打成一个 tar 包，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包，包名为 all.tar.gz。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -xzf all.tar.gz</span><br></pre></td></tr></table></figure>

<p>这条命令是将上面产生的包解开。</p>
<h3 id="2-tar-调用-bzip2"><a href="#2-tar-调用-bzip2" class="headerlink" title="2) tar 调用 bzip2"></a>2) tar 调用 bzip2</h3><p>bzip2 是一个压缩能力更强的压缩程序，.bz2 结尾的文件就是 bzip2 压缩的结果。</p>
<p>与 bzip2 相对的解压程序是 bunzip2。tar 中使用 -j 这个参数来调用 gzip。下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -cjf all.tar.bz2 *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件打成一个 tar 包，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，包名为 all.tar.bz2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -xjf all.tar.bz2</span><br></pre></td></tr></table></figure>

<p>这条命令是将上面产生的包解开。</p>
<h3 id="3-tar-调用-compress"><a href="#3-tar-调用-compress" class="headerlink" title="3)tar 调用 compress"></a>3)tar 调用 compress</h3><p>compress 也是一个压缩程序，但是好象使用 compress 的人不如 gzip 和 bzip2 的人多。.Z 结尾的文件就是 bzip2 压缩的结果。与 compress 相对的解压程序是 uncompress。tar 中使用 -Z 这个参数来调用 compress。下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -cZf all.tar.Z *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件打成一个 tar 包，并且将其用 compress 压缩，生成一个 uncompress 压缩过的包，包名为 all.tar.Z。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -xZf all.tar.Z</span><br></pre></td></tr></table></figure>

<p>这条命令是将上面产生的包解开。</p>
<p>有了上面的知识，你应该可以解开多种压缩文件了，下面对于 tar 系列的压缩文件作一个小结：</p>
<p><strong>1) 对于.tar结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf all.tar</span><br></pre></td></tr></table></figure>

<p><strong>2) 对于 .gz 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip -d all.gz</span><br><span class="line">gunzip all.gz</span><br></pre></td></tr></table></figure>

<p><strong>3)对于 .tgz 或 .tar.gz 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf all.tar.gz</span><br><span class="line">tar -xzf all.tgz</span><br></pre></td></tr></table></figure>

<p><strong>4) 对于 .bz2 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -d all.bz2</span><br><span class="line">bunzip2 all.bz2</span><br></pre></td></tr></table></figure>

<p><strong>5) 对于 tar.bz2 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xjf all.tar.bz2</span><br></pre></td></tr></table></figure>

<p><strong>6) 对于 .Z 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uncompress all.Z</span><br></pre></td></tr></table></figure>

<p><strong>7) 对于 .tar.Z 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xZf all.tar.z</span><br></pre></td></tr></table></figure>

<p>另外对于 Windows 下的常见压缩文件 .zip 和 .rar，Linux 也有相应的方法来解压它们：</p>
<p><strong>1) 对于 .zip</strong></p>
<p>linux 下提供了 zip 和 unzip 程序，zip 是压缩程序，unzip 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># zip all.zip *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件压缩成一个 zip 包:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># unzip all.zip</span><br></pre></td></tr></table></figure>

<p>这条命令是将 all.zip 中的所有文件解压出来。</p>
<p><strong>2) 对于 .rar</strong></p>
<p>要在 linux 下处理 .rar 文件，需要安装 RAR for Linux。下载地址：<a href="http://www.rarsoft.com/download.htm，下载后安装即可。" target="_blank" rel="noopener">http://www.rarsoft.com/download.htm，下载后安装即可。</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># tar -xzpvf rarlinux-x64-5.6.b5.tar.gz</span><br><span class="line"># cd rar </span><br><span class="line"># make</span><br></pre></td></tr></table></figure>

<p>这样就安装好了，安装后就有了 rar 和 unrar 这两个程序，rar 是压缩程序，unrar 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rar a all *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件压缩成一个 rar 包，名为 all.rar，该程序会将 .rar 扩展名将自动附加到包名后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># unrar e all.rar</span><br></pre></td></tr></table></figure>

<p>这条命令是将 all.rar 中的所有文件解压出来：</p>
<hr>
<h2 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h2><p><strong>tar</strong></p>
<p>-C 解压缩到指定目录，且目录必须存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c: 建立压缩档案 </span><br><span class="line">-x：解压 </span><br><span class="line">-t：查看内容 </span><br><span class="line">-r：向压缩归档文件末尾追加文件 </span><br><span class="line">-u：更新原压缩包中的文件</span><br></pre></td></tr></table></figure>

<p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-z：有gzip属性的 </span><br><span class="line">-j：有bz2属性的 </span><br><span class="line">-Z：有compress属性的 </span><br><span class="line">-v：显示所有过程 </span><br><span class="line">-O：将文件解开到标准输出</span><br></pre></td></tr></table></figure>

<p>下面的参数 -f 是必须的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</span><br></pre></td></tr></table></figure>

<p># tar -cf all.tar *.jpg </p>
<p>这条命令是将所有 .jpg 的文件打成一个名为 all.tar 的包。-c 是表示产生新的包，-f 指定包的文件名。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -rf all.tar *.gif</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .gif 的文件增加到 all.tar 的包里面去。-r 是表示增加文件的意思。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -uf all.tar logo.gif</span><br></pre></td></tr></table></figure>

<p>这条命令是更新原来 tar 包 all.tar 中 logo.gif 文件，-u 是表示更新文件的意思。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -tf all.tar</span><br></pre></td></tr></table></figure>

<p>这条命令是列出 all.tar 包中所有文件，-t 是列出文件的意思。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -xf all.tar</span><br></pre></td></tr></table></figure>

<p>这条命令是解出 all.tar 包中所有文件，-x 是解开的意思。</p>
<p><strong>压缩</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar –cvf jpg.tar *.jpg       &#x2F;&#x2F; 将目录里所有jpg文件打包成 tar.jpg </span><br><span class="line">tar –czf jpg.tar.gz *.jpg    &#x2F;&#x2F; 将目录里所有jpg文件打包成 jpg.tar 后，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包，命名为 jpg.tar.gz </span><br><span class="line">tar –cjf jpg.tar.bz2 *.jpg   &#x2F;&#x2F; 将目录里所有jpg文件打包成 jpg.tar 后，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，命名为jpg.tar.bz2 </span><br><span class="line">tar –cZf jpg.tar.Z *.jpg     &#x2F;&#x2F; 将目录里所有 jpg 文件打包成 jpg.tar 后，并且将其用 compress 压缩，生成一个 umcompress 压缩过的包，命名为jpg.tar.Z </span><br><span class="line">rar a jpg.rar *.jpg          &#x2F;&#x2F; rar格式的压缩，需要先下载 rar for linux </span><br><span class="line">zip jpg.zip *.jpg            &#x2F;&#x2F; zip格式的压缩，需要先下载 zip for linux</span><br></pre></td></tr></table></figure>

<p><strong>解压</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar –xvf file.tar         &#x2F;&#x2F; 解压 tar 包 （常用）</span><br><span class="line">tar -xzvf file.tar.gz     &#x2F;&#x2F; 解压 tar.gz </span><br><span class="line">tar -xjvf file.tar.bz2    &#x2F;&#x2F; 解压 tar.bz2 </span><br><span class="line">tar –xZvf file.tar.Z      &#x2F;&#x2F; 解压 tar.Z </span><br><span class="line">unrar e file.rar          &#x2F;&#x2F; 解压 rar </span><br><span class="line">unzip file.zip            &#x2F;&#x2F; 解压 zip</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、*.tar 用 tar –xvf 解压 </span><br><span class="line">2、*.gz 用 gzip -d或者gunzip 解压 </span><br><span class="line">3、*.tar.gz和*.tgz 用 tar –xzf 解压 </span><br><span class="line">4、*.bz2 用 bzip2 -d或者用bunzip2 解压 </span><br><span class="line">5、*.tar.bz2用tar –xjf 解压 </span><br><span class="line">6、*.Z 用 uncompress 解压 </span><br><span class="line">7、*.tar.Z 用tar –xZf 解压 </span><br><span class="line">8、*.rar 用 unrar e解压 </span><br><span class="line">9、*.zip 用 unzip 解压</span><br></pre></td></tr></table></figure>

<h3 id="压缩-解压缩"><a href="#压缩-解压缩" class="headerlink" title="压缩/解压缩"></a>压缩/解压缩</h3><p>总结：tar -cvf tar -xvf（一对）（打包解压）</p>
<p>​            tar -zcvf tar-zxvf(一对) （压缩解压）</p>
<p>​            tar -zcvf 打包文件.tar.gz 被压缩文件/路径 #压缩</p>
<p>​            tar -zxvf 打包文件.tar.gz #压缩文件  </p>
<p>​            tar -zxvf 打包文件.tar.gz -C 目标路径 #解压到指定路径</p>
<p>gzip：压缩（和tar一起用：打包压缩）</p>
<p>Linux gzip命令用于压缩文件。</p>
<p>gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best&#x2F;fast][文件...] 或 gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best&#x2F;fast][目录]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-a或–ascii 　使用ASCII文字模式。</li>
<li>-c或–stdout或–to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。</li>
<li>-d或–decompress或—-uncompress 　解开压缩文件。</li>
<li>-f或–force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。</li>
<li>-h或–help 　在线帮助。</li>
<li>-l或–list 　列出压缩文件的相关信息。</li>
<li>-L或–license 　显示版本与版权信息。</li>
<li>-n或–no-name 　压缩文件时，不保存原来的文件名称及时间戳记。</li>
<li>-N或–name 　压缩文件时，保存原来的文件名称及时间戳记。</li>
<li>-q或–quiet 　不显示警告信息。</li>
<li>-r或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。</li>
<li>-S&lt;压缩字尾字符串&gt;或—-suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。</li>
<li>-t或–test 　测试压缩文件是否正确无误。</li>
<li>-v或–verbose 　显示指令执行过程。</li>
<li>-V或–version 　显示版本信息。</li>
<li>-&lt;压缩效率&gt; 　压缩效率是一个介于1－9的数值，预设值为”6”，指定愈大的数值，压缩效率就会愈高。</li>
<li>–best 　此参数的效果和指定”-9”参数相同。</li>
<li>–fast 　此参数的效果和指定”-1”参数相同。</li>
</ul>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>压缩文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@runoob.com a]# ls &#x2F;&#x2F;显示当前目录文件</span><br><span class="line">a.c b.h d.cpp</span><br><span class="line">[root@runoob.com a]# gzip * &#x2F;&#x2F;压缩目录下的所有文件</span><br><span class="line">[root@runoob.com a]# ls &#x2F;&#x2F;显示当前目录文件</span><br><span class="line">a.c.gz    b.h.gz    d.cpp.gz</span><br><span class="line">[root@runoob.com a]#</span><br></pre></td></tr></table></figure>

<p>接范例1， 列出详细的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@runoob.com a]# gzip -dv * &#x2F;&#x2F;解压文件，并列出详细信息</span><br><span class="line">a.c.gz:     0.0% -- replaced with a.c</span><br><span class="line">b.h.gz:     0.0% -- replaced with b.h</span><br><span class="line">d.cpp.gz:     0.0% -- replaced with d.cpp</span><br><span class="line">[root@runoob.com a]#</span><br></pre></td></tr></table></figure>

<p>接范例1，显示压缩文件的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@runoob.com a]# gzip -l *</span><br><span class="line">     compressed    uncompressed ratio uncompressed_name</span><br><span class="line">         24          0  0.0% a.c</span><br><span class="line">         24          0  0.0% b.h</span><br><span class="line">         26          0  0.0% d.cpp</span><br></pre></td></tr></table></figure>

<h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p>Linux bzip2命令是.bz2文件的压缩程序。</p>
<p>bzip2像gzip一样，tar打包，bzip2压缩tar后文件，扩展名 .tar.bz2</p>
<p>压缩文件 tar -jcvf 打包文件.tar.bz2 被压缩文件/路径</p>
<p>解压 tar -jxvf 打包文件.tar.bz2</p>
<p>-C 解压缩到指定目录，且目录必须存在</p>
<p>bzip2采用新的压缩演算法，压缩效果比传统的LZ77/LZ78压缩演算法来得好。若没有加上任何参数，bzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。</p>
<h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 [-cdfhkLstvVz][--repetitive-best][--repetitive-fast][- 压缩等级][要压缩的文件]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-c或–stdout 　将压缩与解压缩的结果送到标准输出。</li>
<li>-d或–decompress 　执行解压缩。</li>
<li>-f或–force 　bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖，请使用此参数。</li>
<li>-h或–help 　显示帮助。</li>
<li>-k或–keep 　bzip2在压缩或解压缩后，会删除原始的文件。若要保留原始文件，请使用此参数。</li>
<li>-s或–small 　降低程序执行时内存的使用量。</li>
<li>-t或–test 　测试.bz2压缩文件的完整性。</li>
<li>-v或–verbose 　压缩或解压缩文件时，显示详细的信息。</li>
<li>-z或–compress 　强制执行压缩。</li>
<li>-L,–license,</li>
<li>-V或–version 　显示版本信息。</li>
<li>–repetitive-best 　若文件中有重复出现的资料时，可利用此参数提高压缩效果。</li>
<li>–repetitive-fast 　若文件中有重复出现的资料时，可利用此参数加快执行速度。</li>
<li>-压缩等级 　压缩时的区块大小。</li>
</ul>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>解压.bz2文件 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@w3cschool.cc ~]# bzip2 -v temp.bz2 &#x2F;&#x2F;解压文件显示详细处理信息</span><br></pre></td></tr></table></figure>

<p>压缩文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@w3cschool.cc ~]# bzip2 -c a.c b.c c.c</span><br></pre></td></tr></table></figure>

<p>检查文件完整性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@w3cschool.cc ~]# bzip2 -t temp.bz2</span><br></pre></td></tr></table></figure>

<h2 id="P98-100软件安装"><a href="#P98-100软件安装" class="headerlink" title="P98-100软件安装"></a>P98-100软件安装</h2><p>apt是advanced packaging tool，linux下安装管理工具</p>
<p>sudo apt install 软件包#安装</p>
<p>sudo apt remove 软件包名#卸载</p>
<p>sudo apt upgrade#更新</p>
<p>sudo apt install htop#查看当前进程，输入htop即可</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/26/linux4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/26/linux4/" class="post-title-link" itemprop="url">linux基础（61-80集）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 17:38:19 / Modified: 21:50:42" itemprop="dateCreated datePublished" datetime="2020-04-26T17:38:19-05:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P60-61（用户文件权限）"><a href="#P60-61（用户文件权限）" class="headerlink" title="P60-61（用户文件权限）"></a>P60-61（用户文件权限）</h2><p>用户管理包括用户与组管理。</p>
<p> Linux操作系统对多用户的管理，是非常繁琐的，所以用组的概念来管理用户就变得简单，每个用户可以在一个独立的组，每个组也可以有零个用户或者多个用户。</p>
<p>Linux系统用户是根据用户ID来识别的，默认ID长度为32位，从默认ID编号从0开始，但是为了和老式系统兼容，用户ID限制在60000以下，Linux用户分总共分为三种，分别如下：</p>
<p> root用户  （ID 0）</p>
<p> 系统用户 （ID 1-499）</p>
<p>普通用户 （ID 500以上）</p>
<p>Linux系统中的每个文件或者文件夹，都有一个所属用户及所属组，使用id命令可以显示当前用户的信息，使用passwd命令可以修改当前用户密码。Linux操作系统用户的特点如下：</p>
<p>每个用户拥有一个UserID，操作系统实际读取的是UID，而非用户名；</p>
<p>每个用户属于一个主组，属于一个或多个附属组，一个用户最多有31个附属组；</p>
<p>每个组拥有一个GroupID；</p>
<p>每个进程以一个用户身份运行，该用户可对进程拥有资源控制权限；</p>
<p>每个可登陆用户拥有一个指定的Shell环境。</p>
<h2 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h2><p>Linux用户在操作系统可以进行日常管理和维护，涉及到的相关配置文件如下：</p>
<p>/etc/passwd   保存用户信息</p>
<p> /etc/shdaow   保存用户密码（以加密形式保存）</p>
<p> /etc/group    保存组信息</p>
<p> /etc/login.defs  用户属性限制,密码过期时间,密码最大长度等限制</p>
<p> /etc/default/useradd 显示或更改默认的useradd配置文件</p>
<p>如需创建新用户，可以使用命令useradd，执行命令useradd test1即可创建test1用户，同时会创建一个同名的组test1，默认该用户属于test1主组。</p>
<p>Useradd test1命令默认创建用户test1，会根据如下步骤进行操作：</p>
<p> 在/etc/passwd文件中添加用户信息；</p>
<p>如使用passwd命令创建密码，密码会被加密保存在/etc/shdaow中；</p>
<p> 为test1创建家目录：/home/test1；</p>
<p> 将/etc/skel中的.bash开头的文件复制至/home/test1家目录；</p>
<p> 创建与用户名相同的test1组，test1用户默认属于test1同名组；</p>
<p> test1组信息保存在/etc/group配置文件中。</p>
<p>在使用useradd命令创建用户时，可以支持如下参数：</p>
<p>用法：useradd [选项] 登录</p>
<p>useradd -D</p>
<p>useradd -D [选项]</p>
<p>选项：</p>
<p>-b, –base-dir BASE_DIR     指定新账户的家目录；</p>
<p>-c, –comment COMMENT      新账户的 GECOS 字段；</p>
<p>-d, –home-dir HOME_DIR     新账户的主目录；</p>
<p>-D, –defaults         显示或更改默认的 useradd 配置；</p>
<p>-e, –expiredate EXPIRE_DATE  新账户的过期日期；</p>
<p>-f, –inactive INACTIVE     新账户的密码不活动期；</p>
<p>-g, –gid GROUP         新账户主组的名称或ID；</p>
<p>-G, –groups GROUPS     新账户的附加组列表；</p>
<p>-h, –help           显示此帮助信息并推出；</p>
<p>-k, –skel SKEL_DIR       使用此目录作为骨架目录；</p>
<p>-K, –key KEY=VALUE       不使用 /etc/login.defs 中的默认值；</p>
<p>-l, –no-log-init      不要将此用户添加到最近登录和登录失败数据库；</p>
<p>-m, –create-home      创建用户的主目录；</p>
<p>-M, –no-create-home    不创建用户的主目录；</p>
<p>-N, –no-user-group     不创建同名的组；</p>
<p>-o, –non-unique        允许使用重复的 UID 创建用户；</p>
<p>-p, –password  PASSWORD     加密后的新账户密码；</p>
<p>-r, –system          创建一个系统账户；</p>
<p>-R, –root CHROOT_DIR      chroot 到的目录；</p>
<p>-s, –shell SHELL        新账户的登录 shell；</p>
<p>-u, –uid UID          新账户的用户 ID；</p>
<p>-U, –user-group        创建与用户同名的组；</p>
<p>-Z, –selinux-user SEUSER    为SELinux 用户映射使用指定 SEUSER。</p>
<h2 id="Linux组管理"><a href="#Linux组管理" class="headerlink" title="Linux组管理"></a>Linux组管理</h2><p> 所有的Linux或者Windows系统都有组的概念，通过组可以更加方便的管理用户，组的概念应用于各行行业，例如企业会使用部门、职能或地理区域的分类方式来管理成员，映射在Linux系统，同样可以创建用户，并用组的概念对其管理。</p>
<p>Linux组有如下特点：</p>
<p> 每个组有一个组ID；</p>
<p> 组信息保存在/etc/group中；</p>
<p> 每个用户至少拥有一个主组，同时还可以拥有31个附属组。</p>
<p>通过命令groupadd、groupdel、groupmod来对组进行管理，详细参数使用如下：</p>
<p>groupadd用法</p>
<p>-f, –force       如果组已经存在则成功退出；</p>
<p>并且如果 GID 已经存在则取消 –g；</p>
<p>-g, –gid GID       为新组使用 GID；</p>
<p>-h, –help         显示此帮助信息并推出；</p>
<p>-K, –key KEY=VALUE    不使用 /etc/login.defs 中的默认值；</p>
<p>-o, –non-unique      允许创建有重复 GID 的组；</p>
<p>-p, –password PASSWORD  为新组使用此加密过的密码；</p>
<p>-r, –system        创建一个系统账户；</p>
<p>groupmod用法</p>
<p>-g, –gid GID       将组 ID 改为 GID；</p>
<p>-h, –help         显示此帮助信息并推出；</p>
<p>-n, –new-name NEW_GROUP 改名为 NEW_GROUP；</p>
<p>-o, –non-unique      允许使用重复的 GID；</p>
<p>-p, –password PASSWORD  将密码更改为(加密过的) PASSWORD；</p>
<p>groupdel用法</p>
<p>groupdel admin         删除admin组；</p>
<h2 id="二、-Linux权限管理"><a href="#二、-Linux权限管理" class="headerlink" title="二、 Linux权限管理"></a>二、 Linux权限管理</h2><p>Linux权限是操作系统用来限制对资源访问的机制，权限一般分为读、写、执行。系统中每个文件都拥有特定的权限、所属用户及所属组，通过这样的机制来限制哪些用户或用户组可以对特定文件进行相应的操作。</p>
<p>Linux每个进程都是以某个用户身份运行，进程的权限与该用户的权限一样，用户的权限越大，则进程拥有的权限就越大。</p>
<p>Lnux中有的文件及文件夹都有至少权限三种权限，常见的权限如表5-1所示:</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>r（读取）</td>
<td>可读取文件内容</td>
<td>可列出目录内容</td>
</tr>
<tr>
<td>w（写入）</td>
<td>可修改文件内容</td>
<td>可在目录中创建删除内容</td>
</tr>
<tr>
<td>x（执行）</td>
<td>可作为命令执行</td>
<td>可访问目录内容</td>
</tr>
<tr>
<td>目录必须拥有 x 权限，否则无法查看其内容</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Linux权限授权，默认是授权给三种角色，分别是user、group、other，Linux权限与用户之间的关联如下：</p>
<p>U代表User，G代表Group，O代表Other；</p>
<p> 每个文件的权限基于UGO进行设置；</p>
<p>权限三位一组（rwx），同时需授权给三种角色，UGO；</p>
<p> 每个文件拥有一个所属用户和所属组，对应UGO，不属于该文件所属用户或所属组使用O来表示；</p>
<p>在Linux系统中，可以通过ls –l查看peter.net目录的详细属性，如图5-1所示：</p>
<p>drwxrwxr-x  2 peter1 peter1 4096 Dec 10 01:36 peter.net</p>
<p>peter.net目录属性参数详解如下：</p>
<p> d 表示目录，同一位置如果为-则表示普通文件；</p>
<p> rwxrwxr-x 表示三种角色的权限，每三位为一种角色，依次为u，g，o权限，如上则表示user的权限为rwx，group的权限为rwx，other的权限为r-x；</p>
<p> 2表示文件夹的链接数量，可理解为该目录下子目录的数量；</p>
<p> 从左到右，第一个peter1表示该用户名，第二个peter1则为组名，其他人角色默认不显示；</p>
<p> 4096表示该文件夹占据的字节数；</p>
<p> Dec 10 01:36 表示文件创建或者修改的时间；</p>
<p>peter.net 为目录的名，或者文件名。</p>
<p>peter.net目录属性参数详解如下：</p>
<p> d 表示目录，同一位置如果为-则表示普通文件；</p>
<p> rwxrwxr-x 表示三种角色的权限，每三位为一种角色，依次为u，g，o权限，如上则表示user的权限为rwx，group的权限为rwx，other的权限为r-x；</p>
<p> 2表示文件夹的链接数量，可理解为该目录下子目录的数量；</p>
<p> 从左到右，第一个peter1表示该用户名，第二个peter1则为组名，其他人角色默认不显示；</p>
<p> 4096表示该文件夹占据的字节数；</p>
<p> Dec 10 01:36 表示文件创建或者修改的时间；</p>
<p>peter.net 为目录的名，或者文件名。</p>
<h2 id="Chmod用户及组权限"><a href="#Chmod用户及组权限" class="headerlink" title="Chmod用户及组权限"></a>Chmod用户及组权限</h2><p>修改某个用户、组对文件夹的权限，用命令chmod实现，其中以代指ugo，、-、=代表加入、删除和等于对应权限，具体案例如下：</p>
<p>（1） 授予用户对peter.net目录拥有rwx权限</p>
<p>chmod  –R  u+rwx  peter.net</p>
<p>（2） 授予组对peter.net目录拥有rwx权限</p>
<p>chmod  –R  g+rwx  peter.net</p>
<p>（3） 授予用户、组、其他人对jpeter.net目录拥有rwx权限</p>
<p>chmod  –R  u+rwx,g+rwx,o+rwx  peter.net</p>
<p>（4） 撤销用户对peter.net目录拥有w权限</p>
<p>chmod  –R  u-w  peter.net</p>
<p>（5） 撤销用户、组、其他人对peter.net目录拥有x权限</p>
<p>chmod  –R  u-x,g-x,o-x peter.net</p>
<p>（6） 授予用户、组、其他人对jpeter.net目录只有rx权限</p>
<p>chmod  –R  u=rx,g=rx,o=rx  peter.net</p>
<h2 id="Chmod二进制权限"><a href="#Chmod二进制权限" class="headerlink" title="Chmod二进制权限"></a>Chmod二进制权限</h2><p>Linux权限默认使用rwx来表示，为了更简化在系统中对权限进行配置和修改，Linux权限引入二进制表示方法，如下代码：</p>
<p>Linux权限可以将rwx用二进制来表示，其中有权限用1表示，没有权限用0表示；Linux权限用二进制显示如下：rwx=111r-x=101rw-=110r–=100依次类推，转化为十进制，对应十进制结果显示如下：rwx=111=4+2+1=7r-x=101=4+0+1=5rw-=110=4+4+0=6r–=100=4+0+0=4得出结论，用r=4,w=2,x=1来表示权限。</p>
<p>使用二进制方式来修改权限案例演示如下，其中默认peter.nett目录权限为755：</p>
<p>（1） 授予用户对peter.net目录拥有rwx权限</p>
<p>chmod  –R  755 peter.net</p>
<p>（2） 授予组对peter.net目录拥有rwx权限</p>
<p>chmod  –R  775 peter.net</p>
<p>（3） 授予用户、组、其他人对peter.net目录拥有rwx权限</p>
<p>chmod  –R  777  peter.net</p>
<h2 id="Linux特殊权限及掩码"><a href="#Linux特殊权限及掩码" class="headerlink" title="Linux特殊权限及掩码"></a>Linux特殊权限及掩码</h2><p>Linux权限除了常见的rwx权限之外，还有很多特殊的权限，细心的读者会发现，为什么Linux目录默认权限755，而文件默认权限为644呢，这是因为Linux权限掩码umask导致。</p>
<p>每个Linux终端都拥有一个umask属性，umask熟悉可以用来确定新建文件、目录的默认权限，默认系统权限掩码为022。在系统中每创建一个文件或者目录，文件默认权限是666，而目录权限则为777，权限对外开放比较大，所以设置了权限掩码之后，默认的文件和目录权限减去umask值才是真实的文件和目录的权限。</p>
<p> 对应目录权限为：777-022=755；</p>
<p> 对应文件权限为：666-022=644；</p>
<p> 执行umask命令可以查看当前默认的掩码，umask -S 023可以设置默认的权限掩码。</p>
<p>在Linux权限中，除了普通权限外，还有如下表5-2所示，三个特殊权限：</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>Suid</td>
<td>以文件的所属用户身份执行，而非执行文件的用户</td>
<td>无</td>
</tr>
<tr>
<td>sgid</td>
<td>以文件所属组身份去执行</td>
<td>在该目录中创建任意新文件的所属组与该目录的所属组相同</td>
</tr>
<tr>
<td>sticky</td>
<td>无</td>
<td>对目录拥有写入权限的用户仅可以删除其拥有的文件，无法删除其他用户所拥有的文件</td>
</tr>
</tbody></table>
<p>表5-2 Linux三种特殊权限</p>
<p>Linux中设置特殊权限方法如下：</p>
<p>q 设置suid： chmod u+s peter.net</p>
<p>q 设置sgid： chmod g+s peter.net</p>
<p>q 设置sticky： chmod o+t peter.net</p>
<p>特殊权限与设置普通权限一样，可以使用数字方式表示：</p>
<p> SUID   = 4</p>
<p> SGID   = 2</p>
<p> Sticky = 1</p>
<p>可以通过chmod 4755 peter.net对该目录授予特殊权限为s的权限，Linux系统中s权限的应用常见包括：su、passwd、sudo，</p>
<h2 id="P62-63-ls-l"><a href="#P62-63-ls-l" class="headerlink" title="P62-63(ls -l)"></a>P62-63(ls -l)</h2><table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>r（读取）</td>
<td>可读取文件内容</td>
<td>可列出目录内容</td>
</tr>
<tr>
<td>w（写入）</td>
<td>可修改文件内容</td>
<td>可在目录中创建删除内容</td>
</tr>
<tr>
<td>x（执行）</td>
<td>可作为命令执行</td>
<td>可访问目录内容</td>
</tr>
<tr>
<td>目录必须拥有 x 权限，否则无法查看其内容</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>-rw-rw-r–: rw, rw, r</p>
<p>drwxrwxr-x:目录，rwx,rwx,r-x</p>
<p><em>d是目录，第一组是拥有者权限，第二组是组权限，第三组是其他用户权限，每3个一组。</em></p>
<p><em>”/“是根目录，”~“是家目录。Linux存储是以挂载的方式，相当于是树状的，源头就是”/“，也就是根目录。而每个用户都有”家“目录，也就是用户的个人目录，比如root用户的”家“目录就是/root,普通用户a的家目录就是/home/a</em></p>
<h3 id="ls常见命令参数"><a href="#ls常见命令参数" class="headerlink" title="ls常见命令参数"></a>ls常见命令参数</h3><p>ls: -F 给不同的文件添加不同表示,添加帽子</p>
<p>d/   l*  =s </p>
<p>-a: 显示隐藏文件  以.开头的文件</p>
<p>-p: 只给目录添加/</p>
<p>-t: 按照修改时间排序 time </p>
<p>   –time-style=long-iso: ls -l –time-style=long-iso  显示友好长格式时间</p>
<p>-r: 倒着排序 reverse</p>
<p>-S: 按照文件大小排序</p>
<p>-h: 以人类理解的范围显示</p>
<p>-i: 索引节点(inode==书的目录) print the index number of each file(内核根据此区别文件是否同一文件)</p>
<h3 id="ls-–l-文件显示内容分析"><a href="#ls-–l-文件显示内容分析" class="headerlink" title="ls –l 文件显示内容分析"></a>ls –l 文件显示内容分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第一列： 文件类型(共10个字符) + 权限  --&gt; &#96;&#96;man&#96; &#96;find&#96; &#96;搜索&#96;&#96;type&#96;&#96;可看</span><br><span class="line">      &#96;&#96;-:普通文件</span><br><span class="line">      &#96;&#96;d:目录</span><br><span class="line">      &#96;&#96;c:字符设备 --&gt; &#96;&#96;&#x2F;dev&#x2F;tty&#96;   &#96;例如 USB接口、猫等一些串行端口设备</span><br><span class="line">      &#96;&#96;b:块设备  --&gt; &#96;&#96;&#x2F;dev&#96;&#96;下查找 例如光驱，硬盘等属于块设备</span><br><span class="line">      &#96;&#96;.:SELINUX相关 </span><br><span class="line">      &#96;&#96;l:链接文件 --&gt; 软连接</span><br><span class="line">第二列：硬链接个数 默认从1开始 如果是目录，则默认是2(目录不做硬链接)：几种到达的方法</span><br><span class="line">第三列：文件属主</span><br><span class="line">第四列：文件属组</span><br><span class="line">第五列：文件大小</span><br><span class="line">第六-八列：创建时间&#x2F;最后一次修改时间</span><br><span class="line">第九列：文件名</span><br></pre></td></tr></table></figure>

<p><a href="https://images2018.cnblogs.com/blog/519608/201806/519608-20180630125442504-449878811.png" target="_blank" rel="noopener"><img src="https://images2018.cnblogs.com/blog/519608/201806/519608-20180630125442922-137320976.png" alt="image"></a></p>
<h2 id="P64-65-chmod"><a href="#P64-65-chmod" class="headerlink" title="P64-65(chmod)"></a>P64-65(chmod)</h2><p>Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。</p>
<p><strong>使用权限</strong> : 所有使用者</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-cfvR] [--help] [--version] mode file...</span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>mode : 权限设定字串，格式如下 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ugoa...][[+-&#x3D;][rwxX]...][,...]</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li>
<li>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li>
</ul>
<p>其他参数说明：</p>
<ul>
<li>-c : 若该文件权限确实已经更改，才显示其更改动作</li>
<li>-f : 若该文件权限无法被更改也不要显示错误讯息</li>
<li>-v : 显示权限变更的详细资料</li>
<li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>将文件 file1.txt 设为所有人皆可读取 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ugo+r file1.txt</span><br></pre></td></tr></table></figure>

<p>将文件 file1.txt 设为所有人皆可读取 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+r file1.txt</span><br></pre></td></tr></table></figure>

<p>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ug+w,o-w file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p>将 ex1.py 设定为只有该文件拥有者可以执行 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x ex1.py</span><br></pre></td></tr></table></figure>

<p>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R a+r *</span><br></pre></td></tr></table></figure>

<p>此外chmod也可以用数字来表示权限如 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure>

<p>语法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod abc file</span><br></pre></td></tr></table></figure>

<p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p>
<h4 id="r-4，w-2，x-1"><a href="#r-4，w-2，x-1" class="headerlink" title="r=4，w=2，x=1"></a>r=4，w=2，x=1</h4><ul>
<li>若要rwx属性则4+2+1=7；</li>
<li>若要rw-属性则4+2=6；</li>
<li>若要r-x属性则4+1=5。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a&#x3D;rwx file</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure>

<p>效果相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ug&#x3D;rwx,o&#x3D;x file</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 771 file</span><br></pre></td></tr></table></figure>

<p>效果相同</p>
<p>若用chmod 4755 filename可使此程序具有root的权限</p>
<h2 id="P65-66（超级用户）"><a href="#P65-66（超级用户）" class="headerlink" title="P65-66（超级用户）"></a>P65-66（超级用户）</h2><p>sudo的全称为Superuser do的意思</p>
<p>日常使用用标准用户administrator，root用户用来系统维护和管理，对所有资源都有访问权限</p>
<p>默认安装完成之后并不知道root用户的密码，那么如何应用root权限呢？</p>
<h3 id="1-sudo-命令"><a href="#1-sudo-命令" class="headerlink" title="(1)sudo 命令"></a>(1)sudo 命令</h3><p>xzm@ubuntu:~$ sudo</p>
<p>这样输入当前管理员用户密码就可以得到超级用户的权限。但默认的情况下5分钟root权限就失效了。</p>
<h3 id="2-sudo-i"><a href="#2-sudo-i" class="headerlink" title="(2)sudo -i"></a>(2)sudo -i</h3><p>xzm@ubuntu:~$ sudo -i</p>
<p>通过这种方法输入当前管理员用户的密码就可以进到root用户。</p>
<h3 id="3-如果想一直使用root权限，要通过su切换到root用户。"><a href="#3-如果想一直使用root权限，要通过su切换到root用户。" class="headerlink" title="(3)如果想一直使用root权限，要通过su切换到root用户。"></a>(3)如果想一直使用root权限，要通过su切换到root用户。</h3><p>那我们首先要重设置root用户的密码：</p>
<p>xzm@ubuntu:~$ sudo passwd root</p>
<p>这样就可以设置root用户的密码了。</p>
<h3 id="4-之后就可以自由的切换到root用户了"><a href="#4-之后就可以自由的切换到root用户了" class="headerlink" title="(4)之后就可以自由的切换到root用户了"></a>(4)之后就可以自由的切换到root用户了</h3><p>xzm@ubuntu:~$ su</p>
<p>输入root用户的密码即可。</p>
<p>su “king” 或者 exit回到用户权限</p>
<p>Linux su命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。</p>
<p>使用权限：所有使用者。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [-fmp] [-c command] [-s shell] [--help] [--version] [-] [USER [ARG]]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-f 或 –fast 不必读启动档（如 csh.cshrc 等），仅用于 csh 或 tcsh</li>
<li>-m -p 或 –preserve-environment 执行 su 时不改变环境变数</li>
<li>-c command 或 –command=command 变更为帐号为 USER 的使用者并执行指令（command）后再变回原来使用者</li>
<li>-s shell 或 –shell=shell 指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者（USER） shell</li>
<li>–help 显示说明文件</li>
<li>–version 显示版本资讯</li>
<li>- -l 或 –login 这个参数加了之后，就好像是重新 login 为该使用者一样，大部份环境变数（HOME SHELL USER等等）都是以该使用者（USER）为主，并且工作目录也会改变，如果没有指定 USER ，内定是 root</li>
<li>USER 欲变更的使用者帐号</li>
<li>ARG 传入新的 shell 参数</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>变更帐号为 root 并在执行 ls 指令后退出变回原使用者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -c ls root</span><br></pre></td></tr></table></figure>

<p>变更帐号为 root 并传入 -f 参数给新执行的 shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root -f</span><br></pre></td></tr></table></figure>

<p>变更帐号为 clsung 并改变工作目录至 clsung 的家目录（home dir）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - clsung</span><br></pre></td></tr></table></figure>

<p>切换用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hnlinux@runoob.com:~$ whoami &#x2F;&#x2F;显示当前用户</span><br><span class="line">hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ su root &#x2F;&#x2F;切换到root用户</span><br><span class="line">密码： </span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# whoami </span><br><span class="line">root</span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# pwd</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br></pre></td></tr></table></figure>

<p>切换用户，改变环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hnlinux@runoob.com:~$ whoami &#x2F;&#x2F;显示当前用户</span><br><span class="line">hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ su - root &#x2F;&#x2F;切换到root用户</span><br><span class="line">密码： </span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# whoami </span><br><span class="line">root</span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;root</span><br></pre></td></tr></table></figure>



<h2 id="P67-69（组管理）"><a href="#P67-69（组管理）" class="headerlink" title="P67-69（组管理）"></a>P67-69（组管理）</h2><p>sudo来创建删除组，不用sudo会permission denied</p>
<ol>
<li>groupadd 组名：添加组</li>
<li>groupdel 组名 ：删除组</li>
<li>cat /etc/group： 确认组信息</li>
<li>chgrp -R 组名 文件/目录名：递归修改文件/目录所属组</li>
</ol>
<p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 </p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。 </li>
<li>用户口令的管理。</li>
<li>用户组的管理。 </li>
</ul>
<hr>
<h2 id="一、Linux系统用户账号的管理"><a href="#一、Linux系统用户账号的管理" class="headerlink" title="一、Linux系统用户账号的管理"></a>一、Linux系统用户账号的管理</h2><p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p>
<p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。</p>
<h3 id="1、添加新的用户账号使用useradd命令，其语法如下："><a href="#1、添加新的用户账号使用useradd命令，其语法如下：" class="headerlink" title="1、添加新的用户账号使用useradd命令，其语法如下："></a>1、添加新的用户账号使用useradd命令，其语法如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><p>选项:</p>
<ul>
<li>-c comment 指定一段注释性描述。</li>
<li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li>
<li>-g 用户组 指定用户所属的用户组。</li>
<li>-G 用户组，用户组 指定用户所属的附加组。</li>
<li>-s Shell文件 指定用户的登录Shell。</li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
</ul>
</li>
<li><p>用户名: </p>
<p>指定新账号的登录名。</p>
</li>
</ul>
<h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># useradd –d  &#x2F;home&#x2F;sam -m sam</span><br></pre></td></tr></table></figure>

<p>此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）。</p>
<h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># useradd -s &#x2F;bin&#x2F;sh -g group –G adm,root gem</span><br></pre></td></tr></table></figure>

<p>此命令新建了一个用户gem，该用户的登录Shell是 <code>/bin/sh</code>，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。</p>
<p>这里可能新建组：<code>#groupadd group及groupadd adm</code></p>
<p>增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。</p>
<p>Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。</p>
<h3 id="2、删除帐号"><a href="#2、删除帐号" class="headerlink" title="2、删除帐号"></a>2、删除帐号</h3><p>如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p>
<p>删除一个已有的用户账号使用<code>userdel</code>命令，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项是 <strong>-r</strong>，它的作用是把用户的主目录一起删除。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># userdel -r sam</span><br></pre></td></tr></table></figure>

<p>此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p>
<h3 id="3、修改帐号"><a href="#3、修改帐号" class="headerlink" title="3、修改帐号"></a>3、修改帐号</h3><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p>
<p>修改已有用户的信息使用<code>usermod</code>命令，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项包括<code>-c, -d, -m, -g, -G, -s, -u以及-o等</code>，这些选项的意义与<code>useradd</code>命令中的选项一样，可以为用户指定新的资源值。</p>
<p>另外，有些系统可以使用选项：-l 新用户名</p>
<p>这个选项指定一个新的账号，即将原来的用户名改为新的用户名。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># usermod -s &#x2F;bin&#x2F;ksh -d &#x2F;home&#x2F;z –g developer sam</span><br></pre></td></tr></table></figure>

<p>此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。</p>
<h3 id="4、用户口令的管理"><a href="#4、用户口令的管理" class="headerlink" title="4、用户口令的管理"></a>4、用户口令的管理</h3><p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p>
<p>指定和修改用户口令的Shell命令是<code>passwd</code>。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>可使用的选项：</p>
<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。</li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
<p>如果默认用户名，则修改当前用户的口令。</p>
<p>例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ passwd </span><br><span class="line">Old password:****** </span><br><span class="line">New password:******* </span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>如果是超级用户，可以用下列形式指定任何用户的口令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># passwd sam </span><br><span class="line">New password:******* </span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p>
<p>为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。</p>
<p>为用户指定空口令时，执行下列形式的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># passwd -d sam</span><br></pre></td></tr></table></figure>

<p>此命令将用户 sam 的口令删除，这样用户 sam 下一次登录时，系统就不再允许该用户登录了。</p>
<p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># passwd -l sam</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、Linux系统用户组的管理"><a href="#二、Linux系统用户组的管理" class="headerlink" title="二、Linux系统用户组的管理"></a>二、Linux系统用户组的管理</h2><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p>
<h3 id="1、增加一个新的用户组使用groupadd命令。其格式如下："><a href="#1、增加一个新的用户组使用groupadd命令。其格式如下：" class="headerlink" title="1、增加一个新的用户组使用groupadd命令。其格式如下："></a>1、增加一个新的用户组使用groupadd命令。其格式如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd 选项 用户组</span><br></pre></td></tr></table></figure>

<p>可以使用的选项有：</p>
<ul>
<li>-g GID 指定新用户组的组标识号（GID）。</li>
<li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li>
</ul>
<h4 id="实例1："><a href="#实例1：" class="headerlink" title="实例1："></a>实例1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># groupadd group1</span><br></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p>
<h4 id="实例2："><a href="#实例2：" class="headerlink" title="实例2："></a>实例2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># groupadd -g 101 group2</span><br></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。</p>
<h3 id="2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下："><a href="#2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下：" class="headerlink" title="2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下："></a>2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure>

<h4 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># groupdel group1</span><br></pre></td></tr></table></figure>

<p>此命令从系统中删除组group1。</p>
<h3 id="3、修改用户组的属性使用groupmod命令。其语法如下："><a href="#3、修改用户组的属性使用groupmod命令。其语法如下：" class="headerlink" title="3、修改用户组的属性使用groupmod命令。其语法如下："></a>3、修改用户组的属性使用groupmod命令。其语法如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br></pre></td></tr></table></figure>

<p>常用的选项有：</p>
<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li>-n新用户组 将用户组的名字改为新名字</li>
</ul>
<h4 id="实例1：-1"><a href="#实例1：-1" class="headerlink" title="实例1："></a>实例1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># groupmod -g 102 group2</span><br></pre></td></tr></table></figure>

<p>此命令将组group2的组标识号修改为102。</p>
<h4 id="实例2：-1"><a href="#实例2：-1" class="headerlink" title="实例2："></a>实例2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># groupmod –g 10000 -n group3 group2</span><br></pre></td></tr></table></figure>

<p>此命令将组group2的标识号改为10000，组名修改为group3。</p>
<h3 id="4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。"><a href="#4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。" class="headerlink" title="4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。"></a>4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</h3><p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ newgrp root</span><br></pre></td></tr></table></figure>

<p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。</p>
<hr>
<h2 id="三、与用户账号有关的系统文件"><a href="#三、与用户账号有关的系统文件" class="headerlink" title="三、与用户账号有关的系统文件"></a>三、与用户账号有关的系统文件</h2><p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p>
<p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。</p>
<p>下面分别介绍这些文件的内容。</p>
<h3 id="1、-etc-passwd文件是用户管理工作涉及的最重要的一个文件。"><a href="#1、-etc-passwd文件是用户管理工作涉及的最重要的一个文件。" class="headerlink" title="1、/etc/passwd文件是用户管理工作涉及的最重要的一个文件。"></a>1、/etc/passwd文件是用户管理工作涉及的最重要的一个文件。</h3><p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p>
<p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">＃ cat &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">root:x:0:0:Superuser:&#x2F;:</span><br><span class="line">daemon:x:1:1:System daemons:&#x2F;etc:</span><br><span class="line">bin:x:2:2:Owner of system commands:&#x2F;bin:</span><br><span class="line">sys:x:3:3:Owner of system files:&#x2F;usr&#x2F;sys:</span><br><span class="line">adm:x:4:4:System accounting:&#x2F;usr&#x2F;adm:</span><br><span class="line">uucp:x:5:5:UUCP administrator:&#x2F;usr&#x2F;lib&#x2F;uucp:</span><br><span class="line">auth:x:7:21:Authentication administrator:&#x2F;tcb&#x2F;files&#x2F;auth:</span><br><span class="line">cron:x:9:16:Cron daemon:&#x2F;usr&#x2F;spool&#x2F;cron:</span><br><span class="line">listen:x:37:4:Network daemon:&#x2F;usr&#x2F;net&#x2F;nls:</span><br><span class="line">lp:x:71:18:Printer administrator:&#x2F;usr&#x2F;spool&#x2F;lp:</span><br><span class="line">sam:x:200:50:Sam san:&#x2F;home&#x2F;sam:&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>

<p>从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure>

<h3 id="1）”用户名”是代表用户账号的字符串。"><a href="#1）”用户名”是代表用户账号的字符串。" class="headerlink" title="1）”用户名”是代表用户账号的字符串。"></a>1）”用户名”是代表用户账号的字符串。</h3><p>通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</p>
<p>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p>
<h3 id="2）“口令”一些系统中，存放着加密后的用户口令字。"><a href="#2）“口令”一些系统中，存放着加密后的用户口令字。" class="headerlink" title="2）“口令”一些系统中，存放着加密后的用户口令字。"></a>2）“口令”一些系统中，存放着加密后的用户口令字。</h3><p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p>
<h3 id="3）“用户标识号”是一个整数，系统内部用它来标识用户。"><a href="#3）“用户标识号”是一个整数，系统内部用它来标识用户。" class="headerlink" title="3）“用户标识号”是一个整数，系统内部用它来标识用户。"></a>3）“用户标识号”是一个整数，系统内部用它来标识用户。</h3><p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p>
<p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p>
<h3 id="4）“组标识号”字段记录的是用户所属的用户组。"><a href="#4）“组标识号”字段记录的是用户所属的用户组。" class="headerlink" title="4）“组标识号”字段记录的是用户所属的用户组。"></a>4）“组标识号”字段记录的是用户所属的用户组。</h3><p>它对应着/etc/group文件中的一条记录。</p>
<h3 id="5-“注释性描述”字段记录着用户的一些个人情况。"><a href="#5-“注释性描述”字段记录着用户的一些个人情况。" class="headerlink" title="5)“注释性描述”字段记录着用户的一些个人情况。"></a>5)“注释性描述”字段记录着用户的一些个人情况。</h3><p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。</p>
<h3 id="6-“主目录”，也就是用户的起始工作目录。"><a href="#6-“主目录”，也就是用户的起始工作目录。" class="headerlink" title="6)“主目录”，也就是用户的起始工作目录。"></a>6)“主目录”，也就是用户的起始工作目录。</h3><p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p>
<h3 id="7-用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。"><a href="#7-用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。" class="headerlink" title="7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。"></a>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</h3><p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p>
<p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</p>
<p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p>
<p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p>
<h3 id="8-系统中有一类用户称为伪用户（pseudo-users）。"><a href="#8-系统中有一类用户称为伪用户（pseudo-users）。" class="headerlink" title="8)系统中有一类用户称为伪用户（pseudo users）。"></a>8)系统中有一类用户称为伪用户（pseudo users）。</h3><p>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p>
<p>常见的伪用户如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">伪 用 户 含 义 </span><br><span class="line">bin 拥有可执行的用户命令文件 </span><br><span class="line">sys 拥有系统文件 </span><br><span class="line">adm 拥有帐户文件 </span><br><span class="line">uucp UUCP使用 </span><br><span class="line">lp lp或lpd子系统使用 </span><br><span class="line">nobody NFS使用</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="拥有帐户文件"><a href="#拥有帐户文件" class="headerlink" title="拥有帐户文件"></a>拥有帐户文件</h2><p><strong>1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</strong></p>
<p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>
<p><strong>2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生</strong></p>
<p>它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></pre></td></tr></table></figure>

<ol>
<li>“登录名”是与/etc/passwd文件中的登录名相一致的用户账号</li>
<li>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</li>
<li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li>
<li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li>
<li>“最大时间间隔”指的是口令保持有效的最大天数。</li>
<li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li>
<li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li>
<li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li>
</ol>
<p>下面是/etc/shadow的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">＃ cat &#x2F;etc&#x2F;shadow</span><br><span class="line"></span><br><span class="line">root:Dnakfw28zf38w:8764:0:168:7:::</span><br><span class="line">daemon:*::0:0::::</span><br><span class="line">bin:*::0:0::::</span><br><span class="line">sys:*::0:0::::</span><br><span class="line">adm:*::0:0::::</span><br><span class="line">uucp:*::0:0::::</span><br><span class="line">nuucp:*::0:0::::</span><br><span class="line">auth:*::0:0::::</span><br><span class="line">cron:*::0:0::::</span><br><span class="line">listen:*::0:0::::</span><br><span class="line">lp:*::0:0::::</span><br><span class="line">sam:EkdiSECLWPdSa:9740:0:0::::</span><br></pre></td></tr></table></figure>

<h3 id="3、用户组的所有信息都存放在-etc-group文件中。"><a href="#3、用户组的所有信息都存放在-etc-group文件中。" class="headerlink" title="3、用户组的所有信息都存放在/etc/group文件中。"></a>3、用户组的所有信息都存放在/etc/group文件中。</h3><p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p>
<p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p>
<p>当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p>
<p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p>
<p>用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组名:口令:组标识号:组内用户列表</span><br></pre></td></tr></table></figure>

<ol>
<li>“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</li>
<li>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</li>
<li>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</li>
<li>“组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li>
</ol>
<p>/etc/group文件的一个例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root::0:root</span><br><span class="line">bin::2:root,bin</span><br><span class="line">sys::3:root,uucp</span><br><span class="line">adm::4:root,adm</span><br><span class="line">daemon::5:root,daemon</span><br><span class="line">lp::7:root,lp</span><br><span class="line">users::20:root,sam</span><br></pre></td></tr></table></figure>

<h3 id="四、添加批量用户"><a href="#四、添加批量用户" class="headerlink" title="四、添加批量用户"></a>四、添加批量用户</h3><p>添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：</p>
<h3 id="（1）先编辑一个文本用户文件。"><a href="#（1）先编辑一个文本用户文件。" class="headerlink" title="（1）先编辑一个文本用户文件。"></a>（1）先编辑一个文本用户文件。</h3><p>每一列按照<code>/etc/passwd</code>密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user001::600:100:user:&#x2F;home&#x2F;user001:&#x2F;bin&#x2F;bash</span><br><span class="line">user002::601:100:user:&#x2F;home&#x2F;user002:&#x2F;bin&#x2F;bash</span><br><span class="line">user003::602:100:user:&#x2F;home&#x2F;user003:&#x2F;bin&#x2F;bash</span><br><span class="line">user004::603:100:user:&#x2F;home&#x2F;user004:&#x2F;bin&#x2F;bash</span><br><span class="line">user005::604:100:user:&#x2F;home&#x2F;user005:&#x2F;bin&#x2F;bash</span><br><span class="line">user006::605:100:user:&#x2F;home&#x2F;user006:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<h3 id="（2）以root身份执行命令-usr-sbin-newusers，从刚创建的用户文件user-txt中导入数据，创建用户："><a href="#（2）以root身份执行命令-usr-sbin-newusers，从刚创建的用户文件user-txt中导入数据，创建用户：" class="headerlink" title="（2）以root身份执行命令 /usr/sbin/newusers，从刚创建的用户文件user.txt中导入数据，创建用户："></a>（2）以root身份执行命令 <code>/usr/sbin/newusers</code>，从刚创建的用户文件<code>user.txt</code>中导入数据，创建用户：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># newusers &lt; user.txt</span><br></pre></td></tr></table></figure>

<p>然后可以执行命令 <code>vipw</code> 或 <code>vi /etc/passwd</code> 检查 <code>/etc/passwd</code> 文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。</p>
<h3 id="（3）执行命令-usr-sbin-pwunconv。"><a href="#（3）执行命令-usr-sbin-pwunconv。" class="headerlink" title="（3）执行命令/usr/sbin/pwunconv。"></a>（3）执行命令/usr/sbin/pwunconv。</h3><p>将 <code>/etc/shadow</code> 产生的 <code>shadow</code> 密码解码，然后回写到 <code>/etc/passwd</code> 中，并将<code>/etc/shadow</code>的<code>shadow</code>密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 <code>shadow password</code> 功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pwunconv</span><br></pre></td></tr></table></figure>

<h3 id="（4）编辑每个用户的密码对照文件。"><a href="#（4）编辑每个用户的密码对照文件。" class="headerlink" title="（4）编辑每个用户的密码对照文件。"></a>（4）编辑每个用户的密码对照文件。</h3><p>格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:密码</span><br></pre></td></tr></table></figure>

<p>实例文件 <code>passwd.txt</code> 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user001:123456</span><br><span class="line">user002:123456</span><br><span class="line">user003:123456</span><br><span class="line">user004:123456</span><br><span class="line">user005:123456</span><br><span class="line">user006:123456</span><br></pre></td></tr></table></figure>

<h3 id="（5）以-root-身份执行命令-usr-sbin-chpasswd。"><a href="#（5）以-root-身份执行命令-usr-sbin-chpasswd。" class="headerlink" title="（5）以 root 身份执行命令 /usr/sbin/chpasswd。"></a>（5）以 root 身份执行命令 <code>/usr/sbin/chpasswd</code>。</h3><p>创建用户密码，<code>chpasswd</code> 会将经过 <code>/usr/bin/passwd</code> 命令编码过的密码写入 <code>/etc/passwd</code> 的密码栏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chpasswd &lt; passwd.txt</span><br></pre></td></tr></table></figure>

<h3 id="（6）确定密码经编码写入-etc-passwd的密码栏后。"><a href="#（6）确定密码经编码写入-etc-passwd的密码栏后。" class="headerlink" title="（6）确定密码经编码写入/etc/passwd的密码栏后。"></a>（6）确定密码经编码写入/etc/passwd的密码栏后。</h3><p>执行命令 <code>/usr/sbin/pwconv</code> 将密码编码为 <code>shadow password</code>，并将结果写入 <code>/etc/shadow</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pwconv</span><br></pre></td></tr></table></figure>

<p>这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。</p>
<h2 id="P70-71-用户管理"><a href="#P70-71-用户管理" class="headerlink" title="P70-71(用户管理)"></a>P70-71(用户管理)</h2><ol>
<li><p>useradd -m -g 组 新建用户名：添加新用户 -m自动建立用户加目录， -g指定用户所在组，否则会建立一个同名的组。</p>
<p>例： sudo useradd -m -g dev zhangsan </p>
<p>drwxr-xr-x  2 zhangsan     dev          4096 Apr 26 18:30 zhangsan</p>
</li>
<li><p>passwd 用户名： 设置用户密码，如果是普通用户，直接passwd可以修改密码</p>
</li>
<li><p>userdel -r 用户名；删除用户， -r会自动删除用户家目录</p>
</li>
<li><p>cat /etc/passwd | grep 用户名 ：确认用户信息，新建用户后，用户信息会保存在/etc/passwd文件中</p>
</li>
</ol>
<h2 id="P72-75（id，whoami，who）"><a href="#P72-75（id，whoami，who）" class="headerlink" title="P72-75（id，whoami，who）"></a>P72-75（id，whoami，who）</h2><h3 id="id-用户名：查看用户UID和GID信息"><a href="#id-用户名：查看用户UID和GID信息" class="headerlink" title="id 用户名：查看用户UID和GID信息"></a>id 用户名：查看用户UID和GID信息</h3><p>passwd文件：/etc/passwd文件存放用户信息，6个分号组成7个信息</p>
<p>信息说明<br>第一字段: 用户名(vampire)<br>第二字段: 密码位(x),只是一个占位符,真正的密码存放在/etc/shadow文件中（x，表示加密密码）<br>第三字段: UID(501)用户id,0为超级用户,1~499系统用户,一般不能登录系统,也叫做伪用户,500及以上普通用户,管理员创建的,一般可登录（用户标识）<br>第四字段: GID(501)用户初始组id,一般添加用户时,系统自动分配的（组标识）<br>第五字段: GECOS 用户的一些说明信息（用户全名或本地账号）<br>第六字段: $HOME(/home/vampire) 用户家目录,也叫做宿主目录,普通用户家目录在/home下,root用户在/下（家目录）</p>
<p>第七字段: shell(/bin/bash)用户登录后的shell，ubuntu默认是dash</p>
<p> UID，gid，组 依次打印</p>
<p>Linux id命令用于显示用户的ID，以及所属群组的ID。</p>
<p>id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id [-gGnru][--help][--version][用户名称]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-g或–group 　显示用户所属群组的ID。</li>
<li>-G或–groups 　显示用户所属附加群组的ID。</li>
<li>-n或–name 　显示用户，所属群组或附加群组的名称。</li>
<li>-r或–real 　显示实际ID。</li>
<li>-u或–user 　显示用户ID。</li>
<li>-help 　显示帮助。</li>
<li>-version 　显示版本信息。</li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>显示当前用户信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id &#x2F;&#x2F;显示当前用户ID</span><br><span class="line">uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel) context&#x3D;root:system_r:unconfined_t</span><br></pre></td></tr></table></figure>

<p>显示用户群组的ID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id -g</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>显示所有群组的ID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id -g</span><br><span class="line">0 1 2 3 4 5 6 10</span><br></pre></td></tr></table></figure>

<p>显示指定用户信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># id hnlinux</span><br></pre></td></tr></table></figure>

<h3 id="who：查看当前所有登录的用户列表"><a href="#who：查看当前所有登录的用户列表" class="headerlink" title="who：查看当前所有登录的用户列表"></a>who：查看当前所有登录的用户列表</h3><p>Linux who命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。</p>
<p>使用权限：所有使用者都可使用。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who - [husfV] [user]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-H 或 –heading：显示各栏位的标题信息列；</li>
<li>-i 或 -u 或 –idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成”.”号，如果该用户已超过24小时没有任何动作，则标示出”old”字符串；</li>
<li>-m：此参数的效果和指定”am i”字符串相同；</li>
<li>-q 或–count：只显示登入系统的帐号名称和总人数；</li>
<li>-s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题；</li>
<li>-w 或-T或–mesg或–message或–writable：显示用户的信息状态栏；</li>
<li>–help：在线帮助；</li>
<li>–version：显示版本信息。</li>
</ul>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>显示当前登录系统的用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># who  &#x2F;&#x2F;显示当前登录系统的用户</span><br><span class="line">root   tty7     2014-05-13 12:12 (:0)</span><br><span class="line">root   pts&#x2F;0    2014-05-14 17:09 (:0.0)</span><br><span class="line">root   pts&#x2F;1    2014-05-14 18:51 (192.168.1.17)</span><br><span class="line">root   pts&#x2F;2    2014-05-14 19:48 (192.168.1.17)</span><br></pre></td></tr></table></figure>

<p>显示标题栏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># who -H</span><br><span class="line">NAME   LINE     TIME       COMMENT</span><br><span class="line">root   tty7     2014-05-13 12:12 (:0)</span><br><span class="line">root   pts&#x2F;0    2014-05-14 17:09 (:0.0)</span><br><span class="line">root   pts&#x2F;1    2014-05-14 18:51 (192.168.1.17)</span><br><span class="line">root   pts&#x2F;2    2014-05-14 19:48 (192.168.1.17)</span><br></pre></td></tr></table></figure>

<p>显示用户登录来源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># who -l -H</span><br><span class="line">NAME   LINE     TIME       IDLE     PID COMMENT</span><br><span class="line">LOGIN  tty4     2014-05-13 12:11        852 id&#x3D;4</span><br><span class="line">LOGIN  tty5     2014-05-13 12:11        855 id&#x3D;5</span><br><span class="line">LOGIN  tty2     2014-05-13 12:11        862 id&#x3D;2</span><br><span class="line">LOGIN  tty3     2014-05-13 12:11        864 id&#x3D;3</span><br><span class="line">LOGIN  tty6     2014-05-13 12:11        867 id&#x3D;6</span><br><span class="line">LOGIN  tty1     2014-05-13 12:11       1021 id&#x3D;1</span><br></pre></td></tr></table></figure>

<p>显示终端属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># who -T -H</span><br><span class="line">NAME    LINE     TIME       COMMENT</span><br><span class="line">root   + tty7     2014-05-13 12:12 (:0)</span><br><span class="line">root   + pts&#x2F;0    2014-05-14 17:09 (:0.0)</span><br><span class="line">root   - pts&#x2F;1    2014-05-14 18:51 (192.168.1.17)</span><br><span class="line">root   - pts&#x2F;2    2014-05-14 19:48 (192.168.1.17)</span><br></pre></td></tr></table></figure>

<p>只显示当前用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># who -m -H</span><br><span class="line">NAME   LINE     TIME       COMMENT</span><br><span class="line">root   pts&#x2F;1    2014-05-14 18:51 (192.168.1.17)</span><br></pre></td></tr></table></figure>

<p>精简模式显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># who -q</span><br><span class="line">root root root root</span><br><span class="line"># users&#x3D;4</span><br></pre></td></tr></table></figure>

<h3 id="whoami：查看当前登录用户的账户名"><a href="#whoami：查看当前登录用户的账户名" class="headerlink" title="whoami：查看当前登录用户的账户名"></a>whoami：查看当前登录用户的账户名</h3><p>Linux whoami命令用于显示自身用户名称。</p>
<p>显示自身的用户名称，本指令相当于执行”id -un”指令。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami [--help][--version]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>–help 　在线帮助。</li>
<li>–version 　显示版本信息。</li>
</ul>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>显示用户名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># whoami </span><br><span class="line">root</span><br></pre></td></tr></table></figure>

<h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><p>用来设置用户主组/附加组 和登录shell</p>
<p>Linux系统以组Group方式管理用户，用户和组的对应关系为多对多，即某个用户可加入/属于一个或多个组，某个组可以有0个、1个或多个用户。</p>
<p>组的分类<br>从用户的角度，分为主组和附属组。<br>主组：也被称为primary group、first group或initial login group，用户的默认组，用户的gid所标识的组。<br>附属组：也被称为Secondary group或supplementary group，用户的附加组。</p>
<p>通过id命令可查看当前用户的主组和附属组</p>
<p>[root@localhost ~]# id root<br>uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel)</p>
<p>[root@localhost ~]# id gg<br>uid=503(gg) gid=503(gg) groups=503(gg)</p>
<p>[root@localhost ~]# id mm<br>uid=502(mm) gid=500(jww) groups=500(jww)</p>
<p>gid标识主组，groups表示用户所属的全部组（主组和附属组）</p>
<ol>
<li><p>用户必须有且只能有一个主组，可以有0个、1个或多个附属组，就如我们一定会有一个用来安家的房子（类同主组），还可以有n个用于投资或其他打算的房子（附属组）。</p>
</li>
<li><p>主组也为默认组，当用户own某个文件或目录时，默认该文件或目录的group owner为该用户的主组（当然，可以通过chgrp修改group owner）。</p>
</li>
<li><p>在/etc/passwd文件中，记录行第四个字段为gid，即用户的主组id。</p>
</li>
<li><p>在/etc/group文件中，记录行第四个字段为组的成员，不显示将该组作为主组的组成员，只显示将该组作为附属组的组成员，因此，/etc/group的记录行的第四个字段没有完整地列出该组的全部成员。</p>
</li>
<li><p>当通过useradd命令创建新用户时，可以通过-g参数指定已存在的某个组为其主组，若没有使用-g参数，<br>则系统自动创建名称和用户名相同的组作为该用户的主组（前提是variable in /etc/login.defs的USERGROUPS_ENAB属性值为yes），如命令手册的useradd关于-g参数的描述所示：<br>-g, –gid GROUP<br>The group name or number of the user′s initial login group. The<br>group name must exist. A group number must refer to an already<br>existing group.<br>If not specified, the bahavior of useradd will depend on the<br>USERGROUPS_ENAB variable in /etc/login.defs. If this variable is<br>set to yes (or -U/–user-group is specified on the command line), a<br>group will be created for the user, with the same name as her<br>loginname. If the variable is set to no (or -N/–no-user-group is<br>specified on the command line), useradd will set the primary group<br>of the new user to the value specified by the GROUP variable in<br>/etc/default/useradd, or 100 by default.</p>
</li>
</ol>
<p>另外，可通过usermod -g 将普通用户的主组/gid设置为系e799bee5baa6e79fa5e98193e4b893e5b19e31333337613161统中存在的任意某个组（永久性）；<br>也可以通过newgrp暂时性变更当前用户的主组/gid（只对于当前login session有效，非永久性）。<br>通过usermod -G 设置普通用户的附属组。</p>
<p>Linux usermod命令用于修改用户帐号。</p>
<p>usermod可用来修改用户帐号的各项设定。</p>
<p>usermod 命令通过修改系统帐户文件来修改用户账户信息<br>usermod [options] user_name<br>选项(options)<br>-a|–append ##把用户追加到某些组中，仅与-G选项一起使用<br>-c|–comment ##修改/etc/passwd文件第五段comment<br>-d|–home ##修改用户的家目录通常和-m选项一起使用<br>-e|–expiredate ##指定用户帐号禁用的日期，格式YY-MM-DD<br>-f|–inactive ##用户密码过期多少天后采用就禁用该帐号，0表示密码已过期就禁用帐号，-1表示禁用此功能，默认值是-1<br>-g|–gid ##修改用户的gid，改组一定存在<br>-G|–groups ##把用户追加到某些组中，仅与-a选项一起使用<br>-l|–login ##修改用户的登录名称<br>-L|–lock ##锁定用户的密码<br>-m|–move-home ##修改用户的家目录通常和-d选项一起使用<br>-s|–shell ##修改用户的shell<br>-u|–uid ##修改用户的uid，该uid必须唯一<br>-U|–unlock ##解锁用户的密码</p>
<h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod [-LU][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-l &lt;帐号名称&gt;][-s &lt;shell&gt;][-u &lt;uid&gt;][用户帐号]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li><p>-c&lt;备注&gt; 　修改用户帐号的备注文字。</p>
</li>
<li><p>-d登入目录&gt; 　修改用户登入时的目录。</p>
</li>
<li><p>-e&lt;有效期限&gt; 　修改帐号的有效期限。</p>
</li>
<li><p>-f&lt;缓冲天数&gt; 　修改在密码过期后多少天即关闭该帐号。</p>
</li>
<li><p>-g&lt;群组&gt; 　修改用户所属的群组。（常用）</p>
</li>
<li><p>-G&lt;群组&gt; 　修改用户所属的附加群组。（常用）</p>
</li>
<li><p>-l&lt;帐号名称&gt; 　修改用户帐号名称。</p>
</li>
<li><p>-L 　锁定用户密码，使密码无效。</p>
</li>
<li><p>-s<shell> 　修改用户登入后所使用的shell。（常用）</p>
<p>例：usermod -S /bin/bash 用户名</p>
</li>
<li><p>-u<uid> 　修改用户ID。</p>
</li>
<li><p>-U 　解除密码锁定。</p>
</li>
</ul>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>更改登录目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># usermod -d &#x2F;home&#x2F;hnlinux root</span><br></pre></td></tr></table></figure>

<p>改变用户的uid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># usermod -u 777 root</span><br></pre></td></tr></table></figure>



<h3 id="usermod-S-bin-bash-用户名"><a href="#usermod-S-bin-bash-用户名" class="headerlink" title="usermod -S /bin/bash 用户名"></a>usermod -S /bin/bash 用户名</h3><p>用户ubuntu默认是dash，而windows不是，想windows登录也是dash，需要上面的命令修改shell为dash</p>
<p>Bash(GNU Bourne-Again Shell)是许多Linux平台的内定Shell，事实上，还有许多传统UNIX上用的Shell，像tcsh、csh、ash、bsh、ksh等等。</p>
<p>GNU/Linux 操作系统中的 /bin/sh 本是 bash (Bourne-Again Shell) 的符号链接，但鉴于 bash 过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash (Debian Almquist Shell)，并建议将 /bin/sh 指向它，以获得更快的脚本执行速度。Dash Shell 比 Bash Shell 小的多，符合POSIX标准。</p>
<p>Debian和Ubuntu中，/bin/sh默认已经指向dash，这是一个不同于bash的shell，它主要是为了执行脚本而出现，而不是交互，它速度更快，但功能相比bash要少很多，语法严格遵守POSIX标准。</p>
<p>就是这个倒霉的dash解释器使得我按照bash语法写的shell 脚本不能运行。</p>
<p>要知道自己的/bin/sh指向何种解释器，可以用 <strong>ls /bin/sh -al</strong> 命令查看：</p>
<p>​    $ ls /bin/sh -al</p>
<p>​    lrwxrwxrwx 1 root root 4 11月 16 15:33 /bin/sh -&gt; bash</p>
<p>以上结果就表示当前系统用的是dash解释器。</p>
<p>切换到bash的方式其实挺简单的，关键是一直没找出这个原因……</p>
<p>修改默认的sh，可以采用命令<strong>sudo dpkg-reconfigure dash</strong></p>
<p>会出现一个图片状的配置菜单，选no就可以了</p>
<p>再次检查一下， <strong>ls /bin/sh -al</strong> 发现软链接指向/bin/bash</p>
<p>​     lrwxrwxrwx 1 root root 4 11月 16 15:33 /bin/sh -&gt; bash</p>
<h2 id="P76which"><a href="#P76which" class="headerlink" title="P76which"></a>P76which</h2><p>Linux which命令用于查找文件。可以查看指向命令所在位置</p>
<p>/etc/passwd: 用于保存用户信息的文件</p>
<p>/etc/bin/passwd:用于修改用户密码的程序</p>
<p>which指令会在环境变量$PATH设置的目录里查找符合条件的文件。</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which [文件...]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-n&lt;文件名长度&gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</li>
<li>-p&lt;文件名长度&gt; 　与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。</li>
<li>-w 　指定输出时栏位的宽度。</li>
<li>-V 　显示版本信息。</li>
</ul>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>使用指令”which”查看指令”bash”的绝对路径，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ which bash</span><br></pre></td></tr></table></figure>

<p>上面的指令执行后，输出信息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin&#x2F;bash                   #bash可执行程序的绝对路径</span><br></pre></td></tr></table></figure>

<p>我们经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：</p>
<p><strong>which</strong> 　查看可执行文件的位置。</p>
<p><strong>whereis</strong> 查看文件的位置。</p>
<p><strong>locate</strong> 　配合数据库查看文件位置。</p>
<p><strong>find</strong> 　　实际搜寻硬盘查询文件名称。</p>
<p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
<p><strong>1．命令格式：</strong></p>
<p>which 可执行文件名称</p>
<p><strong>2．命令功能：</strong></p>
<p>which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p>
<p><strong>3．命令参数：</strong></p>
<p><strong>-n</strong> 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</p>
<p><strong>-p</strong> 与-n参数相同，但此处的包括了文件的路径。</p>
<p><strong>-w</strong> 指定输出时栏位的宽度。</p>
<p><strong>-V</strong> 显示版本信息</p>
<p><strong>4．使用实例：</strong></p>
<p><strong>实例1：</strong>查找文件、显示命令路径</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which lsmod</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# which pwd</span><br><span class="line">&#x2F;bin&#x2F;pwd</span><br><span class="line">[root@localhost ~]# which adduser</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;adduser</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>which 是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！</p>
<p><strong>实例2：</strong>用 which 去找出 which</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which which</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# which which</span><br><span class="line">alias which&#x3D;&#39;alias | &#x2F;usr&#x2F;bin&#x2F;which --tty-only --read-alias --show-dot --show-tilde&#39;</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;which</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>竟然会有两个 which ，其中一个是 alias 这就是所谓的『命令别名』，意思是输入 which 会等於后面接的那串命令！</p>
<p><strong>实例3：</strong>找出 cd 这个命令</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which cd</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>cd 这个常用的命令竟然找不到啊！为什么呢？这是因为 cd 是bash 内建的命令！ 但是 which 默认是找 PATH 内所规范的目录，所以当然一定找不到的！</p>
<p>bin:<br>bin为binary的简写主要放置一些<strong>系统的必备执行</strong>档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。</p>
<p>/usr/bin:<br>主 要放置一些<strong>应用软体工具的必备执行</strong>档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome<em>、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb</em>、wget等。 </p>
<p>/sbin:<br>主 要放置一些<strong>系统管理的必备</strong>程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。</p>
<p>/usr/sbin: </p>
<p>放置一些<strong>网路管理的必备</strong>程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等</p>
<h2 id="P77（su切换用户）"><a href="#P77（su切换用户）" class="headerlink" title="P77（su切换用户）"></a>P77（su切换用户）</h2><p>Linux su命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。不安全，会返回root。然后无需sudo了，即可改系统等。</p>
<p>使用权限：所有使用者。</p>
<h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [-fmp] [-c command] [-s shell] [--help] [--version] [-] [USER [ARG]]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-f 或 –fast 不必读启动档（如 csh.cshrc 等），仅用于 csh 或 tcsh</li>
<li>-m -p 或 –preserve-environment 执行 su 时不改变环境变数</li>
<li>-c command 或 –command=command 变更为帐号为 USER 的使用者并执行指令（command）后再变回原来使用者</li>
<li>-s shell 或 –shell=shell 指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者（USER） shell</li>
<li>–help 显示说明文件</li>
<li>–version 显示版本资讯</li>
<li>- -l 或 –login 这个参数加了之后，就好像是重新 login 为该使用者一样，大部份环境变数（HOME SHELL USER等等）都是以该使用者（USER）为主，并且工作目录也会改变，如果没有指定 USER ，内定是 root</li>
<li>USER 欲变更的使用者帐号</li>
<li>ARG 传入新的 shell 参数</li>
</ul>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>变更帐号为 root 并在执行 ls 指令后退出变回原使用者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -c ls root</span><br></pre></td></tr></table></figure>

<p>变更帐号为 root 并传入 -f 参数给新执行的 shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root -f</span><br></pre></td></tr></table></figure>

<p>变更帐号为 clsung 并改变工作目录至 clsung 的家目录（home dir）（常用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - clsung</span><br></pre></td></tr></table></figure>

<p>切换用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hnlinux@runoob.com:~$ whoami &#x2F;&#x2F;显示当前用户</span><br><span class="line">hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ su root &#x2F;&#x2F;切换到root用户</span><br><span class="line">密码： </span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# whoami </span><br><span class="line">root</span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# pwd</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br></pre></td></tr></table></figure>

<p>切换用户，改变环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hnlinux@runoob.com:~$ whoami &#x2F;&#x2F;显示当前用户</span><br><span class="line">hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ su - root &#x2F;&#x2F;切换到root用户</span><br><span class="line">密码： </span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# whoami </span><br><span class="line">root</span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;root</span><br></pre></td></tr></table></figure>

<h2 id="P78修改文件权限"><a href="#P78修改文件权限" class="headerlink" title="P78修改文件权限"></a>P78修改文件权限</h2><p>1。 chown: 修改拥有者</p>
<p>2。chgrp：修改组</p>
<p>3 。chmod：修改权限</p>
<p>想要改文件的权限，只有管理员root和所有者才能修改</p>
<p>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。</p>
<p>一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限把自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。</p>
<p><strong>使用权限</strong> : root</p>
<h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [-cfhvR] [--help] [--version] user[:group] file...</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong> :</p>
<ul>
<li>user : 新的文件拥有者的使用者 ID</li>
<li>group : 新的文件拥有者的使用者组(group)</li>
<li>-c : 显示更改的部分的信息</li>
<li>-f : 忽略错误信息</li>
<li>-h :修复符号链接</li>
<li>-v : 显示详细的处理信息</li>
<li>-R : 处理指定目录以及其子目录下的所有文件</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown runoob:runoobgroup file1.txt</span><br></pre></td></tr></table></figure>

<p>将目前目录下的所有文件与子目录的拥有者皆设为 runoob，群体的使用者 runoobgroup:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R runoob:runoobgroup *</span><br></pre></td></tr></table></figure>

<h3 id="1、chmod：更改文件9个属性"><a href="#1、chmod：更改文件9个属性" class="headerlink" title="1、chmod：更改文件9个属性"></a>1、chmod：更改文件9个属性</h3><p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626161252656-1763498520.png" alt="img"></p>
<p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p>
<h4 id="①-数字改变文件权限（常用）"><a href="#①-数字改变文件权限（常用）" class="headerlink" title="① 数字改变文件权限（常用）"></a>① 数字改变文件权限（常用）</h4><p>我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<ul>
<li>r:4</li>
<li>w:2</li>
<li>x:1</li>
</ul>
<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p>
<ul>
<li>owner = rwx = 4+2+1 = 7</li>
<li>group = rwx = 4+2+1 = 7</li>
<li>others= — = 0+0+0 = 0</li>
</ul>
<p>所以等我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure>

<ul>
<li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li>
<li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li>
</ul>
<h4 id="②-符号类型改变文件权限"><a href="#②-符号类型改变文件权限" class="headerlink" title="② 符号类型改变文件权限"></a>② 符号类型改变文件权限</h4><p> 我们就可以藉由u, g, o来代表三种身份的权限！</p>
<p>此外， a 则代表 all 亦即全部的身份！那么读写的权限就可以写成r, w, x！也就是可以使用底下的方式来看：</p>
<table>
<thead>
<tr>
<th>chmod</th>
<th>u g o a</th>
<th>+(加入) -(除去) =(设定)</th>
<th>r w x</th>
<th>文件或目录</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>如果我们需要将文件权限设置为 <strong>-rwxr-xr–</strong> ，可以使用 chmod u=rwx,g=rx,o=r 文件名 来设定。</p>
<p>注意：如果一个目录有写的权限，其他用户对于这个目录下的文件也可以删除。</p>
<h3 id="2、chown：更改文件属主，也可以同时更改文件属组"><a href="#2、chown：更改文件属主，也可以同时更改文件属组" class="headerlink" title="2、chown：更改文件属主，也可以同时更改文件属组"></a>2、chown：更改文件属主，也可以同时更改文件属组</h3><p>注意：这个命令只有管理员root才可以操作。而且系统里是必须存在这个用户。</p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626165146255-1650931601.png" alt="img"></p>
<p>语法：</p>
<p>chown [–R] 属主名： 文件名</p>
<p>chown [-R] 属主名：属组名 文件名</p>
<h3 id="3、chgrp：更改文件属组。"><a href="#3、chgrp：更改文件属组。" class="headerlink" title="3、chgrp：更改文件属组。"></a>3、chgrp：更改文件属组。</h3><p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626170509313-1815193220.png" alt="img"></p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] 属组名 文件名</span><br></pre></td></tr></table></figure>

<p>参数选项</p>
<ul>
<li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li>
</ul>
<h3 id="4、umask设置预设的权限掩码"><a href="#4、umask设置预设的权限掩码" class="headerlink" title="4、umask设置预设的权限掩码"></a><strong>4、umask设置预设的权限掩码</strong></h3><p>Linux umask命令指定在建立文件时预设的权限掩码，在学习这个命令之前，先了解一下默认的所有者和所属组是哪来的？</p>
<p>一个文件创建的时候所有者和所属组是哪来的？</p>
<p>所有者：谁创建的文件谁就是这个文件的所有者。</p>
<p>所属组：就是这个文件创建者的缺省组，每个用户只能有一个缺省组。</p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626172146490-1231316404.png" alt="img"></p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626172519622-446882410.png" alt="img">显示新建文件的缺省权限。</p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626173131946-156221821.png" alt="img"></p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626173426757-2120027575.png" alt="img"></p>
<p>创建一个目录的时候查看发现 权限跟缺省权限是一致的，但是在test目录里创建一个文件后，查看文件缺省权限跟默认缺省权限不一致，这个是为什么呢？</p>
<p>rwxr-xr-x</p>
<p>rw-r–r–  对比发现都少了一个x可执行权限，这是因为在Linux里缺省权限创建的文件是不可具有可执行权限的。</p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626174110254-908588857.png" alt="img"></p>
<p>单独执行  <strong>umask</strong>  发现现实出 <strong>0022</strong> ，这是什么意思呢？</p>
<p>022是权限掩码意思，真正的权限是777-022=755 写出来就是rwxr-xr-x.</p>
<p>如果我们自己要是想修改这个缺省权限，该怎么修改的。</p>
<p>先把想修改的权限格式表示出来，算出对应的数字，再用777-对应的数字就可以，例如：</p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626174709974-11233329.png" alt="img"></p>
<h2 id="P79chmod详解"><a href="#P79chmod详解" class="headerlink" title="P79chmod详解"></a>P79chmod详解</h2><p>这是使用chmod命令时的正确语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [options] mode [，mode] file1 [file2 ...]</span><br></pre></td></tr></table></figure>

<p>以下是chmod使用的一些常用选项：</p>
<p>　●　-f， - silent， - quiet（抑制大多数错误消息）</p>
<p>　●　-v， - verbose（为每个处理的文件输出诊断信息）</p>
<p>　●　-c， - changes（类似于详细但仅在进行更改时报告）</p>
<p>　●　-R， - recursive（递归更改文件和目录）（常用）</p>
<p>　●　–help（显示帮助和退出）</p>
<p>　●　–version（输出版本信息和退出）</p>
<p>下面是可以为用户，组以及计算机上的其他所有人设置的几个数字权限的列表。数字旁边是读/写/执行字母等价物。</p>
<p>　●　7：表示rwx，拥有读、写和执行的权限</p>
<p>　●　6：表示rw-，拥有读和写的权限</p>
<p>　●　5：表示rx，拥有读取和执行的权限</p>
<p>　●　4：表示r–，拥有只读权限</p>
<p>　●　3：表示-wx，拥有写入和执行的权限</p>
<p>　●　2：表示-w-，拥有只写权限</p>
<p>　●　1：表示 - x，仅拥有执行权限</p>
<p>　●　0：表示—，无权限</p>
<p>注：如果需要列出文件的权限，需要使用ls命令。</p>
<p><strong>chmod命令示例</strong></p>
<p>如果用户想要更改文件“participants”的权限，以便所有人都可以完全访问该文件，需要输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 participants</span><br></pre></td></tr></table></figure>

<p>说明：第1个7设置用户的权限，第2个7设置组的权限，第3个7设置其他所有者的权限。</p>
<p>如果用户想成为唯一可以访问它的人，可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 participants</span><br></pre></td></tr></table></figure>

<p>用户想要为自己和其小组成员提供完全访问权限，可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 770 participants</span><br></pre></td></tr></table></figure>

<p>如果用户想为自己保留完全访问权限，但希望阻止其他人修改文件，可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 participants</span><br></pre></td></tr></table></figure>

<p>以下使用上面的字母来更改文件“participants”的权限，以便所有者可以读取和写入文件，但不会更改其他任何人的权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u&#x3D;rw participants</span><br></pre></td></tr></table></figure>

<p><strong>设置模式</strong> </p>
<p>使用chmod命令可以为文件和目录设置其他文件系统模式。例如，要设置粘滞位 - 这意味着只有文件所有者，目录所有者或超级用户可以删除该文件，而不管文件的读写组权限如何 - 在数字序列前加1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 1755 participants</span><br></pre></td></tr></table></figure>

<p>其他：</p>
<p>用户还可以使用chgrp命令更改现有文件和文件夹的组所有权，使用newgrp命令更改新文件和文件夹的默认组。</p>
<p>请记住，chmod命令中使用的符号链接将影响真实的目标对象。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/26/linux3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/26/linux3/" class="post-title-link" itemprop="url">linux基础（42-59集）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 00:03:11 / Modified: 19:03:49" itemprop="dateCreated datePublished" datetime="2020-04-26T00:03:11-05:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P42远程管理常用命令"><a href="#P42远程管理常用命令" class="headerlink" title="P42远程管理常用命令"></a>P42远程管理常用命令</h2><h3 id="关机重启shutdown"><a href="#关机重启shutdown" class="headerlink" title="关机重启shutdown"></a>关机重启shutdown</h3><p>Linux shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。</p>
<p>使用权限：系统管理者。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown [-t seconds] [-rkhncfF] time [message]</span><br></pre></td></tr></table></figure>

<p>shutdown now 立即关机</p>
<p>shutdown +10 10分钟后关机</p>
<p><strong>参数说明</strong>：</p>
<ul>
<li>-t seconds : 设定在几秒钟之后进行关机程序。</li>
<li>-k : 并不会真的关机，只是将警告讯息传送给所有使用者。</li>
<li>-r : 关机后重新开机。（常用，一定要加，不加会启动不了了）</li>
<li>-h : 关机后停机。</li>
<li>-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。</li>
<li>-c : 取消目前已经进行中的关机动作。（常用，取消之前动作）</li>
<li>-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。</li>
<li>-F : 关机时，强迫进行 fsck 动作。</li>
<li>time : 设定关机的时间。</li>
<li>message : 传送给所有使用者的警告讯息。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>立即关机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># shutdown -h now</span><br></pre></td></tr></table></figure>

<p>指定 10 分钟后关机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># shutdown -h 10</span><br></pre></td></tr></table></figure>

<p>重新启动计算机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># shutdown -r now</span><br></pre></td></tr></table></figure>



<h3 id="查看或配置网卡信息"><a href="#查看或配置网卡信息" class="headerlink" title="查看或配置网卡信息"></a>查看或配置网卡信息</h3><h3 id="Ifconfig"><a href="#Ifconfig" class="headerlink" title="Ifconfig"></a>Ifconfig</h3><p>网卡：一个专门负责网络通讯的硬件设备。</p>
<p>Linux ifconfig命令用于显示或设置网络设备。</p>
<p>ifconfig可设置网络设备的状态，或是显示目前的设置。</p>
<p>ifconfig | grep inet： 查看网卡对应IP地址</p>
<p>ifconfig：查看网卡配置信息</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [网络设备][down up -allmulti -arp -promisc][add&lt;地址&gt;][del&lt;地址&gt;][&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;][io_addr&lt;I&#x2F;O地址&gt;][irq&lt;IRQ地址&gt;][media&lt;网络媒介类型&gt;][mem_start&lt;内存地址&gt;][metric&lt;数目&gt;][mtu&lt;字节&gt;][netmask&lt;子网掩码&gt;][tunnel&lt;地址&gt;][-broadcast&lt;地址&gt;][-pointopoint&lt;地址&gt;][IP地址]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>add&lt;地址&gt; 设置网络设备IPv6的IP地址。</li>
<li>del&lt;地址&gt; 删除网络设备IPv6的IP地址。</li>
<li>down 关闭指定的网络设备。</li>
<li>&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt; 设置网络设备的类型与硬件地址。</li>
<li>io_addr&lt;I/O地址&gt; 设置网络设备的I/O地址。</li>
<li>irq&lt;IRQ地址&gt; 设置网络设备的IRQ。</li>
<li>media&lt;网络媒介类型&gt; 设置网络设备的媒介类型。</li>
<li>mem_start&lt;内存地址&gt; 设置网络设备在主内存所占用的起始地址。</li>
<li>metric&lt;数目&gt; 指定在计算数据包的转送次数时，所要加上的数目。</li>
<li>mtu&lt;字节&gt; 设置网络设备的MTU。</li>
<li>netmask&lt;子网掩码&gt; 设置网络设备的子网掩码。</li>
<li>tunnel&lt;地址&gt; 建立IPv4与IPv6之间的隧道通信地址。</li>
<li>up 启动指定的网络设备。</li>
<li>-broadcast&lt;地址&gt; 将要送往指定地址的数据包当成广播数据包来处理。</li>
<li>-pointopoint&lt;地址&gt; 与指定地址的网络设备建立直接连线，此模式具有保密功能。</li>
<li>-promisc 关闭或启动指定网络设备的promiscuous模式。</li>
<li>[IP地址] 指定网络设备的IP地址。</li>
<li>[网络设备] 指定网络设备的名称。</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>显示网络设备信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig        </span><br><span class="line">eth0   Link encap:Ethernet HWaddr 00:50:56:0A:0B:0C </span><br><span class="line">     inet addr:192.168.0.3 Bcast:192.168.0.255 Mask:255.255.255.0</span><br><span class="line">     inet6 addr: fe80::250:56ff:fe0a:b0c&#x2F;64 Scope:Link</span><br><span class="line">     UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</span><br><span class="line">     RX packets:172220 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">     TX packets:132379 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">     collisions:0 txqueuelen:1000 </span><br><span class="line">     RX bytes:87101880 (83.0 MiB) TX bytes:41576123 (39.6 MiB)</span><br><span class="line">     Interrupt:185 Base address:0x2024 </span><br><span class="line"></span><br><span class="line">lo    Link encap:Local Loopback </span><br><span class="line">     inet addr:127.0.0.1 Mask:255.0.0.0</span><br><span class="line">     inet6 addr: ::1&#x2F;128 Scope:Host</span><br><span class="line">     UP LOOPBACK RUNNING MTU:16436 Metric:1</span><br><span class="line">     RX packets:2022 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">     TX packets:2022 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">     collisions:0 txqueuelen:0 </span><br><span class="line">     RX bytes:2459063 (2.3 MiB) TX bytes:2459063 (2.3 MiB)</span><br></pre></td></tr></table></figure>

<p>启动关闭指定网卡</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 down</span><br><span class="line"># ifconfig eth0 up</span><br></pre></td></tr></table></figure>

<p>为网卡配置和删除IPv6地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 add 33ffe:3240:800:1005::2&#x2F; 64 &#x2F;&#x2F;为网卡诶之IPv6地址</span><br><span class="line"></span><br><span class="line"># ifconfig eth0 del 33ffe:3240:800:1005::2&#x2F; 64 &#x2F;&#x2F;为网卡删除IPv6地址</span><br></pre></td></tr></table></figure>

<p>用ifconfig修改MAC地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 down &#x2F;&#x2F;关闭网卡</span><br><span class="line"># ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE &#x2F;&#x2F;修改MAC地址</span><br><span class="line"># ifconfig eth0 up &#x2F;&#x2F;启动网卡</span><br><span class="line"># ifconfig eth1 hw ether 00:1D:1C:1D:1E &#x2F;&#x2F;关闭网卡并修改MAC地址 </span><br><span class="line"># ifconfig eth1 up &#x2F;&#x2F;启动网卡</span><br></pre></td></tr></table></figure>

<p>配置IP地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 192.168.1.56 </span><br><span class="line">&#x2F;&#x2F;给eth0网卡配置IP地址</span><br><span class="line"># ifconfig eth0 192.168.1.56 netmask 255.255.255.0 </span><br><span class="line">&#x2F;&#x2F; 给eth0网卡配置IP地址,并加上子掩码</span><br><span class="line"># ifconfig eth0 192.168.1.56 netmask 255.255.255.0 broadcast 192.168.1.255</span><br><span class="line">&#x2F;&#x2F; 给eth0网卡配置IP地址,加上子掩码,加上个广播地址</span><br></pre></td></tr></table></figure>

<p>启用和关闭ARP协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 arp  &#x2F;&#x2F;开启</span><br><span class="line"># ifconfig eth0 -arp  &#x2F;&#x2F;关闭</span><br></pre></td></tr></table></figure>

<p>设置最大传输单元</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 mtu 1500 </span><br><span class="line">&#x2F;&#x2F;设置能通过的最大数据包大小为 1500 bytes</span><br></pre></td></tr></table></figure>

<h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h3><p>ping ip地址：检查目标主机连接是否正常</p>
<p>ping 本地ip：检查本地ip是否正常。（一般127.0.0.1是本地回环地址，用了检查本机网卡是否正常，localhost）</p>
<p>ping用来检查计算机间网络是否通畅，数值越大，速度越慢，ping一下计算机看是否开着</p>
<p>Linux ping命令用于检测主机。</p>
<p>执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [-dfnqrRv][-c&lt;完成次数&gt;][-i&lt;间隔秒数&gt;][-I&lt;网络界面&gt;][-l&lt;前置载入&gt;][-p&lt;范本样式&gt;][-s&lt;数据包大小&gt;][-t&lt;存活数值&gt;][主机名称或IP地址]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-d 使用Socket的SO_DEBUG功能。</li>
<li>-c&lt;完成次数&gt; 设置完成要求回应的次数。</li>
<li>-f 极限检测。</li>
<li>-i&lt;间隔秒数&gt; 指定收发信息的间隔时间。</li>
<li>-I&lt;网络界面&gt; 使用指定的网络接口送出数据包。</li>
<li>-l&lt;前置载入&gt; 设置在送出要求信息之前，先行发出的数据包。</li>
<li>-n 只输出数值。</li>
<li>-p&lt;范本样式&gt; 设置填满数据包的范本样式。</li>
<li>-q 不显示指令执行过程，开头和结尾的相关信息除外。</li>
<li>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。</li>
<li>-R 记录路由过程。</li>
<li>-s&lt;数据包大小&gt; 设置数据包的大小。</li>
<li>-t&lt;存活数值&gt; 设置存活数值TTL的大小。</li>
<li>-v 详细显示指令的执行过程。</li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>检测是否与主机连通</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># ping www.w3cschool.cc &#x2F;&#x2F;ping主机</span><br><span class="line">PING aries.m.alikunlun.com (114.80.174.110) 56(84) bytes of data.</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.025 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.036 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.034 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.034 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;5 ttl&#x3D;64 time&#x3D;0.028 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;6 ttl&#x3D;64 time&#x3D;0.028 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;7 ttl&#x3D;64 time&#x3D;0.034 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;8 ttl&#x3D;64 time&#x3D;0.034 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;9 ttl&#x3D;64 time&#x3D;0.036 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;10 ttl&#x3D;64 time&#x3D;0.041 ms</span><br><span class="line"></span><br><span class="line">--- aries.m.alikunlun.com ping statistics ---</span><br><span class="line">10 packets transmitted, 30 received, 0% packet loss, time 29246ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.021&#x2F;0.035&#x2F;0.078&#x2F;0.011 ms</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;需要手动终止Ctrl+C</span><br></pre></td></tr></table></figure>

<p>指定接收包的次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ping -c 2 www.w3cschool.cc</span><br><span class="line">PING aries.m.alikunlun.com (114.80.174.120) 56(84) bytes of data.</span><br><span class="line">64 bytes from 114.80.174.120: icmp_seq&#x3D;1 ttl&#x3D;54 time&#x3D;6.18 ms</span><br><span class="line">64 bytes from 114.80.174.120: icmp_seq&#x3D;2 ttl&#x3D;54 time&#x3D;15.4 ms</span><br><span class="line"></span><br><span class="line">--- aries.m.alikunlun.com ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1016ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 6.185&#x2F;10.824&#x2F;15.464&#x2F;4.640 ms</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;收到两次包后，自动退出</span><br></pre></td></tr></table></figure>

<p>多参数使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ping -i 3 -s 1024 -t 255 g.cn &#x2F;&#x2F;ping主机</span><br><span class="line">PING g.cn (203.208.37.104) 1024(1052) bytes of data.</span><br><span class="line">1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq&#x3D;0 ttl&#x3D;243 time&#x3D;62.5 ms</span><br><span class="line">1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq&#x3D;1 ttl&#x3D;243 time&#x3D;63.9 ms</span><br><span class="line">1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq&#x3D;2 ttl&#x3D;243 time&#x3D;61.9 ms</span><br><span class="line"></span><br><span class="line">--- g.cn ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 6001ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 61.959&#x2F;62.843&#x2F;63.984&#x2F;0.894 ms, pipe 2</span><br><span class="line">[root@linux ~]# </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-i 3 发送周期为 3秒 -s 设置发送包的大小 -t 设置TTL值为 255</span><br></pre></td></tr></table></figure>

<h2 id="P47-52远程登录和复制文件（ssh）"><a href="#P47-52远程登录和复制文件（ssh）" class="headerlink" title="P47-52远程登录和复制文件（ssh）"></a>P47-52远程登录和复制文件（ssh）</h2><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh:"></a>ssh:</h3><p>Security shell, 数据传输加密，压缩</p>
<p>ssh [-p port] user@remote</p>
<p>user是远程机器上的用户名，如果不指定的话默认当前用户。</p>
<p>remote是远程机器的地址，可以是ip/域名，或者是后面会提到的别名。</p>
<p>port是ssh server的监听端口， 如果不指定，默认22.</p>
<p>windows下载：putty和xshell</p>
<p>使用exit退出用户登录</p>
<p><strong>ip：ip是是分配给网络上使用IP协议的设备的数字标签。</strong>我们现在经常使用的是 ipv4， 由32位二进制数字组成，常以XXX.XXX.XXX.XXX形式表现。</p>
<p><strong>域名：是由一串用“点”分隔的字符组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。</strong>如 i.cnblogs.com。</p>
<p>域名按域名系统（DNS）的规则流程组成。在DNS中注册的任何名称都是域名。域名用于各种网络环境和应用程序特定的命名和寻址目的。</p>
<p>域名和ip有区别也有联系，域名通常都会和IP绑定起来，通过访问域名来访问网络主机上的服务。ip地址通常是指主机，而域名通常表示一个网站。一个域名可以绑定到多个ip，多个域名也可以绑定到一个ip。</p>
<p><strong>域名系统（DNS）：因特网上作为域名和ip地址相互映射的分布式数据库，能使用户更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址。通过主机名，最终得到该主机名对应的ip地址的过程叫做域名解析。 DNS协议运行在UDP协议之上，端口号53。</strong></p>
<p><strong>端口号：端口，（英语：port），主要分为物理端口和逻辑端口。</strong>我们一般说的都是逻辑端口，用于区分不同的服务。因为网络中一台主机只有一个IP，但是一个主机可以提供多个服务，端口号就用于区分一个主机上的不同服务。一个IP地址的端口通过16bit进行编号，最多可以有65536个端口，标识是从0<del>65535。**端口号分为公认端口（0</del>1023）、注册端口（1024<del>49151）和动态端口（49152</del>65535）。**我们自己的服务一般都绑定在注册端口上。</p>
<p><strong>跨域：</strong>在 HTML 中，<code>,</code>, <code>,</code>, <code>,</code> 等标签以及 Ajax 都可以指向一个资源地址，<strong>而所谓的跨域请求就是指</strong>：当前发起请求的域与该请求指向的资源所在的域不一样。<strong>这里的域指的是这样的一个概念：我们认为若协议 + 域名 + 端口号均相同，那么就是同域。</strong></p>
<h3 id="常见的端口号及其用途"><a href="#常见的端口号及其用途" class="headerlink" title="常见的端口号及其用途"></a><a href="https://www.cnblogs.com/innershare/p/10749981.html" target="_blank" rel="noopener">常见的端口号及其用途</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">一些常见的端口号及其用途如下：</span><br><span class="line">21端口：FTP 文件传输服务（常用）</span><br><span class="line">22端口：SSH 端口（常用）</span><br><span class="line">23端口：TELNET 终端仿真服务</span><br><span class="line">25端口：SMTP 简单邮件传输服务</span><br><span class="line">53端口：DNS 域名解析服务</span><br><span class="line">80端口：HTTP 超文本传输服务，web端口（常用）</span><br><span class="line">110端口：POP3 “邮局协议版本3”使用的端口</span><br><span class="line">443端口：HTTPS 加密的超文本传输服务（常用）</span><br><span class="line">1433端口：MS SQL*SERVER数据库 默认端口号</span><br><span class="line">1521端口：Oracle数据库服务</span><br><span class="line">1863端口：MSN Messenger的文件传输功能所使用的端口</span><br><span class="line">3306端口：MYSQL 默认端口号（常用）</span><br><span class="line">3389端口：Microsoft RDP 微软远程桌面使用的端口</span><br><span class="line">5631端口：Symantec pcAnywhere 远程控制数据传输时使用的端口</span><br><span class="line">5632端口：Symantec pcAnywhere 主控端扫描被控端时使用的端口</span><br><span class="line">5000端口：MS SQL Server使用的端口</span><br><span class="line">8000端口：腾讯QQ</span><br></pre></td></tr></table></figure>

<p>   SSH(远程连接工具)连接原理：ssh服务是一个守护进程(demon)，系统后台监听客户端的连接，ssh服务端的进程名为sshd,负责实时监听客户端的请求(IP 22端口)，包括公共秘钥等交换等信息。</p>
<p>ssh服务端由2部分组成： openssh(提供ssh服务)  openssl(提供加密的程序)</p>
<p>ssh的客户端可以用 XSHELL，Securecrt, Mobaxterm等工具进行连接</p>
<h3 id="SSH的工作机制"><a href="#SSH的工作机制" class="headerlink" title="SSH的工作机制"></a>SSH的工作机制</h3><p>   服务器启动的时候自己产生一个密钥(768bit公钥)，本地的ssh客户端发送连接请求到ssh服务器，服务器检查连接点客户端发送的数据和IP地址，确认合法后发送密钥(768bits)给客户端，此时客户端将本地私钥(256bit)和服务器的公钥(768bit)结合成密钥对key(1024bit),发回给服务器端，建立连接通过key-pair数据传输。    </p>
<h3 id="SSH的加密技术"><a href="#SSH的加密技术" class="headerlink" title="SSH的加密技术"></a>SSH的加密技术</h3><p>加密技术：传输过程，数据加密。<br>1.SSH1没有对客户端的秘钥进行校验，很容易被植入恶意代码<br>2.SSH2增加了一个确认联机正确性的Diffe_Hellman机制，每次数据的传输，Server都会检查数据来源的正确性，避免黑客入侵。<br> SSH2支持RSA和DSA密钥<br>    DSA:digital signature Algorithm 数字签名<br>    RSA:既可以数字签名又可以加密    </p>
<h3 id="SSH知识小结"><a href="#SSH知识小结" class="headerlink" title="SSH知识小结"></a>SSH知识小结</h3><p>  1.SSH是安全的加密协议，用于远程连接Linux服务器<br>  2.SSH的默认端口是22，安全协议版本是SSH2<br>  3.SSH服务器端主要包含2个服务功能SSH连接和SFTP服务器<br>  4.SSH客户端包含ssh连接命令和远程拷贝scp命令等 </p>
<h3 id="如何防止SSH登录入侵"><a href="#如何防止SSH登录入侵" class="headerlink" title="如何防止SSH登录入侵"></a>如何防止SSH登录入侵</h3><p>  1.密钥登录,更改端口<br>  2.牤牛阵法<br>  3.监听本地内网IP(ListenAddress 192.168.25.*)</p>
<h3 id="SSH功能大全"><a href="#SSH功能大全" class="headerlink" title="SSH功能大全"></a>SSH功能大全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.登录          &#96;&#96;    &#96;&#96;ssh&#96; &#96;-p22 omd@192.168.25.137        &#96;&#96;  &#96;&#96;2.直接执行命令 --&gt;最好全路径          &#96;&#96;    &#96;&#96;ssh&#96; &#96;root@192.168.25.137 &#96;&#96;ls&#96; &#96;-ltr &#96;&#96;&#x2F;backup&#x2F;data&#96;            &#96;      &#96;&#96;&#x3D;&#x3D;&gt;&#96;&#96;ssh&#96; &#96;root@192.168.25.137 &#96;&#96;&#x2F;bin&#x2F;ls&#96; &#96;-ltr &#96;&#96;&#x2F;backup&#x2F;data&#96;        &#96;  &#96;&#96;3.查看已知主机           &#96;&#96;    &#96;&#96;cat&#96; &#96;&#x2F;root&#x2F;&#96;&#96;.&#96;&#96;ssh&#96;&#96;&#x2F;known_hosts&#96;&#96;  &#96;&#96;4.&#96;&#96;ssh&#96;&#96;远程执行&#96;&#96;sudo&#96;&#96;命令&#96;&#96;    &#96;&#96;ssh&#96; &#96;-t omd@192.168.25.137 &#96;&#96;sudo&#96; &#96;rsync&#96; &#96;hosts &#96;&#96;&#x2F;etc&#x2F;&#96; &#96;  &#96;&#96;5.&#96;&#96;scp&#96;        &#96;       &#96;&#96;1.功能  --&gt;远程文件的安全(加密)拷贝          &#96;&#96;         &#96;&#96;scp&#96; &#96;-P22 -r -p &#96;&#96;&#x2F;home&#x2F;omd&#x2F;h&#96;&#96;.txt omd@192.168.25.137:&#96;&#96;&#x2F;home&#x2F;omd&#x2F;&#96;        &#96;       &#96;&#96;2.&#96;&#96;scp&#96;&#96;知识小结          &#96;&#96;         &#96;&#96;scp&#96;&#96;是加密远程拷贝，&#96;&#96;cp&#96;&#96;为本地拷贝          &#96;&#96;         &#96;&#96;可以推送过去，也可以拉过来          &#96;&#96;         &#96;&#96;每次都是全量拷贝(效率不高，适合第一次)，增量拷贝用&#96;&#96;rsync&#96; &#96;  &#96;&#96;6.&#96;&#96;ssh&#96;&#96;自带的&#96;&#96;sftp&#96;&#96;功能        &#96;&#96;       &#96;&#96;1.Window和Linux的传输工具          &#96;&#96;         &#96;&#96;wincp  filezip          &#96;&#96;        &#96;&#96;sftp&#96; &#96;--&gt;基于&#96;&#96;ssh&#96;&#96;的安全加密传输          &#96;&#96;        &#96;&#96;samba  &#96;&#96;       &#96;&#96;2.&#96;&#96;sftp&#96;&#96;客户端连接          &#96;&#96;        &#96;&#96;sftp&#96; &#96;-oPort&#x3D;22 root@192.168.25.137          &#96;&#96;        &#96;&#96;put &#96;&#96;&#x2F;etc&#x2F;hosts&#96; &#96;&#x2F;tmp&#96;          &#96;        &#96;&#96;get &#96;&#96;&#x2F;etc&#x2F;hosts&#96; &#96;&#x2F;home&#x2F;omd&#96;  &#96;      &#96;&#96;3.&#96;&#96;sftp&#96;&#96;小结：          &#96;&#96;        &#96;&#96;1.linux下使用命令： &#96;&#96;sftp&#96; &#96;-oPort&#x3D;22 root@x.x.x.x          &#96;&#96;        &#96;&#96;2.put加客户端本地路径上传          &#96;&#96;        &#96;&#96;3.get下载服务器端内容到本地          &#96;&#96;        &#96;&#96;4.远程连接默认连接用户的家目录</span><br></pre></td></tr></table></figure>

<h3 id="ssh常见命令参数"><a href="#ssh常见命令参数" class="headerlink" title="ssh常见命令参数"></a>ssh常见命令参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usage: &#96;&#96;ssh&#96; &#96;[-1246AaCfgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]&#96;&#96;      &#96;&#96;[-D [bind_address:]port] [-e escape_char] [-F configfile]&#96;&#96;      &#96;&#96;[-i identity_file] [-L [bind_address:]port:host:hostport]&#96;&#96;      &#96;&#96;[-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]&#96;&#96;      &#96;&#96;[-R [bind_address:]port:host:hostport] [-S ctl_path]&#96;&#96;      &#96;&#96;[-W host:port] [-w local_tun[:remote_tun]]&#96;&#96;      &#96;&#96;[user@]&#96;&#96;hostname&#96; &#96;[&#96;&#96;command&#96;&#96;]</span><br></pre></td></tr></table></figure>

<h3 id="关于后台ssh服务的相关"><a href="#关于后台ssh服务的相关" class="headerlink" title="关于后台ssh服务的相关"></a>关于后台ssh服务的相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 查询openssl软件&#96;&#96;  &#96;&#96;rpm -qa openssh openssl&#96;&#96;# 查询sshd进程&#96;&#96;  &#96;&#96;ps&#96; &#96;-ef | &#96;&#96;grep&#96; &#96;ssh&#96;&#96;    &#96;&#96;--&gt; &#96;&#96;&#x2F;usr&#x2F;sbin&#x2F;sshd&#96;&#96;# 查看ssh端口&#96;&#96;  &#96;&#96;netstat&#96; &#96;-lntup | &#96;&#96;grep&#96; &#96;ssh&#96; &#96;  &#96;&#96;ss | &#96;&#96;grep&#96; &#96;ssh&#96;        &#96;(效果同上，同下，好用)&#96;&#96;  &#96;&#96;netstat&#96; &#96;-a | &#96;&#96;grep&#96; &#96;ssh&#96;&#96;(记住这个)&#96;&#96;  &#96;&#96;netstat&#96; &#96;-lnt | &#96;&#96;grep&#96; &#96;22  &#x3D;&#x3D;&gt; 查看22端口有没有开&#96;&#96;&#x2F;ssh&#96;&#96;服务有没有开启&#96;&#96;  &#96;&#96;技巧： &#96;&#96;netstat&#96; &#96;-lnt | &#96;&#96;grep&#96; &#96;ssh&#96; &#96;| &#96;&#96;wc&#96; &#96;-l --&gt;只要大于2个就是&#96;&#96;ssh&#96;&#96;服务就是好的&#96;&#96;# 查看ssh的秘钥目录&#96;&#96;  &#96;&#96;ll &#96;&#96;&#x2F;root&#x2F;&#96;&#96;.&#96;&#96;ssh&#96;&#96;&#x2F;known_hosts&#96; &#96;# 当前用户家目录的.ssh目录下&#96;&#96;# ssh的配置文件&#96;&#96;  &#96;&#96;cat&#96; &#96;&#x2F;etc&#x2F;ssh&#x2F;sshd_config&#96;  &#96;# ssh服务的关闭&#96;&#96;  &#96;&#96;service sshd stop&#96;&#96;# ssh服务的开启：&#96;&#96;  &#96;&#96;service sshd start&#96;&#96;# ssh服务的重启&#96;&#96;  &#96;&#96;service sshd reload  [停止进程后重启] &#x3D;&#x3D;&gt; 推荐&#96;&#96;  &#96;&#96;service sshd restart  [干掉进程后重启] &#x3D;&#x3D;&gt; 不推荐&#96;&#96;# ssh远程登录&#96;&#96;  &#96;&#96;ssh&#96; &#96;192.168.1.100   &#96;&#96;# 默认利用当前宿主用户的用户名登录&#96;&#96;  &#96;&#96;ssh&#96; &#96;omd@192.168.1.100 &#96;&#96;# 利用远程机的用户登录&#96;&#96;  &#96;&#96;ssh&#96; &#96;omd@192.168.1.100 -o stricthostkeychecking&#x3D;no &#96;&#96;# 首次登陆免输yes登录&#96;&#96;  &#96;&#96;ssh&#96; &#96;omd@192.168.1.100 &#96;&#96;&quot;ls &#x2F;home&#x2F;omd&quot;&#96; &#96;# 当前服务器A远程登录服务器B后执行某个命令&#96;&#96;  &#96;&#96;ssh&#96; &#96;omd@192.168.1.100 -t &#96;&#96;&quot;sh &#x2F;home&#x2F;omd&#x2F;ftl.sh&quot;&#96; &#96;# 当前服务器A远程登录服务器B后执行某个脚本</span><br></pre></td></tr></table></figure>



<p><a href="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235424314-1763487959.png" target="_blank" rel="noopener"><img src="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235425105-243399260.png" alt="image"></a></p>
<h3 id="ssh免密设置"><a href="#ssh免密设置" class="headerlink" title="ssh免密设置"></a>ssh免密设置</h3><p>1、进入用户的家目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]&#96;&#96;# cd &#x2F;root&#x2F;.ssh&#x2F;       【root用户就在root目录下的.ssh目录】&#96;&#96;[root@localhost ~]&#96;&#96;# cd &#x2F;home&#x2F;omd&#x2F;.ssh&#x2F;  【普通用户就是在家目录下的.ssh目录】</span><br></pre></td></tr></table></figure>

<p><a href="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235425480-983102625.png" target="_blank" rel="noopener"><img src="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235425878-2009080640.png" alt="image"></a></p>
<p>2、根据DSA算法生成私钥和公钥【默认建立在当前用户的家目录】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost .&#96;&#96;ssh&#96;&#96;]&#96;&#96;# ssh-keygen -t dsa   # 一路回车即可&#96;&#96;        &#96;&#96;id_dsa     --&gt;私钥(钥匙) &#96;&#96;        &#96;&#96;id_dsa.pub   --&gt;公钥(锁)</span><br></pre></td></tr></table></figure>

<p><a href="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235426240-141091905.png" target="_blank" rel="noopener"><img src="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235426686-779103595.png" alt="image"></a></p>
<p>3.拷贝公钥给目标服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost .&#96;&#96;ssh&#96;&#96;]&#96;&#96;# ssh-copy-id -i id_dsa.pub omd@192.168.25.110       【 使用ssh登录的默认端口22】&#96;&#96;[root@localhost .&#96;&#96;ssh&#96;&#96;]&#96;&#96;# ssh-copy-id -i id_dsa.pub –p 666 omd@192.168.25.120  【使用ssh登录设置的端口666】</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/519608/201808/519608-20180812120135470-239324972.png" alt="img"></p>
<p>\4. 查看目标服务器生成的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[omd@localhost .&#96;&#96;ssh&#96;&#96;]$ ll &#96;&#96;&#x2F;home&#x2F;omd&#x2F;&#96;&#96;.&#96;&#96;ssh&#96;&#96;&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>

<p><a href="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235427845-1655006958.png" target="_blank" rel="noopener"><img src="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235428167-614741798.png" alt="image"></a></p>
<p>\5. 免密码登录目标服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh&#96; &#96;omd@192.168.25.110</span><br></pre></td></tr></table></figure>

<p>\6. 总结一下钥匙和锁的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.多个钥匙开一把锁&#96;&#96;   &#96;&#96;把id_dsa.pub 复制给各个服务器&#96; &#96;2.一个钥匙开duobasuo&#96;&#96;   &#96;&#96;把id_dsa 传给各个服务器&#96;&#96;   &#96;&#96;把id_dsa 传给自己</span><br></pre></td></tr></table></figure>

<h3 id="ssh排查问题"><a href="#ssh排查问题" class="headerlink" title="ssh排查问题"></a>ssh排查问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.判断物理链路是否通 &#96;&#96;ping&#96; &#96;192.168.25.130   线路 | 防火墙 | 是否同一个网的&#96;&#96;      &#96;&#96;ping&#96;  &#96;本身是icmp协议&#96;&#96;2.判断服务是否正常</span><br><span class="line">telnet 192.168.25.130 22</span><br><span class="line">3.Linux防火墙</span><br><span class="line">service iptables status &#x3D;&#x3D;&gt; &#96;&#96;&#x2F;etc&#x2F;init&#96;&#96;.d&#96;&#96;&#x2F;iptables&#96; &#96;status　　</span><br><span class="line">4.打开&#96;&#96;ssh&#96;&#96;的调测进行观察</span><br><span class="line">ssh&#96; &#96;-vvv omd@192.168.1.100</span><br></pre></td></tr></table></figure>

<h3 id="SSH批量分发与管理方案小结"><a href="#SSH批量分发与管理方案小结" class="headerlink" title="SSH批量分发与管理方案小结"></a>SSH批量分发与管理方案小结</h3><p>1.利用root做ssh key验证</p>
<blockquote>
<p>优点：简单，易用<br>  缺点：安全性能差，无法禁止root远程连接</p>
</blockquote>
<p>2.利用普通用户omd        –&gt;推荐</p>
<blockquote>
<p>  思路：把要分发的文件拷贝到服务器用户的家目录，然后利用sudo提权拷贝分发的文件和对应目录<br>  优点：安全<br>  缺点：复杂，配置麻烦<br>  1.sudo提权<br>    echo ‘omd   All=(All)   NOPASSWD:/usr/bin/rsync’ &gt;&gt; /etc/sudoers<br>    visudo -c<br>    grep omd /etc/sudoers<br>  2.ssh分发到服务器的家目录<br>    ssh -p22 -r /etc/hosts <a href="mailto:omd@192.168.25.137">omd@192.168.25.137</a>:~<br>  3.ssh使用sudo复制到目标服务器的/etc<br>    ssh -t <a href="mailto:omd@192.168.25.137">omd@192.168.25.137</a> sudo rsync hosts /etc/</p>
</blockquote>
<p>3.拓展方案2，不用sudo，而是设置suid对固定命令提权</p>
<blockquote>
<p> 优点：相当安全<br>    缺点：复杂，安全性较差，任何人都可以处理带有suid权限的命令<br>    1.which rsync<br>    2.chmod 4755 /usr/bin/rsync    </p>
</blockquote>
<h3 id="ssh章节小结"><a href="#ssh章节小结" class="headerlink" title="ssh章节小结"></a>ssh章节小结</h3><p>  1.ssh远程的加密连接协议，相关软件openssh,openssl<br>  2.默认端口22<br>  3.ssh版本协议<br>  4.服务器ssh连接，ftp连接，sshd守护进程，开机启动<br>  5.ssh客户端重要命令：ssh(用户登录&amp;&amp;远程命令),scp,sftp,<br>  6.安全验证方式：口令，密钥 学习原理<br>  7.ssh服务优化：改端口，改监听，no root,no empty,no DNS,<br>  8.ssh密钥对，公钥在服务器端，私钥在客户端</p>
<h3 id="修改ssh服务的启动文件sshd的几个点"><a href="#修改ssh服务的启动文件sshd的几个点" class="headerlink" title="修改ssh服务的启动文件sshd的几个点"></a>修改ssh服务的启动文件sshd的几个点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-1修改 &#96;&#96;&#x2F;etc&#x2F;ssh&#x2F;sshd_config&#96;&#96;     GSSAPIAuthentication &#96;&#96;yes&#96;  &#96;解决一台服务器管理多个&#96;&#96;ssh&#96;&#96;服务&#96;&#96;  &#96;&#96;UseDNS no 加快响应速度因为在内网环境下&#96;&#96;  &#96;&#96;PermitRootLogin no 不运行root用户直接登录&#96;&#96;  &#96;&#96;Port 11544 更改访问端口号&#96;&#96;  &#96;&#96;ListenAddress 192.168.25.130 只监听内网的IP&#96;&#96;  &#96;&#96;Match User anoncvs   当前环境允许登录的用户&#96;&#96;  &#96;&#96;PermitRootLogin no   是否允许root用户登录，一般不允许开&#96;&#96;1-2重启服务&#96;&#96;  &#96;&#96;service sshd restart    写入命令进内存&#96;&#96;  &#96;&#96;service sshd reload(优先) reload是一个平滑的访问，不影响用户使用&#96;&#96;1-3查看连接端口&#96;&#96;  &#96;&#96;netstat&#96; &#96;-an | &#96;&#96;grep&#96; &#96;EST</span><br></pre></td></tr></table></figure>

<h3 id="SSH跳过HostKeyChecking，不用输入yes"><a href="#SSH跳过HostKeyChecking，不用输入yes" class="headerlink" title="SSH跳过HostKeyChecking，不用输入yes"></a><strong>SSH跳过</strong>HostKeyChecking，不用输入yes</h3><p>SSH跳过输入ssh跳过RSA key fingerprint输入yes/no</p>
<p>在配置大量的节点之间需要ssh连通的时候，如果自动复制很多节点，都需要输入yes，两两节点之间都要互通一次，这样会造成很大的麻烦</p>
<p><strong>解决1；</strong>修改配置文件/etc/ssh/ssh_config</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找 到 # StrictHostKeyChecking ask &#96;&#96;修改为：StrictHostKeyChecking &#96;&#96;no</span><br></pre></td></tr></table></figure>

<p><strong>解决2：</strong> 添加参数 –o 【o=option】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.25.133 -o &#96;&#96;&quot;StrictHostKeyChecking no&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/519608/201808/519608-20180811164712431-1409487808.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -o &#96;&#96;&quot;StrictHostKeyChecking no&quot;&#96; &#96;newfile.txt &#96;&quot;mailto:root@192.168.25.133:&#x2F;root&quot;&#96;&#96;&gt;root@192.168.25.133:&#x2F;root</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/519608/201808/519608-20180811164724290-117606623.png" alt="img"></p>
<h2 id="P53-55远程登录和复制文件（scp）"><a href="#P53-55远程登录和复制文件（scp）" class="headerlink" title="P53-55远程登录和复制文件（scp）"></a>P53-55远程登录和复制文件（scp）</h2><p>scp：secure copy </p>
<p>指定端口-P port：注意是大写的P, port是指定数据传输用到的端口号（常用）</p>
<p>Linux scp 命令用于 Linux 之间复制文件和目录。</p>
<p>scp 是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。</p>
<p>scp 是加密的，<a href="https://www.runoob.com/linux/linux-comm-rcp.html" target="_blank" rel="noopener">rcp</a> 是不加密的，scp 是 rcp 的加强版。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]</span><br><span class="line">[-l limit] [-o ssh_option] [-P port] [-S program]</span><br><span class="line">[[user@]host1:]file1 [...] [[user@]host2:]file2</span><br></pre></td></tr></table></figure>

<p>简易写法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [可选参数] file_source file_target</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li>-1： 强制scp命令使用协议ssh1</li>
<li>-2： 强制scp命令使用协议ssh2</li>
<li>-4： 强制scp命令只使用IPv4寻址</li>
<li>-6： 强制scp命令只使用IPv6寻址</li>
<li>-B： 使用批处理模式（传输过程中不询问传输口令或短语）</li>
<li>-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li>
<li>-p：保留原文件的修改时间，访问时间和访问权限。</li>
<li>-q： 不显示传输进度条。</li>
<li>-r： 递归复制整个目录。(常用)</li>
<li>-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li>
<li>-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li>
<li>-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li>
<li>-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li>
<li>-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。</li>
<li>-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，</li>
<li>-P port：注意是大写的P, port是指定数据传输用到的端口号（常用）</li>
<li>-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li>
</ul>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><h4 id="1、从本地复制到远程"><a href="#1、从本地复制到远程" class="headerlink" title="1、从本地复制到远程"></a>1、从本地复制到远程</h4><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_username@remote_ip:remote_file </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_ip:remote_file</span><br></pre></td></tr></table></figure>



<ul>
<li>第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名； </li>
<li>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；</li>
</ul>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3 </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3</span><br></pre></td></tr></table></figure>

<p>复制目录命令格式： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp -r local_folder remote_ip:remote_folder</span><br></pre></td></tr></table></figure>

<ul>
<li>第1个指定了用户名，命令执行后需要再输入密码；</li>
<li>第2个没有指定用户名，命令执行后需要输入用户名和密码；</li>
</ul>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; </span><br><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;</span><br></pre></td></tr></table></figure>

<p>上面命令将本地 music 目录复制到远程 others 目录下。</p>
<h4 id="2、从远程复制到本地"><a href="#2、从远程复制到本地" class="headerlink" title="2、从远程复制到本地"></a>2、从远程复制到本地</h4><p>从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例 </p>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 </span><br><span class="line">scp -r www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; &#x2F;home&#x2F;space&#x2F;music&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>1.如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#scp 命令使用端口号 4588</span><br><span class="line">scp -P 4588 remote@www.runoob.com:&#x2F;usr&#x2F;local&#x2F;sin.sh &#x2F;home&#x2F;administrator</span><br></pre></td></tr></table></figure>

<p>2.使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。</p>
<h2 id="（scp-remote-to-local）："><a href="#（scp-remote-to-local）：" class="headerlink" title="（scp remote to local）："></a>（scp remote to local）：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r XXX@atlas.cselabs.umn.edu:~&#x2F;Desktop&#x2F;p3-code ~&#x2F;Desktop：</span><br></pre></td></tr></table></figure>



<h2 id="（scp-local-to-remote）"><a href="#（scp-local-to-remote）" class="headerlink" title="（scp local to remote）:"></a>（scp local to remote）:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r  ~&#x2F;Desktop&#x2F;C++CODE xxx@ipaddress: ~&#x2F;Desktop</span><br></pre></td></tr></table></figure>

<p>df -h:查看磁盘容量</p>
<p>Windows没有scp命令，需要安装PuTTy，用pscp命令或者安装FileZilla使用FTP进行文件传输。</p>
<h2 id="P56-59（ssh高级）"><a href="#P56-59（ssh高级）" class="headerlink" title="P56-59（ssh高级）"></a>P56-59（ssh高级）</h2><h3 id="免密码登录和配置别名"><a href="#免密码登录和配置别名" class="headerlink" title="免密码登录和配置别名"></a>免密码登录和配置别名</h3><p>ssh配置都在用户家目录下的.ssh目录下</p>
<p>ls -alh, 找到.ssh隐藏文件，如何cd进入，然后ls -alh看known_hosts，可以看到已经有的连接。</p>
<h3 id="免密码登录："><a href="#免密码登录：" class="headerlink" title="免密码登录："></a>免密码登录：</h3><p>步骤：1. 配置公钥: ssh-keygen即可生成ssh钥匙，一路回车即可</p>
<p>​            2.上传公钥到服务器：ssh-copy-id -p port user@remote, 可以让服务器记住公钥。</p>
<p>ssh是什么？ssh (SSH client) is a program for logging into a remote machine and for executing commands on a remote machine. （自己翻译哈）</p>
<p>讲ssh服务的用法之前得需要知道这个服务是否已经开启</p>
<p>查看ssh服务是否开启的命令:systemctl status sshd。输入这个命令之后，会得到如下的一个提示</p>
<p><img src="https://img-blog.csdn.net/20150118231938468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHh1cWlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>第二行最后一个单词disabled表示sshd服务开机不自动启动</p>
<p>第三行inactive（dead）表示sshd服务当前是关闭的</p>
<p>现在我们来开启sshd服务，输入systemctl start sshd，然后再输入systemctl status sshd查看结果</p>
<p><img src="https://img-blog.csdn.net/20150118232419468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHh1cWlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>现在我们可以看到第三行是active（running），这表示sshd服务当前是开启的，但仍然是开机不启动。不过，这并不影响我们使用sshd，至于如何管理这些服务，并不在我们本节讨论范围内。</p>
<p>ssh可以干什么，举个例子，我现在有个朋友电脑出了点问题，但是现在他在北京，我在西安 ，为给他修个电脑，我不划算去北京吧，怎么办？用ssh。</p>
<p>首先得知道他的ip地址，然后登录他的root用户，用命令：ssh root@<strong><em>.</em></strong>.<em>.**</em>  星号代表ip</p>
<p><img src="https://img-blog.csdn.net/20150118234218989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHh1cWlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>输入完命令后，会有一个提示，问你是否确信连接？输入yes，再然后输入他root的密码，就进入他的电脑了。但这样有个不好的地方，我知道了他root的密码，那以后岂不是可以在他的电脑上为所欲为了，这样他肯定是不愿意的，我要是不小心删掉了他珍藏多年的种子，他肯定会杀了我。</p>
<p>######我现在是他的身份#####</p>
<p>  那在这种情况下，他应该怎么办？（ps：我现在以他的身份来做）可以先给自己的电脑上一把锁，然后需要进入你电脑的人一把钥匙，你不想让别人进的时候把锁删掉就行了。那具体怎么做呢？</p>
<p>第一步：删除/root/.ssh/下的所有东西，如果没有.shh文件夹，建立一个。</p>
<p>第二步：在.ssh文件夹下，建立钥匙，使用命令ssh-keygen</p>
<p><img src="https://img-blog.csdn.net/20150119000500906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHh1cWlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>输入命令后，第一个提示问你存在哪里，默认就好，直接回车。第二个问题让你输入一个密码，这个密码就是以后别人在拥有私钥的情况下，进入你主机需要的密码。输入完再输入一次，就会生成一个钥匙跟一把锁。</p>
<p><img src="https://img-blog.csdn.net/20150119000931595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHh1cWlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>id_rsa叫私钥，也就是钥匙，id_rsa.pub叫公钥。</p>
<p>第三步：用锁来锁定本机的哪个用户，以root为例，命令是ssh-copy-id root@<strong><em>.</em></strong>.<em>.**</em>  id为本机的id。回车之后会提示你是否连接？回答yes就行，然后会提示你输入要锁定用户的密码，现在要锁定root ，那就输入root密码就行。</p>
<p>第四步：谁想连本机，把私钥发给谁就行，比如说，我发给一个叫playsand的用户。命令是：</p>
<p> scp id_rsa playsand@<strong><em>.</em></strong>.<em>.**</em>:/home/playsand/.ssh 这个星号代表的是playsand用户的id，后面代表的是存储路径，一定要在playsand下建立一个.ssh目录，如果有，则将里面内容清空。</p>
<p>#####现在我是playsand用户#####</p>
<p>在自己的.ssh目录下，输入ssh root@<strong><em>.</em></strong>.<em>.**</em> id是root的id，回车之后会提示你是否连接？回答yes，然后会提示输入密码，这个密码就是上面第二步设定的密码，输入之后，就进入了。如果输入错了，系统会提示你输入root的密码，同样，输入root密码也可以进入，这就跟刚开始一样。</p>
<p>#####现在我是root用户####</p>
<p>在这里有几个小小的设置：</p>
<p>1.让别人登录自己的root用户是件很危险的事，怎么能让别人怎么都登录不了自己的root用户呢；</p>
<p>编辑ssh_config文件(vim /etc/ssh/ssh_config),将#PermitRootLogin yes改成PermitRootLogin no(大约在48行)，推出保存之后，重启以下ssh服务（systemctl reload sshd）</p>
<p>2.要是不认识的人或者有恶意的人不小心得到了私钥和密码，对于本机来说很危险，可以设置白名单，让指定的人可以登录；</p>
<p>同样vim /etc/ssh/ssh_config,找一个空行写下：allowusers 指定用户名，这样只有指定的用户可以登录本机。e.g：allowusers playsand  就是允许playsand用户登录，其他用户都登录不了，同理，重启下ssh服务。</p>
<p>3.让别人知道登录自己的root密码或者用户密码总是不安全的，怎样让别人只能通过私钥密码登录？</p>
<p>同样vim /etc/ssh/ssh_config,将passwordAuthentication yes 改成passwordAuthentication no ，这样，别人只能通过私钥密码登录本机。修改完重启ssh服务。</p>
<p>使用ssh登录服务器的时候，需要输入ip地址、端口、用户名、密码等信息，比较麻烦，容易输错。还好，通过客户端和服务器的配置参数，可实现免密码快速登录。服务器可通过保存客户端的公钥，用于验证客户端的身份，从而省去输入密码的步骤。客户端也可通过配置服务器参数来简化登录命令。<br>本文主要是记录了ssh面密码快速登录的配置过程，主要分为以下几个步骤。</p>
<ol>
<li>客户端生成密钥，包括私钥和公钥。</li>
<li>在服务器中配置客户端的公钥。</li>
<li>在客户端配置服务器登录相关参数。</li>
</ol>
<p>本文示例中的服务器ip地址为192.168.1.1，ssh端口为22。</p>
<h2 id="客户端生成密钥"><a href="#客户端生成密钥" class="headerlink" title="客户端生成密钥"></a>客户端生成密钥</h2><p>客户端生成密钥的方法很简单，只需要使用ssh-keygen命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>生成密钥过程中，建议采用默认值，只需要按三次回车之后，就会再～/.ssh目录下生成密钥文件，其中，id_rsa为私钥，id_rsa.pub为公钥。 </p>
<h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>服务器的~/.ssh/authorized_keys文件保存可快速连接的客户端的公钥。只需把客户端生成的id_rsa.pub文件的内容拷贝到authorized_keys文件的末尾。拷贝的方法有：</p>
<ol>
<li>直接拷贝。由于id_rsa.pub和authorized_keys都是文本文件，可通过拷贝命令直接拷贝。</li>
<li>把id_rsa.pub上传到服务器，然后再把内容添加到authorized_keys文件中。<br>在客户端把文件上传到服务器的用户目录的操作命令如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~&#x2F;.ssh&#x2F;id_rsa.pub root@192.168.1.1:</span><br></pre></td></tr></table></figure>

<p>在服务器操作的命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>


<p>配置好之后，登录服务器就不再需要密码了。 </p>
<h2 id="在客户端配置服务器登录相关参数"><a href="#在客户端配置服务器登录相关参数" class="headerlink" title="在客户端配置服务器登录相关参数"></a>在客户端配置服务器登录相关参数</h2><p>除了密码之外，登录时，还需要配置ip地址、端口、用户等信息，也比较繁琐。可通过客户端的~/.ssh/config配置服务器的相关参数简化登录命令。<br>config文件的配置内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host server</span><br><span class="line">Hostname 192.168.1.1</span><br><span class="line">Port 22</span><br><span class="line">User bingoli</span><br></pre></td></tr></table></figure>


<p>其中，Host为服务器的名称，输入登录命令时使用，后续登录只需要记住这个名字就可以；Hostname为服务器的ip地址；Port为ssh的端口；User为服务器的用户名。配置好相关参数之后，就可以使用简化的命令登录服务器了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh server</span><br></pre></td></tr></table></figure>

<h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>在本地.ssh文件夹下vi config，然后</p>
<p>Host school</p>
<p>​    HostName ip地址</p>
<p>​    User xxxx</p>
<p>​    Port 22</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jackson</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jackson</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
