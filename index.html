<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jackson Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jackson Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jackson">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jackson Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jackson Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/vim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/09/vim/" class="post-title-link" itemprop="url">vim</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-09 06:23:35 / Modified: 06:24:26" itemprop="dateCreated datePublished" datetime="2020-05-09T06:23:35-05:00">2020-05-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h1 id="vim操作大全"><a href="#vim操作大全" class="headerlink" title="vim操作大全"></a><a href="https://www.cnblogs.com/chichung/p/9497784.html" target="_blank" rel="noopener">vim操作大全</a></h1><p># 转自 <a href="https://blog.csdn.net/weixin_37657720/article/details/80645991" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37657720/article/details/80645991</a></p>
<p>曾经使用了两年多的Vim，手册也翻过一遍。虽然现在不怎么用vim了，曾经的笔记还是贴出来，与喜欢vim的朋友分享。</p>
<h1 id="1-关于Vim"><a href="#1-关于Vim" class="headerlink" title="1. 关于Vim"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id59" target="_blank" rel="noopener">1. 关于Vim</a></h1><p>vim是我最喜欢的编辑器，也是<a href="http://lib.csdn.net/base/linux" target="_blank" rel="noopener">Linux</a>下第二强大的编辑器。 虽然emacs是公认的世界第一，我认为使用emacs并没有使用vi进行编辑来得高效。 如果是初学vi，运行一下vimtutor是个聪明的决定。 （如果你的系统环境不是中文，而你想使用中文的vimtutor，就运行vimtutor zh）</p>
<h2 id="1-1-Vim的几种模式"><a href="#1-1-Vim的几种模式" class="headerlink" title="1.1 Vim的几种模式"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id60" target="_blank" rel="noopener">1.1 Vim的几种模式</a></h2><ul>
<li>正常模式：可以使用快捷键命令，或按:输入命令行。</li>
<li>插入模式：可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。</li>
<li>可视模式：正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式。</li>
<li>替换模式：正常模式下，按R进入。</li>
</ul>
<h1 id="2-启动Vim"><a href="#2-启动Vim" class="headerlink" title="2. 启动Vim"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id61" target="_blank" rel="noopener">2. 启动Vim</a></h1><ul>
<li>vim -c cmd file: 在打开文件前，先执行指定的命令；</li>
<li>vim -r file: 恢复上次异常退出的文件；</li>
<li>vim -R file: 以只读的方式打开文件，但可以强制保存；</li>
<li>vim -M file: 以只读的方式打开文件，不可以强制保存；</li>
<li>vim -y num file: 将编辑窗口的大小设为num行；</li>
<li>vim + file: 从文件的末尾开始；</li>
<li>vim +num file: 从第num行开始；</li>
<li>vim +/string file: 打开file，并将光标停留在第一个找到的string上。</li>
<li>vim –remote file: 用已有的vim进程打开指定的文件。 如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim –remote file在已有的gvim中打开文件。</li>
</ul>
<h1 id="3-文档操作"><a href="#3-文档操作" class="headerlink" title="3. 文档操作"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id62" target="_blank" rel="noopener">3. 文档操作</a></h1><ul>
<li>:e file –关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi会警告。</li>
<li>:e! file –放弃对当前文件的修改，编辑新的文件。</li>
<li>:e+file – 开始新的文件，并从文件尾开始编辑。</li>
<li>:e+n file – 开始新的文件，并从第n行开始编辑。</li>
<li>:enew –编译一个未命名的新文档。(CTRL-W n)</li>
<li>:e – 重新加载当前文档。</li>
<li>:e! – 重新加载当前文档，并丢弃已做的改动。</li>
<li>:e#或ctrl+^ – 回到刚才编辑的文件，很实用。</li>
<li>:f或ctrl+g – 显示文档名，是否修改，和光标位置。</li>
<li>:f filename – 改变编辑的文件名，这时再保存相当于另存为。</li>
<li>gf – 打开以光标所在字符串为文件名的文件。</li>
<li>:w – 保存修改。</li>
<li>:n1,n2w filename – 选择性保存从某n1行到另n2行的内容。</li>
<li>:wq – 保存并退出。</li>
<li>ZZ – 保存并退出。</li>
<li>:x – 保存并退出。</li>
<li>:q[uit] ——退出当前窗口。(CTRL-W q或CTRL-W CTRL-Q)</li>
<li>:saveas newfilename – 另存为</li>
<li>:browse e – 会打开一个文件浏览器让你选择要编辑的文件。 如果是终端中，则会打开netrw的文件浏览窗口； 如果是gvim，则会打开一个图形界面的浏览窗口。 实际上:browse后可以跟任何编辑文档的命令，如sp等。 用browse打开的起始目录可以由browsedir来设置：<ul>
<li>:set browsedir=last – 用上次访问过的目录（默认）；</li>
<li>:set browsedir=buffer – 用当前文件所在目录；</li>
<li>:set browsedir=current – 用当前工作目录；</li>
</ul>
</li>
<li>:Sex – 水平分割一个窗口，浏览文件系统；</li>
<li>:Vex – 垂直分割一个窗口，浏览文件系统；</li>
</ul>
<h1 id="4-光标的移动"><a href="#4-光标的移动" class="headerlink" title="4. 光标的移动"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id63" target="_blank" rel="noopener">4. 光标的移动</a></h1><h2 id="4-1-基本移动"><a href="#4-1-基本移动" class="headerlink" title="4.1 基本移动"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id64" target="_blank" rel="noopener">4.1 基本移动</a></h2><p>以下移动都是在normal模式下。</p>
<ul>
<li>h或退格: 左移一个字符；</li>
<li>l或空格: 右移一个字符；</li>
<li>j: 下移一行；</li>
<li>k: 上移一行；</li>
<li>gj: 移动到一段内的下一行；</li>
<li>gk: 移动到一段内的上一行；</li>
<li>+或Enter: 把光标移至下一行第一个非空白字符。</li>
<li>-: 把光标移至上一行第一个非空白字符。</li>
<li>w: 前移一个单词，光标停在下一个单词开头；</li>
<li>W: 移动下一个单词开头，但忽略一些标点；</li>
<li>e: 前移一个单词，光标停在下一个单词末尾；</li>
<li>E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点；</li>
<li>b: 后移一个单词，光标停在上一个单词开头；</li>
<li>B: 移动到上一个单词开头，忽略一些标点；</li>
<li>ge: 后移一个单词，光标停在上一个单词末尾；</li>
<li>gE: 同 ge ，不过‘单词’包含单词相邻的标点。</li>
<li>(: 前移1句。</li>
<li>): 后移1句。</li>
<li>{: 前移1段。</li>
<li>}: 后移1段。</li>
<li>fc: 把光标移到同一行的下一个c字符处</li>
<li>Fc: 把光标移到同一行的上一个c字符处</li>
<li>tc: 把光标移到同一行的下一个c字符前</li>
<li>Tc: 把光标移到同一行的上一个c字符后</li>
<li>;: 配合f &amp; t使用，重复一次</li>
<li>,: 配合f &amp; t使用，反向重复一次</li>
</ul>
<p>上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。</p>
<ul>
<li>0: 移动到行首。</li>
<li>g0: 移到光标所在屏幕行行首。</li>
<li>^: 移动到本行第一个非空白字符。</li>
<li>g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。</li>
<li>: 移动光标所在屏幕行行尾。</li>
<li>n|: 把光标移到递n列上。</li>
<li>nG: 到文件第n行。</li>
<li>:n<cr> 移动到第n行。</li>
<li>:$<cr> 移动到最后一行。</li>
<li>H: 把光标移到屏幕最顶端一行。</li>
<li>M: 把光标移到屏幕中间一行。</li>
<li>L: 把光标移到屏幕最底端一行。</li>
<li>gg: 到文件头部。</li>
<li>G: 到文件尾部。</li>
</ul>
<h2 id="4-2-翻屏"><a href="#4-2-翻屏" class="headerlink" title="4.2 翻屏"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id65" target="_blank" rel="noopener">4.2 翻屏</a></h2><ul>
<li>ctrl+f: 下翻一屏。</li>
<li>ctrl+b: 上翻一屏。</li>
<li>ctrl+d: 下翻半屏。</li>
<li>ctrl+u: 上翻半屏。</li>
<li>ctrl+e: 向下滚动一行。</li>
<li>ctrl+y: 向上滚动一行。</li>
<li>n%: 到文件n%的位置。</li>
<li>zz: 将当前行移动到屏幕中央。</li>
<li>zt: 将当前行移动到屏幕顶端。</li>
<li>zb: 将当前行移动到屏幕底端。</li>
</ul>
<h2 id="4-3-标记"><a href="#4-3-标记" class="headerlink" title="4.3 标记"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id66" target="_blank" rel="noopener">4.3 标记</a></h2><p>使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置。 Ctrl+o和Ctrl+i 很像浏览器上的 后退 和 前进 。</p>
<ul>
<li>m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。</li>
<li>m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。</li>
<li>`{a-z}: 移动到标记位置。</li>
<li>‘{a-z}: 移动到标记行的行首。</li>
<li>`{0-9}：回到上[2-10]次关闭vim时最后离开的位置。</li>
<li>“: 移动到上次编辑的位置。”也可以，不过“精确到列，而”精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。</li>
<li>`”: 移动到上次离开的地方。</li>
<li>`.: 移动到最后改动的地方。</li>
<li>:marks 显示所有标记。</li>
<li>:delmarks a b – 删除标记a和b。</li>
<li>:delmarks a-c – 删除标记a、b和c。</li>
<li>:delmarks a c-f – 删除标记a、c、d、e、f。</li>
<li>:delmarks! – 删除当前缓冲区的所有标记。</li>
<li>:help mark-motions 查看更多关于mark的知识。</li>
</ul>
<h1 id="5-插入文本"><a href="#5-插入文本" class="headerlink" title="5. 插入文本"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id67" target="_blank" rel="noopener">5. 插入文本</a></h1><h2 id="5-1-基本插入"><a href="#5-1-基本插入" class="headerlink" title="5.1 基本插入"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id68" target="_blank" rel="noopener">5.1 基本插入</a></h2><ul>
<li>i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入=， 按esc进入命令模式，就会出现8个=。 这在插入分割线时非常有用，如30i+<esc>就插入了36个+组成的分割线。</li>
<li>I: 在当前行第一个非空字符前插入；</li>
<li>gI: 在当前行第一列插入；</li>
<li>a: 在光标后插入；</li>
<li>A: 在当前行最后插入；</li>
<li>o: 在下面新建一行插入；</li>
<li>O: 在上面新建一行插入；</li>
<li>:r filename在当前位置插入另一个文件的内容。</li>
<li>:[n]r filename在第n行插入另一个文件的内容。</li>
<li>:r !date 在光标处插入当前日期与时间。同理，:r !command可以将其它shell命令的输出插入当前文档。</li>
</ul>
<h2 id="5-2-改写插入"><a href="#5-2-改写插入" class="headerlink" title="5.2 改写插入"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id69" target="_blank" rel="noopener">5.2 改写插入</a></h2><ul>
<li>c[n]w: 改写光标后1(n)个词。</li>
<li>c[n]l: 改写光标后n个字母。</li>
<li>c[n]h: 改写光标前n个字母。</li>
<li>[n]cc: 修改当前[n]行。</li>
<li>[n]s: 以输入的文本替代光标之后1(n)个字符，相当于c[n]l。</li>
<li>[n]S: 删除指定数目的行，并以所输入文本代替之。</li>
</ul>
<p>注意，类似cnw,dnw,ynw的形式同样可以写为ncw,ndw,nyw。</p>
<h1 id="6-剪切复制和寄存器"><a href="#6-剪切复制和寄存器" class="headerlink" title="6. 剪切复制和寄存器"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id70" target="_blank" rel="noopener">6. 剪切复制和寄存器</a></h1><h2 id="6-1-剪切和复制、粘贴"><a href="#6-1-剪切和复制、粘贴" class="headerlink" title="6.1 剪切和复制、粘贴"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id71" target="_blank" rel="noopener">6.1 剪切和复制、粘贴</a></h2><ul>
<li>[n]x: 剪切光标右边n个字符，相当于d[n]l。</li>
<li>[n]X: 剪切光标左边n个字符，相当于d[n]h。</li>
<li>y: 复制在可视模式下选中的文本。</li>
<li>yy or Y: 复制整行文本。</li>
<li>y[n]w: 复制一(n)个词。</li>
<li>y[n]l: 复制光标右边1(n)个字符。</li>
<li>y[n]h: 复制光标左边1(n)个字符。</li>
<li>yor D: 删除（剪切）当前位置到行尾的内容。</li>
<li>d[n]w: 删除（剪切）1(n)个单词</li>
<li>d[n]l: 删除（剪切）光标右边1(n)个字符。</li>
<li>d[n]h: 删除（剪切）光标左边1(n)个字符。</li>
<li>d0: 删除（剪切）当前位置到行首的内容</li>
<li>[n] dd: 删除（剪切）1(n)行。</li>
<li>:m,nd<cr> 剪切m行到n行的内容。</li>
<li>d1G或dgg: 剪切光标以上的所有行。</li>
<li>dG: 剪切光标以下的所有行。</li>
<li>daw和das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</li>
<li>d/f<cr>：这是一个比较高级的组合命令，它将删除当前位置 到下一个f之间的内容。</li>
<li>p: 在光标之后粘贴。</li>
<li>P: 在光标之前粘贴。</li>
</ul>
<h2 id="6-2-文本对象"><a href="#6-2-文本对象" class="headerlink" title="6.2 文本对象"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id72" target="_blank" rel="noopener">6.2 文本对象</a></h2><ul>
<li>aw：一个词</li>
<li>as：一句。</li>
<li>ap：一段。</li>
<li>ab：一块（包含在圆括号中的）。</li>
</ul>
<p>y, d, c, v都可以跟文本对象。</p>
<h2 id="6-3-寄存器"><a href="#6-3-寄存器" class="headerlink" title="6.3 寄存器"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id73" target="_blank" rel="noopener">6.3 寄存器</a></h2><ul>
<li>a-z：都可以用作寄存器名。”ayy把当前行的内容放入a寄存器。</li>
<li>A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。 如”Ayy把当前行的内容追加到a寄存器中。</li>
<li>:reg 显示所有寄存器的内容。</li>
<li>“”：不加寄存器索引时，默认使用的寄存器。</li>
<li>“<em>：当前选择缓冲区，”</em>yy把当前行的内容放入当前选择缓冲区。</li>
<li>“+：系统剪贴板。”+yy把当前行的内容放入系统剪贴板。</li>
</ul>
<h1 id="7-查找与替换"><a href="#7-查找与替换" class="headerlink" title="7. 查找与替换"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id74" target="_blank" rel="noopener">7. 查找与替换</a></h1><h2 id="7-1-查找"><a href="#7-1-查找" class="headerlink" title="7.1 查找"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id75" target="_blank" rel="noopener">7.1 查找</a></h2><ul>
<li>/something: 在后面的文本中查找something。</li>
<li>?something: 在前面的文本中查找something。</li>
<li>/pattern/+number: 将光标停在包含pattern的行后面第number行上。</li>
<li>/pattern/-number: 将光标停在包含pattern的行前面第number行上。</li>
<li>n: 向后查找下一个。</li>
<li>N: 向前查找下一个。</li>
</ul>
<p>可以用grep或vimgrep查找一个模式都在哪些地方出现过，</p>
<p>其中:grep是调用外部的grep程序，而:vimgrep是vim自己的查找算法。</p>
<p>用法为： :vim[grep]/pattern/[g] [j] files</p>
<p>g的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。</p>
<p>j的含义是grep结束后，结果停在第j项，默认是停在第一项。</p>
<p>vimgrep前面可以加数字限定搜索结果的上限，如</p>
<p>:1vim/pattern/ % 只查找那个模式在本文件中的第一个出现。</p>
<p>其实vimgrep在读纯文本电子书时特别有用，可以生成导航的目录。</p>
<p>比如电子书中每一节的标题形式为：n. xxxx。你就可以这样：</p>
<p>:vim/^d{1,}./ %</p>
<p>然后用:cw或:copen查看结果，可以用C-w H把quickfix窗口移到左侧，</p>
<p>就更像个目录了。</p>
<h2 id="7-2-替换"><a href="#7-2-替换" class="headerlink" title="7.2 替换"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id76" target="_blank" rel="noopener">7.2 替换</a></h2><ul>
<li>:s/old/new - 用new替换当前行第一个old。</li>
<li>:s/old/new/g - 用new替换当前行所有的old。</li>
<li>:n1,n2s/old/new/g - 用new替换文件n1行到n2行所有的old。</li>
<li>:%s/old/new/g - 用new替换文件中所有的old。</li>
<li>:%s/^/xxx/g - 在每一行的行首插入xxx，^表示行首。</li>
<li>:%s/表示行尾。</li>
<li>所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。</li>
</ul>
<p>还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，</p>
<p>语法为 :[range]g/pattern/command</p>
<p>例如 :%g/^ xyz/normal dd。</p>
<p>表示对于以一个空格和xyz开头的行执行normal模式下的dd命令。</p>
<p>关于range的规定为：</p>
<ul>
<li>如果不指定range，则表示当前行。</li>
<li>m,n: 从m行到n行。</li>
<li>0: 最开始一行（可能是这样）。</li>
<li>$: 最后一行</li>
<li>.: 当前行</li>
<li>%: 所有行</li>
</ul>
<h2 id="7-3-正则表达式"><a href="#7-3-正则表达式" class="headerlink" title="7.3 正则表达式"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id77" target="_blank" rel="noopener">7.3 正则表达式</a></h2><p>高级的查找替换就要用到正则表达式。</p>
<ul>
<li>\d: 表示十进制数（我猜的）</li>
<li>\s: 表示空格</li>
<li>\S: 非空字符</li>
<li>\a: 英文字母</li>
<li>|: 表示 或</li>
<li>.: 表示.</li>
<li>{m,n}: 表示m到n个字符。这要和 \s与\a等连用，如 \a{m,n} 表示m 到n个英文字母。</li>
<li>{m,}: 表示m到无限多个字符。</li>
<li>**: 当前目录下的所有子目录。</li>
</ul>
<p>:help pattern得到更多帮助。</p>
<hr>
<h1 id="8-排版"><a href="#8-排版" class="headerlink" title="8. 排版"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id78" target="_blank" rel="noopener">8. 排版</a></h1><h2 id="8-1-基本排版"><a href="#8-1-基本排版" class="headerlink" title="8.1 基本排版"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id79" target="_blank" rel="noopener">8.1 基本排版</a></h2><ul>
<li>&lt;&lt; 向左缩进一个shiftwidth</li>
<li>&gt;&gt; 向右缩进一个shiftwidth</li>
<li>:ce(nter) 本行文字居中</li>
<li>:le(ft) 本行文字靠左</li>
<li>:ri(ght) 本行文字靠右</li>
<li>gq 对选中的文字重排，即对过长的文字进行断行</li>
<li>gqq 重排当前行</li>
<li>gqnq 重排n行</li>
<li>gqap 重排当前段</li>
<li>gqnap 重排n段</li>
<li>gqnj 重排当前行和下面n行</li>
<li>gqQ 重排当前段对文章末尾</li>
<li>J 拼接当前行和下一行</li>
<li>gJ 同 J ，不过合并后不留空格。</li>
</ul>
<h2 id="8-2-拼写检查"><a href="#8-2-拼写检查" class="headerlink" title="8.2 拼写检查"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id80" target="_blank" rel="noopener">8.2 拼写检查</a></h2><ul>
<li>:set spell－开启拼写检查功能</li>
<li>:set nospell－关闭拼写检查功能</li>
<li>]s－移到下一个拼写错误的单词</li>
<li>[s－作用与上一命令类似，但它是从相反方向进行搜索</li>
<li>z=－显示一个有关拼写错误单词的列表，可从中选择</li>
<li>zg－告诉拼写检查器该单词是拼写正确的</li>
<li>zw－与上一命令相反，告诉拼写检查器该单词是拼写错误的</li>
</ul>
<h2 id="8-3-统计字数"><a href="#8-3-统计字数" class="headerlink" title="8.3 统计字数"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id81" target="_blank" rel="noopener">8.3 统计字数</a></h2><p>g ^g可以统计文档字符数，行数。 将光标放在最后一个字符上，用字符数减去行数可以粗略统计中文文档的字数。 以上对 Mac 或 Unix 的文件格式适用。 如果是 Windows 文件格式（即换行符有两个字节），字数的统计方法为： 字符数 - 行数 * 2。</p>
<hr>
<h1 id="9-编辑多个文件"><a href="#9-编辑多个文件" class="headerlink" title="9. 编辑多个文件"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id82" target="_blank" rel="noopener">9. 编辑多个文件</a></h1><h2 id="9-1-一次编辑多个文件"><a href="#9-1-一次编辑多个文件" class="headerlink" title="9.1 一次编辑多个文件"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id83" target="_blank" rel="noopener">9.1 一次编辑多个文件</a></h2><p>我们可以一次打开多个文件，如</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi a.txt b.txt c.txt</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>使用:next(:n)编辑下一个文件。</li>
<li>:2n 编辑下2个文件。</li>
<li>使用:previous或:N编辑上一个文件。</li>
<li>使用:wnext，保存当前文件，并编辑下一个文件。</li>
<li>使用:wprevious，保存当前文件，并编辑上一个文件。</li>
<li>使用:args 显示文件列表。</li>
<li>:n filenames或:args filenames 指定新的文件列表。</li>
<li>vi -o filenames 在水平分割的多个窗口中编辑多个文件。</li>
<li>vi -O filenames 在垂直分割的多个窗口中编辑多个文件。</li>
</ul>
<h2 id="9-2-多标签编辑"><a href="#9-2-多标签编辑" class="headerlink" title="9.2 多标签编辑"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id84" target="_blank" rel="noopener">9.2 多标签编辑</a></h2><ul>
<li>vim -p files: 打开多个文件，每个文件占用一个标签页。</li>
<li>:tabe, tabnew – 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。</li>
<li>^w gf – 在新的标签页里打开光标下路径指定的文件。</li>
<li>:tabn – 切换到下一个标签。Control + PageDown，也可以。</li>
<li>:tabp – 切换到上一个标签。Control + PageUp，也可以。</li>
<li>[n] gt – 切换到下一个标签。如果前面加了 n ， 就切换到第n个标签。第一个标签的序号就是1。</li>
<li>:tab split – 将当前缓冲区的内容在新页签中打开。</li>
<li>:tabc[lose] – 关闭当前的标签页。</li>
<li>:tabo[nly] – 关闭其它的标签页。</li>
<li>:tabs – 列出所有的标签页和它们包含的窗口。</li>
<li>:tabm[ove] [N] – 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。</li>
</ul>
<h2 id="9-3-缓冲区"><a href="#9-3-缓冲区" class="headerlink" title="9.3 缓冲区"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id85" target="_blank" rel="noopener">9.3 缓冲区</a></h2><ul>
<li>:buffers或:ls或:files 显示缓冲区列表。</li>
<li>ctrl+^：在最近两个缓冲区间切换。</li>
<li>:bn – 下一个缓冲区。</li>
<li>:bp – 上一个缓冲区。</li>
<li>:bl – 最后一个缓冲区。</li>
<li>:b[n]或:[n]b – 切换到第n个缓冲区。</li>
<li>:nbw(ipeout) – 彻底删除第n个缓冲区。</li>
<li>:nbd(elete) – 删除第n个缓冲区，并未真正删除，还在unlisted列表中。</li>
<li>:ba[ll] – 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。</li>
</ul>
<h1 id="10-分屏编辑"><a href="#10-分屏编辑" class="headerlink" title="10. 分屏编辑"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id86" target="_blank" rel="noopener">10. 分屏编辑</a></h1><ul>
<li>vim -o file1 file2:水平分割窗口，同时打开file1和file2</li>
<li>vim -O file1 file2:垂直分割窗口，同时打开file1和file2</li>
</ul>
<h2 id="10-1-水平分割"><a href="#10-1-水平分割" class="headerlink" title="10.1 水平分割"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id87" target="_blank" rel="noopener">10.1 水平分割</a></h2><ul>
<li>:split(:sp) – 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S) 注意如果在终端下，CTRL-S可能会冻结终端，请按CTRL-Q继续。</li>
<li>:split filename – 水平分割窗口，并在新窗口中显示另一个文件。</li>
<li>:nsplit(:nsp) – 水平分割出一个n行高的窗口。</li>
<li>:[N]new – 水平分割出一个N行高的窗口，并编辑一个新文件。 (CTRL-W n或 CTRL-W CTRL-N)</li>
<li>ctrl+w f –水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。</li>
<li>C-w C-^ – 水平分割一个窗口，打开刚才编辑的文件。</li>
</ul>
<h2 id="10-2-垂直分割"><a href="#10-2-垂直分割" class="headerlink" title="10.2 垂直分割"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id88" target="_blank" rel="noopener">10.2 垂直分割</a></h2><ul>
<li>:vsplit(:vsp) – 把当前窗口分割成水平分布的两个窗口。 (CTRL-W v或CTRL CTRL-V)</li>
<li>:[N]vne[w] – 垂直分割出一个新窗口。</li>
<li>:vertical 水平分割的命令： 相应的垂直分割。</li>
</ul>
<h2 id="10-3-关闭子窗口"><a href="#10-3-关闭子窗口" class="headerlink" title="10.3 关闭子窗口"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id89" target="_blank" rel="noopener">10.3 关闭子窗口</a></h2><ul>
<li>:qall – 关闭所有窗口，退出vim。</li>
<li>:wall – 保存所有修改过的窗口。</li>
<li>:only – 只保留当前窗口，关闭其它窗口。(CTRL-W o)</li>
<li>:close – 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x同样工作 )</li>
</ul>
<h2 id="10-4-调整窗口大小"><a href="#10-4-调整窗口大小" class="headerlink" title="10.4 调整窗口大小"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id90" target="_blank" rel="noopener">10.4 调整窗口大小</a></h2><ul>
<li>ctrl+w + –当前窗口增高一行。也可以用n增高n行。</li>
<li>ctrl+w - –当前窗口减小一行。也可以用n减小n行。</li>
<li>ctrl+w _ –当前窗口扩展到尽可能的大。也可以用n设定行数。</li>
<li>:resize n – 当前窗口n行高。</li>
<li>ctrl+w = – 所有窗口同样高度。</li>
<li>n ctrl+w _ – 当前窗口的高度设定为n行。</li>
<li>ctrl+w &lt; –当前窗口减少一列。也可以用n减少n列。</li>
<li>ctrl+w &gt; –当前窗口增宽一列。也可以用n增宽n列。</li>
<li>ctrl+w | –当前窗口尽可能的宽。也可以用n设定列数。</li>
</ul>
<h2 id="10-5-切换和移动窗口"><a href="#10-5-切换和移动窗口" class="headerlink" title="10.5 切换和移动窗口"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id91" target="_blank" rel="noopener">10.5 切换和移动窗口</a></h2><p>如果支持鼠标，切换和调整子窗口的大小就简单了。</p>
<ul>
<li>ctrl+w ctrl+w: 切换到下一个窗口。或者是ctrl+w w。</li>
<li>ctrl+w p: 切换到前一个窗口。</li>
<li>ctrl+w h(l,j,k):切换到左（右，下，上）的窗口。</li>
<li>ctrl+w t(b):切换到最上（下）面的窗口。<BR></li>
<li>ctrl+w H(L,K,J): 将当前窗口移动到最左（右、上、下）面。</li>
<li>ctrl+w r：旋转窗口的位置。</li>
<li>ctrl+w T: 将当前的窗口移动到新的标签页上。</li>
</ul>
<h1 id="11-快速编辑"><a href="#11-快速编辑" class="headerlink" title="11. 快速编辑"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id92" target="_blank" rel="noopener">11. 快速编辑</a></h1><h2 id="11-1-改变大小写"><a href="#11-1-改变大小写" class="headerlink" title="11.1 改变大小写"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id93" target="_blank" rel="noopener">11.1 改变大小写</a></h2><ul>
<li>~: 反转光标所在字符的大小写。</li>
<li>可视模式下的U或u：把选中的文本变为大写或小写。</li>
<li>gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如gu5j，把当前行和下面四行全部变成小写。</li>
</ul>
<h2 id="11-2-替换（normal模式）"><a href="#11-2-替换（normal模式）" class="headerlink" title="11.2 替换（normal模式）"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id94" target="_blank" rel="noopener">11.2 替换（normal模式）</a></h2><ul>
<li>r: 替换光标处的字符，同样支持汉字。</li>
<li>R: 进入替换模式，按esc回到正常模式。</li>
</ul>
<h2 id="11-3-撤消与重做（normal模式）"><a href="#11-3-撤消与重做（normal模式）" class="headerlink" title="11.3 撤消与重做（normal模式）"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id95" target="_blank" rel="noopener">11.3 撤消与重做（normal模式）</a></h2><ul>
<li>[n] u: 取消一(n)个改动。</li>
<li>:undo 5 – 撤销5个改变。</li>
<li>:undolist – 你的撤销历史。</li>
<li>ctrl + r: 重做最后的改动。</li>
<li>U: 取消当前行中所有的改动。</li>
<li>:earlier 4m – 回到4分钟前</li>
<li>:later 55s – 前进55秒</li>
</ul>
<h2 id="11-4-宏"><a href="#11-4-宏" class="headerlink" title="11.4 宏"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id96" target="_blank" rel="noopener">11.4 宏</a></h2><ul>
<li>. –重复上一个编辑动作</li>
<li>qa：开始录制宏a（键盘操作记录）</li>
<li>q：停止录制</li>
<li>@a：播放宏a</li>
</ul>
<h1 id="12-编辑特殊文件"><a href="#12-编辑特殊文件" class="headerlink" title="12. 编辑特殊文件"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id97" target="_blank" rel="noopener">12. 编辑特殊文件</a></h1><h2 id="12-1-文件加解密"><a href="#12-1-文件加解密" class="headerlink" title="12.1 文件加解密"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id98" target="_blank" rel="noopener">12.1 文件加解密</a></h2><ul>
<li>vim -x file: 开始编辑一个加密的文件。</li>
<li>:X – 为当前文件设置密码。</li>
<li>:set key= – 去除文件的密码。</li>
</ul>
<p><a href="http://www.cnblogs.com/jiqingwu/admin/vim-quick-edit.html" target="_blank" rel="noopener">这里是</a> 滇狐总结的比较高级的vi技巧。</p>
<h2 id="12-2-文件的编码"><a href="#12-2-文件的编码" class="headerlink" title="12.2 文件的编码"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id99" target="_blank" rel="noopener">12.2 文件的编码</a></h2><ul>
<li>:e ++enc=utf8 filename, 让vim用utf-8的编码打开这个文件。</li>
<li>:w ++enc=gbk，不管当前文件什么编码，把它转存成gbk编码。</li>
<li>:set fenc或:set fileencoding，查看当前文件的编码。</li>
<li>在vimrc中添加set fileencoding=ucs-bom,utf-8,cp936，vim会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936对应于gbk编码。 ucs-bom对应于windows下的文件格式。</li>
</ul>
<p>让vim 正确处理文件格式和文件编码，有赖于 <a href="http://www.cnblogs.com/jiqingwu/admin/vimrc.html" target="_blank" rel="noopener">~/.vimrc的正确配置</a></p>
<h2 id="12-3-文件格式"><a href="#12-3-文件格式" class="headerlink" title="12.3 文件格式"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id100" target="_blank" rel="noopener">12.3 文件格式</a></h2><p>大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。</p>
<ul>
<li>:e ++ff=dos filename, 让vim用dos格式打开这个文件。</li>
<li>:w ++ff=mac filename, 以mac格式存储这个文件。</li>
<li>:set ff，显示当前文件的格式。</li>
<li>在vimrc中添加set fileformats=unix,dos,mac，让vim自动识别文件格式。</li>
</ul>
<h1 id="13-编程辅助"><a href="#13-编程辅助" class="headerlink" title="13. 编程辅助"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id101" target="_blank" rel="noopener">13. 编程辅助</a></h1><h2 id="13-1-一些按键"><a href="#13-1-一些按键" class="headerlink" title="13.1 一些按键"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id102" target="_blank" rel="noopener">13.1 一些按键</a></h2><ul>
<li>gd: 跳转到局部变量的定义处；</li>
<li>gD: 跳转到全局变量的定义处，从当前文件开头开始搜索；</li>
<li>g;: 上一个修改过的地方；</li>
<li>g,: 下一个修改过的地方；</li>
<li>[[: 跳转到上一个函数块开始，需要有单独一行的{。</li>
<li>]]: 跳转到下一个函数块开始，需要有单独一行的{。</li>
<li>[]: 跳转到上一个函数块结束，需要有单独一行的}。</li>
<li>][: 跳转到下一个函数块结束，需要有单独一行的}。</li>
<li>[{: 跳转到当前块开始处；</li>
<li>]}: 跳转到当前块结束处；</li>
<li>[/: 跳转到当前注释块开始处；</li>
<li>]/: 跳转到当前注释块结束处；</li>
<li>%: 不仅能移动到匹配的(),{}或[]上，而且能在#if，#else， #endif之间跳跃。</li>
</ul>
<p>下面的括号匹配对编程很实用的。</p>
<ul>
<li>ci’, di’, yi’：修改、剪切或复制’之间的内容。</li>
<li>ca’, da’, ya’：修改、剪切或复制’之间的内容，包含’。</li>
<li>ci”, di”, yi”：修改、剪切或复制”之间的内容。</li>
<li>ca”, da”, ya”：修改、剪切或复制”之间的内容，包含”。</li>
<li>ci(, di(, yi(：修改、剪切或复制()之间的内容。</li>
<li>ca(, da(, ya(：修改、剪切或复制()之间的内容，包含()。</li>
<li>ci[, di[, yi[：修改、剪切或复制[]之间的内容。</li>
<li>ca[, da[, ya[：修改、剪切或复制[]之间的内容，包含[]。</li>
<li>ci{, di{, yi{：修改、剪切或复制{}之间的内容。</li>
<li>ca{, da{, ya{：修改、剪切或复制{}之间的内容，包含{}。</li>
<li>ci&lt;, di&lt;, yi&lt;：修改、剪切或复制&lt;&gt;之间的内容。</li>
<li>ca&lt;, da&lt;, ya&lt;：修改、剪切或复制&lt;&gt;之间的内容，包含&lt;&gt;。</li>
</ul>
<h2 id="13-2-ctags"><a href="#13-2-ctags" class="headerlink" title="13.2 ctags"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id103" target="_blank" rel="noopener">13.2 ctags</a></h2><ul>
<li>ctags -R: 生成tag文件，-R表示也为子目录中的文件生成tags</li>
<li>:set tags=path/tags – 告诉ctags使用哪个tag文件</li>
<li>:tag xyz – 跳到xyz的定义处，或者将光标放在xyz上按C-]，返回用C-t</li>
<li>:stag xyz – 用分割的窗口显示xyz的定义，或者C-w ]， 如果用C-w n ]，就会打开一个n行高的窗口</li>
<li>:ptag xyz – 在预览窗口中打开xyz的定义，热键是C-w }。</li>
<li>:pclose – 关闭预览窗口。热键是C-w z。</li>
<li>:pedit abc.h – 在预览窗口中编辑abc.h</li>
<li>:psearch abc – 搜索当前文件和当前文件include的文件，显示包含abc的行。</li>
</ul>
<p>有时一个tag可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。</p>
<ul>
<li>:[n]tnext – 下一[n]个匹配。</li>
<li>:[n]tprev – 上一[n]个匹配。</li>
<li>:tfirst – 第一个匹配</li>
<li>:tlast – 最后一个匹配</li>
<li>:tselect tagname – 打开选择列表</li>
</ul>
<p>tab键补齐</p>
<ul>
<li>:tag xyz<tab> – 补齐以xyz开头的tag名，继续按tab键，会显示其他的。</li>
<li>:tag /xyz<tab> – 会用名字中含有xyz的tag名补全。</li>
</ul>
<h2 id="13-3-cscope"><a href="#13-3-cscope" class="headerlink" title="13.3 cscope"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id104" target="_blank" rel="noopener">13.3 cscope</a></h2><ul>
<li>cscope -Rbq: 生成cscope.out文件</li>
<li>:cs add /path/to/cscope.out /your/work/dir</li>
<li>:cs find c func – 查找func在哪些地方被调用</li>
<li>:cw – 打开quickfix窗口查看结果</li>
</ul>
<h2 id="13-4-gtags"><a href="#13-4-gtags" class="headerlink" title="13.4 gtags"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id105" target="_blank" rel="noopener">13.4 gtags</a></h2><p>Gtags综合了ctags和cscope的功能。 使用Gtags之前，你需要安装GNU Gtags。 然后在工程目录运行 gtags 。</p>
<ul>
<li>:Gtags funcname 定位到 funcname 的定义处。</li>
<li>:Gtags -r funcname 查询 funcname被引用的地方。</li>
<li>:Gtags -s symbol 定位 symbol 出现的地方。</li>
<li>:Gtags -g string Goto string 出现的地方。 :Gtags -gi string 忽略大小写。</li>
<li>:Gtags -f filename 显示 filename 中的函数列表。 你可以用 :Gtags -f % 显示当前文件。</li>
<li>:Gtags -P pattern 显示路径中包含特定模式的文件。 如 :Gtags -P .h$ 显示所有头文件， :Gtags -P /vm/ 显示vm目录下的文件。</li>
</ul>
<h2 id="13-5-编译"><a href="#13-5-编译" class="headerlink" title="13.5 编译"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id106" target="_blank" rel="noopener">13.5 编译</a></h2><p>vim提供了:make来编译程序，默认调用的是make， 如果你当前目录下有makefile，简单地:make即可。</p>
<p>如果你没有make程序，你可以通过配置makeprg选项来更改make调用的程序。 如果你只有一个abc.<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java</a>文件，你可以这样设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set makeprg&#x3D;javac\ abc.java</span><br></pre></td></tr></table></figure>

<p>然后:make即可。如果程序有错，可以通过quickfix窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让vim识别错误信息。 如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:setl efm&#x3D;%A%f:%l:\ %m,%-Z%p^,%-C%.%#</span><br></pre></td></tr></table></figure>

<p>%f表示文件名，%l表示行号， %m表示错误信息，其它的还不能理解。 请参考 :help errorformat。</p>
<h2 id="13-6-快速修改窗口"><a href="#13-6-快速修改窗口" class="headerlink" title="13.6 快速修改窗口"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id107" target="_blank" rel="noopener">13.6 快速修改窗口</a></h2><p>其实是quickfix插件提供的功能， 对编译调试程序非常有用 :)</p>
<ul>
<li>:copen – 打开快速修改窗口。</li>
<li>:cclose – 关闭快速修改窗口。</li>
</ul>
<p>快速修改窗口在make程序时非常有用，当make之后：</p>
<ul>
<li>:cl – 在快速修改窗口中列出错误。</li>
<li>:cn – 定位到下一个错误。</li>
<li>:cp – 定位到上一个错误。</li>
<li>:cr – 定位到第一个错误。</li>
</ul>
<h2 id="13-7-自动补全"><a href="#13-7-自动补全" class="headerlink" title="13.7 自动补全"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id108" target="_blank" rel="noopener">13.7 自动补全</a></h2><ul>
<li>C-x C-s – 拼写建议。</li>
<li>C-x C-v – 补全vim选项和命令。</li>
<li>C-x C-l – 整行补全。</li>
<li>C-x C-f – 自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按 C-n和C-p。</li>
<li>C-x C-p 和C-x C-n – 用文档中出现过的单词补全当前的词。 直接按C-p和C-n也可以。</li>
<li>C-x C-o – 编程时可以补全关键字和函数名啊。</li>
<li>C-x C-i – 根据头文件内关键字补全。</li>
<li>C-x C-d – 补全宏定义。</li>
<li>C-x C-n – 按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。</li>
</ul>
<p>当弹出补全菜单后：</p>
<ul>
<li>C-p 向前切换成员；</li>
<li>C-n 向后切换成员；</li>
<li>C-e 退出下拉菜单，并退回到原来录入的文字；</li>
<li>C-y 退出下拉菜单，并接受当前选项。</li>
</ul>
<h2 id="13-8-多行缩进缩出"><a href="#13-8-多行缩进缩出" class="headerlink" title="13.8 多行缩进缩出"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id109" target="_blank" rel="noopener">13.8 多行缩进缩出</a></h2><ul>
<li>正常模式下，按两下&gt;;光标所在行会缩进。</li>
<li>如果先按了n，再按两下&gt;;，光标以下的n行会缩进。</li>
<li>对应的，按两下&lt;;，光标所在行会缩出。</li>
<li>如果在编辑代码文件，可以用=进行调整。</li>
<li>在可视模式下，选择要调整的代码块，按=，代码会按书写规则缩排好。</li>
<li>或者n =，调整n行代码的缩排。</li>
</ul>
<h2 id="13-9-折叠"><a href="#13-9-折叠" class="headerlink" title="13.9 折叠"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id110" target="_blank" rel="noopener">13.9 折叠</a></h2><ul>
<li>zf – 创建折叠的命令，可以在一个可视区域上使用该命令；</li>
<li>zd – 删除当前行的折叠；</li>
<li>zD – 删除当前行的折叠；</li>
<li>zfap – 折叠光标所在的段；</li>
<li>zo – 打开折叠的文本；</li>
<li>zc – 收起折叠；</li>
<li>za – 打开/关闭当前折叠；</li>
<li>zr – 打开嵌套的折行；</li>
<li>zm – 收起嵌套的折行；</li>
<li>zR (zO) – 打开所有折行；</li>
<li>zM (zC) – 收起所有折行；</li>
<li>zj – 跳到下一个折叠处；</li>
<li>zk – 跳到上一个折叠处；</li>
<li>zi – enable/disable fold;</li>
</ul>
<h1 id="14-命令行"><a href="#14-命令行" class="headerlink" title="14. 命令行"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id111" target="_blank" rel="noopener">14. 命令行</a></h1><p>normal模式下按:进入命令行模式</p>
<h2 id="14-1-命令行模式下的快捷键："><a href="#14-1-命令行模式下的快捷键：" class="headerlink" title="14.1 命令行模式下的快捷键："></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id112" target="_blank" rel="noopener">14.1 命令行模式下的快捷键：</a></h2><ul>
<li>上下方向键：上一条或者下一条命令。如果已经输入了部分命令，则找上一 条或者下一条匹配的命令。</li>
<li>左右方向键：左/右移一个字符。</li>
<li>C-w： 向前删除一个单词。</li>
<li>C-h： 向前删除一个字符，等同于Backspace。</li>
<li>C-u： 从当前位置移动到命令行开头。</li>
<li>C-b： 移动到命令行开头。</li>
<li>C-e： 移动到命令行末尾。</li>
<li>Shift-Left： 左移一个单词。</li>
<li>Shift-Right： 右移一个单词。</li>
<li>@： 重复上一次的冒号命令。</li>
<li>q： 正常模式下，q然后按’:’，打开命令行历史缓冲区， 可以像编辑文件一样编辑命令。</li>
<li>q/和q? 可以打开查找历史记录。</li>
</ul>
<h2 id="14-2-执行外部命令"><a href="#14-2-执行外部命令" class="headerlink" title="14.2 执行外部命令"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id113" target="_blank" rel="noopener">14.2 执行外部命令</a></h2><ul>
<li>:! cmd 执行外部命令。</li>
<li>:!! 执行上一次的外部命令。</li>
<li>:sh 调用shell，用exit返回vim。</li>
<li>:r !cmd 将命令的返回结果插入文件当前位置。</li>
<li>:m,nw !cmd 将文件的m行到n行之间的内容做为命令输入执行命令。</li>
</ul>
<h1 id="15-其它"><a href="#15-其它" class="headerlink" title="15. 其它"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id114" target="_blank" rel="noopener">15. 其它</a></h1><h2 id="15-1-工作目录"><a href="#15-1-工作目录" class="headerlink" title="15.1 工作目录"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id115" target="_blank" rel="noopener">15.1 工作目录</a></h2><ul>
<li>:pwd 显示vim的工作目录。</li>
<li>:cd path 改变vim的工作目录。</li>
<li>:set autochdir 可以让vim 根据编辑的文件自动切换工作目录。</li>
</ul>
<h2 id="15-2-一些快捷键（收集中）"><a href="#15-2-一些快捷键（收集中）" class="headerlink" title="15.2 一些快捷键（收集中）"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id116" target="_blank" rel="noopener">15.2 一些快捷键（收集中）</a></h2><ul>
<li>K: 打开光标所在词的manpage。</li>
<li>*: 向下搜索光标所在词。</li>
<li>g*: 同上，但部分符合即可。</li>
<li>#: 向上搜索光标所在词。</li>
<li>g#: 同上，但部分符合即可。</li>
<li>g C-g: 统计全文或统计部分的字数。</li>
</ul>
<h2 id="15-3-在线帮助"><a href="#15-3-在线帮助" class="headerlink" title="15.3 在线帮助"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id117" target="_blank" rel="noopener">15.3 在线帮助</a></h2><ul>
<li>:h(elp)或F1 打开总的帮助。</li>
<li>:help user-manual 打开用户手册。</li>
<li>命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。</li>
<li>:helptags somepath 为somepath中的文档生成索引。</li>
<li>:helpgrep 可以搜索整个帮助文档，匹配的列表显示在quickfix窗口中。</li>
<li>Ctrl+] 跳转到tag主题，Ctrl+t 跳回。</li>
<li>:ver 显示版本信息。</li>
</ul>
<h2 id="15-4-一些小功能"><a href="#15-4-一些小功能" class="headerlink" title="15.4 一些小功能"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id118" target="_blank" rel="noopener">15.4 一些小功能</a></h2><ul>
<li>简单计算器: 在插入模式下，输入C-r =，然后输入表达式，就能在 光标处得到计算结果。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/09/vim/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/08/c-all/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/08/c-all/" class="post-title-link" itemprop="url">C++入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-08 18:11:18 / Modified: 22:31:51" itemprop="dateCreated datePublished" datetime="2020-05-08T18:11:18-05:00">2020-05-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-如何运行"><a href="#C-如何运行" class="headerlink" title="C++如何运行"></a>C++如何运行</h1><h2 id="g-应用说明"><a href="#g-应用说明" class="headerlink" title="g++ 应用说明"></a>g++ 应用说明</h2><p>程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.cpp -lstdc++ -o main</span><br><span class="line">#意思是-l std c++</span><br></pre></td></tr></table></figure>

<p>下面是一个保存在文件 helloworld.cpp 中一个简单的 C++ 程序的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最简单的编译方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ helloworld.cpp</span><br></pre></td></tr></table></figure>

<p>由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;a.out</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>通常我们使用 <strong>-o</strong> 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ helloworld.cpp -o helloworld</span><br></pre></td></tr></table></figure>

<p>执行 helloworld:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;helloworld</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>如果是多个 C++ 代码文件，如 runoob1.cpp、runoob2.cpp，编译命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ runoob1.cpp runoob2.cpp -o runoob</span><br></pre></td></tr></table></figure>

<p>生成一个 runoob 可执行文件。</p>
<p>g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -Wall -std&#x3D;c++11 main.cpp</span><br></pre></td></tr></table></figure>

<h3 id="g-常用命令选项"><a href="#g-常用命令选项" class="headerlink" title="g++ 常用命令选项"></a>g++ 常用命令选项</h3><table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-ansi</td>
<td align="left">只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td>
</tr>
<tr>
<td align="left">-c</td>
<td align="left">只编译并生成目标文件。</td>
</tr>
<tr>
<td align="left">-DMACRO</td>
<td align="left">以字符串”1”定义 MACRO 宏。</td>
</tr>
<tr>
<td align="left">-DMACRO=DEFN</td>
<td align="left">以字符串”DEFN”定义 MACRO 宏。</td>
</tr>
<tr>
<td align="left">-E</td>
<td align="left">只运行 C 预编译器。</td>
</tr>
<tr>
<td align="left">-g</td>
<td align="left">生成调试信息。GNU 调试器可利用该信息。</td>
</tr>
<tr>
<td align="left">-IDIRECTORY</td>
<td align="left">指定额外的头文件搜索路径DIRECTORY。</td>
</tr>
<tr>
<td align="left">-LDIRECTORY</td>
<td align="left">指定额外的函数库搜索路径DIRECTORY。</td>
</tr>
<tr>
<td align="left">-lLIBRARY</td>
<td align="left">连接时搜索指定的函数库LIBRARY。</td>
</tr>
<tr>
<td align="left">-m486</td>
<td align="left">针对 486 进行代码优化。</td>
</tr>
<tr>
<td align="left">-o</td>
<td align="left">FILE 生成指定的输出文件。用在生成可执行文件时。</td>
</tr>
<tr>
<td align="left">-O0</td>
<td align="left">不进行优化处理。</td>
</tr>
<tr>
<td align="left">-O</td>
<td align="left">或 -O1 优化生成代码。</td>
</tr>
<tr>
<td align="left">-O2</td>
<td align="left">进一步优化。</td>
</tr>
<tr>
<td align="left">-O3</td>
<td align="left">比 -O2 更进一步优化，包括 inline 函数。</td>
</tr>
<tr>
<td align="left">-shared</td>
<td align="left">生成共享目标文件。通常用在建立共享库时。</td>
</tr>
<tr>
<td align="left">-static</td>
<td align="left">禁止使用共享连接。</td>
</tr>
<tr>
<td align="left">-UMACRO</td>
<td align="left">取消对 MACRO 宏的定义。</td>
</tr>
<tr>
<td align="left">-w</td>
<td align="left">不生成任何警告信息。</td>
</tr>
<tr>
<td align="left">-Wall</td>
<td align="left">生成所有警告信息。</td>
</tr>
</tbody></table>
<h1 id="C-注释"><a href="#C-注释" class="headerlink" title="C++ 注释"></a>C++ 注释</h1><p>程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。</p>
<p>C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。</p>
<p>C++ 注释以 /* 开始，以 */ 终止。例如：</p>
<p>/* 这是注释 <em>/  /</em> C++ 注释也可以 * 跨行 */</p>
<p>注释也能以 // 开始，直到行末为止。</p>
<p> 块注释符（/<em>…</em>/）是不可以嵌套使用的。</p>
<p>此外，我们还可以使用 <strong>#if 0 … #endif</strong> 来实现注释，且可以实现嵌套，格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if 0</span><br><span class="line">   code</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>你可以把 <strong>#if 0</strong> 改成 <strong>#if 1</strong> 来执行 <strong>code</strong> 的代码。</p>
<p>这种形式对程序调试也可以帮助，测试时使用 <strong>#if 1</strong> 来执行测试代码，发布后使用 <strong>#if 0</strong> 来屏蔽测试代码。</p>
<p><strong>#if</strong> 后可以是任意的条件语句。</p>
<p>下面的代码如果 condition 条件为 true 执行 code1 ，否则执行 code2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if condition</span><br><span class="line">  code1</span><br><span class="line">#else</span><br><span class="line">  code2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h1 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C++ 数据类型"></a>C++ 数据类型</h1><h2 id="基本的内置类型"><a href="#基本的内置类型" class="headerlink" title="基本的内置类型"></a>基本的内置类型</h2><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">布尔型</td>
<td align="left">bool</td>
</tr>
<tr>
<td align="left">字符型</td>
<td align="left">char</td>
</tr>
<tr>
<td align="left">整型</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">浮点型</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">双浮点型</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">无类型</td>
<td align="left">void</td>
</tr>
<tr>
<td align="left">宽字符型</td>
<td align="left">wchar_t</td>
</tr>
</tbody></table>
<p>其实 wchar_t 是这样来的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef short int wchar_t;&#x2F;&#x2F;占2或4字节</span><br></pre></td></tr></table></figure>

<p>所以 wchar_t 实际上的空间是和 short int 一样。</p>
<p>一些基本类型可以使用一个或多个类型修饰符进行修饰：</p>
<ul>
<li><p>signed</p>
</li>
<li><p>unsigned</p>
</li>
<li><p>short：带short都是2字节</p>
</li>
<li><p>long</p>
</li>
<li><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">位</th>
<th align="left">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td align="left">1 个字节</td>
<td align="left">-128 到 127 或者 0 到 255</td>
</tr>
<tr>
<td align="left">unsigned char</td>
<td align="left">1 个字节</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left">signed char</td>
<td align="left">1 个字节</td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td align="left">4 个字节</td>
<td align="left">0 到 4294967295</td>
</tr>
<tr>
<td align="left">signed int</td>
<td align="left">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">short int</td>
<td align="left">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="left">unsigned short int</td>
<td align="left">2 个字节</td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="left">signed short int</td>
<td align="left">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="left">long int</td>
<td align="left">4 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left">signed long int</td>
<td align="left">8 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left">unsigned long int</td>
<td align="left">8 个字节</td>
<td align="left">0 到 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">4 个字节</td>
<td align="left">精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">8 个字节</td>
<td align="left">双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td>
</tr>
<tr>
<td align="left">long double</td>
<td align="left">16 个字节</td>
<td align="left">长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td>
</tr>
<tr>
<td align="left">wchar_t</td>
<td align="left">2 或 4 个字节</td>
<td align="left">1 个宽字符</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="typedef-声明"><a href="#typedef-声明" class="headerlink" title="typedef 声明"></a>typedef 声明</h2><p>您可以使用 <strong>typedef</strong> 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef type newname;</span><br></pre></td></tr></table></figure>

<p>例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef int feet;</span><br></pre></td></tr></table></figure>

<p>现在，下面的声明是完全合法的，它创建了一个整型变量 distance：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feet distance;</span><br></pre></td></tr></table></figure>

<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>
<p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p>
<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum 枚举名&#123; </span><br><span class="line">     标识符[&#x3D;整型常数], </span><br><span class="line">     标识符[&#x3D;整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[&#x3D;整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure>

<p>如果枚举没有初始化, 即省掉”=整型常数”时, 则从第一个标识符开始。</p>
<p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum color &#123; red, green, blue &#125; c;</span><br><span class="line">c &#x3D; blue;</span><br></pre></td></tr></table></figure>

<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，<strong>green</strong> 的值为 5。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum color &#123; red, green&#x3D;5, blue &#125;;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>blue</strong> 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。</p>
<h1 id="C-变量类型"><a href="#C-变量类型" class="headerlink" title="C++ 变量类型"></a>C++ 变量类型</h1><p>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。</p>
<p>基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bool</td>
<td align="left">存储值 true 或 false。</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">通常是一个字符（八位）。这是一个整数类型。</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">对机器而言，整数的最自然的大小。</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。<img src="https://www.runoob.com/wp-content/uploads/2014/09/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png" alt="img"></td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">双精度浮点值。双精度是1位符号，11位指数，52位小数。<img src="https://www.runoob.com/wp-content/uploads/2014/09/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.png" alt="img"></td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">表示类型的缺失。</td>
</tr>
<tr>
<td align="left">wchar_t</td>
<td align="left">宽字符类型。</td>
</tr>
</tbody></table>
<p>C++ 也允许定义各种其他类型的变量，比如<strong>枚举、指针、数组、引用、数据结构、类</strong>等等，这将会在后续的章节中进行讲解。</p>
<h2 id="C-中的变量定义"><a href="#C-中的变量定义" class="headerlink" title="C++ 中的变量定义"></a>C++ 中的变量定义</h2><p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type variable_list;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>type</strong> 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，<strong>variable_list</strong> 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。</p>
<p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p>
<h2 id="C-中的变量声明"><a href="#C-中的变量声明" class="headerlink" title="C++ 中的变量声明"></a>C++ 中的变量声明</h2><p>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<p>当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 <strong>extern</strong> 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>尝试下面的实例，其中，变量在头部就已经被声明，但它们是在主函数内被定义和初始化的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 变量声明</span><br><span class="line">extern int a, b;</span><br><span class="line">extern int c;</span><br><span class="line">extern float f;</span><br><span class="line">  </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 变量定义</span><br><span class="line">  int a, b;</span><br><span class="line">  int c;</span><br><span class="line">  float f;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; 实际初始化</span><br><span class="line">  a &#x3D; 10;</span><br><span class="line">  b &#x3D; 20;</span><br><span class="line">  c &#x3D; a + b;</span><br><span class="line"> </span><br><span class="line">  cout &lt;&lt; c &lt;&lt; endl ;</span><br><span class="line"> </span><br><span class="line">  f &#x3D; 70.0&#x2F;3.0;</span><br><span class="line">  cout &lt;&lt; f &lt;&lt; endl ;</span><br><span class="line"> </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30</span><br><span class="line">23.3333</span><br></pre></td></tr></table></figure>

<p>同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数声明</span><br><span class="line">int func();</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 函数调用</span><br><span class="line">    int i &#x3D; func();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 函数定义</span><br><span class="line">int func()</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>现在才算理解声明和定义的区别了：</strong></p>
<p>定义包含了声明，但是声明不包含定义，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 0;     &#x2F;&#x2F;定义并声明了变量 a</span><br><span class="line">extern int a;  &#x2F;&#x2F;只是声明了有一个变量 a 存在，具体 a 在哪定义的，需要编译器编译的时候去找。</span><br></pre></td></tr></table></figure>

<p>函数也是类似，定义的时候同时声明。但如果只是声明，编译器只知道有这么个函数，具体函数怎么定义的要编译器去找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void fun1();  &#x2F;&#x2F;函数声明</span><br><span class="line"></span><br><span class="line">void fun1()&#123;  &#x2F;&#x2F;函数定义</span><br><span class="line">    cout&lt;&lt;&quot;fun1&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C/C++ 编译 cpp 文件是从上往下编译，所以 main 函数里面调用其他函数时，如果其他函数在 main 函数的下面，则要在 main 函数上面先声明这个函数。</p>
<p>或者把 main 函数放在最下面，这个不仅限于 main 函数，其他函数的调用都是如此。被调用的函数要在调用的函数之前声明。</p>
<p>用 extern 声明外部变量是不能进行初始化：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/20180617101214118.png" alt="img"></p>
<p>为什么会这样呢？因为 <strong>extern int a;</strong> 只是声明而不是定义，声明是不会为变量开辟内存空间的，自然无法对其进行初始化的操作</p>
<h2 id="C-中的左值（Lvalues）和右值（Rvalues"><a href="#C-中的左值（Lvalues）和右值（Rvalues" class="headerlink" title="C++ 中的左值（Lvalues）和右值（Rvalues)"></a>C++ 中的左值（Lvalues）和右值（Rvalues)</h2><p>C++ 中有两种类型的表达式：</p>
<ul>
<li><strong>左值（lvalue）：</strong>指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>
<li><strong>右值（rvalue）：</strong>术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>
</ul>
<p>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int g &#x3D; 20;</span><br></pre></td></tr></table></figure>

<p>但是下面这个就不是一个有效的语句，会生成编译时错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 &#x3D; 20;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C8/" class="post-title-link" itemprop="url">计算机网络8</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-07 20:13:27" itemprop="dateCreated datePublished" datetime="2020-05-07T20:13:27-05:00">2020-05-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C7/" class="post-title-link" itemprop="url">计算机网络7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-07 20:13:19" itemprop="dateCreated datePublished" datetime="2020-05-07T20:13:19-05:00">2020-05-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C6/" class="post-title-link" itemprop="url">计算机网络6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-07 20:13:16 / Modified: 20:13:17" itemprop="dateCreated datePublished" datetime="2020-05-07T20:13:16-05:00">2020-05-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C5/" class="post-title-link" itemprop="url">计算机网络5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-07 20:13:14" itemprop="dateCreated datePublished" datetime="2020-05-07T20:13:14-05:00">2020-05-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4/" class="post-title-link" itemprop="url">计算机网络4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-07 20:13:06" itemprop="dateCreated datePublished" datetime="2020-05-07T20:13:06-05:00">2020-05-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/" class="post-title-link" itemprop="url">计算机网络3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-07 20:13:03" itemprop="dateCreated datePublished" datetime="2020-05-07T20:13:03-05:00">2020-05-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/" class="post-title-link" itemprop="url">计算机网络2（25-53）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-07 20:13:01" itemprop="dateCreated datePublished" datetime="2020-05-07T20:13:01-05:00">2020-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-08 16:31:24" itemprop="dateModified" datetime="2020-05-08T16:31:24-05:00">2020-05-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h3 id="数据链路层使用的信道主要有以下两种类型："><a href="#数据链路层使用的信道主要有以下两种类型：" class="headerlink" title="数据链路层使用的信道主要有以下两种类型："></a>数据链路层使用的信道主要有以下两种类型：</h3><p>点对点信道。这种信道使用一对一的点对点通信方式。</p>
<p>广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发 </p>
<h2 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h2><h3 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h3><p>链路(link)是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。</p>
<p>一条链路只是一条通路的一个组成部分。</p>
<p>数据链路(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p>
<p>现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。</p>
<p>一般的适配器都包括了数据链路层和物理层这两层的功能。  常常在两个对等的数据链路层之间画出一个数字管道，而在这条数字管道上传输的数据单位是帧。</p>
<p><strong>数据链路层传送的是帧</strong></p>
<h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><p>(1) 封装成帧：封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。</p>
<p>首部和尾部的一个重要作用就是进行帧定界，头SOH，尾EOT</p>
<p>(2) 透明传输：若数据部分有EOT，则后面会当成无效帧丢弃，</p>
<p>解决办法：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是 1B)。</p>
<p>字节填充(byte stuffing)或字符填充(character stuffing)——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</p>
<p>如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 </p>
<p>(3) 差错控制 ：在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。</p>
<p>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。</p>
<p>误码率与信噪比有很大的关系。</p>
<p>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 </p>
<h3 id="循环冗余检验的原理-（解决差错控制的）"><a href="#循环冗余检验的原理-（解决差错控制的）" class="headerlink" title="循环冗余检验的原理 （解决差错控制的）"></a>循环冗余检验的原理 （解决差错控制的）</h3><p>在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。</p>
<p>在发送端，先把数据划分为组。假定每组 <em>k</em> 个比特。 </p>
<p>假设待传送的一组数据 <em>M</em> = 101001（现在 <em>k</em> = 6）。我们在 <em>M</em> 的后面再添加供差错检测用的 <em>n</em> 位冗余码一起发送。 </p>
<p><em>冗余码计算：（很重要）</em></p>
<p>用二进制的模 2 运算进行 2<em>n</em> 乘 <em>M</em> 的运算，这相当于在 <em>M</em> 后面添加 <em>n</em> 个 0。</p>
<p>得到的 (<em>k</em> + <em>n</em>) 位的数除以事先选定好的长度为 (<em>n</em> + 1) 位的除数 <em>P</em>，得出商是 <em>Q</em> 而余数是 <em>R</em>，余数 <em>R</em> 比除数 <em>P</em> 少1 位，即 <em>R</em> 是 <em>n</em> 位。 </p>
<p>举例：现在 <em>k</em> = 6, <em>M</em> = 101001。</p>
<p>设 <em>n</em> = 3, 除数 <em>P</em> = 1101，</p>
<p>被除数是 2^n*M = 101001000。 </p>
<p>模 2 运算的结果是：商 <em>Q</em> = 110101，</p>
<p>​      余数 <em>R</em> = 001。</p>
<p>把余数 <em>R</em> 作为冗余码添加在数据 <em>M</em> 的后面发送出去。发送的数据是：2^n<em>M + *R</em> </p>
<p>  即：101001001，共 (<em>k</em> + <em>n</em>) 位。 </p>
<p>接收端对收到的每一帧进行 CRC 检验 :(1) 若得出的余数 <em>R</em> = 0，则判定这个帧没有差错，就接受(accept)。</p>
<p>(2) 若余数 <em>R</em> ¹ 0，则判定这个帧有差错，就丢弃。</p>
<p>但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。</p>
<p>只要经过严格的挑选，并使用位数足够多的除数 <em>P</em>，那么出现检测不到的差错的概率就很小很小。 </p>
<h3 id="帧检验序列-FCS"><a href="#帧检验序列-FCS" class="headerlink" title="帧检验序列 FCS"></a>帧检验序列 FCS</h3><p>在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。</p>
<p>循环冗余检验 CRC 和帧检验序列 FCS并不等同。</p>
<p>CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。</p>
<p>FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。 </p>
<h4 id="注意：仅用循环冗余检验-CRC-差错检测技术只能做到无差错接受-accept-。"><a href="#注意：仅用循环冗余检验-CRC-差错检测技术只能做到无差错接受-accept-。" class="headerlink" title="注意：仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受(accept)。"></a>注意：仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受(accept)。</h4><p>“无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。要做到“可靠传输”（即发送什么就收到什么）就必须再加上确认和重传机制。 </p>
<h2 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h2><h3 id="PPP-协议的特点-："><a href="#PPP-协议的特点-：" class="headerlink" title="PPP 协议的特点 ："></a>PPP 协议的特点 ：</h3><p>现在全世界使用得最多的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。</p>
<p>用户使用拨号电话线接入因特网时，一般都是使用 PPP 协议。 </p>
<h3 id="PPP-协议应满足的需求"><a href="#PPP-协议应满足的需求" class="headerlink" title="PPP 协议应满足的需求"></a>PPP 协议应满足的需求</h3><p>简单——这是首要的要求</p>
<p>封装成帧 </p>
<p>透明性 </p>
<p>多种网络层协议 </p>
<p>多种类型链路 </p>
<p>差错检测 </p>
<p>检测连接状态 </p>
<p>最大传送单元 </p>
<p>网络层地址协商 </p>
<p>数据压缩协商 </p>
<h3 id="PPP-协议不需要的功能"><a href="#PPP-协议不需要的功能" class="headerlink" title="PPP 协议不需要的功能"></a>PPP 协议不需要的功能</h3><p>纠错 </p>
<p>流量控制 </p>
<p>序号 </p>
<p>多点线路 </p>
<p>半双工或单工链路 </p>
<h3 id="PPP-协议有三个组成部分"><a href="#PPP-协议有三个组成部分" class="headerlink" title="PPP 协议有三个组成部分"></a>PPP 协议有三个组成部分</h3><p>一个将 IP 数据报封装到串行链路的方法。</p>
<p>从底层到高层分为</p>
<p>高级数据链路控制协议 HDLC</p>
<p>链路控制协议 LCP (Link Control Protocol)。</p>
<p>网络控制协议 NCP (Network Control Protocol)。  </p>
<h3 id="PPP-协议的帧格式"><a href="#PPP-协议的帧格式" class="headerlink" title="PPP 协议的帧格式"></a>PPP 协议的帧格式</h3><p>标志字段 F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110）。表示开始，和结束帧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">					首部                    ip数据报									  尾部</span><br><span class="line">	     F  A  C  协议					    信息部分									FCS  F</span><br><span class="line">字节数  1  1  1  2             不超过1500字节&lt;&#x3D;MTU           2    1</span><br><span class="line">字节    7E FF 03                                                7E</span><br><span class="line">&lt;--------------------------------PPP帧-----------------------------&gt;</span><br></pre></td></tr></table></figure>

<p>PPP 有一个 2 个字节的协议字段。</p>
<p>当协议字段为 0x0021 时，PPP 帧的信息字段就是IP 数据报。</p>
<p>若为 0xC021, 则信息字段是 PPP 链路控制数据。</p>
<p>若为 0x8021，则表示这是网络控制数据。 </p>
<p>地址字段 A 只置为 0xFF。地址字段实际上并不起作用。</p>
<p>控制字段 C 通常置为 0x03。</p>
<p>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。   </p>
<h4 id="透明传输问题"><a href="#透明传输问题" class="headerlink" title="透明传输问题 :"></a>透明传输问题 :</h4><p>当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充（和 HDLC 的做法一样）。 当 PPP 用在异步传输时，就使用一种特殊的字符填充法。 </p>
<h4 id="字符填充"><a href="#字符填充" class="headerlink" title="字符填充 :"></a>字符填充 :</h4><p>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列(0x7D, 0x5E)。 </p>
<p>若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列(0x7D, 0x5D)。</p>
<p>若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。 </p>
<h4 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h4><p>PPP 协议用在 SONET/SDH 链路时，是使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。</p>
<p>在发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除，</p>
<h4 id="不提供使用序号和确认-的可靠传输"><a href="#不提供使用序号和确认-的可靠传输" class="headerlink" title="不提供使用序号和确认 的可靠传输"></a>不提供使用序号和确认 的可靠传输</h4><p>PPP 协议之所以不使用序号和确认机制是出于以下的考虑：</p>
<p>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</p>
<p>在因特网环境下，PPP 的信息字段放入的数据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</p>
<p>帧检验序列 FCS 字段可保证无差错接受。  </p>
<h3 id="PPP-协议的工作状态"><a href="#PPP-协议的工作状态" class="headerlink" title="PPP 协议的工作状态"></a>PPP 协议的工作状态</h3><p>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</p>
<p>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</p>
<p>这些分组及其响应选择一些 PPP 参数，和进行网络层配置，NCP 给新接入的 PC机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</p>
<p>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。  </p>
<p>33集</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/" class="post-title-link" itemprop="url">计算机网络1（1-20）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-07 20:12:58" itemprop="dateCreated datePublished" datetime="2020-05-07T20:12:58-05:00">2020-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-08 11:35:43" itemprop="dateModified" datetime="2020-05-08T11:35:43-05:00">2020-05-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>操作系统：</p>
<p>网络基础服务： DNS DHCP RAS FTP Web </p>
<p>网络：思科CCNA OSI参考模型 TCPIP协议</p>
<p>计算机网络书分为五层：物理层，数据链路层，网络层，运输层，应用层</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>网络：电信网络，计算机网络，有线电视网络。</p>
<p>有3个特点：数字化，网络化，信息化</p>
<p>计算机网络分为：因特网，其他网络</p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><h3 id="网络互联网因特网区别"><a href="#网络互联网因特网区别" class="headerlink" title="网络互联网因特网区别"></a>网络互联网因特网区别</h3><p>网络（Network）：许多计算机连接在一起</p>
<p>互联网（Network of Networks，internet）：许多网络连接在一起</p>
<p>因特网（Internet）：全球最大的一个互联网</p>
<p>因特网是美国发明的属于美国国家的网络。<br>互联网是基于因特网，百全球各网络与网络之间所串连成的庞大网络。<br>注意：因特网属于美国其有最高权利，又链接世界，拥有世界唯度一服务器，可以随时停止某些地区网络内的服务，历史案例有伊拉克和叙利亚。中国用的不是互联网而是美国的因特网，所以这方面国家网络安全堪忧！而国家网络安全是国家主权非常重要的延伸和表现！因容特网也是维持美国霸权的一个重要方面。</p>
<p>n网络(network)由若干结点(node)和连接这些结点的链路(link)组成。 </p>
<p>n互联网是“网络的网络”(network of networks)。</p>
<p>n连接在因特网上的计算机都称为主机(host)。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node</span><br><span class="line">在网络中的 node 的标准译名是“结点”而不是“节点”。</span><br><span class="line">但数据结构的树(tree)中的 node 应当译为“节点”</span><br></pre></td></tr></table></figure>

<h3 id="因特网发展3阶段"><a href="#因特网发展3阶段" class="headerlink" title="因特网发展3阶段"></a>因特网发展3阶段</h3><p>第一阶段是从单个网络 ARPANET 向互联网发展的过程。 </p>
<p>1983 年 TCP/IP 协议成为 ARPANET 上的标准协议。</p>
<p>人们把 1983 年作为因特网的诞生时间。 </p>
<p>第二阶段的特点是建成了三级结构的因特网。 </p>
<p>三级计算机网络，分为主干网、地区网和校园网（或企业网）</p>
<p>第三阶段的特点是逐渐形成了多层次 ISP 结构的因特网。</p>
<p>出现了因特网服务提供者 ISP (Internet Service Provider)。 </p>
<p>根据提供服务的覆盖面积大小以及所拥有的IP 地址数目的不同，ISP 也分成为不同的层次。</p>
<p>主机A → 本地 ISP → 第二层 ISP → NAP → 第一层 ISP → NAP → 第二层 ISP → 本地 ISP → 主机B</p>
<p>因特网的迅猛发展始于 20 世纪 90 年代。由欧洲原子核研究组织 CERN 开发的万维网 <strong>WWW</strong> (World Wide Web)被广泛使用在因特网上，大大方便了广大非网络专业人员对网络的使用，成为因特网的这种指数级增长的主要驱动力。 </p>
<h3 id="万维网因特网互联网区别"><a href="#万维网因特网互联网区别" class="headerlink" title="万维网因特网互联网区别"></a>万维网因特网互联网区别</h3><p>互联网包含因特网，因特网包含万维网。即互联网&gt;因特网&gt;万维网。</p>
<p>互联网是设备之间互联通信， 万维网是服务与数据资源之间的共享利用</p>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><h3 id="因特网组成"><a href="#因特网组成" class="headerlink" title="因特网组成"></a>因特网组成</h3><p>从因特网的工作方式上看，可以划分为以下的两大块：</p>
<p>(1) 边缘部分 由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</p>
<p>(2) 核心部分 由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）</p>
<h3 id="两种通信方式"><a href="#两种通信方式" class="headerlink" title="两种通信方式"></a>两种通信方式</h3><p>在网络边缘的端系统中运行的程序之间的通信方式通常可划分为两大类：</p>
<p>客户服务器方式（C/S 方式） 即Client/Server方式 ：客户是服务的请求方，服务器是服务的提供方。</p>
<p>对等方式（P2P 方式） 即 Peer-to-Peer方式 ：对等连接(peer-to-peer，简写为 P2P)是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。只要两个主机都运行了对等连接软件（P2P 软件），它们就可以进行平等的、对等连接通信。双方都可以下载对方已经存储在硬盘中的共享文档。主机既是客户又同时是服务器</p>
<h3 id="因特网核心：数据交换方式"><a href="#因特网核心：数据交换方式" class="headerlink" title="因特网核心：数据交换方式"></a>因特网核心：数据交换方式</h3><p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p>
<p>在网络核心部分起特殊作用的是<strong>路由器(router)</strong>。</p>
<p>路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。 </p>
<h4 id="电路交换Circuit-Switching-电路交换必定是面向连接的。"><a href="#电路交换Circuit-Switching-电路交换必定是面向连接的。" class="headerlink" title="电路交换Circuit Switching:电路交换必定是面向连接的。"></a>电路交换Circuit Switching:电路交换必定是面向连接的。</h4><p>电路交换的三个阶段：建立连接,通信,释放连接</p>
<p>一般打电话就是电路交换</p>
<h4 id="报文交换Message-Switching：比分组长很多，交换时延也长，基本不用了"><a href="#报文交换Message-Switching：比分组长很多，交换时延也长，基本不用了" class="headerlink" title="报文交换Message Switching：比分组长很多，交换时延也长，基本不用了"></a>报文交换Message Switching：比分组长很多，交换时延也长，基本不用了</h4><h4 id="分组交换Packet-Switching：在发送端，先把较长的报文划分成较短的、固定长度的数据段。"><a href="#分组交换Packet-Switching：在发送端，先把较长的报文划分成较短的、固定长度的数据段。" class="headerlink" title="分组交换Packet Switching：在发送端，先把较长的报文划分成较短的、固定长度的数据段。"></a>分组交换Packet Switching：在发送端，先把较长的报文划分成较短的、固定长度的数据段。</h4><p>每个数据段前添加首部构成分组，接收端收到分组后剥去首部还原成报文，最后还原成原来的报文</p>
<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><h3 id="不同类别网络"><a href="#不同类别网络" class="headerlink" title="不同类别网络"></a>不同类别网络</h3><h3 id="不同作用范围的网络"><a href="#不同作用范围的网络" class="headerlink" title="不同作用范围的网络"></a>不同作用范围的网络</h3><p>广域网 <strong>WAN</strong> (Wide Area Network)：花钱买服务 花钱买带宽</p>
<p>局域网 <strong>LAN</strong> (Local Area Network)：自己买设备，自己维护，带宽固定 100M100M 距离100米以内</p>
<p>城域网 <strong>MAN</strong> (Metropolitan Area Network)</p>
<h3 id="个人区域网-PAN-Personal-Area-Network"><a href="#个人区域网-PAN-Personal-Area-Network" class="headerlink" title="个人区域网 PAN (Personal Area Network)"></a>个人区域网 <strong>PAN</strong> (Personal Area Network)</h3><p>从网络的使用者进行分类</p>
<p>公用网 (public network) </p>
<p>专用网 (private network) </p>
<h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p>星型，总线型，环形，树形，网状</p>
<h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><h3 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h3><p>1.速率</p>
<p>比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。Bit 来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。</p>
<p>速率即数据率(data rate)或比特率(bit rate)是计算机网络中最重要的一个性能指标。速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等。速率往往是指额定速率或标称速率。 </p>
<p>2.带宽</p>
<p>带宽”(bandwidth)本来是指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等）。</p>
<p>现在“带宽”是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s)。  </p>
<p>兆比每秒，即 Mb/s</p>
<p>3.吞吐量</p>
<p>吞吐量(throughput)表示在单位时间内通过某个网络（或信道、接口）的数据量。</p>
<p>吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p>
<p>吞吐量受网络的带宽或网络的额定速率的限制。 </p>
<p>4.时延(delay 或 latency)</p>
<p>传输时延（发送时延 ）  发送数据时，数据块从结点进入到传输媒体所需要的时间。</p>
<p>也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 </p>
<p>数据经历的总时延就是发送时延、传播时延、处理时延和排队时延</p>
<p>5.时延带宽积</p>
<p>时延带宽积 = 传播时延 *带宽</p>
<p>链路的时延带宽积又称为以比特为单位的链路长度。 </p>
<p>6.往返时间 Round-Trip TIme</p>
<p>7.利用率</p>
<p>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。</p>
<p>网络利用率则是全网络的信道利用率的加权平均值。</p>
<p>信道利用率并非越高越好。 </p>
<h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p>ISO：国家标准化组织</p>
<p>OSI/RM：互联网法律上的国际标准</p>
<p>TCP/IP Suite：因特网事实上的国际标准</p>
<p>Network Protocols：数据交换遵循的规则.标准或约定</p>
<p>网络体系结构：计算机网络各层及其协议的集合</p>
<h3 id="OSI七层模型："><a href="#OSI七层模型：" class="headerlink" title="OSI七层模型："></a>OSI七层模型：</h3><p>Application应用层：能够产生网络流量，能够和用户交互的应用程序</p>
<p>Presentation表示层：加密，压缩，开发人员</p>
<p>Session会话层：服务和客户端建立的会话，查木马， netstat -nb</p>
<p>网络工程师解决下面三层传输，不包括物理层</p>
<p>Transport传输层：可靠传输建立对话， 不可靠传输，流量控制</p>
<p>Network网络层：ip地址编制，选择最佳路径</p>
<p>Date Link数据链路层：数据如何封装，添加物理层地址 MAC地址</p>
<p>Physical物理层：电压 接口标准</p>
<h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p>网络排错：从底层到高层</p>
<h3 id="网络完全："><a href="#网络完全：" class="headerlink" title="网络完全："></a>网络完全：</h3><p>物理层安全</p>
<p>数据链路层安全 ADSL AP密码</p>
<p>网络层安全</p>
<p>应用层安全 SQL注入漏洞 上传漏洞</p>
<h2 id="13"><a href="#13" class="headerlink" title="13"></a>13</h2><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3><p>Application, Transport,Internet,Network Access</p>
<p>TCP/IP 是四层的体系结构：应用层、运输层、网际层和网络接口层。</p>
<p>往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构 。 </p>
<h3 id="本书5层模型："><a href="#本书5层模型：" class="headerlink" title="本书5层模型："></a>本书5层模型：</h3><p>Application, Transport,Internet,Data Link，Physical</p>
<p>应用层(application layer) ：传输数据单元PDU</p>
<p>运输层(transport layer) ：运输层报文</p>
<p>网络层(network layer) ：ip数据报（ip分组）</p>
<p>数据链路层(data link layer) ：数据帧</p>
<p>物理层(physical layer) ：0101</p>
<h3 id="发送数据过程"><a href="#发送数据过程" class="headerlink" title="发送数据过程"></a>发送数据过程</h3><p>应用层数据加上运输层首部，网络层首部，链路层首部和尾部，最后转化为比特流</p>
<h2 id="15"><a href="#15" class="headerlink" title="15"></a>15</h2><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>  物理层的主要任务描述为确定与传输媒体的接口的一些特性，即： </p>
<p>机械特性  指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</p>
<p>电气特性  指明在接口电缆的各条线上出现的电压的范围。</p>
<p>功能特性  指明某条线上出现的某一电平的电压表示何种意义。</p>
<p>过程特性  指明对于不同功能的各种可能事件的出现顺序。 </p>
<h3 id="数据通信系统模型"><a href="#数据通信系统模型" class="headerlink" title="数据通信系统模型"></a>数据通信系统模型</h3><p>输入信息到源点，然后输入数据到发送器然后发送信号到传输系统，然后接收器接受信号，然后输出数据到终点，然后输出信息。</p>
<h2 id="16"><a href="#16" class="headerlink" title="16"></a>16</h2><h3 id="几个术语"><a href="#几个术语" class="headerlink" title="几个术语"></a>几个术语</h3><p>通信的目的是传送消息。</p>
<p>数据(data)——运送消息的实体。</p>
<p>信号(signal)——数据的电气的或电磁的表现。 </p>
<p>“模拟的”(analogous)——代表消息的参数的取值是连续的。 </p>
<p>“数字的”(digital)——代表消息的参数的取值是离散的。 </p>
<p>码元(code)——在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p>
<h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>信道一般表示向一个方向传送信息的媒体。</p>
<p>单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。</p>
<p>双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</p>
<p>双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。 </p>
<h3 id="基带-baseband-信号和-带通-band-pass-信号"><a href="#基带-baseband-信号和-带通-band-pass-信号" class="headerlink" title="基带(baseband)信号和 带通(band pass)信号"></a>基带(baseband)信号和 带通(band pass)信号</h3><p>基带信号（即基本频带信号）——来自信源的信号</p>
<p>带通信号——把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。 </p>
<h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号进行调制(modulation)。 </p>
<p>最基本的二元制调制方法有以下几种：</p>
<p>调幅(AM)：载波的振幅随基带数字信号而变化。 </p>
<p>调频(FM)：载波的频率随基带数字信号而变化。</p>
<p>调相(PM) ：载波的初始相位随基带数字信号而变化。 </p>
<h3 id="数据通信常见编码"><a href="#数据通信常见编码" class="headerlink" title="数据通信常见编码"></a>数据通信常见编码</h3><p>单极性不归零码：只用一个电压值，用高电平表示1，没电平表示0 </p>
<p>双极性不归零码：正负电平表示二进制1，0，正负幅值相等</p>
<p>双极性归零码：正负零三电平</p>
<p>曼彻斯特编码(Manchester Encoding): 位中间电平从低到高跳变表示”0”;位中间电平从高到低跳变表示”1”。 </p>
<p>差分曼彻斯特编码(differential Manchester encoding): 在最初信号的时候,即第一个信号时:如果中间位电平从低到高,则表示0;如果中间位电平从高到低,则表示1。抗干扰能力比曼彻斯特编码强</p>
<h2 id="17"><a href="#17" class="headerlink" title="17"></a>17</h2><h3 id="信道极限容量"><a href="#信道极限容量" class="headerlink" title="信道极限容量"></a>信道极限容量</h3><p>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 </p>
<p>码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重。 </p>
<p>数字信号通过实际的信道 ：1.有失真，但是可识别 2. 失真大，无法识别 </p>
<h3 id="1-信道能够通过的频率范围"><a href="#1-信道能够通过的频率范围" class="headerlink" title="1.信道能够通过的频率范围"></a>1.信道能够通过的频率范围</h3><p>奈氏准则**。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">理想低通信道下的最高码元传输速率＝2W Baud</span><br><span class="line"></span><br><span class="line">其中W是理想低通信道的带宽，单位为赫兹；Baud是波特，即码元传输速率的单位，1波特为每秒传送1个码元。</span><br></pre></td></tr></table></figure>

<p>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</p>
<p> <strong>奈氏准则</strong>指出，码元传输速率是受限的；香农定理则给出了信息传输速率的极限。也就是说，奈氏准则认为码元编码足够好，就不会限制信息传输速率。<br>码元传输速率（波特率），是指传输码元的速率（废话）。与制信息传输速率（比特率）的区别在于，一个码元通过调频调相，可以显示出多种变化，就可以代表多个比特。一般来讲，信息传输速率=码元传输速率*log2(码元变化数量百)。<br>所以其实区别只有一个度，那就是奈氏准则是针对波特率的，没有限制比特率，他认为码元传输速率一旦确定，再确定码元所载的比特数，极限知信息传输速率也就确定了；而香农公式通过极其复杂的推演（我看不懂），得出了结论：信息传输速率也是有极限的，且这个极限不是由波特率单独决定，还是由传输带宽和信道噪比决定的。</p>
<h3 id="2-信噪比"><a href="#2-信噪比" class="headerlink" title="2.信噪比"></a>2.信噪比</h3><p><strong>香农公式</strong></p>
<p>香农(Shannon)用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。</p>
<p>信道的极限信息传输速率 <em>C</em> 可表达为</p>
<p>​    <em>C</em> = <em>W</em> log2(1+<em>S</em>/<em>N</em>) b/s </p>
<p><em>W</em> 为信道的带宽（以 Hz 为单位）；</p>
<p><em>S</em> 为信道内所传信号的平均功率；</p>
<p><em>N</em> 为信道内部的高斯噪声功率。 </p>
<p>结论：信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 </p>
<p>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。 </p>
<p>若信道带宽 <em>W</em> 或信噪比 <em>S</em>/<em>N</em> 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 <em>C</em> 也就没有上限。</p>
<p>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。 </p>
<h4 id="信息传输速率受香农公式限制，而码元传输速率受奈氏准则的限制"><a href="#信息传输速率受香农公式限制，而码元传输速率受奈氏准则的限制" class="headerlink" title="信息传输速率受香农公式限制，而码元传输速率受奈氏准则的限制"></a>信息传输速率受香农公式限制，而码元传输速率受奈氏准则的限制</h4><h2 id="18"><a href="#18" class="headerlink" title="18"></a>18</h2><h3 id="电信领域使用电磁波频率"><a href="#电信领域使用电磁波频率" class="headerlink" title="电信领域使用电磁波频率"></a>电信领域使用电磁波频率</h3><p>数据通信：小于10^-4HZ 大于10^16HZ</p>
<h3 id="导向传输媒体"><a href="#导向传输媒体" class="headerlink" title="导向传输媒体"></a>导向传输媒体</h3><p>双绞线：屏蔽双绞线 STP (Shielded Twisted Pair)，无屏蔽双绞线 UTP (Unshielded Twisted Pair)</p>
<p>同轴电缆：50 W 同轴电缆，75 W 同轴电缆</p>
<p>光缆 ：光线在纤芯中传输的方式是不断地全反射</p>
<h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>（Hub）是指将多条以太网双绞线或光纤集合连接在同一段物理介质下的设备；是一个多端口的转发器，当以HUB为中心设备时，网络中某条线路产生了故障，并不影响其它线路的工作。主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。<br>它工作于OSI参考模型第一层，即“物理层”，属于局域网中的基础设备版，采用CSMA/CD（即带冲突检测的载波监听多路访问技术)介质访问控制机制。集线器每个接口简单的收发比特，收到权1就转发1，收到0就转发0，不进行碰撞检测。HUB不具备交换机所具有的MAC地址表，所以它发送数据时都是没有针对性的，而是采用广播方式发送。在局域网中得到广泛应用。</p>
<h2 id="20"><a href="#20" class="headerlink" title="20"></a>20</h2><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><p>复用(multiplexing)是通信技术中的基本概念。 就是共享信道。</p>
<h4 id="频分复用-FDM-Frequency-Division-Multiplexing-：常用，电话就是。"><a href="#频分复用-FDM-Frequency-Division-Multiplexing-：常用，电话就是。" class="headerlink" title="频分复用 FDM(Frequency Division Multiplexing) ：常用，电话就是。"></a>频分复用 FDM(Frequency Division Multiplexing) ：常用，电话就是。</h4><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p>
<p>频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率</p>
<h4 id="时分复用TDM-Time-Division-Multiplexing"><a href="#时分复用TDM-Time-Division-Multiplexing" class="headerlink" title="时分复用TDM (Time Division Multiplexing)"></a>时分复用TDM (Time Division Multiplexing)</h4><p>时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</p>
<p>每一个用户所占用的时隙是周期性地出现（其周期就是 TDM 帧的长度）。</p>
<p>TDM 信号也称为等时(isochronous)信号。</p>
<p>时分复用的所有用户是在不同的时间占用同样的频带宽度。</p>
<p>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。时分复用可能会造成线路资源的浪费 </p>
<h4 id="统计时分复用-STDM-Statistic-TDM"><a href="#统计时分复用-STDM-Statistic-TDM" class="headerlink" title="统计时分复用 STDM (Statistic TDM)"></a>统计时分复用 STDM (Statistic TDM)</h4><h4 id="波分复用-WDM-Wavelength-Division-Multiplexing-：光的频分复用"><a href="#波分复用-WDM-Wavelength-Division-Multiplexing-：光的频分复用" class="headerlink" title="波分复用 WDM(Wavelength Division Multiplexing)  ：光的频分复用"></a>波分复用 WDM(Wavelength Division Multiplexing)  ：光的频分复用</h4><h3 id="码分复用-CDM-Code-Division-Multiplexing"><a href="#码分复用-CDM-Code-Division-Multiplexing" class="headerlink" title="码分复用 CDM (Code Division Multiplexing)"></a>码分复用 CDM (Code Division Multiplexing)</h3><p>常用的名词是码分多址 CDMA  (Code Division Multiple Access)。</p>
<p>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</p>
<p>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 </p>
<p>每一个比特时间划分为 <em>m</em> 个短的间隔，称为码片(chip)。</p>
<p>CDMA特点：每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(orthogonal)。在实用的系统中是使用伪随机码序列。 </p>
<h4 id="码片序列的正交关系"><a href="#码片序列的正交关系" class="headerlink" title="码片序列的正交关系"></a>码片序列的正交关系</h4><p>令向量 <strong>S</strong> 表示站 S 的码片向量，令 <strong>T</strong> 表示其他任何站的码片向量。 </p>
<p>两个不同站的码片序列正交，就是向量 <strong>S</strong> 和<strong>T</strong> 的规格化内积(inner product)都是 0： </p>
<img src="/Users/mengxiaowang/Library/Application Support/typora-user-images/image-20200508103821364.png" alt="image-20200508103821364" style="zoom:25%;" />

<p>任何一个码片向量和该码片向量自己的规格化内积都是1 。</p>
<p>一个码片向量和该码片反码的向量的规格化内积值是 –1。 </p>
<img src="/Users/mengxiaowang/Library/Application Support/typora-user-images/image-20200508103923650.png" alt="image-20200508103923650" style="zoom:25%;" />

<h3 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h3><p>1.脉码调制 PCM 体制 </p>
<p>脉码调制 PCM 体制最初是为了在电话局之间的中继线上传送多路的电话。</p>
<p>由于历史上的原因，PCM 有两个互不兼容的国际标准，即北美的 24 路 PCM（简称为 T1）和欧洲的 30 路 PCM（简称为 E1）。我国采用的是欧洲的 E1 标准。</p>
<ol start="2">
<li>同步光纤网 SONET 和 同步数字系列 SDH </li>
</ol>
<p>速率标准不统一，不是同步传输。</p>
<h3 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h3><h4 id="xDSL技术"><a href="#xDSL技术" class="headerlink" title="xDSL技术"></a>xDSL技术</h4><p>xDSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。</p>
<p>虽然标准模拟电话信号的频带被限制在 300~3400 kHz 的范围内，但用户线本身实际可通过的信号频率仍然超过 1 MHz。</p>
<p>xDSL 技术就把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。</p>
<p>DSL 就是数字用户线(Digital Subscriber Line)的缩写。而 DSL 的前缀 x 则表示在数字用户线上实现的不同宽带方案。 </p>
<p>分为</p>
<p>ADSL (Asymmetric Digital Subscriber Line)：非对称数字用户线</p>
<p>HDSL (High speed DSL)：高速数字用户线</p>
<p>SDSL (Single-line DSL)：1 对线的数字用户线</p>
<p>VDSL (Very high speed DSL)：甚高速数字用户线</p>
<p>DSL ：ISDN 用户线。</p>
<p>RADSL (Rate-Adaptive DSL)：速率自适应 DSL，是 ADSL 的一个子集，可自动调节线路速率）。 </p>
<h4 id="ADSL特点"><a href="#ADSL特点" class="headerlink" title="ADSL特点"></a>ADSL特点</h4><p>上行和下行带宽做成不对称的。</p>
<p>上行指从用户到 ISP，而下行指从 ISP 到用户。</p>
<p>ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。</p>
<p>我国目前采用的方案是离散多音调 <strong>DMT</strong> (Discrete Multi-Tone)调制技术。这里的“多音调”就是“多载波”或“多子信道”的意思。</p>
<p>光纤同轴混合网</p>
<h4 id="HFC-Hybrid-Fiber-Coax"><a href="#HFC-Hybrid-Fiber-Coax" class="headerlink" title="HFC (Hybrid Fiber Coax)"></a>HFC (Hybrid Fiber Coax)</h4><p>HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。</p>
<p>HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。</p>
<p>现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。而 HFC 网则需要对 CATV 网进行改造， </p>
<p>HFC特点：(1) HFC网的主干线路采用光纤(2) HFC 网采用结点体系结构 (3) HFC 网具有比 CATV 网更宽的频谱，且具有双向传输功能 </p>
<h4 id="FTTx-技术"><a href="#FTTx-技术" class="headerlink" title="FTTx 技术"></a>FTTx 技术</h4><p>实现宽带居民接入网的方案。这里字母 x 可代表不同意思。</p>
<p>光纤到家 FTTH (Fiber To The Home)：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法。</p>
<p>光纤到大楼 FTTB (Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。</p>
<p>光纤到路边 FTTC (Fiber To The Curb)：从路边到各用户可使用星形结构双绞线作为传输媒体。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jackson</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jackson</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
