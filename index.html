<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jackson Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jackson Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jackson">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jackson Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jackson Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/05/%E5%BC%80%E5%85%B3app/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/05/%E5%BC%80%E5%85%B3app/" class="post-title-link" itemprop="url">开关app，terminal上网</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-05 15:13:13 / Modified: 16:22:06" itemprop="dateCreated datePublished" datetime="2020-05-05T15:13:13-05:00">2020-05-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Use-terminal-to-open-and-close-application-or-file"><a href="#Use-terminal-to-open-and-close-application-or-file" class="headerlink" title="Use terminal to open and close application or file"></a>Use terminal to open and close application or file</h1><h2 id="What-the-heck-a-new-world"><a href="#What-the-heck-a-new-world" class="headerlink" title="What the heck, a new world!"></a>What the heck, a new world!</h2><p>Very simple, so first of all, if we want to open a application</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">open -a applicationname</span><br><span class="line">#我这里用的是Google Chrome</span><br><span class="line">open -a &quot;Google Chrome&quot;#不加”“也可以,最好别加，好像有bug，因为下面atom加了显示失败</span><br><span class="line">如果要打开某个文件</span><br><span class="line">open .&#x2F;Desktop&#x2F;a.cpp -a Atom  #打开桌面的c++文件用atom打开</span><br></pre></td></tr></table></figure>

<p>Hell no, how to close</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osascript -e &#39;quit app &quot;Atom&quot;&#39;#osascript -e &#39;quit app &quot;Applicationname&quot;&#39;</span><br></pre></td></tr></table></figure>



<p>用terminal玩转web browser</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">You’ll want to install the main w3m package and the w3m-img package if you want inline image support. Use the following command on Ubuntu:</span><br><span class="line"></span><br><span class="line">sudo apt-get install w3m w3m-img</span><br><span class="line"></span><br><span class="line">For Mac following command will install:</span><br><span class="line"></span><br><span class="line">brew install w3m</span><br><span class="line"></span><br><span class="line">You can use the arrow keys to move the cursor around or click at the desired location to move the cursor there. If you want to type in a text box, select the text box with your cursor and press Enter before typing your text. Load a hyperlink by selecting it with your cursor and pressing Enter.</span><br><span class="line">Shortcuts:</span><br><span class="line">Tab: Press the Tab key to position your cursor over the next hyperlink on the page.</span><br><span class="line">Shift-B: will take you back a page.</span><br><span class="line">Shif-U: If you want to load a different URL, you’ll get an URL prompt.</span><br><span class="line">Shift-H: To view the help page if you want to see a more complete list of keyboard shortcuts.</span><br><span class="line">Shift-T: To open a new tab and then you can press Shift-U and enter the new URL. Yes, it does support tab browsing:)</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">w3m 网址</span><br><span class="line">w3m baidu.com</span><br><span class="line">Tab: move to next interaction point</span><br><span class="line">Enter:Trigger interaction item(click&#x2F;enter)</span><br><span class="line">有text的话可以输入想search的内容</span><br><span class="line">jk，上下左右 移动光标</span><br><span class="line">qy 退出w3m</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/03/python400%E9%9B%8610/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/03/python400%E9%9B%8610/" class="post-title-link" itemprop="url">python400集10</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-03 19:14:05" itemprop="dateCreated datePublished" datetime="2020-05-03T19:14:05-05:00">2020-05-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/03/python400%E9%9B%869/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/03/python400%E9%9B%869/" class="post-title-link" itemprop="url">python400集9</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-03 19:14:01" itemprop="dateCreated datePublished" datetime="2020-05-03T19:14:01-05:00">2020-05-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/03/python400%E9%9B%868/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/03/python400%E9%9B%868/" class="post-title-link" itemprop="url">python400集8</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-03 19:13:58" itemprop="dateCreated datePublished" datetime="2020-05-03T19:13:58-05:00">2020-05-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/03/python400%E9%9B%867/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/03/python400%E9%9B%867/" class="post-title-link" itemprop="url">python400集7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-03 19:13:54" itemprop="dateCreated datePublished" datetime="2020-05-03T19:13:54-05:00">2020-05-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/03/python400%E9%9B%866/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/03/python400%E9%9B%866/" class="post-title-link" itemprop="url">python400集6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-03 19:13:51" itemprop="dateCreated datePublished" datetime="2020-05-03T19:13:51-05:00">2020-05-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/03/python400%E9%9B%865/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/03/python400%E9%9B%865/" class="post-title-link" itemprop="url">python400集5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-03 19:13:49" itemprop="dateCreated datePublished" datetime="2020-05-03T19:13:49-05:00">2020-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-05 15:06:02" itemprop="dateModified" datetime="2020-05-05T15:06:02-05:00">2020-05-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件操作（IO技术）"><a href="#文件操作（IO技术）" class="headerlink" title="文件操作（IO技术）"></a>文件操作（IO技术）</h1><p>一个完整的程序一般都包括数据的存储和读取;我们在前面写的程序数据都没有进行实 际的存储，因此 python 解释器执行完数据就消失了。实际开发中，我们经常需要从外部存 储介质(硬盘、光盘、U 盘等)读取数据，或者将程序产生的数据存储到文件中，实现“持 久化”保存。</p>
<p>很多软件系统是将数据存储的数据库中;数据库实际也是基于文件 形式存储的</p>
<p><strong>文本文件和二进制文件</strong></p>
<p>按文件中数据组织形式，我们把文件分为文本文件和二进制文件两大类。</p>
<ol>
<li>文本文件</li>
</ol>
<p>文本文件存储的是普通“字符”文本，python 默认为 unicode 字符集(两个字节表示 一个字符，最多可以表示:65536 个)，可以使用记事本程序打开。但是，像 word 软件 编辑的文档不是文本文件。</p>
<ol start="2">
<li>二进制文件</li>
</ol>
<p>二进制文件把数据内容用“字节”进行存储，无法用记事本打开。必须使用专用的软件 解码。常见的有:MP4 视频文件、MP3 音频文件、JPG 图片、doc 文档等等。</p>
<h2 id="文件操作相关模块概述"><a href="#文件操作相关模块概述" class="headerlink" title="文件操作相关模块概述"></a><strong>文件操作相关模块概述</strong></h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>io 模块</td>
<td>文件流的输入和输出操作 input output</td>
</tr>
<tr>
<td>os 模块</td>
<td>基本操作系统功能，包括文件操作</td>
</tr>
<tr>
<td>glob 模块</td>
<td><code>查找符合特定规则的文件路径名</code></td>
</tr>
<tr>
<td>fnmatch 模块</td>
<td><code>使用模式来匹配文件路径名</code></td>
</tr>
<tr>
<td>fileinput 模块</td>
<td>处理多个输入文件</td>
</tr>
<tr>
<td>filecmp 模块</td>
<td>用于文件的比较</td>
</tr>
<tr>
<td>cvs 模块</td>
<td>用于 csv 文件处理</td>
</tr>
<tr>
<td>pickle 和 cPickle</td>
<td>用于序列化和反序列化</td>
</tr>
<tr>
<td>xml 包</td>
<td>用于 XML 数据处理</td>
</tr>
<tr>
<td>bz2、gzip、zipfile、zlib、tarfile</td>
<td><code>用于处理压缩和解压缩文件(分别对应不同的算法)</code></td>
</tr>
</tbody></table>
<h2 id="创建文件对象-open"><a href="#创建文件对象-open" class="headerlink" title="创建文件对象 open()"></a><strong>创建文件对象 open()</strong></h2><p>open()函数用于创建文件对象，基本语法格式如下: open(文件名[,打开方式])</p>
<p>如果只是文件名，代表在当前目录下的文件。文件名可以录入全路径，比如:D:\a\b.txt。</p>
<h3 id="为了减少“-”的输入，可以使用原始字符串-r-“d-b-txt”。"><a href="#为了减少“-”的输入，可以使用原始字符串-r-“d-b-txt”。" class="headerlink" title="为了减少“\”的输入，可以使用原始字符串:r “d:\b.txt”。"></a>为了减少“\”的输入，可以使用原始字符串:r “d:\b.txt”。</h3><h3 id="示例如下"><a href="#示例如下" class="headerlink" title="示例如下:"></a>示例如下:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f &#x3D; open(r&quot;d:\b.txt&quot;,&quot;w&quot;)</span><br></pre></td></tr></table></figure>

<p>打开方式有如下几种:</p>
<p>模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> r 读 read 模式</span><br><span class="line"></span><br><span class="line">w 写 write 模式。如果文件不存在则创建;如果文件存在，则重写新内容;</span><br><span class="line"></span><br><span class="line">a 追加 append 模式。如果文件不存在则创建;如果文件存在，则在文件末尾追加内容</span><br><span class="line"></span><br><span class="line">b 二进制 binary 模式(可与其他模式组合使用)</span><br><span class="line"></span><br><span class="line">+ 读、写模式(可与其他模式组合使用)</span><br></pre></td></tr></table></figure>

<p>文本文件对象和二进制文件对象的创建: 如果我们没有增加模式“b”，则默认创建的是文本文件对象，处理的基本单元是“字符”。如果是二进制模式“b”，则创建的是二进制文件对象，处理的基本单元是“字节”。</p>
<h2 id="文本文件的写入"><a href="#文本文件的写入" class="headerlink" title="文本文件的写入"></a><strong>文本文件的写入</strong></h2><p><strong>基本的文件写入操作</strong></p>
<p>文本文件的写入一般就是三个步骤: </p>
<ol>
<li>创建文件对象</li>
<li>写入数据</li>
<li>关闭文件对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">r"a.txt"</span>,<span class="string">"a"</span>) </span><br><span class="line">s = <span class="string">"itbaizhan\nsxt\n"</span> </span><br><span class="line">f.write(s)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h2 id="常用编码介绍"><a href="#常用编码介绍" class="headerlink" title="常用编码介绍"></a><strong>常用编码介绍</strong></h2><p>在操作文本文件时，经常会操作中文，这时候就经常会碰到乱码问题。</p>
<h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a><strong>ASCII</strong></h3><p>全称为 American Standard Code for Information Interchange，美国信 息交换标准代码，这是世界上最早最通用的单字节编码系统，主要用来显示现代 英语及其他西欧语言。</p>
<p>ASCII 码用 7 位表示，只能表示 128 个字符。只定义了 27=128 个字符，用 7bit 即可完全编码，而一字节 8bit 的容量是 256，所以一字节 ASCII 的编码最 高位总是 0。</p>
<p>0<del>31 表示控制字符如回车、退格、删除等;32</del>126 表示打印字符即可以 通过键盘输入并且能显示出来的字符;其中 48<del>57 为 0 到 9 十个阿拉伯数字， 65</del>90 为 26 个大写英文字母，97~122 号为 26 个小写英文字母，其余为一 些标点符号、运算符号等，具体可以参考 ASCII 标准表(大家自行百度，不在此 赘述)。</p>
<h3 id="ISO8859-1"><a href="#ISO8859-1" class="headerlink" title="ISO8859-1"></a><strong>ISO8859-1</strong></h3><p>ISO-8859-1 又称 Latin-1，是一个 8 位单字节字符集，它把 ASCII 的最高 位也利用起来，并兼容了 ASCII，新增的空间是 128，但它并没有完全用完。</p>
<p>在 ASCII 编码之上又增加了西欧语言、希腊语、泰语、阿拉伯语、希伯来语 对应的文字符号，它是向下兼容 ASCII 编码</p>
<h3 id="GB2312-GBK-GB18030"><a href="#GB2312-GBK-GB18030" class="headerlink" title="GB2312,GBK,GB18030"></a><strong>GB2312,GBK,GB18030</strong></h3><h4 id="·GB2312"><a href="#·GB2312" class="headerlink" title="·GB2312"></a><strong>·GB2312</strong></h4><p>GB2312 全称为信息交换用汉字编码字符集，是中国于 1980 年发布，主要 用于计算机系统中的汉字处理。GB2312 主要收录了 6763 个汉字、682 个符号。</p>
<p>GB2312 覆盖了汉字的大部分使用率，但不能处理像古汉语等特殊的罕用字， 所以后来出现了像 GBK、GB18030 这种编码。</p>
<p><strong>GB2312 完全兼容 ISO8859-1。</strong></p>
<h4 id="·GBK"><a href="#·GBK" class="headerlink" title="·GBK"></a><strong>·GBK</strong></h4><p>全称为 Chinese Internal Code Specification，即汉字内码扩展规范，于 1995 年制定。 它主要是扩展了 GB2312，在它的基础上又加了更多的汉字，它一共收录了 21003 个汉字</p>
<h4 id="·GB18030"><a href="#·GB18030" class="headerlink" title="·GB18030"></a><strong>·GB18030</strong></h4><p>现在最新的内码字集于 2000 年发布，并于 2001 年强制执行，包含了中国大部分少数 民族的语言字符，收录汉字数超过 70000 余个。</p>
<p>它主要采用单字节、双字节、四字节对字符编码，它是向下兼容 GB2312 和 GBK 的， 虽然是我国的强制使用标准，但在实际生产中很少用到，用得最多的反而是 GBK 和 GB2312</p>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a><strong>Unicode</strong></h3><p>Unicode 编码设计成了固定两个字节，所有的字符都用 16 位(2^16=65536) 表示，包括之前只占 8 位的英文字符等，所以会造成空间的浪费，UNICODE 在 很长的一段时间内都没有得到推广应用。</p>
<p>6</p>
<p>北京尚学堂·百战程序员 高淇的 python400 集:从零打好内功，直达手写神经网络 Unicode 完全重新设计，不兼容 iso8859-1，也不兼容任何其他编码。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a><strong>UTF-8</strong></h3><p>对于英文字母，unicode 也需要两个字节来表示。所以 unicode 不便 于传输和存储。因此而产生了 UTF 编码，UTF-8 全称是(8-bit Unicode Transformation Format)。</p>
<p>UTF 编码兼容 iso8859-1 编码，同时也可以用来表示所有语言的字符， 不过，UTF 编码是不定长编码，每一个字符的长度从 1-4 个字节不等。其中， 英文字母都是用一个字节表示，而汉字使用三个字节。</p>
<p>【老鸟建议】一般项目都会使用 UTF-8。unicode 中虽然汉字是两个字节， UTF-8 中汉字是 3 个字节。但是互联网中一个网页也包含了大量的英文字母， 这些英文字母只占用 1 个字节，整体占用空间，UTF-8 仍然由于 Unicode。</p>
<h2 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a><strong>中文乱码问题</strong></h2><p>windows 操作系统默认的编码是 GBK，Linux 操作系统默认的编码是 UTF-8。当我们 用 open()时，调用的是操作系统打开的文件，默认的编码是 GBK。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在文件编辑区单击右键，选择 FileEncoding，选择 GBK 即可:</span><br></pre></td></tr></table></figure>

<h2 id="write-writelines-写入数据"><a href="#write-writelines-写入数据" class="headerlink" title="write()/writelines()写入数据"></a><strong>write()/writelines()写入数据</strong></h2><p>write(a):把字符串 a 写入到文件中 </p>
<p>writelines(b):把字符串列表写入文件中，不添加换行符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">r"d:\bb.txt"</span>,<span class="string">"w"</span>,encoding=<span class="string">"utf-8"</span>) </span><br><span class="line">s = [<span class="string">"高淇\n"</span>,<span class="string">"高老三\n"</span>,<span class="string">"高老四\n"</span>] </span><br><span class="line">f.writelines(s)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h2 id="close-关闭文件流"><a href="#close-关闭文件流" class="headerlink" title="close()关闭文件流"></a><strong>close()关闭文件流</strong></h2><p>由于文件底层是由操作系统控制，所以我们打开的文件对象必须显式调用 close()方法 关闭文件对象。当调用 close()方法时，首先会把缓冲区数据写入文件(也可以直接调用 flush() 方法)，再关闭文件，释放文件对象。</p>
<p>为了确保打开的文件对象正常关闭，一般结合异常机制的 finally 或者 with 关键字实现 无论何种情况都能关闭打开的文件对象。</p>
<p>结合异常机制 finally 确保关闭文件对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	f = open(<span class="string">r"my01.txt"</span>,<span class="string">"a"</span>) </span><br><span class="line">  str = <span class="string">"gaoqi"</span></span><br><span class="line">	f.write(str)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e: </span><br><span class="line">  print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  f.close()</span><br></pre></td></tr></table></figure>

<h2 id="with-语句-上下文管理器"><a href="#with-语句-上下文管理器" class="headerlink" title="with 语句(上下文管理器)"></a><strong>with 语句(上下文管理器)</strong></h2><p>with 关键字(上下文管理器)可以自动管理上下文资源，不论什么原因跳出 with 块，都能 确保文件正确的关闭，并且可以在代码块执行完毕后自动还原进入该代码块时的现场。</p>
<p>使用 with 管理文件写入操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="string">"高淇\n"</span>,<span class="string">"高老三\n"</span>,<span class="string">"高老五\n"</span>]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"d:\bb.txt"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">	f.writelines(s)</span><br></pre></td></tr></table></figure>

<h2 id="文本文件的读取"><a href="#文本文件的读取" class="headerlink" title="文本文件的读取"></a><strong>文本文件的读取</strong></h2><p>文件的读取一般使用如下三个方法: 1. read([size])</p>
<p>从文件中读取 size 个字符，并作为结果返回。如果没有 size 参数，则读取整个文件。</p>
<p>读取到文件末尾，会返回空字符串。 2. readline()</p>
<p>读取一行内容作为结果返回。读取到文件末尾，会返回空字符串。 3. readlines()</p>
<p>文本文件中，每一行作为一个字符串存入列表中，返回该列表</p>
<p>读取一个文件前 4 个字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(r&quot;bb&quot;,&quot;r&quot;,encoding&#x3D;&quot;utf-8&quot;) as f: </span><br><span class="line">	print(f.read(4))</span><br></pre></td></tr></table></figure>

<p>文件较小，一次将文件内容读入到程序中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(r&quot;d:\bb.txt&quot;,&quot;r&quot;) as f: </span><br><span class="line">	print(f.read())</span><br></pre></td></tr></table></figure>

<p>按行读取一个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with open(r&quot;bb.txt&quot;,&quot;r&quot;) as f: </span><br><span class="line">	while True:</span><br><span class="line">		fragment &#x3D; f.readline() </span><br><span class="line">		if not fragment:</span><br><span class="line">			break </span><br><span class="line">		else:</span><br><span class="line">			print(fragment,end&#x3D;&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p>使用迭代器(每次返回一行)读取文本文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(r&quot;d:\bb.txt&quot;,&quot;r&quot;) as f: </span><br><span class="line">	for a in f:</span><br><span class="line">		print(a,end&#x3D;&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p>为文本文件每一行的末尾增加行号</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"e.txt"</span>,<span class="string">"r"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f: </span><br><span class="line">  lines = f.readlines()</span><br><span class="line">  lines = [ line.rstrip()+<span class="string">" #"</span>+str(index+<span class="number">1</span>)+<span class="string">"\n"</span> <span class="keyword">for</span> index,line <span class="keyword">in</span> enumerate(lines)] <span class="comment">#推导式生成列表</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"e.txt"</span>,<span class="string">"w"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f: </span><br><span class="line">  f.writelines(lines)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">执行前文件内容:</span><br><span class="line">我 love u! </span><br><span class="line">尚学堂 </span><br><span class="line">百战程序员</span><br><span class="line">执行程序后文件内容:</span><br><span class="line">我 love u! #1 </span><br><span class="line">尚学堂 #2 </span><br><span class="line">百战程序员 #3</span><br></pre></td></tr></table></figure>

<p><strong>二进制文件的读取和写入</strong></p>
<p>二进制文件的处理流程和文本文件流程一致。首先还是要创建文件对象，不过，我们需要指 定二进制模式，从而创建出二进制文件对象。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f &#x3D; open(r&quot;d:\a.txt&quot;, &#39;wb&#39;) #可写的、重写模式的二进制文件对象</span><br><span class="line">f &#x3D; open(r&quot;d:\a.txt&quot;, &#39;ab&#39;)  #可写的、追加模式的二进制文件对象</span><br><span class="line">f &#x3D; open(r&quot;d:\a.txt&quot;, &#39;rb&#39;) #可读的二进制文件对象</span><br></pre></td></tr></table></figure>

<p>创建好二进制文件对象后，仍然可以使用 write()、read()实现文件的读写操作。</p>
<p>读取图片文件，实现文件的拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with open(&#39;aa.gif&#39;, &#39;rb&#39;) as f:</span><br><span class="line">	with open(&#39;aa_copy.gif&#39;, &#39;wb&#39;) as w:</span><br><span class="line">		for line in f.readlines():</span><br><span class="line">    w.write(line)</span><br><span class="line">print(&#39;图片拷贝完成!&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="文件对象的常用属性和方法"><a href="#文件对象的常用属性和方法" class="headerlink" title="文件对象的常用属性和方法"></a>文件对象的常用属性和方法</h2><p>文件对象封装了文件相关的操作。在前面我们学习了通过文件对象对文件进行读写操作。本 节我们详细列出文件对象的常用属性和方法，并进行说明。</p>
<p>文件对象的属性<br> 属性                                                说明</p>
<table>
<thead>
<tr>
<th>name</th>
<th>返回文件的名字</th>
</tr>
</thead>
<tbody><tr>
<td>mode</td>
<td>返回文件的打开模式</td>
</tr>
<tr>
<td>closed</td>
<td>若文件被关闭则返回 True</td>
</tr>
</tbody></table>
<p>文件对象的打开模式</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读模式</td>
</tr>
<tr>
<td>w</td>
<td>写模式</td>
</tr>
<tr>
<td>a</td>
<td>追加模式</td>
</tr>
<tr>
<td>b</td>
<td><code>二进制模式(可与其他模式组合)</code></td>
</tr>
<tr>
<td>+</td>
<td><code>读写模式(可以其他模式组合)</code></td>
</tr>
</tbody></table>
<p>文件对象的常用方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>read([size])</td>
<td>从文件中读取 size 个字节或字符的内容返回。若省略[size]，则读 取到文件末尾，即一次读取文件所有内容</td>
</tr>
<tr>
<td>readline()</td>
<td>从文本文件中读取一行内容</td>
</tr>
<tr>
<td>readlines()</td>
<td>把文本文件中每一行都作为独立的字符串对象，并将这些对象放入 列表返回</td>
</tr>
<tr>
<td>write(str)</td>
<td>将字符串 str 内容写入文件</td>
</tr>
<tr>
<td>writelines(s)</td>
<td>将字符串列表 s 写入文件文件，不添加换行符</td>
</tr>
<tr>
<td>seek(offset ,whence])</td>
<td>把文件指针移动到新的位置，offset 表示相对于 whence 的多少个 字节的偏移量; offset:                                 off 为正往结束方向移动，为负往开始方向移动 whence 不同的值代表不同含义:  0: 从文件头开始计算(默认值) 1:从当前位置开始计算  2:从文件尾开始计算</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>tell()</td>
<td>返回文件指针的当前位置</td>
</tr>
<tr>
<td>truncate([size])</td>
<td>不论指针在什么位置，只留下指针前 size 个字节的内容，其余全 部删除;  如果没有传入 size，则当指针当前位置到文件末尾内容全部删除</td>
</tr>
<tr>
<td>flush()</td>
<td>把缓冲区的内容写入文件，但不关闭文件</td>
</tr>
<tr>
<td>close()</td>
<td>把缓冲区内容写入文件，同时关闭文件，释放文件对象相关资源</td>
</tr>
</tbody></table>
<h2 id="文件任意位置操作"><a href="#文件任意位置操作" class="headerlink" title="文件任意位置操作"></a><strong>文件任意位置操作</strong></h2><p>seek()移动文件指针示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;e.txt&quot;,&quot;r&quot;,encoding&#x3D;&quot;utf-8&quot;) as f: </span><br><span class="line">	print(&quot;文件名是:&#123;0&#125;&quot;.format(f.name)) </span><br><span class="line">	print(f.tell())</span><br><span class="line">	print(&quot;读取的内容:&#123;0&#125;&quot;.format(str(f.readline()))) </span><br><span class="line">	print(f.tell())</span><br><span class="line">	f.seek(0,0) </span><br><span class="line">	print(&quot;读取的内容:&#123;0&#125;&quot;.format(str(f.readline())))</span><br></pre></td></tr></table></figure>

<h2 id="使用-pickle-序列化"><a href="#使用-pickle-序列化" class="headerlink" title="使用 pickle 序列化"></a><strong>使用 pickle 序列化</strong></h2><p>Python 中，一切皆对象，对象本质上就是一个“存储数据的内存块”。有时候，我们 需要将“内存块的数据”保存到硬盘上，或者通过网络传输到其他的计算机上。这时候，就 需要“对象的序列化和反序列化”。 对象的序列化机制广泛的应用在分布式、并行系统上。</p>
<p>序列化指的是:将对象转化成“串行化”数据形式，存储到硬盘或通过网络传输到其他 地方。反序列化是指相反的过程，将读取到的“串行化数据”转化成对象。</p>
<p>我们可以使用 pickle 模块中的函数，实现序列化和反序列操作。</p>
<p>序列化我们使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> pickle.dump(obj, file) obj 就是要被序列化的对象，file 指的是存储的文件</span><br><span class="line">pickle.load(file) 从 file 读取数据，反序列化成对象</span><br></pre></td></tr></table></figure>

<p>1.序列化是指把对象转换为字节序列的过程，而反序列化是指把字节序列恢复为对象的过程</p>
<p>2.对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。</p>
<p>3.序列化机制的核心作用就是对象状态的保存与重建。</p>
<p>4.反序列化就是客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p>
<p>5.序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态。</p>
<p>6.序列化算法一般会按步骤做如下事情：</p>
<p>（1）将对象实例相关的类元数据输出。<br>（2）递归地输出类的超类描述直到不再有超类。<br>（3）类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。<br>（4）从上至下递归输出实例的数据</p>
<p>7.序列化的好处：</p>
<p>一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），</p>
<p>二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。</p>
<h4 id="对象序列化到文件中-反序列化"><a href="#对象序列化到文件中-反序列化" class="headerlink" title="对象序列化到文件中,反序列化"></a>对象序列化到文件中,反序列化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"d:\data.dat"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> f:<span class="comment">#序列化</span></span><br><span class="line">  a1=<span class="string">"nihao"</span></span><br><span class="line">  a2=<span class="string">"223"</span></span><br><span class="line">  pickle.dump(a1,f)</span><br><span class="line">  pickle.dump(a2,f)</span><br><span class="line"> <span class="comment">#反序列化</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"d:\data.dat"</span>,<span class="string">"rb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">  a1 = pickle.load(f)</span><br><span class="line">  a2 = pickle.load(f)</span><br><span class="line">  print(a1);print(a2)</span><br><span class="line">  <span class="comment">#打印出：nihao</span></span><br><span class="line">          <span class="number">223</span></span><br></pre></td></tr></table></figure>

<h2 id="CSV-文件的操作"><a href="#CSV-文件的操作" class="headerlink" title="CSV 文件的操作"></a><strong>CSV 文件的操作</strong></h2><p>csv(Comma Separated Values)是逗号分隔符文本格式，常用于数据交换、Excel 文件和数据库数据的导入和导出。与 Excel 文件不同，CSV 文件中:</p>
<p>值没有类型，所有值都是字符串 不能指定字体颜色等样式 不能指定单元格的宽高，不能合并单元格，没有多个工作表</p>
<p>不能嵌入图像图表</p>
<h3 id="csv-reader-对象和-csv-文件读取"><a href="#csv-reader-对象和-csv-文件读取" class="headerlink" title="csv.reader 对象和 csv 文件读取"></a><strong>csv.reader 对象和 csv 文件读取</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"d:\a.csv"</span>) <span class="keyword">as</span> a:</span><br><span class="line">	a_csv = csv.reader(a) <span class="comment">#创建 csv 对象,它是一个包含所有数据的列表，每一行为一个元素</span></span><br><span class="line">  headers = next(a_csv) <span class="comment">#获得列表对象，包含标题行的信息</span></span><br><span class="line">  print(headers)</span><br><span class="line">	<span class="keyword">for</span> row <span class="keyword">in</span> a_csv:<span class="comment">#循环打印各行内容</span></span><br><span class="line">		print(row)</span><br><span class="line">    <span class="comment">#['高老三', '19', '测试工程师', '20000'] </span></span><br><span class="line">    [<span class="string">'高老五'</span>, <span class="string">'20'</span>, <span class="string">'人工智能开发'</span>, <span class="string">'50000'</span>]</span><br></pre></td></tr></table></figure>

<h3 id="csv-writer-对象和-csv-文件写入"><a href="#csv-writer-对象和-csv-文件写入" class="headerlink" title="csv.writer 对象和 csv 文件写入"></a><strong>csv.writer 对象和 csv 文件写入</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">headers = [<span class="string">"工号"</span>,<span class="string">"姓名"</span>,<span class="string">"年龄"</span>,<span class="string">"地址"</span>,<span class="string">"月薪"</span>]</span><br><span class="line">rows = [(<span class="string">"1001"</span>,<span class="string">"高淇"</span>,<span class="number">18</span>,<span class="string">"西三旗 1 号院"</span>,<span class="string">"50000"</span>),(<span class="string">"1002"</span>,<span class="string">"高八"</span>,<span class="number">19</span>,<span class="string">"西三旗 1 号院"</span>,<span class="string">"30000"</span>)] </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"d:\b.csv"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> b:</span><br><span class="line">	b_csv = csv.writer(b) <span class="comment">#创建 csv 对象</span></span><br><span class="line">	b_csv.writerow(headers) <span class="comment">#写入一行(标题)</span></span><br><span class="line">	b_csv.writerows(rows)  <span class="comment">#写入多行(数据)</span></span><br><span class="line">```</span><br><span class="line">执行结果:</span><br><span class="line">工号,姓名,年龄,地址,月薪 </span><br><span class="line"><span class="number">1001</span>,高淇,<span class="number">18</span>,西三旗 <span class="number">1</span> 号院,<span class="number">50000</span> </span><br><span class="line"><span class="number">1002</span>,高八,<span class="number">19</span>,西三旗 <span class="number">1</span> 号院,<span class="number">30000</span></span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="os-和-os-path-模块"><a href="#os-和-os-path-模块" class="headerlink" title="os 和 os.path 模块"></a><strong>os 和 os.path 模块</strong></h2><p>os 模块可以帮助我们直接对操作系统进行操作。我们可以直接调用操作系统的可执行 文件、命令，直接操作文件、目录等等。在系统运维的核心基础。</p>
<p>**os 模块-调用操作系统命令</p>
<h3 id="·os-system-可以帮助我们直接调用系统的命令"><a href="#·os-system-可以帮助我们直接调用系统的命令" class="headerlink" title="** ·os.system 可以帮助我们直接调用系统的命令"></a>** <strong>·os.system 可以帮助我们直接调用系统的命令</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import os </span><br><span class="line">os.system(&quot;notepad.exe&quot;)#os.system 调用 windows 系统的记事本程序</span><br><span class="line">import os</span><br><span class="line">os.system(&quot;ping www.baidu.com&quot;)#os.system 调用 windows 系统中 ping 命令</span><br><span class="line">import os</span><br><span class="line">os.startfile(r&quot;C:\Program Files (x86)\Tencent\WeChat\WeChat.exe&quot;)#运行安装好的微信</span><br></pre></td></tr></table></figure>

<p><strong>【注】</strong>Linux 是命令行操作更容易，我们可以通过 os.system 可以更加容易的调用相关的命 令;</p>
<p>【注】控制台输出中文可能会有乱码问题，可以在 file–&gt;setting 中设置</p>
<p><strong>os.startfile:直接调用可执行文件</strong></p>
<p><strong>os 模块-文件和目录操作</strong></p>
<p>我们可以通过前面讲的文件对象实现对于文件内容的读写操作。如果，还需要对文件和 目录做其他操作，可以使用 os 和 os.path 模块。</p>
<p>os 模块下常用操作文件的方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>remove(path)</td>
<td>删除指定的文件</td>
</tr>
<tr>
<td>rename(src,dest)</td>
<td>重命名文件或目录</td>
</tr>
<tr>
<td>stat(path)</td>
<td>返回文件的所有属性</td>
</tr>
<tr>
<td>listdir(path)</td>
<td>返回 path 目录下的文件和目录列表</td>
</tr>
</tbody></table>
<p>os 模块下关于目录操作的相关方法，汇总如下:</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>mkdir(path)</td>
<td>创建目录</td>
</tr>
<tr>
<td>makedirs(path1/path2/path3/… )</td>
<td>创建多级目录</td>
</tr>
<tr>
<td>rmdir(path)</td>
<td>删除目录</td>
</tr>
<tr>
<td>removedirs(path1/path2…)</td>
<td>删除多级目录</td>
</tr>
<tr>
<td>getcwd()</td>
<td>返回当前工作目录:current work dir</td>
</tr>
<tr>
<td>chdir(path)</td>
<td>把 path 设为当前工作目录</td>
</tr>
<tr>
<td>walk()</td>
<td>遍历目录树</td>
</tr>
<tr>
<td>sep</td>
<td><code>当前操作系统所使用的路径分隔符</code></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/01/rsa%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/01/rsa%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">rsa加密算法详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-01 14:12:10 / Modified: 14:25:12" itemprop="dateCreated datePublished" datetime="2020-05-01T14:12:10-05:00">2020-05-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们日常传输数据想防止hacker的攻击，需要加密算法，常见的：对称加密，非对称加密，对称加密相对于交易双方有相同钥匙，但是任意一方被黑，两方都有危险，而非对称加密，最经典的rsa解决了这个问题。</p>
<p>rsa算法原理：</p>
<p>首先找出两个质数 p和q</p>
<p>计算   n = p * q</p>
<p>φ(n) = (p-1)  * (q-1)      这个函数又叫欧拉函数</p>
<p>公钥e    1 &lt; e &lt; φ(n)   在这个范围取出一个整数，并且 e 和 φ(n) 互质</p>
<p>私钥d    (e * d ) / φ(n)  = x  ······ 1       (x是几无所谓，余数必须是1，比如 φ(n)是20 e是3 那么d就是7)</p>
<p> 加密  m^e / n =x  ······  c     (这几个x都代表任意数的商，在这里面没有直接意义，可以忽略不看，这三个x也都不相等)</p>
<p> 解密  c^d  / n =x   ······ m   (可以从数学上证明，经过这一系列的计算，得到结果的余数一定是m)<br>————————————————<br>版权声明：本文为CSDN博主「狱蝶阿一」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_42510528/java/article/details/80765361" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42510528/java/article/details/80765361</a></p>
<p><strong>一、RSA加密简介</strong>（ssh典型用此算法）</p>
<p>　　RSA加密是一种非对称加密。可以在不直接传递密钥的情况下，完成解密。这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。是由一对密钥来进行加解密的过程，分别称为公钥和私钥。两者之间有数学相关，该加密算法的原理就是对一极大整数做因数分解的困难性来保证安全性。通常个人保存私钥，公钥是公开的（可能同时多人持有）。</p>
<p>　　</p>
<p><strong>二、RSA加密、签名区别</strong></p>
<p>　　加密和签名都是为了安全性考虑，但略有不同。常有人问加密和签名是用私钥还是公钥？其实都是对加密和签名的作用有所混淆。简单的说，加密是为了防止信息被泄露，而签名是为了防止信息被篡改。这里举2个例子说明。</p>
<p><strong>第一个场景</strong>：战场上，B要给A传递一条消息，内容为某一指令。</p>
<p>RSA的加密过程如下：</p>
<p>（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。</p>
<p>（2）A传递自己的公钥给B，B用A的公钥对消息进行加密。</p>
<p>（3）A接收到B加密的消息，利用A自己的私钥对消息进行解密。</p>
<p>　　在这个过程中，只有2次传递过程，第一次是A传递公钥给B，第二次是B传递加密消息给A，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行解密，防止了消息内容的泄露。</p>
<p>所以.ssh文件中私钥千万别动，那是你唯一救命稻草。但是公钥随便给别人。 </p>
<p><strong>第二个场景：</strong>A收到B发的消息后，需要进行回复“收到”。</p>
<p>RSA签名的过程如下：</p>
<p>（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。</p>
<p>（2）A用自己的私钥对消息加签，形成签名，并将加签的消息和消息本身一起传递给B。</p>
<p>（3）B收到消息后，在获取A的公钥进行验签，如果验签出来的内容与消息本身一致，证明消息是A回复的。</p>
<p>　　在这个过程中，只有2次传递过程，第一次是A传递加签的消息和消息本身给B，第二次是B获取A的公钥，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行签名，即使知道了消息内容，也无法伪造带签名的回复给B，防止了消息内容的篡改。</p>
<p>　　但是，综合两个场景你会发现，第一个场景虽然被截获的消息没有泄露，但是可以利用截获的公钥，将假指令进行加密，然后传递给A。第二个场景虽然截获的消息不能被篡改，但是消息的内容可以利用公钥验签来获得，并不能防止泄露。所以在实际应用中，要根据情况使用，也可以同时使用加密和签名，比如A和B都有一套自己的公钥和私钥，当A要给B发送消息时，先用B的公钥对消息加密，再对加密的消息使用A的私钥加签名，达到既不泄露也不被篡改，更能保证消息的安全性。</p>
<p>　　<strong>总结：公钥加密、私钥解密、私钥签名、公钥验签。</strong></p>
<p><strong>三、RSA加密、签名的方法，代码例子如下：</strong></p>
<p>java实现此算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">  1 import java.io.ByteArrayOutputStream;&#x2F;&#x2F;都是javase6以后的包</span><br><span class="line">  2 import java.security.KeyFactory;</span><br><span class="line">  3 import java.security.KeyPair;</span><br><span class="line">  4 import java.security.KeyPairGenerator;</span><br><span class="line">  5 import java.security.PrivateKey;</span><br><span class="line">  6 import java.security.PublicKey;</span><br><span class="line">  7 import java.security.Signature;</span><br><span class="line">  8 import java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line">  9 import java.security.spec.X509EncodedKeySpec;</span><br><span class="line"> 10 import javax.crypto.Cipher;</span><br><span class="line"> 11 import org.apache.commons.codec.binary.Base64;</span><br><span class="line"> 12 </span><br><span class="line"> 13 public class TestRSA &#123;</span><br><span class="line"> 14 </span><br><span class="line"> 15     &#x2F;**</span><br><span class="line"> 16      * RSA最大加密明文大小</span><br><span class="line"> 17      *&#x2F;</span><br><span class="line"> 18     private static final int MAX_ENCRYPT_BLOCK &#x3D; 117;</span><br><span class="line"> 19 </span><br><span class="line"> 20     &#x2F;**</span><br><span class="line"> 21      * RSA最大解密密文大小</span><br><span class="line"> 22      *&#x2F;</span><br><span class="line"> 23     private static final int MAX_DECRYPT_BLOCK &#x3D; 128;</span><br><span class="line"> 24 </span><br><span class="line"> 25     &#x2F;**</span><br><span class="line"> 26      * 获取密钥对</span><br><span class="line"> 27      * </span><br><span class="line"> 28      * @return 密钥对</span><br><span class="line"> 29      *&#x2F;</span><br><span class="line"> 30     public static KeyPair getKeyPair() throws Exception &#123;</span><br><span class="line"> 31         KeyPairGenerator generator &#x3D; KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line"> 32         generator.initialize(1024);</span><br><span class="line"> 33         return generator.generateKeyPair();</span><br><span class="line"> 34     &#125;</span><br><span class="line"> 35 </span><br><span class="line"> 36     &#x2F;**</span><br><span class="line"> 37      * 获取私钥</span><br><span class="line"> 38      * </span><br><span class="line"> 39      * @param privateKey 私钥字符串</span><br><span class="line"> 40      * @return</span><br><span class="line"> 41      *&#x2F;</span><br><span class="line"> 42     public static PrivateKey getPrivateKey(String privateKey) throws Exception &#123;</span><br><span class="line"> 43         KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line"> 44         byte[] decodedKey &#x3D; Base64.decodeBase64(privateKey.getBytes());</span><br><span class="line"> 45         PKCS8EncodedKeySpec keySpec &#x3D; new PKCS8EncodedKeySpec(decodedKey);</span><br><span class="line"> 46         return keyFactory.generatePrivate(keySpec);</span><br><span class="line"> 47     &#125;</span><br><span class="line"> 48 </span><br><span class="line"> 49     &#x2F;**</span><br><span class="line"> 50      * 获取公钥</span><br><span class="line"> 51      * </span><br><span class="line"> 52      * @param publicKey 公钥字符串</span><br><span class="line"> 53      * @return</span><br><span class="line"> 54      *&#x2F;</span><br><span class="line"> 55     public static PublicKey getPublicKey(String publicKey) throws Exception &#123;</span><br><span class="line"> 56         KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line"> 57         byte[] decodedKey &#x3D; Base64.decodeBase64(publicKey.getBytes());</span><br><span class="line"> 58         X509EncodedKeySpec keySpec &#x3D; new X509EncodedKeySpec(decodedKey);</span><br><span class="line"> 59         return keyFactory.generatePublic(keySpec);</span><br><span class="line"> 60     &#125;</span><br><span class="line"> 61     </span><br><span class="line"> 62     &#x2F;**</span><br><span class="line"> 63      * RSA加密</span><br><span class="line"> 64      * </span><br><span class="line"> 65      * @param data 待加密数据</span><br><span class="line"> 66      * @param publicKey 公钥</span><br><span class="line"> 67      * @return</span><br><span class="line"> 68      *&#x2F;</span><br><span class="line"> 69     public static String encrypt(String data, PublicKey publicKey) throws Exception &#123;</span><br><span class="line"> 70         Cipher cipher &#x3D; Cipher.getInstance(&quot;RSA&quot;);</span><br><span class="line"> 71         cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line"> 72         int inputLen &#x3D; data.getBytes().length;</span><br><span class="line"> 73         ByteArrayOutputStream out &#x3D; new ByteArrayOutputStream();</span><br><span class="line"> 74         int offset &#x3D; 0;</span><br><span class="line"> 75         byte[] cache;</span><br><span class="line"> 76         int i &#x3D; 0;</span><br><span class="line"> 77         &#x2F;&#x2F; 对数据分段加密</span><br><span class="line"> 78         while (inputLen - offset &gt; 0) &#123;</span><br><span class="line"> 79             if (inputLen - offset &gt; MAX_ENCRYPT_BLOCK) &#123;</span><br><span class="line"> 80                 cache &#x3D; cipher.doFinal(data.getBytes(), offset, MAX_ENCRYPT_BLOCK);</span><br><span class="line"> 81             &#125; else &#123;</span><br><span class="line"> 82                 cache &#x3D; cipher.doFinal(data.getBytes(), offset, inputLen - offset);</span><br><span class="line"> 83             &#125;</span><br><span class="line"> 84             out.write(cache, 0, cache.length);</span><br><span class="line"> 85             i++;</span><br><span class="line"> 86             offset &#x3D; i * MAX_ENCRYPT_BLOCK;</span><br><span class="line"> 87         &#125;</span><br><span class="line"> 88         byte[] encryptedData &#x3D; out.toByteArray();</span><br><span class="line"> 89         out.close();</span><br><span class="line"> 90         &#x2F;&#x2F; 获取加密内容使用base64进行编码,并以UTF-8为标准转化成字符串</span><br><span class="line"> 91         &#x2F;&#x2F; 加密后的字符串</span><br><span class="line"> 92         return new String(Base64.encodeBase64String(encryptedData));</span><br><span class="line"> 93     &#125;</span><br><span class="line"> 94 </span><br><span class="line"> 95     &#x2F;**</span><br><span class="line"> 96      * RSA解密</span><br><span class="line"> 97      * </span><br><span class="line"> 98      * @param data 待解密数据</span><br><span class="line"> 99      * @param privateKey 私钥</span><br><span class="line">100      * @return</span><br><span class="line">101      *&#x2F;</span><br><span class="line">102     public static String decrypt(String data, PrivateKey privateKey) throws Exception &#123;</span><br><span class="line">103         Cipher cipher &#x3D; Cipher.getInstance(&quot;RSA&quot;);</span><br><span class="line">104         cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">105         byte[] dataBytes &#x3D; Base64.decodeBase64(data);</span><br><span class="line">106         int inputLen &#x3D; dataBytes.length;</span><br><span class="line">107         ByteArrayOutputStream out &#x3D; new ByteArrayOutputStream();</span><br><span class="line">108         int offset &#x3D; 0;</span><br><span class="line">109         byte[] cache;</span><br><span class="line">110         int i &#x3D; 0;</span><br><span class="line">111         &#x2F;&#x2F; 对数据分段解密</span><br><span class="line">112         while (inputLen - offset &gt; 0) &#123;</span><br><span class="line">113             if (inputLen - offset &gt; MAX_DECRYPT_BLOCK) &#123;</span><br><span class="line">114                 cache &#x3D; cipher.doFinal(dataBytes, offset, MAX_DECRYPT_BLOCK);</span><br><span class="line">115             &#125; else &#123;</span><br><span class="line">116                 cache &#x3D; cipher.doFinal(dataBytes, offset, inputLen - offset);</span><br><span class="line">117             &#125;</span><br><span class="line">118             out.write(cache, 0, cache.length);</span><br><span class="line">119             i++;</span><br><span class="line">120             offset &#x3D; i * MAX_DECRYPT_BLOCK;</span><br><span class="line">121         &#125;</span><br><span class="line">122         byte[] decryptedData &#x3D; out.toByteArray();</span><br><span class="line">123         out.close();</span><br><span class="line">124         &#x2F;&#x2F; 解密后的内容 </span><br><span class="line">125         return new String(decryptedData, &quot;UTF-8&quot;);</span><br><span class="line">126     &#125;</span><br><span class="line">127 </span><br><span class="line">128     &#x2F;**</span><br><span class="line">129      * 签名</span><br><span class="line">130      * </span><br><span class="line">131      * @param data 待签名数据</span><br><span class="line">132      * @param privateKey 私钥</span><br><span class="line">133      * @return 签名</span><br><span class="line">134      *&#x2F;</span><br><span class="line">135     public static String sign(String data, PrivateKey privateKey) throws Exception &#123;</span><br><span class="line">136         byte[] keyBytes &#x3D; privateKey.getEncoded();</span><br><span class="line">137         PKCS8EncodedKeySpec keySpec &#x3D; new PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">138         KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line">139         PrivateKey key &#x3D; keyFactory.generatePrivate(keySpec);</span><br><span class="line">140         Signature signature &#x3D; Signature.getInstance(&quot;MD5withRSA&quot;);</span><br><span class="line">141         signature.initSign(key);</span><br><span class="line">142         signature.update(data.getBytes());</span><br><span class="line">143         return new String(Base64.encodeBase64(signature.sign()));</span><br><span class="line">144     &#125;</span><br><span class="line">145 </span><br><span class="line">146     &#x2F;**</span><br><span class="line">147      * 验签</span><br><span class="line">148      * </span><br><span class="line">149      * @param srcData 原始字符串</span><br><span class="line">150      * @param publicKey 公钥</span><br><span class="line">151      * @param sign 签名</span><br><span class="line">152      * @return 是否验签通过</span><br><span class="line">153      *&#x2F;</span><br><span class="line">154     public static boolean verify(String srcData, PublicKey publicKey, String sign) throws Exception &#123;</span><br><span class="line">155         byte[] keyBytes &#x3D; publicKey.getEncoded();</span><br><span class="line">156         X509EncodedKeySpec keySpec &#x3D; new X509EncodedKeySpec(keyBytes);</span><br><span class="line">157         KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line">158         PublicKey key &#x3D; keyFactory.generatePublic(keySpec);</span><br><span class="line">159         Signature signature &#x3D; Signature.getInstance(&quot;MD5withRSA&quot;);</span><br><span class="line">160         signature.initVerify(key);</span><br><span class="line">161         signature.update(srcData.getBytes());</span><br><span class="line">162         return signature.verify(Base64.decodeBase64(sign.getBytes()));</span><br><span class="line">163     &#125;</span><br><span class="line">164 </span><br><span class="line">165     public static void main(String[] args) &#123;</span><br><span class="line">166         try &#123;</span><br><span class="line">167             &#x2F;&#x2F; 生成密钥对</span><br><span class="line">168             KeyPair keyPair &#x3D; getKeyPair();</span><br><span class="line">169             String privateKey &#x3D; new String(Base64.encodeBase64(keyPair.getPrivate().getEncoded()));</span><br><span class="line">170             String publicKey &#x3D; new String(Base64.encodeBase64(keyPair.getPublic().getEncoded()));</span><br><span class="line">171             System.out.println(&quot;私钥:&quot; + privateKey);</span><br><span class="line">172             System.out.println(&quot;公钥:&quot; + publicKey);</span><br><span class="line">173             &#x2F;&#x2F; RSA加密</span><br><span class="line">174             String data &#x3D; &quot;待加密的文字内容&quot;;</span><br><span class="line">175             String encryptData &#x3D; encrypt(data, getPublicKey(publicKey));</span><br><span class="line">176             System.out.println(&quot;加密后内容:&quot; + encryptData);</span><br><span class="line">177             &#x2F;&#x2F; RSA解密</span><br><span class="line">178             String decryptData &#x3D; decrypt(encryptData, getPrivateKey(privateKey));</span><br><span class="line">179             System.out.println(&quot;解密后内容:&quot; + decryptData);</span><br><span class="line">180             </span><br><span class="line">181             &#x2F;&#x2F; RSA签名</span><br><span class="line">182             String sign &#x3D; sign(data, getPrivateKey(privateKey));</span><br><span class="line">183             &#x2F;&#x2F; RSA验签</span><br><span class="line">184             boolean result &#x3D; verify(data, getPublicKey(publicKey), sign);</span><br><span class="line">185             System.out.print(&quot;验签结果:&quot; + result);</span><br><span class="line">186         &#125; catch (Exception e) &#123;</span><br><span class="line">187             e.printStackTrace();</span><br><span class="line">188             System.out.print(&quot;加解密异常&quot;);</span><br><span class="line">189         &#125;</span><br><span class="line">190     &#125;</span><br><span class="line">191 &#125;</span><br></pre></td></tr></table></figure>

<p>　　PS:RSA加密对明文的长度有所限制，规定需加密的明文最大长度=密钥长度-11（单位是字节，即byte），所以在<strong>加密和解密的过程中需要分块进行</strong>。而密钥默认是1024位，即1024位/8位-11=128-11=117字节。所以默认加密前的明文最大长度117字节，解密密文最大长度为128字。那么为啥两者相差11字节呢？是因为RSA加密使用到了填充模式（padding），即内容不足117字节时会自动填满，用到填充模式自然会占用一定的字节，而且这部分字节也是参与加密的。</p>
<p>　　密钥长度的设置就是上面例子的第32行。可自行调整，当然非对称加密随着密钥变长，安全性上升的同时性能也会有所下降。</p>
<p>改编自：<a href="https://www.cnblogs.com/pcheng/p/9629621.html，https://blog.csdn.net/weixin_42510528/java/article/details/80765361" target="_blank" rel="noopener">https://www.cnblogs.com/pcheng/p/9629621.html，https://blog.csdn.net/weixin_42510528/java/article/details/80765361</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/python400%E9%9B%864/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/python400%E9%9B%864/" class="post-title-link" itemprop="url">python400集4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 15:09:31" itemprop="dateCreated datePublished" datetime="2020-04-29T15:09:31-05:00">2020-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-03 20:08:15" itemprop="dateModified" datetime="2020-05-03T20:08:15-05:00">2020-05-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="异常和错误"><a href="#异常和错误" class="headerlink" title="异常和错误"></a>异常和错误</h1><p>软件程序在运行过程中，非常可能遇到刚刚提到的这些问题，我们称之为 异常，英文是:Exception，意思是例外。</p>
<h2 id="异常机制本质"><a href="#异常机制本质" class="headerlink" title="异常机制本质"></a>异常机制本质</h2><p>异常指程序运行过程中出现的非正常现象，例如用户输入错误、除数为零、需 要处理的文件不存在、数组下标越界等。</p>
<p>所谓异常处理，就是指程序在出现问题时依然可以正确的执行剩余的程序，而 不会因为异常而终止程序执行。</p>
<p>python 中，引进了很多用来描述和处理异常的类，称为异常类。异常类定义中 包含了该类异常的信息和对异常进行处理的方法。</p>
<p>python 中内建异常类的继承层次:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseException:所以异常的父类</span><br><span class="line">有4子类：KeyBoardInterrupt, Exception, SystemExit,GeneratorExit</span><br><span class="line">Exception内子类：NameError, ValueError, AttributeError等</span><br></pre></td></tr></table></figure>

<p><strong>python 中一切都是对象，异常也采用对象的方式来处理。处理过程:</strong> </p>
<ol>
<li><p><strong>抛出异常:</strong>在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给解释器。</p>
</li>
<li><p><strong>捕获异常:</strong>解释器得到该异常后，寻找相应的代码来处理该异常。</p>
</li>
</ol>
<p>异常解决的关键:定位</p>
<p>当发生异常时，解释器会报相关的错误信息，并会在控制台打印出相关错误信息。我们 只需按照从上到下的顺序即可追溯(Trackback)错误发生的过程，最终定位引起错误的那一 行代码。</p>
<h2 id="try…-一个except-结构"><a href="#try…-一个except-结构" class="headerlink" title="try… 一个except 结构"></a><strong>try…</strong> 一个<strong>except</strong> 结构</h2><p>try…except 是最常见的异常处理结构。结构如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">	被监控的可能引发异常的语句块</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> BaseException [<span class="keyword">as</span> e]:</span><br><span class="line"></span><br><span class="line">	异常处理语句块</span><br></pre></td></tr></table></figure>

<p>try 块包含着可能引发异常的代码，except 块则用来捕捉和处理发生的异常。执行的时 候，如果 try 块中没有引发异常，则跳过 ecept 块继续执行后续代码;执行的时候，如果 try块中发生了异常，则跳过 try 块中的后续代码，跳到相应的 except 块中处理异常;异常处理 完后，继续执行后续代码。</p>
<p>例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  print(<span class="string">"step1"</span>)</span><br><span class="line">  a=<span class="number">3</span>/<span class="number">0</span></span><br><span class="line">  print(<span class="string">"step2"</span>)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">  print(<span class="string">"step3"</span>)</span><br><span class="line">  print(<span class="string">"e"</span>)</span><br><span class="line">print(<span class="string">"step4"</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">step1</span><br><span class="line">step3</span><br><span class="line">division by zero </span><br><span class="line">step4</span><br></pre></td></tr></table></figure>

<p>例子2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">  print(&quot;step1&quot;)</span><br><span class="line">  a&#x3D;3&#x2F;2</span><br><span class="line">  print(&quot;step2&quot;)</span><br><span class="line">except BaseException as e:</span><br><span class="line">  print(&quot;step3&quot;)</span><br><span class="line">  print(&quot;e&quot;)</span><br><span class="line">print(&quot;step4&quot;)</span><br></pre></td></tr></table></figure>

<p>#结果</p>
<p>step1<br>step2<br>step4</p>
<h2 id="try…多个-except-结构"><a href="#try…多个-except-结构" class="headerlink" title="try…多个 except 结构"></a><strong>try…</strong>多个 <strong>except</strong> 结构</h2><p>上面的结构可以捕获所有的异常，工作中也很常见。但是，从经典理论考虑，一般建议 尽量捕获可能出现的多个异常(按照先子类后父类的顺序)，并且针对性的写出异常处理代 码。为了避免遗漏可能出现的异常，可以在最后增加 BaseException。结构如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">	被监控的可能引发异常的语句块</span><br><span class="line">except Exception1:</span><br><span class="line"> 处理 Exception1 的语句块</span><br><span class="line"></span><br><span class="line">except Exception2:</span><br><span class="line"> 处理 Exception2 的语句块</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	a=input(<span class="string">"输入一个被除数："</span>)</span><br><span class="line">	b=input(<span class="string">"输入一个除数："</span>)</span><br><span class="line">  c=float(a)/float(b)</span><br><span class="line">  print(c)</span><br><span class="line"><span class="keyword">except</span> ZeroDicisionError:</span><br><span class="line">  print(<span class="string">"除数不为0"</span>)</span><br><span class="line"><span class="keyword">except</span> TypeError: </span><br><span class="line">  print(<span class="string">"异常:除数和被除数都应该为数值类型"</span>)</span><br><span class="line"><span class="keyword">except</span> NameError: </span><br><span class="line">  print(<span class="string">"异常:变量不存在"</span>)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">    print(type(e)) </span><br><span class="line"> ```</span><br><span class="line">请输入被除数:<span class="number">10</span> </span><br><span class="line">请输入除数:<span class="number">0</span> </span><br><span class="line">异常:除数不能为 <span class="number">0</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="try…except…else-结构"><a href="#try…except…else-结构" class="headerlink" title="try…except…else 结构"></a><strong>try…except…else</strong> 结构</h2><p> try…except…else 结构增加了“else 块”。如果 try 块中没有抛出异常，则执行 else 块。如果</p>
<p>try 块中抛出异常，则执行 except 块，不执行 else 块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发生异常的执行情况(执行 except 块，没有执行 else):</span><br><span class="line"></span><br><span class="line">没有发生异常的执行情况(执行完 try 块后，执行 else):</span><br></pre></td></tr></table></figure>

<h2 id="try…except…finally-结构"><a href="#try…except…finally-结构" class="headerlink" title="try…except…finally 结构"></a><strong>try…except…finally</strong> 结构</h2><p> try…except…finally 结构中，finally 块无论是否发生异常都会被执行;通常用来释放 try 块中申请的资源</p>
<p> finally 中的语句，无论是否发生异常都执行</p>
<p>读取文件，finally 中保证关闭文件资源</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	f = open(<span class="string">"d:/a.txt"</span>,<span class="string">'r'</span>) </span><br><span class="line">  content = f.readline() </span><br><span class="line">  print(content)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	f.close() <span class="comment">#释放资源。此处也可能会发生异常。若发生异常，则程序终止,不会继续往下执行</span></span><br><span class="line">print(<span class="string">"step4"</span>)</span><br><span class="line">```</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">[Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">'d:/a.txt'</span></span><br><span class="line">File <span class="string">"C:/PycharmProjects/mypro_exception/my01.py"</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">f.close() <span class="comment">#释放资源。此处也可能会发生异常。若发生异常，则程序终止,不会继续往下执行</span></span><br><span class="line">NameError: name <span class="string">'f'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined Process finished <span class="keyword">with</span> exit code <span class="number">1</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>需要把f.close也try except</p>
<h2 id="return-语句和异常处理问题"><a href="#return-语句和异常处理问题" class="headerlink" title="return 语句和异常处理问题"></a><strong>return</strong> 语句和异常处理问题</h2><p> 由于 return 有两种作用:结束方法运行、返回值。我们一般不把 return 放到异常处理结构</p>
<p>中，而是放到方法最后。</p>
<h3 id="一般不要将-return-语句放到-try、except、else、finally-块中，会发生一些意想不到的错误。建议放到方法最后。"><a href="#一般不要将-return-语句放到-try、except、else、finally-块中，会发生一些意想不到的错误。建议放到方法最后。" class="headerlink" title="一般不要将 return 语句放到 try、except、else、finally 块中，会发生一些意想不到的错误。建议放到方法最后。"></a>一般不要将 return 语句放到 try、except、else、finally 块中，会发生一些意想不到的错误。建议放到方法最后。</h3><h2 id="常见异常的解决"><a href="#常见异常的解决" class="headerlink" title="常见异常的解决"></a>常见异常的解决</h2><p>Python 中的异常都派生自 BaseException 类</p>
<p>\1. SyntaxError:语法错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D;3 </span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>\2. NameError:尝试访问一个没有申明的变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(a)</span><br><span class="line">NameError: name &#39;a&#39; is not defined</span><br></pre></td></tr></table></figure>

<p>\3. ZeroDivisionError:除数为0错误(零除错误)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 3&#x2F;0</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>

<p>\4. ValueError:数值错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float(&quot;gaoqi&quot;)</span><br><span class="line">ValueError: could not convert string to float: &#39;gaoqi&#39;</span><br></pre></td></tr></table></figure>

<p>\5. TypeError:类型错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123+&quot;abc&quot;</span><br><span class="line">TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;</span><br></pre></td></tr></table></figure>

<p>\6. AttributeError:访问对象的不存在的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.sayhi()</span><br><span class="line">AttributeError: &#39;int&#39; object has no attribute &#39;sayhi&#39;</span><br></pre></td></tr></table></figure>

<p>\7. IndexError:索引越界异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[10]</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure>

<p>\8. KeyError:字典的关键字不存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[&#39;salary&#39;] KeyError: &#39;salary&#39;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>异常名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArithmeticError</code></td>
<td>所有数值计算错误的基类</td>
</tr>
<tr>
<td><code>AssertionError</code></td>
<td>断言语句失败</td>
</tr>
<tr>
<td><code>AttributeError</code></td>
<td>对象没有这个属性</td>
</tr>
<tr>
<td><code>BaseException</code></td>
<td>所有异常的基类</td>
</tr>
<tr>
<td><code>DeprecationWarning</code></td>
<td>关于被弃用的特征的警告</td>
</tr>
<tr>
<td><code>EnvironmentError</code></td>
<td>操作系统错误的基类</td>
</tr>
<tr>
<td>EOFError</td>
<td>没有内建输入,到达 EOF 标记</td>
</tr>
<tr>
<td>Exception</td>
<td>常规错误的基类</td>
</tr>
<tr>
<td><code>FloatingPointError</code></td>
<td>浮点计算错误</td>
</tr>
<tr>
<td><code>FutureWarning</code></td>
<td><code>关于构造将来语义会有改变的警告</code></td>
</tr>
<tr>
<td><code>GeneratorExit</code></td>
<td>生成器(generator)发生异常来通知退出</td>
</tr>
<tr>
<td>ImportError</td>
<td>导入模块/对象失败</td>
</tr>
<tr>
<td><code>IndentationError</code></td>
<td>缩进错误</td>
</tr>
<tr>
<td>IndexError</td>
<td>序列中没有此索引(index)</td>
</tr>
<tr>
<td>IOError</td>
<td>输入/输出操作失败</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>KeyboardInterrupt</code></th>
<th>用户中断执行(通常是输入^C)</th>
</tr>
</thead>
<tbody><tr>
<td>KeyError</td>
<td>映射中没有这个键</td>
</tr>
<tr>
<td>LookupError</td>
<td>无效数据查询的基类</td>
</tr>
<tr>
<td>MemoryError</td>
<td>内存溢出错误(对于 Python 解释器不是致命的)</td>
</tr>
<tr>
<td>NameError</td>
<td>未声明/初始化对象 (没有属性)</td>
</tr>
<tr>
<td><code>NotImplementedError</code></td>
<td>尚未实现的方法</td>
</tr>
<tr>
<td>OSError</td>
<td>操作系统错误</td>
</tr>
<tr>
<td><code>OverflowError</code></td>
<td>数值运算超出最大限制</td>
</tr>
<tr>
<td><code>OverflowWarning</code></td>
<td>旧的关于自动提升为长整型(long)的警告</td>
</tr>
<tr>
<td><code>PendingDeprecationWarning</code></td>
<td><code>关于特性将会被废弃的警告</code></td>
</tr>
<tr>
<td><code>ReferenceError</code></td>
<td>弱引用(Weak reference)试图访问已经垃圾回收了的对象</td>
</tr>
<tr>
<td><code>RuntimeError</code></td>
<td>一般的运行时错误</td>
</tr>
<tr>
<td><code>RuntimeWarning</code></td>
<td>可疑的运行时行为(runtime behavior)的警告</td>
</tr>
<tr>
<td><code>StandardError</code></td>
<td><code>所有的内建标准异常的基类</code></td>
</tr>
<tr>
<td><code>StopIteration</code></td>
<td>迭代器没有更多的值</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>Python 语法错误</td>
</tr>
<tr>
<td><code>SyntaxWarning</code></td>
<td>可疑的语法的警告</td>
</tr>
<tr>
<td>SystemError</td>
<td>一般的解释器系统错误</td>
</tr>
<tr>
<td>SystemExit</td>
<td>解释器请求退出</td>
</tr>
<tr>
<td>TabError</td>
<td>Tab 和空格混用</td>
</tr>
<tr>
<td>TypeError</td>
<td>对类型无效的操作</td>
</tr>
<tr>
<td><code>UnboundLocalError</code></td>
<td>访问未初始化的本地变量</td>
</tr>
<tr>
<td><code>UnicodeDecodeError</code></td>
<td>Unicode 解码时的错误</td>
</tr>
<tr>
<td><code>UnicodeEncodeError</code></td>
<td>Unicode 编码时错误</td>
</tr>
<tr>
<td><code>UnicodeError</code></td>
<td>Unicode 相关的错误</td>
</tr>
<tr>
<td><code>UnicodeTranslateError</code></td>
<td>Unicode 转换时错误</td>
</tr>
<tr>
<td>UserWarning</td>
<td>用户代码生成的警告</td>
</tr>
<tr>
<td>ValueError</td>
<td>传入无效的参数</td>
</tr>
<tr>
<td>Warning</td>
<td>警告的基类</td>
</tr>
<tr>
<td><code>WindowsError</code></td>
<td>系统调用失败</td>
</tr>
<tr>
<td><code>ZeroDivisionError</code></td>
<td>除(或取模)零 (所有数据类型)</td>
</tr>
</tbody></table>
<h2 id="with-上下文管理"><a href="#with-上下文管理" class="headerlink" title="with 上下文管理"></a><strong>with</strong> 上下文管理</h2><p> finally 块由于是否发生异常都会执行，通常我们放释放资源的代码。其实，我们可以通过 with 上下文管理，更方便的实现释放资源的操作。 with 上下文管理的语法结构如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> context_expr [ <span class="keyword">as</span> var]: </span><br><span class="line">	语句块</span><br></pre></td></tr></table></figure>

<p>with 上下文管理可以自动管理资源，在 with 代码块执行完毕后自动还原进入该代码之前的 现场或上下文。不论何种原因跳出 with 块，不论是否有异常，总能保证资源正常释放。极 大的简化了工作，在文件操作、网络通信相关的场合非常常用。</p>
<h3 id="With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发"><a href="#With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发" class="headerlink" title="With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发"></a>With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"d:/bb.txt"</span>) <span class="keyword">as</span> f: </span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">		print(line)</span><br></pre></td></tr></table></figure>

<h2 id="trackback-模块"><a href="#trackback-模块" class="headerlink" title="trackback 模块"></a><strong>trackback</strong> 模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">  print(<span class="string">"step1"</span>)</span><br><span class="line">	num = <span class="number">1</span>/<span class="number">0</span> </span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	traceback.print_exc()</span><br><span class="line">  ```</span><br><span class="line">  step1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/mengxiaowang/Documents/a.py"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    num = <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">  ```</span><br></pre></td></tr></table></figure>

<p>使用 traceback 将异常信息写入日志文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">  print(<span class="string">"step1"</span>)</span><br><span class="line">	num = <span class="number">1</span>/<span class="number">0</span> </span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="keyword">with</span> open(<span class="string">"d:/a.log"</span>,<span class="string">"a"</span>) <span class="keyword">as</span> f: </span><br><span class="line">    traceback.print_exc(file=f)</span><br></pre></td></tr></table></figure>

<h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>程序开发中，有时候我们也需要自己定义异常类。自定义异常类一般都是运行时异常，通常继承 Exception 或其子类即可。命名一般以 Error、Exception 为后缀。</p>
<p> 自定义异常由 raise 语句主动抛出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">classAgeError(Exception): <span class="comment">#继承Exception </span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,errorInfo)</span>:</span></span><br><span class="line">		Exception.__init__(self)</span><br><span class="line">		self.errorInfo = errorInfo </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> str(self.errorInfo)+<span class="string">",年龄错误!应该在 1-150 之间"</span></span><br><span class="line"><span class="comment">############测试代码################</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: <span class="comment">#如果为 True，则模块是作为独立文件运行， 可以执行测试代码</span></span><br><span class="line">	age = int(input(<span class="string">"输入一个年龄:"</span>)) </span><br><span class="line">  	<span class="keyword">if</span> age&lt;<span class="number">1</span> <span class="keyword">or</span> age&gt;<span class="number">150</span>:</span><br><span class="line">    	<span class="keyword">raise</span> AgeError(age)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">			print(<span class="string">"正常的年龄:"</span>,age)</span><br><span class="line">```</span><br><span class="line">输入一个年龄：<span class="number">160</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"C:/Users/Administrator/PycharmProjects/mypro_exception/my10.py"</span>, line <span class="number">16</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"><span class="keyword">raise</span> AgeError(age)</span><br><span class="line">__main__.AgeError: <span class="number">200</span>,年龄错误!应该在 <span class="number">1</span><span class="number">-150</span> 之间</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="if-name-‘main‘-的作用"><a href="#if-name-‘main‘-的作用" class="headerlink" title="if name == ‘main‘:的作用"></a>if <strong>name</strong> == ‘<strong>main</strong>‘:的作用</h2><p>简单说：</p>
<h4 id="在当前执行的程序下（例如当前程序为test-py），如果导入其他模块（other-test-py），则运行程序时other-test-py的if-name-‘main‘-语句判断失败，将不会运行下面的方法。"><a href="#在当前执行的程序下（例如当前程序为test-py），如果导入其他模块（other-test-py），则运行程序时other-test-py的if-name-‘main‘-语句判断失败，将不会运行下面的方法。" class="headerlink" title="在当前执行的程序下（例如当前程序为test.py），如果导入其他模块（other_test.py），则运行程序时other_test.py的if name == ‘main‘ 语句判断失败，将不会运行下面的方法。"></a>在当前执行的程序下（例如当前程序为test.py），如果导入其他模块（other_test.py），则运行程序时other_test.py的if <strong>name</strong> == ‘<strong>main</strong>‘ 语句判断失败，将不会运行下面的方法。</h4><p>也就是说导入的模块的if <strong>name</strong> == ‘<strong>main</strong>‘ 语句下的方法是不会执行的。只会执行当前的if <strong>name</strong> == ‘<strong>main</strong>‘ 下的方法。<br>一个python文件通常有两种使用方法，第一是作为脚本直接执行，第二是 import 到其他的 python 脚本中被调用（模块重用）执行。因此 if <strong>name</strong> == ‘main’: 的作用就是控制这两种情况执行代码的过程，在 if <strong>name</strong> == ‘main’: 下的代码只有在第一种情况下（即文件作为脚本直接执行）才会被执行，而 import 到其他脚本中是不会被执行的。举例说明如下：</p>
<ul>
<li>直接执行</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190510141202522.png" alt="img"></p>
<p><strong>直接执行 test.py，</strong>结果如下图，可以成功 print 两行字符串。即<strong>，if <strong>name</strong>==”<strong>main</strong>“: 语句之前和之后的代码都被执行。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190510141303114.png" alt="img"></p>
<ul>
<li>import 执行</li>
</ul>
<p>然后在同一文件夹新建名称为 import_test.py 的脚本，输入如下代码：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510141602268.png" alt="img"></p>
<p>执行 <strong>import_test.py 脚本</strong>，输出结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510141624918.png" alt="img"></p>
<p>只输出了第一行字符串。即，<strong>if <strong>name</strong>==”<strong>main</strong>“: 之前的语句被执行，之后的没有被执行。</strong></p>
<h3 id="if-name-‘main‘-的运行原理"><a href="#if-name-‘main‘-的运行原理" class="headerlink" title="if name == ‘main‘:的运行原理"></a>if <strong>name</strong> == ‘<strong>main</strong>‘:的运行原理</h3><p><strong>每个python模块</strong>（python文件，也就是此处的 test.py 和 import_test.py）都包含<strong>内置的变量 <strong>name</strong></strong>，当该模块被<strong>直接执行</strong>的时候，<strong><strong>name</strong> 等于文件名（包含后缀 .py ）</strong>；如果该模块 <strong>import</strong> 到其他模块中，<strong>则该模块的 <strong>name</strong> 等于模块名称（不包含后缀.py）。</strong></p>
<p>而 <strong>“<strong>main</strong>” 始终指当前执行模块的名称（包含后缀.py）</strong>。进而当模块被<strong>直接执行</strong>时<strong>，<strong>name</strong> == ‘main’ 结果为真。</strong></p>
<p>为了进一步说明，我们在 test.py 脚本的 if <strong>name</strong>==”<strong>main</strong>“: 之前<strong>加入 print(<strong>name</strong>)，</strong>即将 <strong>name</strong> 打印出来。文件内容和结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510142230219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlcWlhbmc1MjU=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190510142253482.png" alt="img"></p>
<p>可以看出，此时变量<strong><strong>name</strong>的值为”<strong>main</strong>“。</strong></p>
<p>再执行 import_test.py，执行结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510142441889.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190510142452571.png" alt="img"></p>
<p>此时，<strong>test.py中的<strong>name</strong>变量值为 test，</strong>不满足 <strong>name</strong>==”<strong>main</strong>“ 的条件，因此，无法执行其后的代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/python400%E9%9B%863/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/python400%E9%9B%863/" class="post-title-link" itemprop="url">python400集3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 15:09:28" itemprop="dateCreated datePublished" datetime="2020-04-29T15:09:28-05:00">2020-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-01 23:12:23" itemprop="dateModified" datetime="2020-05-01T23:12:23-05:00">2020-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="python面向对象"><a href="#python面向对象" class="headerlink" title="python面向对象"></a>python面向对象</h1><p>类定义数据类型的属性(数据)和方法(行为),也就是说，“类将行为和状态打 包在一起”。</p>
<p>对象是类的具体实体，一般称为“类的实例”。“方法代码是共享的，属性数据不共享”。</p>
<p>定义类的语法格式如下: class 类名:</p>
<p>类体</p>
<p>要点如下:</p>
<ol>
<li><p>类名必须符合“标识符”的规则;一般规定，首字母大写，多个单词使用“驼峰原则”。</p>
<ol start="2">
<li>类体中我们可以定义属性和方法。</li>
<li>. 属性用来描述数据，方法(即函数)用来描述这些数据相关的操作。</li>
</ol>
</li>
</ol>
<h2 id="init构造方法和new方法"><a href="#init构造方法和new方法" class="headerlink" title="init构造方法和new方法"></a><strong><strong>init</strong>构造方法和<strong>new</strong>方法</strong></h2><p>类是抽象的，也称之为“对象的模板”。我们需要通过类这个模板，创建类的实例对象，然 后才能使用类定义的功能。</p>
<p>我们前面说过一个 Python 对象包含三个部分:id(identity 识别码)、type(对象类型)、 value(对象的值)。</p>
<p>现在，我们可以更进一步的说，一个 Python 对象包含如下部分: 1. id(identity 识别码)</p>
<ol start="2">
<li>type(对象类型) 3. value(对象的值)：(1) 属性(attribute) (2) 方法(method)</li>
</ol>
<h4 id="创建对象，我们需要定义构造函数init-方法。构造方法用于执行“实例对象的初始化工-作”，即对象创建后，初始化当前对象的相关属性，无返回值。"><a href="#创建对象，我们需要定义构造函数init-方法。构造方法用于执行“实例对象的初始化工-作”，即对象创建后，初始化当前对象的相关属性，无返回值。" class="headerlink" title="创建对象，我们需要定义构造函数init()方法。构造方法用于执行“实例对象的初始化工 作”，即对象创建后，初始化当前对象的相关属性，无返回值。"></a>创建对象，我们需要定义构造函数<strong>init</strong>()方法。构造方法用于执行“实例对象的初始化工 作”，即对象创建后，初始化当前对象的相关属性，无返回值。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_init_()</span><br></pre></td></tr></table></figure>

<p>的要点如下:<br> \1. 名称固定，必须为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__init__()</span><br></pre></td></tr></table></figure>

<p> \2. 第一个参数固定，必须为:self。 self 指的就是刚刚创建好的实例对象。<br> \3. 构造函数通常用来初始化实例对象的实例属性，如下代码就是初始化实例属性:name 和 score。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,score)</span>:</span></span><br><span class="line">	self.name = name <span class="comment">#实例属性 </span></span><br><span class="line">	self.score = score</span><br></pre></td></tr></table></figure>

<p>\4. 通过“类名(参数列表)”来调用构造函数。调用后，将创建好的对象返回给相应的变量。 比如:s1 = Student(‘张三’, 80)</p>
<p>\5. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__init__()方法:初始化创建好的对象，初始化指的是:“给实例属性赋值”</span><br></pre></td></tr></table></figure>


<p> \6. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__new__()方法: 用于创建对象，但我们一般无需重定义该方法。</span><br></pre></td></tr></table></figure>


<p> \7.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果我们不定义__init__方法，系统会提供一个默认的__init__方法。如果我们定义了带参 的__init__方法，系统不创建默认的__init__方法。</span><br></pre></td></tr></table></figure>

<p>注:<br> \1. Python中的self相当于C++中的self指针，JAVA和C#中的this关键字。Python中， self 必须为构造函数的第一个参数，名字可以任意修改。但一般遵守惯例，都叫做 self。</p>
<h2 id="实例属性和实例方法"><a href="#实例属性和实例方法" class="headerlink" title="实例属性和实例方法"></a>实例属性和实例方法</h2><h3 id="实例属性instance（其实跟java差不多）"><a href="#实例属性instance（其实跟java差不多）" class="headerlink" title="实例属性instance（其实跟java差不多）"></a>实例属性instance（其实跟java差不多）</h3><p>实例属性是从属于实例对象的属性，也称为“实例变量”。他的使用有如下几个要点: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\1. 实例属性一般在__init__()方法中通过如下代码定义:</span><br><span class="line"></span><br><span class="line">self.实例属性名 &#x3D; 初始值</span><br><span class="line"> \2. 在本类的其他实例方法中，也是通过 self 进行访问:</span><br><span class="line"></span><br><span class="line">self.实例属性名</span><br><span class="line"> \3. 创建实例对象后，通过实例对象访问:</span><br><span class="line"></span><br><span class="line">obj01 &#x3D; 类名() #创建对象，调用__init__()初始化属性 </span><br><span class="line">obj01.实例属性名 &#x3D; 值 #可以给已有属性赋值，也可以新加属性</span><br></pre></td></tr></table></figure>



<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a><strong>实例方法</strong></h3><p>实例方法是从属于实例对象的方法。实例方法的定义格式如下: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def 方法名(self [, 形参列表]):</span><br><span class="line">	函数体</span><br><span class="line">方法的调用格式如下:</span><br><span class="line">	对象.方法名([实参列表])</span><br></pre></td></tr></table></figure>



<p>要点:<br> \1. 定义实例方法时，第一个参数必须为 self。和前面一样，self 指当前的实例对象。 2. 调用实例方法时，不需要也不能给 self 传参。self 由解释器自动传参。</p>
<h3 id="·-函数和方法的区别"><a href="#·-函数和方法的区别" class="headerlink" title="· 函数和方法的区别"></a><strong>· 函数和方法的区别</strong></h3><ol>
<li><p>都是用来完成一个功能的语句块，本质一样。</p>
</li>
<li><p>方法调用时，通过对象来调用。方法从属于特定实例对象，普通函数没有这个特点。 </p>
</li>
<li><p>直观上看，方法定义时需要传递 self，函数不需要。</p>
</li>
</ol>
<p><strong>· 实例对象的方法调用本质:</strong></p>
<p><strong>a = Student()</strong></p>
<p><strong>a.say_score()</strong></p>
<p>解释器翻译:</p>
<p><strong>Student.say_score(a)</strong></p>
<p><strong>· 其他操作:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> dir(obj)可以获得对象的所有属性、方法</span><br><span class="line"><span class="number">2.</span>obj.__dict__ 对象的属性字典</span><br><span class="line"><span class="number">3.</span><span class="keyword">pass</span> 空语句</span><br><span class="line"><span class="number">4.</span>isinstance(对象,类型) 判断“对象”是不是“指定类型”</span><br></pre></td></tr></table></figure>

<h2 id="类对象、类属性、类方法、静态方法"><a href="#类对象、类属性、类方法、静态方法" class="headerlink" title="类对象、类属性、类方法、静态方法"></a><strong>类对象、类属性、类方法、静态方法</strong></h2><p><strong>类对象</strong></p>
<p>我们在前面讲的类定义格式中，“class 类名:”。实际上，当解释器执行 class 语句时， 就会创建一个类对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	<span class="keyword">pass</span> <span class="comment">#空语句</span></span><br><span class="line">print(type(Student)) </span><br><span class="line">print(id(Student))</span><br><span class="line">Stu2 = Student </span><br><span class="line">s1 = Stu2() </span><br><span class="line">print(s1)</span><br></pre></td></tr></table></figure>

<p>执行结果如下:<br> &lt;class ‘type’&gt;</p>
<p>51686328<br> &lt;<strong>main</strong>.Student object at 0x0000000002B5FDD8&gt;</p>
<p>我们可以看到实际上生成了一个变量名就是类名“Student”的对象。我们通过赋值给新变 量 Stu2，也能实现相关的调用。说明，确实创建了“类对象”。</p>
<p>【注】pass 为空语句。就是表示什么都不做，只是作为一个占位符存在。当你写代码时， 遇到暂时不知道往方法或者类中加入什么时，可以先用 pass 占位，后期再补上。</p>
<h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a><strong>类属性</strong></h3><p>类属性是从属于“类对象”的属性，也称为“类变量”。由于，类属性从属于类对象，可以 被所有实例对象共享。</p>
<p>类属性的定义方式:<br> class 类名:</p>
<p>类变量名= 初始值 在类中或者类的外面，我们可以通过:“类名.类变量名”来读写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	company = <span class="string">"SXT"</span> <span class="comment">#类属性 </span></span><br><span class="line">	count = <span class="number">0</span> <span class="comment">#类属性</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,score)</span>:</span> </span><br><span class="line">		self.name = name 	</span><br><span class="line">		self.score = score <span class="comment">#实例属性</span></span><br><span class="line">		Student.count = Student.count+<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_score</span><span class="params">(self)</span>:</span> <span class="comment">#实例方法 </span></span><br><span class="line">  print(<span class="string">"我的公司是:"</span>,Student.company) </span><br><span class="line">  print(self.name,<span class="string">'的分数是:'</span>,self.score)</span><br><span class="line">s1 = Student(<span class="string">'张三'</span>,<span class="number">80</span>) <span class="comment">#s1 是实例对象，自动调用__init__()方法 </span></span><br><span class="line">s1.say_score()</span><br><span class="line">print(<span class="string">'一共创建&#123;0&#125;个 Student 对象'</span>.format(Student.count))</span><br><span class="line">```</span><br><span class="line">执行结果:</span><br><span class="line">我的公司是: SXT</span><br><span class="line">张三 的分数是: <span class="number">80</span> </span><br><span class="line">一共创建 <span class="number">1</span> 个 Student 对象</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a><strong>类方法</strong></h3><p>类方法是从属于“类对象”的方法。类方法通过装饰器@classmethod 来定义，格式如下: @classmethod</p>
<p>def 类方法名(cls [，形参列表]) : 函数体</p>
<p>要点如下:<br> \1. @classmethod 必须位于方法上面一行<br> \2. 第一个 cls 必须有;cls 指的就是“类对象”本身;<br> \3. 调用类方法格式:“类名.类方法名(参数列表)”。 参数列表中，不需要也不能给 cls 传 值。<br> \4. 类方法中访问实例属性和实例方法会导致错误<br> \5. 子类继承父类方法时，传入 cls 是子类对象，而非父类对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	company = <span class="string">"SXT"</span> <span class="comment">#类属性 </span></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printCompany</span><span class="params">(cls)</span>:</span> </span><br><span class="line">    print(cls.company)</span><br><span class="line">Student.printCompany()</span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a><strong>静态方法</strong></h3><p>Python 中允许定义与“类对象”无关的方法，称为“静态方法”。</p>
<p>“静态方法”和在模块中定义普通函数没有区别，只不过“静态方法”放到了“类的名字空 间里面”，需要通过“类调用”。</p>
<p>静态方法通过装饰器@staticmethod 来定义，格式如下: @staticmethod</p>
<p>def 静态方法名([形参列表]) : 函数体</p>
<p>要点如下:</p>
<ol>
<li><p>@staticmethod 必须位于方法上面一行</p>
</li>
<li><p>调用静态方法格式:“类名.静态方法名(参数列表)”。 </p>
</li>
<li><p>静态方法中访问实例属性和实例方法会导致错误</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	company = <span class="string">"SXT"</span> <span class="comment"># 类属性</span></span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span> <span class="comment"># 静态方法</span></span><br><span class="line"> 		print(<span class="string">"&#123;0&#125;+&#123;1&#125;=&#123;2&#125;"</span>.format(a,b,(a+b)))</span><br><span class="line"> 		<span class="keyword">return</span> a+b</span><br><span class="line"> Student.add(<span class="number">20</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h2 id="del方法-析构函数-和垃圾回收机制"><a href="#del方法-析构函数-和垃圾回收机制" class="headerlink" title="del方法(析构函数)和垃圾回收机制"></a><strong><strong>del</strong>方法(析构函数)和垃圾回收机制</strong></h2><p><strong>del</strong>方法称为“析构方法”，用于实现对象被销毁时所需的操作。比如:释放对象 占用的资源，例如:打开的文件资源、网络连接等。</p>
<p>Python 实现自动的垃圾回收，当对象没有被引用时(引用计数为 0)，由垃圾回收器 调用<strong>del</strong>方法。</p>
<p>我们也可以通过 del 语句删除对象，从而保证调用<strong>del</strong>方法。 系统会自动提供<strong>del</strong>方法，一般不需要自定义析构方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#析构函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span> </span><br><span class="line">  print(<span class="string">"销毁对象:&#123;0&#125;"</span>.format(self))</span><br><span class="line">p1 = Person() </span><br><span class="line">p2 = Person()</span><br><span class="line"><span class="keyword">del</span> p2</span><br><span class="line">print(<span class="string">"end"</span>)</span><br><span class="line">```</span><br><span class="line">运算结果:</span><br><span class="line">销毁对象:&lt;__main__.Person object at <span class="number">0x02175610</span>&gt; 程序结束</span><br><span class="line">销毁对象:&lt;__main__.Person object at <span class="number">0x021755D0</span>&gt;</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="call方法和可调用对象"><a href="#call方法和可调用对象" class="headerlink" title="call方法和可调用对象"></a><strong><strong>call</strong>方法和可调用对象</strong></h2><p>定义了<strong>call</strong>方法的对象，称为“可调用对象”，即该对象可以像函数一样被调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalaryAccount</span>:</span> <span class="string">'''工资计算类'''</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, salary)</span>:</span> </span><br><span class="line">    yearSalary = salary*<span class="number">12</span> </span><br><span class="line">    daySalary = salary//<span class="number">30</span></span><br><span class="line">		hourSalary = daySalary//<span class="number">8</span> </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">dict(monthSalary=salary,yearSalary=yearSalary,daySalary=daySalary ,hourSalary=hourSalary)</span><br><span class="line">s = SalaryAccount()</span><br><span class="line">print(s(<span class="number">5000</span>)) <span class="comment">#可以像调用函数一样调用对象的__call__方法</span></span><br><span class="line"><span class="comment">#&#123;'monthSalary': 5000, 'yearSalary': 60000, 'daySalary': 166, 'hourSalary': 20&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="方法没有重载"><a href="#方法没有重载" class="headerlink" title="方法没有重载"></a><strong>方法没有重载</strong></h2><p>在其他语言中，可以定义多个重名的方法，只要保证方法签名唯一即可。方法签名包含 3 个部分:方法名、参数数量、参数类型。</p>
<p>Python 中，方法的的参数没有声明类型(调用时确定参数的类型)，参数的数量也可以由 可变参数控制。因此，Python 中是没有方法的重载的。定义一个方法即可有多种调用方式， 相当于实现了其他语言中的方法的重载。</p>
<h3 id="如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。-建议-不要使用重名的方法-Python-中方法没有重载。"><a href="#如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。-建议-不要使用重名的方法-Python-中方法没有重载。" class="headerlink" title="如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。 建议:不要使用重名的方法!Python 中方法没有重载。"></a>如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。 建议:不要使用重名的方法!Python 中方法没有重载。</h3><h2 id="方法的动态性"><a href="#方法的动态性" class="headerlink" title="方法的动态性"></a><strong>方法的动态性</strong></h2><p>Python 是动态语言，我们可以动态的为类添加新的方法，或者动态的修改类的已有的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"努力上班!"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_game</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;0&#125;玩游戏"</span>.format(self))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work2</span><span class="params">(s)</span>:</span></span><br><span class="line">    print(<span class="string">"好好工作，努力上班!"</span>)</span><br><span class="line">Person.play = play_game</span><br><span class="line">Person.work = work2 </span><br><span class="line">p = Person()</span><br><span class="line">p.play()</span><br><span class="line">p.work()</span><br><span class="line">```</span><br><span class="line">&lt;__main__.Person object at <span class="number">0x7fb0405fdee0</span>&gt;玩游戏</span><br><span class="line">好好工作，努力上班!</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>我们可以看到，Person 动态的新增了 play_game 方法，以及用 work2 替换了 work 方法。</p>
<h2 id="私有属性和私有方法-实现封装"><a href="#私有属性和私有方法-实现封装" class="headerlink" title="私有属性和私有方法(实现封装)"></a><strong>私有属性和私有方法(实现封装)</strong></h2><p>Python 对于类的成员没有严格的访问控制限制，这与其他面向对象语言有区别。关于私有 属性和私有方法，有如下要点:</p>
<ol>
<li><p>通常我们约定，两个下划线开头的属性是私有的(private)。其他为公共的(public)。 </p>
</li>
<li><p>类内部可以访问私有属性(方法)</p>
</li>
<li><p>类外部不能直接访问私有属性(方法)</p>
</li>
<li><p>类外部可以通过“_类名__私有属性(方法)名”访问私有属性(方法)</p>
</li>
</ol>
<p>【注】方法本质上也是属性!只不过是可以通过()执行而已。所以，此处讲的私有属性和公有属性，也同时讲解了私有方法和公有方法的用法。如下测试中，同时也包含了私有方法和 公有方法的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试私有属性、私有方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">	__company = <span class="string">"google"</span> <span class="comment">#私有类属性. 通过 dir 可以查到_Employee__company</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.__age = age <span class="comment">#私有实例属性</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">say_company</span><span class="params">(self)</span>:</span> </span><br><span class="line">    print(<span class="string">"我的公司是:"</span>,Employee.__company) <span class="comment">#类内部可以直接访问私有属性</span></span><br><span class="line">		print(self.name,<span class="string">"的年龄是:"</span>,self.__age) </span><br><span class="line">    self.__work()</span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">__work</span><span class="params">(self)</span>:</span> <span class="comment">#私有实例方法 通过 dir 可以查到 _Employee__work</span></span><br><span class="line">		print(<span class="string">"工作!好好工作，好好赚钱，娶个媳妇!"</span>)</span><br><span class="line">p1 = Employee(<span class="string">"高淇"</span>,<span class="number">32</span>)</span><br><span class="line">print(p1.name)</span><br><span class="line">print(dir(p1)) <span class="comment"># </span></span><br><span class="line">p1.say_company()</span><br><span class="line">print(p1._Employee__age) <span class="comment">#通过这种方式可以直接访问到私有属性 。通过 dir 可以查到属性:_Employee__age </span></span><br><span class="line"><span class="comment">#print(p1.__age) #直接访问私有属性，报错</span></span><br><span class="line"> <span class="comment">#p1.__sleep() #直接访问私有方法，报错</span></span><br><span class="line">  ```</span><br><span class="line">  执行结果:</span><br><span class="line">高淇</span><br><span class="line">[<span class="string">'_Person__age'</span>, <span class="string">'_Person__leg_num'</span>, <span class="string">'_Person__sleep'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'name'</span>, <span class="string">'say_age'</span>]</span><br><span class="line">腿的数目: <span class="number">2</span></span><br><span class="line">高淇 的年龄是: <span class="number">18</span></span><br><span class="line">睡觉</span><br><span class="line"><span class="number">18</span></span><br><span class="line">从打印的 Person 对象所有属性我们可以看出。私有属性“__age”在实际存储时是按照 “_Person__age”这个属性来存储的。这也就是为什么我们不能直接使用“__age”而可以 使用“_Person__age”的根本原因。</span><br><span class="line">  ```</span><br></pre></td></tr></table></figure>

<h2 id="property-装饰器"><a href="#property-装饰器" class="headerlink" title="@property 装饰器"></a><strong>@property 装饰器</strong></h2><p>@property 可以将一个方法的调用方式变成“属性调用”</p>
<p>@property 主要用于帮助我们处理属性的读操作、写操作。对于某一个属性，我们可以直 接通过:</p>
<p>emp1.salary = 30000 如上的操作读操作、写操作。但是，这种做法不安全。比如，我需要限制薪水必须为 1-10000 的数字。这时候，我们就需要通过 getter、setter 方法来处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,salary)</span>:</span> </span><br><span class="line">    self.name = name</span><br><span class="line"> 		self.__salary = salary</span><br><span class="line"><span class="meta">	@property #相当于 salary 属性的 getter 方法</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">salary</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"月薪为&#123;0&#125;,年薪为 &#123;1&#125;"</span>.format(self.__salary,(<span class="number">12</span>*self.__salary)))</span><br><span class="line"> 		<span class="keyword">return</span> self.__salary;</span><br><span class="line"><span class="meta"> 	@salary.setter</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">salary</span><span class="params">(self,salary)</span>:</span> <span class="comment">#相当于 salary 属性的 setter 方法</span></span><br><span class="line"> 		<span class="keyword">if</span>(<span class="number">0</span>&lt;salary&lt;<span class="number">1000000</span>): </span><br><span class="line">      self.__salary = salary</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line"> 			print(<span class="string">"薪水录入错误!只能在 0-1000000 之间"</span>)</span><br><span class="line">emp1 = Employee(<span class="string">"高淇"</span>,<span class="number">100</span>) </span><br><span class="line">print(emp1.salary)</span><br><span class="line">emp1.salary = <span class="number">-200</span></span><br></pre></td></tr></table></figure>

<p>运行结果:<br> 月薪为 100,年薪为 1200</p>
<p>100<br> 月薪为 100,年薪为 1200<br> 100<br> 薪水录入错误!只能在 0-1000000 之间</p>
<h2 id="属性和方法命名总结"><a href="#属性和方法命名总结" class="headerlink" title="属性和方法命名总结"></a><strong>属性和方法命名总结</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· _xxx:保护成员，不能用“from module import * ”导入，只有类对象和子类对象能访 问这些成员。(类似java 的proetected)</span><br><span class="line"> · __xxx__:系统定义的特殊成员</span><br><span class="line"> · __xxx: 类中的私有成员，只有类对象自己能访问，子类对象也不能访问。(但，在类外 部可以通过“对象名. _类名__xxx”这种特殊方式访问。Python 不存在严格意义的私有成员)（类似java的private）</span><br></pre></td></tr></table></figure>

<p>注:再次强调，方法和属性都遵循上面的规则。</p>
<p>私有属性是无法被继承的。由此可知，在 Python 中私有属性为假私有属性。那为什么不从语法上保证 private 字段的私密性呢？用最简单的一句话来说：We are all consenting adults here。正如Python 程序员的观点：开放要比封闭好。</p>
<p>综上所述：</p>
<p>Python 编译器无法严格保证 private 字段的私密性。</p>
<p>只有当子类不受自己控制的时候，才可以考虑使用 private 属性来避免名称冲突。所以python还是不如java啊。</p>
<h2 id="类编码风格"><a href="#类编码风格" class="headerlink" title="类编码风格"></a><strong>类编码风格</strong></h2><p>\1. 类名首字母大写，多个单词之间采用驼峰原则。<br> \2. 实例名、模块名采用小写，多个单词之间采用下划线隔开。<br> \3. 每个类，应紧跟“文档字符串”，说明这个类的作用。<br> \4. 可以用空行组织代码，但不能滥用。在类中，使用一个空行隔开方法;模块中，使用两 个空行隔开多个类。</p>
<h1 id="面向对象进阶"><a href="#面向对象进阶" class="headerlink" title="面向对象进阶"></a>面向对象进阶</h1><p><strong>面向对象三大特征介绍</strong></p>
<p>Python 是面向对象的语言，也支持面向对象编程的三大特性:继承、封装(隐藏)、多态。</p>
<p><strong>·封装(隐藏)</strong></p>
<p>隐藏对象的属性和实现细节，只对外提供必要的方法。相当于将“细节封装起来”，只 对外暴露“相关调用方法”。</p>
<p>通过前面学习的“私有属性、私有方法”的方式，实现“封装”。Python 追求简洁的 语法，没有严格的语法级别的“访问控制符”，更多的是依靠程序员自觉实现。</p>
<p><strong>·继承</strong></p>
<p>继承可以让子类具有父类的特性，提高了代码的重用性。</p>
<p>从设计上是一种增量进化，原有父类设计不变的情况下，可以增加新的功能，或者改进 已有的算法。</p>
<p><strong>·多态</strong></p>
<p>多态是指同一个方法调用由于对象不同会产生不同的行为。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h2><p>继承是面向对象程序设计的重要特征，也是实现“代码复用”的重要手段。</p>
<p>如果一个新类继承自一个设计好的类，就直接具备了已有类的特征，就大大降低了工作 难度。已有的类，我们称为“父类或者基类”，新的类，我们称为“子类或者派生类”。</p>
<h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a><strong>语法格式</strong></h3><p>Python 支持多重继承，一个子类可以继承多个父类。继承的语法格式如下: </p>
<p>class 子类类名(父类 1[，父类 2，…]):</p>
<p>​    类体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果在类定义中没有指定父类，则默认父类是 object 类。也就是说，object 是所有类的父 类，里面定义了一些所有类共有的默认实现，比如:__new__()。</span><br><span class="line"></span><br><span class="line">定义子类时，必须在其构造函数中调用父类的构造函数。调用格式如下: 父类名.__init__(self, 参数列表)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,score)</span>:</span></span><br><span class="line"> 		self.score = score</span><br><span class="line">		Person.__init__(self,name,age) <span class="comment">#构造函数中包含调用父类构造函数。根据需要，不是必须。 子类并不会自动调用父类的__init__()，我们必须显式的调用它</span></span><br></pre></td></tr></table></figure>

<h3 id="类成员的继承和重写"><a href="#类成员的继承和重写" class="headerlink" title="类成员的继承和重写"></a><strong>类成员的继承和重写</strong></h3><p>\1. 成员继承:子类继承了父类除构造方法之外的所有成员。<br> \2. 方法重写:子类可以重新定义父类中的方法，这样就会覆盖父类的方法，也称为“重写”</p>
<h3 id="查看类的继承层次结构"><a href="#查看类的继承层次结构" class="headerlink" title="查看类的继承层次结构"></a><strong>查看类的继承层次结构</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过类的方法 mro()或者类的属性__mro__可以输出这个类的继承层次结构。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">pass</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span><span class="keyword">pass</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B)</span>:</span><span class="keyword">pass</span></span><br><span class="line">print(C.mro())</span><br><span class="line"><span class="comment">#[&lt;class '__main__.C'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]</span></span><br><span class="line"><span class="comment">#c继承B，继承A，继承object</span></span><br></pre></td></tr></table></figure>

<h3 id="object-根类"><a href="#object-根类" class="headerlink" title="object 根类"></a><strong>object 根类</strong></h3><p>object 类是所有类的父类，因此所有的类都有 object 类的属性和方法。我们显然有必要深 入研究一下 object 类的结构。对于我们继续深入学习 Python 很有好处。</p>
<p><strong>dir()查看对象属性</strong></p>
<p>为了深入学习对象，我们先学习内置函数 dir()，他可以让我们方便的看到指定对象所有的 属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span> </span><br><span class="line">    self.name = name</span><br><span class="line"> 		self.age = age</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say_age</span><span class="params">(self)</span>:</span> </span><br><span class="line">    print(self.name,<span class="string">"的年龄是:"</span>,self.age)</span><br><span class="line">obj = object() </span><br><span class="line">print(dir(obj))</span><br><span class="line">s2 = Person(<span class="string">"高淇"</span>,<span class="number">18</span>)</span><br><span class="line">print(dir(s2))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;]</span><br><span class="line">[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;age&#39;, &#39;name&#39;, &#39;say_age&#39;]</span><br></pre></td></tr></table></figure>

<p>从上面我们可以发现这样几个要点: </p>
<ol>
<li>Person 对象增加了六个属性:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__dict__ __module__ __weakref__ age name say_age</span><br></pre></td></tr></table></figure>

<p>\2. object 的所有属性，Person 类作为 object 的子类，显然包含了所有的属性。<br> \3. 我们打印 age、name、say_age，发现 say_age 虽然是方法，实际上也是属性。只不过， 这个属性的类型是“method”而已。</p>
<p>age &lt;class ‘int’&gt;<br> name &lt;class ‘str’&gt;</p>
<p>say_age &lt;class ‘method’&gt;</p>
<h2 id="重写str-方法"><a href="#重写str-方法" class="headerlink" title="重写str()方法"></a><strong>重写<strong>str</strong>()方法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object 有一个__str__()方法，用于返回一个对于“对象的描述”，对应于内置函数 str() 经常用于 print()方法，帮助我们查看对象的信息。__str__()可以重写。</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"> <span class="string">'''将对象转化成一个字符串，一般用于 print 方法'''</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"名字是:&#123;0&#125;,年龄是&#123;1&#125;"</span>.format(self.name,self.__age)</span><br></pre></td></tr></table></figure>

<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a><strong>多重继承</strong></h2><p>Python 支持多重继承，一个子类可以有多个“直接父类”。这样，就具备了“多个父 类”的特点。但是由于，这样会被“类的整体层次”搞的异常复杂，尽量避免使用。<strong>class</strong> C(B,A):</p>
<h2 id="MRO"><a href="#MRO" class="headerlink" title="MRO()"></a><strong>MRO()</strong></h2><p>Python 支持多继承，如果父类中有相同名字的方法，在子类没有指定父类名时，解释器将 “从左向右”按顺序搜索。<br> MRO(Method Resolution Order):方法解析顺序。 我们可以通过 mro()方法获得 “类的层次结构”，方法解析顺序也是按照这个“类的层次结构”寻找的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">aa</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"aa"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span> </span><br><span class="line">    print(<span class="string">"say AAA!"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">bb</span><span class="params">(self)</span>:</span></span><br><span class="line">			print(<span class="string">"bb"</span>)</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span> </span><br><span class="line">      print(<span class="string">"say BBB!"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B,A)</span>:</span> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cc</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"cc"</span>)</span><br><span class="line">c = C()</span><br><span class="line">print(C.mro()) <span class="comment">#打印类的层次结构</span></span><br><span class="line">c.say() <span class="comment">#解释器寻找方法是“从左到右”的方式寻找，此时会执行 B 类中的 say()</span></span><br></pre></td></tr></table></figure>

<p>[&lt;class ‘<strong>main</strong>.C’&gt;, &lt;class ‘<strong>main</strong>.B’&gt;, &lt;class ‘<strong>main</strong>.A’&gt;, &lt;class ‘object’&gt;]<br>say BBB!</p>
<h2 id="super-获得父类定义"><a href="#super-获得父类定义" class="headerlink" title="super()获得父类定义"></a><strong>super()获得父类定义</strong></h2><p>在子类中，如果想要获得父类的方法时，我们可以通过 super()来做。super()代表父类的定义，不是父类对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def say(self):</span><br><span class="line"> #A.say(self) 调用父类的 say 方法 </span><br><span class="line"> super().say() #通过 super()调用父类的方法</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h2><p>多态(polymorphism)是指同一个方法调用由于对象不同可能会产生不同的行为。在现实 生活中，我们有很多例子。比如:同样是调用人的休息方法，张三的休息是睡觉，李四的休 息是玩游戏，高淇老师是敲代码。同样是吃饭的方法，中国人用筷子吃饭，英国人用刀叉吃 饭，印度人用手吃饭。</p>
<p>关于多态要注意以下 2 点:<br> \1. 多态是方法的多态，属性没有多态。<br> \2. 多态的存在有 2 个必要条件:继承、方法重写。</p>
<h2 id="特殊方法和运算符重载"><a href="#特殊方法和运算符重载" class="headerlink" title="特殊方法和运算符重载"></a><strong>特殊方法和运算符重载</strong></h2><p>Python 的运算符实际上是通过调用对象的特殊方法实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span> </span><br><span class="line">b = <span class="number">30</span></span><br><span class="line">c = a+b</span><br><span class="line">d = a.__add__(b) </span><br><span class="line">print(<span class="string">"c="</span>,c)</span><br><span class="line">print(<span class="string">"d="</span>,d)</span><br><span class="line"><span class="comment">#运算结果: c= 50</span></span><br><span class="line">d= <span class="number">50</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">常见的特殊方法统计如下:</span><br><span class="line"></span><br><span class="line">__init__  构造方法      对象创建:p &#x3D; Person()</span><br><span class="line">__del__  析构方法 对象回收</span><br><span class="line">__repr__,__str__  打印，转换     rint(a)</span><br><span class="line">__call__ 函数调用 a()</span><br><span class="line">__getattr__ 点号运算 a.xxx</span><br><span class="line">__setattr__ 属性赋值 a.xxx &#x3D; value</span><br><span class="line">__getitem__ 索引运算 a[key]</span><br><span class="line">__setitem__ 索引赋值 a[key]&#x3D;value</span><br><span class="line">__len__ 长度 len(a)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运算符+ __add__ 加法</span><br><span class="line">运算符- __sub__ 减法</span><br><span class="line">&lt;,&lt;&#x3D;,&#x3D;&#x3D;  __lt__,__le__，__eq__ 比较运算符</span><br><span class="line">&gt;,&gt;&#x3D;,!&#x3D; __gt__,__ge__,__ne__ 比较运算符</span><br><span class="line">|,^,&amp; __or__,__xor__,__and__  或、异或、与</span><br><span class="line">&lt;&lt;,&gt;&gt; __lshift__,__rshift__ 左移、右移</span><br><span class="line">*,&#x2F;,%,&#x2F;&#x2F; __mul__,__truediv__,__mod__,_ _floordiv__ 乘、浮点除、模运算 (取余)、整数除</span><br><span class="line">** __pow__ 指数运算</span><br></pre></td></tr></table></figure>

<p>我们可以重写上面的特殊方法，即实现了“运算符的重载”。</p>
<h2 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a><strong>特殊属性</strong></h2><p>Python 对象中包含了很多双下划线开始和结束的属性，这些是特殊属性，有特殊用法。这 里我们列出常见的特殊属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">obj.__dict__对象的属性字典</span><br><span class="line">obj.__class__对象所属的类</span><br><span class="line">class.__bases__类的基类元组(多继承)</span><br><span class="line">class.__base__类的基类</span><br><span class="line">class.__mro__类层次结构</span><br><span class="line">class.__subclasses__()子类列表</span><br><span class="line">print(dir(c)) </span><br><span class="line">print(c.__dict__) </span><br><span class="line">print(c.__class__) </span><br><span class="line">print(C.__bases__) </span><br><span class="line">print(C.mro()) </span><br><span class="line">print(A.__subclasses__())</span><br></pre></td></tr></table></figure>

<p><strong>对象的浅拷贝和深拷贝</strong></p>
<p><strong>·变量的赋值操作</strong></p>
<p>只是形成两个变量，实际还是指向同一个对象。</p>
<p><strong>·浅拷贝</strong></p>
<p>Python 拷贝一般都是浅拷贝。拷贝时，对象包含的子对象内容不拷贝。因此，源对象 和拷贝对象会引用同一个子对象。<br> <strong>·深拷贝</strong></p>
<p>使用 copy 模块的 deepcopy 函数，递归拷贝对象中包含的子对象。源对象和拷贝对象 所有的子对象也不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">m2 &#x3D; copy.copy(m) #m2 是新拷贝的另一个手机对象</span><br><span class="line">m3 &#x3D; copy.deepcopy(m)</span><br></pre></td></tr></table></figure>

<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a><strong>组合</strong></h2><p>“is-a”关系，我们可以使用“继承”。从而实现子类拥有的父类的方法和属性。“is-a” 关系指的是类似这样的关系:狗是动物，dog is animal。狗类就应该继承动物类。</p>
<p>“has-a”关系，我们可以使用“组合”，也能实现一个类拥有另一个类的方法和属性。” has-a”关系指的是这样的关系:手机拥有 CPU。 MobilePhone has a CPU。self.cpu=cpu</p>
<h2 id="设计模式-工厂模式实现"><a href="#设计模式-工厂模式实现" class="headerlink" title="设计模式_工厂模式实现"></a><strong>设计模式_工厂模式实现</strong></h2><p>设计模式是面向对象语言特有的内容，是我们在面临某一类问题时候固定的做法，设计 模式有很多种，比较流行的是:GOF(Goup Of Four)23 种设计模式。当然，我们没有 必要全部学习，学习几个常用的即可。</p>
<p>对于初学者，我们学习两个最常用的模式:工厂模式和单例模式。</p>
<p>工厂模式实现了创建者和调用者的分离，使用专门的工厂类将选择实现类、创建对象进 行统一的管理和控制。</p>
<h2 id="设计模式-单例模式实现"><a href="#设计模式-单例模式实现" class="headerlink" title="设计模式_单例模式实现"></a><strong>设计模式_单例模式实现</strong></h2><p>单例模式(Singleton Pattern)的核心作用是确保一个类只有一个实例，并且提供一 个访问该实例的全局访问点。</p>
<p>单例模式只生成一个实例对象，减少了对系统资源的开销。当一个对象的产生需要比较 多的资源，如读取配置文件、产生其他依赖对象时，可以产生一个“单例对象”，然后永久 驻留内存中，从而极大的降低开销。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单例模式有多种实现的方式，我们这里推荐重写__new__()的方法。</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jackson</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jackson</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
