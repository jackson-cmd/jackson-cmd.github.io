<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DynamicProgramming</title>
    <url>/2020/04/17/DynamicProgramming/</url>
    <content><![CDATA[<h2 id="This-is-a-easy-way-to-learn-Dynamic-Programming"><a href="#This-is-a-easy-way-to-learn-Dynamic-Programming" class="headerlink" title="This is a easy way to learn Dynamic Programming"></a>This is a easy way to learn Dynamic Programming</h2><p>DP is known as bottom-up and top-down.<br>Top-down is like a recursion, but with memoized, when using top-down, draw tree.<br>Bottom-up is like careful brute force, you need to track all the subquestions’ answer for further use.</p>
<p>This is a picture from MIT course that explain the fib questions use bottom-up, I actually like bottom-up way, because it is easy to understand, you need to draw a table to find the optimal solution, although you can use it for fib one.</p>
<img src="/Users/mengxiaowang/Library/Application Support/typora-user-images/Screen Shot 2020-04-17 at 8.26.03 PM.png" style="zoom:50%;" />

<p>Here are some dp classic questions.</p>
<p><em>1. *</em>Find a Path***</p>
<p>​    <em>Leetcode 62. Unique Paths</em></p>
<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] nums =<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] b: nums )&#123;</span><br><span class="line">            Arrays.fill(b, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                nums[i][j]=nums[i-<span class="number">1</span>][j]+nums[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>63.*</em>Unique Paths II***</p>
<p>robot is located at the top-left corner of a <u><em>m</em> x <em>n</em></u> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> col=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            obstacleGrid[i][<span class="number">0</span>]=(obstacleGrid[i][<span class="number">0</span>]==<span class="number">0</span> &amp;&amp; obstacleGrid[i-<span class="number">1</span>][<span class="number">0</span>]==<span class="number">1</span>)? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][j]=(obstacleGrid[<span class="number">0</span>][j]==<span class="number">0</span> &amp;&amp; obstacleGrid[<span class="number">0</span>][j-<span class="number">1</span>]==<span class="number">1</span>)? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    obstacleGrid[i][j]=obstacleGrid[i-<span class="number">1</span>][j]+obstacleGrid[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    obstacleGrid[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>ccna10</title>
    <url>/2020/05/10/ccna10/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>











<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>ccna思科课</title>
    <url>/2020/05/10/ccna/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="1-计算机网络基础"><a href="#1-计算机网络基础" class="headerlink" title="1.计算机网络基础"></a>1.计算机网络基础</h2><h6 id="C-S架构的优缺点："><a href="#C-S架构的优缺点：" class="headerlink" title="C/S架构的优缺点："></a>C/S架构的优缺点：</h6><ul>
<li>优点：<br>1.客户端因为是独立设计，所以可以实现个性化<br>2.因为客户端是需要进行安装的，可以不需要重复安装和加载<br>3.因为客户端是独立开发的，所以有能力对客户端进行安全设计<br>4.如果遇到不同的操作系统，需要为不同的操作系统各开发一套客户端</li>
<li>缺点：<br>1.因为客户端是不需要重复安装，所以用户可以不更新与升级，增加了维护成本。<br>2.因为需要开发客户端和服务器两套程序，所以开发成本会增加</li>
</ul>
<h6 id="B-S架构的优缺点："><a href="#B-S架构的优缺点：" class="headerlink" title="B/S架构的优缺点："></a>B/S架构的优缺点：</h6><ul>
<li>优点：<br>1.因为B/S架构具备通用性，所以开发成本较低。<br>2.因为不需要安装客户端，所以客户端不需要进行升级，只需要更新后台代码即可实现所有客户端的更新。<br>3.因为B/S架构多用WEB网页进行开发，所以增、删功能也非常容易，只需要修改网页即可完成</li>
<li>缺点：<br>1.耗流量，每次都要加载全部的内容（不过有缓存可以降低流量损耗）<br>2.因为没有独立的客户端，所以无法实现个性化（通过账号体系可以实现）<br>3.因为没有独立设计客户端，所以客户端难以实现安全控制（HTTPS、控件）。<br>4.难以实现特殊的操作（删本地文件），所以所有的杀毒软件都是C/S架构的。<br>B/S架构更多的时候是使用了HTTP协议、而C/S架构更多的时候使用的WinSocke t协议（TCP、UDP）</li>
</ul>
<blockquote>
<p>总结：CS响应速度快，安全性强，一般应用于局域网中，但是开发维护成本高；BS可以实现跨平台，客户端零维护，但是个性化能力低，响应速度较慢。所以有些单位日常办公应用BS，在实际生产中使用CS结构。</p>
</blockquote>
<p><strong>rs 路由器和交换机：router switch</strong></p>
<p><strong><em>交换机可以实现局域网，而路由器是连接不同局域网，实现广域网。</em></strong></p>
<p>1、LAN 局域网(Local Area Network)接口，通俗讲就是路由和用户之间网线口；一组终端设备和由共同的组织管理的用户。所有用户连接lan下。</p>
<p>2、WAN 广域网(Wide Area Network)，通俗讲就是和光猫猫外部网连接的网线口；连接分布于不同地理位置的LAN.</p>
<p>3、WLAN无线局域网(Wireless LAN)，数据通过电磁波传输；</p>
<p>通俗点说，WAN口是对外的接口，和运营商、上级网络打交道。</p>
<p>LAN和WLAN是对内的接口，内部的电脑、手机、PAD，都是接入到LAN或者WLAN。</p>
<p><img src="https://img-blog.csdn.net/20180504090210322" alt="img"></p>
<h3 id="互联网服务提供商（Internet-Service-Provider），简称ISP，作用："><a href="#互联网服务提供商（Internet-Service-Provider），简称ISP，作用：" class="headerlink" title="互联网服务提供商（Internet Service Provider），简称ISP，作用："></a>互联网服务提供商（<em>Internet Service Provider</em>），简称<em>ISP</em>，作用：</h3><p>一是接入服务，即帮助用户接入Internet；二是导航服务，即帮助用户在Internet上找到所需要的信息；三是信息服务，即建立数据服务系统，收集、加工、存储信息，定期维护更新，并通过网络向用户提供信息内容服务。</p>
<h3 id="HUB-SWITCH-ROUTER-DIFFERENCES"><a href="#HUB-SWITCH-ROUTER-DIFFERENCES" class="headerlink" title="HUB, SWITCH, ROUTER DIFFERENCES:"></a>HUB, SWITCH, ROUTER DIFFERENCES:</h3><p>Hub: only detects that a device is physically connected to it.集线器</p>
<p>Switch: can detect specific devices that are connected to it.</p>
<p>keeps a record of the MAC addresses of those devices. </p>
<p>Hubs and swtiches are used to exchange data within a local area network. Not used to exchange data outside their own network. To exchange data outside their ow network, a device needs to be able to read I.P. addresses.</p>
<p>Router: routes data from one network to another based on their IP address.</p>
<h3 id="端口port"><a href="#端口port" class="headerlink" title="端口port"></a>端口port</h3><h5 id="端口概念"><a href="#端口概念" class="headerlink" title="端口概念"></a>端口概念</h5><p>在网络技术中，端口（port）大致有两种意思：<br>一是物理上的端口，比如ADSL、Modem、集线器、交换机、路由器用于连接其他网络设备的接口，如RJ-45端口、SC端口等等。<br>二是逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。<br>这里要说的是逻辑意义上的端口。</p>
<h6 id="什么是端口"><a href="#什么是端口" class="headerlink" title="什么是端口"></a>什么是端口</h6><p>在Internet上，各主机间通过TCP/TP协议发送和接收数据报，各个数据报根据其目的主机的IP地址来进行互联网络中的路由选择。可见，把数据报顺利的传送到目的主机是没有问题的。我们知道大多数操作系统都支持多程序（进程）同时运行，那么目的主机应该把接收到的数据报传送给众多同时运行的进程中的哪一个？显然这个问题有待解决，端口机制便由此被引入了进来。</p>
<p>本地操作系统会给那些有需求的进程分配协议端口（protocal port，即我们常说的端口），每个协议端口由一个正整数标识，如：80，139等等。当目的主机接收到数据报后，将根据报文首部的目的端口号，把数据发送到相应端口，而与此端口相对应的那个进程将会领取数据并等待下一组数据的到来。</p>
<p>端口其实就是队，操作系统为各个进程分配了不同的队，数据报按照目的端口被推入相应的队中，等待被进程取用，在极特殊的情况下，这个队也是有可能溢出的，不过操作系统允许各进程指定和调整自己的队的大小。不光接受数据报的进程需要开启它自己的端口，发送数据报的进程也需要开启端口，这样，数据报中将会标识有源端口，以便接受方能顺利的回传数据报到这个端口。</p>
<h5 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h5><p>我们知道，一台拥有IP地址的主机可以提供许多服务，比如Web服务，FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP地址与网络服务的关系是一对多的关系。实际上是通过”IP地址+端口号”来区分不同的服务的。<br>客户端通常对它所使用的端口号并不关心，只需保证该端口号在本机上是唯一的就可以了。客户端端口号又称作临时端口号（即存在时间很短）。这是因为它通常只是在用户运行该客户程序时才存在，而服务器则只要主机开着，其服务就运行。</p>
<h6 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h6><p>可以使用Netstat命令：开始-&gt;运行，键入”cmd”并回车，打开命令提示符窗口。在命令提示符状态下键入”netstat -a -n”，按下回车键后就可以看到以数字形式显示的 TCP和UDP连接的端口号及状态。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/9113969-67c6d199315602ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p>
<h4 id="关闭-开启端口"><a href="#关闭-开启端口" class="headerlink" title="关闭/开启端口"></a>关闭/开启端口</h4><p>默认的情况下，有很多不安全的或者没有什么用的端口是开启的，比如Telent服务的23端口、FTP服务的21端口、SMTP服务的25端口、RPC服务的135端口等。为了保证系统的安全性，我们可以通过下面的方法来关闭/开启端口。</p>
<h6 id="关闭端口"><a href="#关闭端口" class="headerlink" title="关闭端口"></a>关闭端口</h6><p>比如关闭Apache2.4服务端口，可以这样做：开始-&gt;运行-&gt;服务-&gt;在服务窗口找到Apache2.4并双击-&gt;单击”停止”按钮来停止该服务-&gt;然后在”启动类型”中选择”禁用”-&gt;最后单击”确定”按钮即可。关闭了Apache2.4服务就相当于关闭了对应的端口。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/9113969-f7b38d620a983ae3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/602" alt="img"></p>
<h6 id="开启端口"><a href="#开启端口" class="headerlink" title="开启端口"></a>开启端口</h6><p>如果要开启该端口只要先在”启动类型”选择”自动”，单击”确定”按钮，再打开该服务，在”服务状态中单击”启动”按钮即可启用该端口，最后，单击”确定”按钮即可。</p>
<h4 id="端口分类"><a href="#端口分类" class="headerlink" title="端口分类"></a>端口分类</h4><p>逻辑意义上的端口有多种分类标准，下面是两种常见的分类：</p>
<h5 id="1-按端口号分布划分"><a href="#1-按端口号分布划分" class="headerlink" title="1.按端口号分布划分"></a>1.按端口号分布划分</h5><h6 id="（1）知名端口（Well-Known-Ports）"><a href="#（1）知名端口（Well-Known-Ports）" class="headerlink" title="（1）知名端口（Well-Known Ports）"></a>（1）知名端口（Well-Known Ports）</h6><p>知名端口即众所周知的端口号，范围从0到1023，这些端口号一般固定分配给一些服务。比如25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务，135端口分配给RPC（远程过程调用）服务等等。</p>
<h6 id="（2）动态端口（Dynamic-Ports）"><a href="#（2）动态端口（Dynamic-Ports）" class="headerlink" title="（2）动态端口（Dynamic Ports）"></a>（2）动态端口（Dynamic Ports）</h6><p>动态端口的范围从1024到65535，这些端口号一般不固定分配给某个服务，也就是说许多服务都可以使用这些端口。只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。比如1024端口就是分配给第一个向系统发出申请的程序。在关闭程序进程后，就会释放所占用的端口号。<br>不过动态端口也常常被病毒木马程序所利用，如冰河默认连接端口是7626、WAY 2.4是8011、Netspy 3.0是7306、YAI病毒是1024等等。</p>
<h6 id="2-按协议类型划分"><a href="#2-按协议类型划分" class="headerlink" title="2.按协议类型划分"></a>2.按协议类型划分</h6><p>按协议类型划分，可以分为TCP、UDP、IP和ICMP（Internet控制消息协议）等端口。</p>
<h6 id="（1）TCP端口"><a href="#（1）TCP端口" class="headerlink" title="（1）TCP端口"></a>（1）TCP端口</h6><p>TCP端口，即传输控制协议端口，需要在客户端和服务器之间建立连接，这样可以提供可靠的数据传输。常见的包括FTP服务的21端口，Telent服务的23端口，SMTP服务的25端口，以及HTTP服务的80端口等。</p>
<h6 id="（2）UDP端口"><a href="#（2）UDP端口" class="headerlink" title="（2）UDP端口"></a>（2）UDP端口</h6><p>UDP端口，即用户数据包协议端口，无需在客户端和服务器之间建立连接，安全性得不到保障。常见的有DNS服务的53端口，SNMP（简单网络管理协议）服务的161端口，QQ使用的8000和4000端口等等。</p>
<h5 id="端口在入侵中的作用"><a href="#端口在入侵中的作用" class="headerlink" title="端口在入侵中的作用"></a>端口在入侵中的作用</h5><p>有人曾经把服务器比作房子，而把端口比作通向不同房间（服务）的门。入侵者要占领这间房子，势必要破门而入（物理入侵另说），那么对于入侵者来说，了解房子开了几扇门，都是什么样的门，门后面有什么东西就显得至关重要。<br>入侵者通常会用扫描器对目标主机的端口进行扫描，以确定哪些端口是开放的，从开放的端口，入侵者可以知道目标主机大致提供了哪些服务，进而猜测可能存在的漏洞，因此对端口的扫描可以帮助我们更好的了解目标主机，而对于管理员，扫描本机的开放端口也是做好安全防范的第一步。</p>
<h6 id="常见端口表汇总"><a href="#常见端口表汇总" class="headerlink" title="常见端口表汇总"></a>常见端口表汇总</h6><p>1　tcpmux　TCP Port Service Multiplexer 传输控制协议端口服务多路开关选择器<br>2　compressnet　Management Utility　　　　 compressnet 管理实用程序<br>3　compressnet　Compression Process　　　　压缩进程<br>5　rje　Remote Job Entry　　　　　　　　　 远程作业登录<br>7　echo　Echo　　　　　　　　　　　　　　　回显<br>9　discard　Discard　　　　　　　　　　　　丢弃<br>11　systat　Active Users　　　　　　　　　 在线用户<br>13　daytime　Daytime　　　　　　　　　　　 时间<br>17　qotd　Quote of the Day　　　　　　　　 每日引用<br>18　msp　Message Send Protocol　　　　　　 消息发送协议<br>19　chargen　Character Generator　　　　　 字符发生器<br>20　ftp-data　File Transfer [Default Data]　文件传输协议(默认数据口)　<br>21　ftp　File Transfer [Control]　　　　　　文件传输协议(控制)<br>22　ssh　SSH Remote Login Protocol　　　　 SSH远程登录协议<br>23　telnet　Telnet　　　　　　　　　　　　 终端仿真协议<br>24　?　any private mail system　　　　　　 预留给个人用邮件系统<br>25　smtp　Simple Mail Transfer　　　　　　 简单邮件发送协议<br>27　nsw-fe　NSW User System FE　　　　　　 NSW 用户系统现场工程师<br>29　msg-icp　MSG ICP　　　　　　　　　　　 MSG　ICP<br>31　msg-auth　MSG Authentication　　　　　 MSG验证<br>33　dsp　Display Support Protocol　　　　　显示支持协议<br>35　?　any private printer server　　　　　预留给个人打印机服务<br>37　time　Time　　　　　　　　　　　　　　 时间<br>38　rap　Route Access Protocol　　　　　　 路由访问协议<br>39　rlp　Resource Location Protocol　　　　资源定位协议<br>41　graphics　Graphics　　　　　　　　　　 图形<br>42　nameserver　WINS Host Name Server　　　WINS 主机名服务<br>43　nicname　Who Is　　　　　　　　　　　　“绰号” who is服务<br>44　mpm-flags　MPM FLAGS Protocol　　　　　MPM(消息处理模块)标志协议<br>45　mpm　Message Processing Module [recv]　消息处理模块　<br>46　mpm-snd　MPM [default send]　　　　　　消息处理模块(默认发送口)<br>47　ni-ftp　NI FTP　　　　　　　　　　　　 NI FTP<br>48　auditd　Digital Audit Daemon　　　　　 数码音频后台服务　<br>49　tacacs　Login Host Protocol (TACACS)　 TACACS登录主机协议<br>50　re-mail-ck　Remote Mail Checking Protocol　远程邮件检查协议<br>51　la-maint　IMP Logical Address Maintenance　IMP(接口信息处理机)逻辑地址维<br>护<br>52　xns-time　XNS Time Protocol　　　　　　施乐网络服务系统时间协议　　<br>53　domain　Domain Name Server　　　　　　 域名服务器<br>54　xns-ch　XNS Clearinghouse　　　　　　　施乐网络服务系统票据交换<br>55　isi-gl　ISI Graphics Language　　　　　ISI图形语言<br>56　xns-auth　XNS Authentication　　　　　 施乐网络服务系统验证<br>57　?　any private terminal access　　　　 预留个人用终端访问<br>58　xns-mail　XNS Mail　　　　　　　　　　 施乐网络服务系统邮件<br>59　?　any private file service　　　　　　预留个人文件服务<br>60　?　Unassigned　　　　　　　　　　　　　未定义<br>61　ni-mail　NI MAIL　　　　　　　　　　　 NI邮件?<br>62　acas　ACA Services　　　　　　　　　　 异步通讯适配器服务<br>63　whois+ whois+　　　　　　　　　　　　　 WHOIS+<br>64　covia　Communications Integrator (CI)　通讯接口　<br>65　tacacs-ds　TACACS-Database Service　　 TACACS数据库服务<br>66　sql<em>net　Oracle SQL</em>NET　　　　　　　　Oracle SQL*NET<br>67　bootps　Bootstrap Protocol Server　　　引导程序协议服务端<br>68　bootpc　Bootstrap Protocol Client　　　引导程序协议客户端<br>69　tftp　Trivial File Transfer　　　　　　小型文件传输协议<br>70　gopher　Gopher　　　　　　　　　　　　 信息检索协议<br>71　netrjs-1　Remote Job Service　　　　　 远程作业服务<br>72　netrjs-2　Remote Job Service　　　　　 远程作业服务<br>73　netrjs-3　Remote Job Service　　　　　 远程作业服务<br>74　netrjs-4　Remote Job Service　　　　　 远程作业服务<br>75　?　any private dial out service　　　　预留给个人拨出服务<br>76　deos　Distributed External Object Store 分布式外部对象存储　<br>77　?　any private RJE service　　　　　　预留给个人远程作业输入服务<br>78　vettcp　vettcp　　　　　　　　　　　　 修正TCP?<br>79　finger　Finger　　　　　　　　　　　　 FINGER(查询远程主机在线用户等信<br>息)<br>80　http　World Wide Web HTTP　　　　　　　全球信息网超文本传输协议<br>81　hosts2-ns　HOSTS2 Name Server　　　　　HOST2名称服务<br>82　xfer　XFER Utility　　　　　　　　　　 传输实用程序<br>83　mit-ml-dev　MIT ML Device　　　　　　　模块化智能终端ML设备<br>84　ctf　Common Trace Facility　　　　　　 公用追踪设备<br>85　mit-ml-dev　MIT ML Device　　　　　　　模块化智能终端ML设备<br>86　mfcobol　Micro Focus Cobol　　　　　　 Micro Focus Cobol编程语言<br>87　?　any private terminal link　　　　　 预留给个人终端连接<br>88　kerberos　Kerberos　　　　　　　　　　 Kerberros安全认证系统<br>89　su-mit-tg　SU/MIT Telnet Gateway　　　 SU/MIT终端仿真网关<br>90　dnsix　DNSIX Securit Attribute Token Map　DNSIX 安全属性标记图　<br>91　mit-dov　MIT Dover Spooler　　　　　　 MIT Dover假脱机<br>92　npp　Network Printing Protocol　　　　 网络打印协议<br>93　dcp　Device Control Protocol　　　　　 设备控制协议<br>94　objcall　Tivoli Object Dispatcher　　　Tivoli对象调度<br>95　supdup　SUPDUP　　　　　　　　　　　　<br>96　dixie　DIXIE Protocol Specification　　DIXIE协议规范<br>97　swift-rvf　Swift Remote Virtural File Protocol　快速远程虚拟文件协议　<br>98　tacnews　TAC News　　　　　　　　　　　TAC(东京大学自动计算机?)新闻协议</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>ccna3</title>
    <url>/2020/05/10/ccna3/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>











<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>ccna4</title>
    <url>/2020/05/10/ccna4/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>











<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>ccna1</title>
    <url>/2020/05/10/ccna1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="OSI-TCP分层"><a href="#OSI-TCP分层" class="headerlink" title="OSI-TCP分层"></a>OSI-TCP分层</h1><p>1、ISO：国际标准化组织，是一个全球性的非政府组织。</p>
<p>2、OSI：开放原始码组织，是一个致力于推动开源软件发展的非盈利组织。</p>
<p>ISO 创建 OSI模型</p>
<p>OSI参考模型<br><img src="https://img-blog.csdn.net/20180812081221499?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZHJld2dpdGh1Yg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:150%;" /></p>
<p>TCP/IP协议四层：应用层，传输层，网络互联层，网络接口层。</p>
<h2 id="TCP-IP-和-ISO-OSI"><a href="#TCP-IP-和-ISO-OSI" class="headerlink" title="TCP/IP 和 ISO/OSI"></a>TCP/IP 和 ISO/OSI</h2><p>　　<img src="https://img2018.cnblogs.com/blog/1330623/201811/1330623-20181111094255969-906399626.png" alt="img"></p>
<p>　　ISO/OSI模型，即开放式通信系统互联参考模型（Open System Interconnection Reference Model），是国际标准化组织（ISO）提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。<br>　　TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议，通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。TCP/IP协议簇是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与OSI的七层模型相对应。</p>
<p><a href="https://www.cnblogs.com/duanwandao/p/9941411.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="TCP-IP分层模型"><a href="#TCP-IP分层模型" class="headerlink" title="TCP/IP分层模型"></a>TCP/IP分层模型</h2><p>　　<img src="https://img2018.cnblogs.com/blog/1330623/201811/1330623-20181111094517799-658969358.png" alt="img"></p>
<ul>
<li>应用层</li>
</ul>
<p>　　应用层决定了向用户提供应用服务时通信的活动。||  应用层负责处理特定的应用程序细节。 </p>
<p>　　TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域 名系统）服务就是其中两类。 HTTP 协议也处于该层。</p>
<ul>
<li>传输层</li>
</ul>
<p>　　传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据 传输。 </p>
<p>　　在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报 协议）。</p>
<hr>
<p>　　主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。</p>
<p> 　TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。为了提供可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。</p>
<p>　　UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。一个数据报是指从发送方传输到接收方的一个信息单元（例如，发送方指定的一定字节数的信息）。UDP协议任何必需的可靠性必须由应用层来提供。</p>
<ul>
<li>网络层</li>
</ul>
<p>　　网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数 据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计 算机，并把数据包传送给对方。</p>
<p>　　与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所 起的作用就是在众多的选项内选择一条传输路线。</p>
<hr>
<p>　　也称作互联网层（在第一个图中为网际层），处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。</p>
<p>　　IP是一种网络层协议，提供的是一种不可靠的服务，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。</p>
<p>　　ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。</p>
<p>　　IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</p>
<ul>
<li>链路层</li>
</ul>
<p>　　用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱 动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等 物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在 链路层的作用范围之内。</p>
<hr>
<p>　　也称作数据链路层或网络接口层（在第一个图中为网络接口层和硬件层），通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</p>
<h2 id="数据的封装与分用"><a href="#数据的封装与分用" class="headerlink" title="数据的封装与分用"></a>数据的封装与分用</h2><p>　　<img src="https://img2018.cnblogs.com/blog/1330623/201811/1330623-20181111100150782-1142480745.png" alt="img"></p>
<p>　　</p>
<p>　　当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），该过程如图所示。</p>
<p>　　TCP传给IP的数据单元称作TCP报文段或简称为TCP段（TCP segment）；UDP数据与TCP数据基本一致。唯一的不同是UDP传给IP的信息单元称作U D P数据报（UDP datagram），而且UDP的首部长为8字节。IP传给网络接口层的数据单元称作IP数据报(IP datagram)。通过以太网传输的比特流称作帧(Frame )。 </p>
<p>　　<img src="https://img2018.cnblogs.com/blog/1330623/201811/1330623-20181111100506569-1755504964.png" alt="img"></p>
<p>　　当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。协议是通过目的端口号、源I P地址和源端口号进行解包的。</p>
<h2 id="其他相关概念"><a href="#其他相关概念" class="headerlink" title="其他相关概念"></a>其他相关概念</h2><p>　　<img src="https://img2018.cnblogs.com/blog/1330623/201811/1330623-20181111100625410-1390955722.png" alt="img"></p>
<ul>
<li>端口号</li>
</ul>
<p>　　服务器一般都是通过知名端口号来识别的。例如，对于每个TCP/IP实现来说，FTP服务器的TCP端口号都是21，每个Telnet服务器的TCP端口号都是23，每个TFTP (简单文件传送协议)服务器的UDP端口号都是69。任何TCP/IP实现所提供的服务都用知名的1～1023之间的端口号。这些知名端口号由Internet号分配机构（Internet Assigned Numbers Authority, IANA）来管理。知名端口号介于1～255之间；256～1023之间的端口号通常都是由Unix系统占用，以提供一些特定的Unix服务；1024~5000端口号用于客户端分配临时端口号；大于5000的端口号是为其他服务器预留的。</p>
<ul>
<li>DNS</li>
</ul>
<p>　　DNS 是计算机域名系统 (Domain Name System 或Domain Name Service) 的缩写，它是由解析器以及域名服务器组成的。域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器。</p>
<h2 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP/IP 通信传输流"></a>TCP/IP 通信传输流</h2><p>　　<img src="https://img2018.cnblogs.com/blog/1330623/201811/1330623-20181113084120716-1173123907.png" alt="img"></p>
<p>　　利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通 信。发送端从应用层往下走，接收端则往应用层往上走。 </p>
<p>　　我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层 （HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。 </p>
<p>　　接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数 据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端 口号后转发给网络层。</p>
<p>　　在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链 路层。这样一来，发往网络的通信请求就准备齐全了。</p>
<p>　　接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用 层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。</p>
<p>　　<img src="https://img2018.cnblogs.com/blog/1330623/201811/1330623-20181113084255642-1746116334.png" alt="img"></p>
<p>　　发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该 层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层 时会把对应的首部消去。</p>
<p>　　这种把数据信息包装起来的做法称为封装（encapsulate）。</p>
<h2 id="负责传输的-IP-协议"><a href="#负责传输的-IP-协议" class="headerlink" title="负责传输的 IP 协议"></a>负责传输的 IP 协议</h2><p>　　按层次分，IP（Internet Protocol）网际协议位于网络层。Internet Protocol 这个名称可能听起来有点夸张，但事实正是如此，因为几乎 所有使用网络的系统都会用到 IP 协议。TCP/IP 协议族中的 IP 指的就 是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能 有人会把“IP”和“IP 地址”搞混，“IP”其实是一种协议的名称。</p>
<p>　　IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方 那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。</p>
<p>　　IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定 地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。</p>
<p>　　使用 ARP 协议凭借 MAC 地址进行通信</p>
<p>　　IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网 （LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转 才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方 的 IP 地址就可以反查出对应的 MAC 地址。</p>
<p>　　<img src="https://img2018.cnblogs.com/blog/1330623/201811/1330623-20181113085614769-669036395.png" alt="img"></p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>设备：屏蔽双绞线，非屏蔽双绞线，集线器，转换器，中继器</p>
<p>走数字信号，也就是比特流。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>网卡号就是mac地址，数据链路层对应接口部分。以太网地址就是MAC地址。有mac地址才可以上网。</p>
<p>设备：交换机，网卡，网桥。</p>
<p>mac地址是48位二进制。12个16进制数表示。前24位是标准组织IEEE制度，后24位厂家直接指定。</p>
<p>例：00-1C-25-91-65-48 或001c.2591.6548</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>为了更精准找到用户，需要为网络设备提供逻辑地址，所以需要ip地址。也叫因特网地址。ip地址最常用设备就是路由器。ip用算法编译，最快转发到达。实现一个一个结点最快到达。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>负责建立端到端的连接，负责数据在端到端之前的传输。传输层通过端口号区分上层服务。</p>
<p>提供TCP和UDP</p>
<h4 id="1-对比"><a href="#1-对比" class="headerlink" title="1. 对比"></a>1. 对比</h4><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">UDP</th>
<th align="left">TCP</th>
</tr>
</thead>
<tbody><tr>
<td align="left">是否连接</td>
<td align="left">无连接</td>
<td align="left">面向连接</td>
</tr>
<tr>
<td align="left">是否可靠</td>
<td align="left">不可靠传输，不使用流量控制和拥塞控制</td>
<td align="left">可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td align="left">连接对象个数</td>
<td align="left">支持一对一，一对多，多对一和多对多交互通信</td>
<td align="left">只能是一对一通信</td>
</tr>
<tr>
<td align="left">传输方式</td>
<td align="left">面向报文</td>
<td align="left">面向字节流</td>
</tr>
<tr>
<td align="left">首部开销</td>
<td align="left">首部开销小，仅8字节</td>
<td align="left">首部最小20字节，最大60字节</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">适用于实时应用（IP电话、视频会议、直播等）域名DNS系统，视频流</td>
<td align="left">适用于要求可靠传输的应用，例如文件传输，电子邮件，web浏览器</td>
</tr>
</tbody></table>
<h4 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h4><ul>
<li>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。</li>
<li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li>
<li>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</li>
</ul>
<h3 id="二、UDP"><a href="#二、UDP" class="headerlink" title="二、UDP"></a>二、UDP</h3><p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<p>它有以下几个特点：</p>
<h4 id="1-面向无连接"><a href="#1-面向无连接" class="headerlink" title="1. 面向无连接"></a>1. 面向无连接</h4><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>
<p>具体来说就是：</p>
<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<h4 id="2-有单播，多播，广播的功能"><a href="#2-有单播，多播，广播的功能" class="headerlink" title="2. 有单播，多播，广播的功能"></a>2. 有单播，多播，广播的功能</h4><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>
<h4 id="3-UDP是面向报文的"><a href="#3-UDP是面向报文的" class="headerlink" title="3. UDP是面向报文的"></a>3. UDP是面向报文的</h4><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>
<h4 id="4-不可靠性"><a href="#4-不可靠性" class="headerlink" title="4. 不可靠性"></a>4. 不可靠性</h4><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>
<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>
<p><img src="https://image.fundebug.com/2019-03-21-02.gif" alt="img"></p>
<p>从上面的动态图可以得知，UDP只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。</p>
<h4 id="5-头部开销小，传输数据报文时是很高效的。"><a href="#5-头部开销小，传输数据报文时是很高效的。" class="headerlink" title="5. 头部开销小，传输数据报文时是很高效的。"></a>5. 头部开销小，传输数据报文时是很高效的。</h4><p><img src="https://image.fundebug.com/2019-03-21-03.png" alt="img"></p>
<p>UDP 头部包含了以下几个数据：</p>
<ul>
<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li>
</ul>
<p>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p>
<h3 id="三、TCP"><a href="#三、TCP" class="headerlink" title="三、TCP"></a>三、TCP</h3><p>当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。</p>
<p>TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p>
<h4 id="1-TCP连接过程"><a href="#1-TCP连接过程" class="headerlink" title="1. TCP连接过程"></a>1. TCP连接过程</h4><p>如下图所示，可以看到建立一个TCP连接的过程为（三次握手的过程）:</p>
<p><img src="https://image.fundebug.com/2019-03-21-04.png" alt="img"></p>
<p><strong>第一次握手</strong></p>
<p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</p>
<p><strong>第二次握手</strong></p>
<p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p>
<p><strong>第三次握手</strong></p>
<p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p>
<p>这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。</p>
<p><img src="https://image.fundebug.com/2019-03-21-05.gif" alt="img"></p>
<h4 id="2-TCP断开链接"><a href="#2-TCP断开链接" class="headerlink" title="2. TCP断开链接"></a>2. TCP断开链接</h4><p><img src="https://image.fundebug.com/2019-03-21-06.png" alt="img"></p>
<p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。</p>
<p><strong>第一次握手</strong></p>
<p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p>
<p><strong>第二次握手</strong></p>
<p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。</p>
<p><strong>第三次握手</strong></p>
<p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。</p>
<p><strong>第四次握手</strong></p>
<p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p>
<h4 id="3-TCP协议的特点"><a href="#3-TCP协议的特点" class="headerlink" title="3. TCP协议的特点"></a>3. TCP协议的特点</h4><ul>
<li><p>面向连接</p>
<p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p>
</li>
<li><p>仅支持单播传输</p>
</li>
</ul>
<p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p>
<ul>
<li>面向字节流</li>
</ul>
<p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p>
<ul>
<li><p>可靠传输</p>
<p>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>
</li>
<li><p>提供拥塞控制</p>
</li>
</ul>
<p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p>
<ul>
<li>TCP提供全双工通信</li>
</ul>
<p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>就是.exe文件</p>
<p>为应用软件提供接口，从而使得应用程序能够使用网络服务。例：http,ftp,telnet,dns,smtp…</p>
<p>每个应用程序都有端口号，http：80端口，ftp：21端口。dns：53端口。</p>
<p>|   E |  IP | UDP | APPLIACTION </p>
<p>| fram|packet|segment|payload</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>ccna2</title>
    <url>/2020/05/10/ccna2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="ip地址以及子网掩码"><a href="#ip地址以及子网掩码" class="headerlink" title="ip地址以及子网掩码"></a>ip地址以及子网掩码</h1><p>ip地址我们看到是十进制的，而实际上是二进制。</p>
<p>0000 0000八位字段，4个字段。0.0.0.0-255.255.255.255共42亿9千多万。</p>
<h2 id="IP地址分类（A类-B类-C类-D类-E类）"><a href="#IP地址分类（A类-B类-C类-D类-E类）" class="headerlink" title="IP地址分类（A类 B类 C类 D类 E类）"></a>IP地址分类（A类 B类 C类 D类 E类）</h2><p>IP地址由四段组成，每个字段是一个字节，8位，最大值是255，,</p>
<p>IP地址由两部分组成，即<a href="http://baike.baidu.com/view/547479.htm" target="_blank" rel="noopener">网络地址</a>和<a href="http://baike.baidu.com/view/547482.htm" target="_blank" rel="noopener">主机地址</a>。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。二者是主从关系。</p>
<p>IP地址的四大类型标识的是网络中的某台主机。IPv4的地址长度为32位，共4个字节，但实际中我们用<a href="http://baike.baidu.com/view/828066.htm" target="_blank" rel="noopener">点分十进制</a>记法。</p>
<p><img src="https://images2018.cnblogs.com/blog/1440532/201809/1440532-20180912093201807-306001370.png" alt="img"></p>
<p>IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。  全0和全1的都保留不用。</p>
<p>A类：(1.0.0.0-126.0.0.0)（默认子网掩码：255.0.0.0或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。</p>
<p>B类：(128.0.0.0-191.255.0.0)（默认子网掩码：255.255.0.0或0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。</p>
<p>C类：(192.0.0.0-223.255.255.0)（子网掩码：255.255.255.0或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。</p>
<p>D类：是<em>多播地址</em>。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户[1] 。</p>
<p>E类：是<em>保留地址</em>。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。</p>
<p>在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下：<br>A类地址：10.0.0.0～10.255.255.255<br>B类地址：172.16.0.0～172.31.255.255<br>C类地址：192.168.0.0～192.168.255.255</p>
<p><strong>回送地址</strong>：loopback环回</p>
<p><strong>127.0.0.1。 也是本机地址，等效于localhost或本机IP。一般用于测试使用。例如：ping 127.0.0.1来测试本机TCP/IP是否正常。</strong></p>
<p>能用的ip只有abc三类：37个亿 </p>
<p> <img src="https://images2018.cnblogs.com/blog/1440532/201809/1440532-20180912093223517-341420925.png" alt="img"></p>
<p>A类：(1.0.0.0-126.0.0.0)（默认子网掩码：255.0.0.0 ==\8）(缩写是8)</p>
<p>B类：(128.0.0.0-191.255.0.0)（默认子网掩码：255.255.0.0 ==\16s）</p>
<p>C类：(192.0.0.0-223.255.255.0)（子网掩码：255.255.255.0 ==\24）</p>
<p>子网掩码：将一个ip地址</p>
<p>例：192.168.1.1 mask：255.255.255.    0，掩盖住的是24位1. 1就是网络号，后面的就是主机号。</p>
<p>子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。</p>
<p>子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。<br>子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。</p>
<p>子网掩码——屏蔽一个IP地址的网络部分的“全1”比特模式。对于A类地址来说，默认的子网掩码是255.0.0.0；对于B类地址来说默认的子网掩码是255.255.0.0；对于C类地址来说默认的子网掩码是255.255.255.0。</p>
<ul>
<li>通过子网掩码，就可以判断两个IP在不在一个局域网内部。</li>
<li>子网掩码可以看出有多少位是网络号，有多少位是主机号</li>
</ul>
<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><hr>
<p>网关(Gateway)又称网间连接器、协议转换器。默认网关在网络层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连</p>
<p>网关实质上是一个网络通向其他网络的IP地址。</p>
<p>比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1<del>192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1</del>192.168.2.254”，子网掩码为255.255.255.0。</p>
<p>在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络中的主机处在不同的网络里。</p>
<p>而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。</p>
<p>所以说，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。那么这个IP地址是哪台机器的IP地址呢？网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。</p>
<h2 id="广播地址-Broadcast-Address"><a href="#广播地址-Broadcast-Address" class="headerlink" title="广播地址(Broadcast Address)"></a>广播地址(Broadcast Address)</h2><hr>
<p>广播地址(Broadcast Address)是专门用于同时向网络中所有工作站进行发送的一个地址。</p>
<p>在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为2 进制的11111111 ），当发出一个目的地址为10.1.1.255 的分组（封包）时，它将被分发给该网段上的所有计算机。</p>
<h1 id="根据IP地址和子网掩码求-网络地址-和-广播地址"><a href="#根据IP地址和子网掩码求-网络地址-和-广播地址" class="headerlink" title="根据IP地址和子网掩码求 网络地址 和 广播地址"></a>根据IP地址和子网掩码求 网络地址 和 广播地址</h1><hr>
<ul>
<li>将IP地址和子网掩码换算为二进制，子网掩码连续全1的是网络地址，后面的是主机地址，虚线前为网络地址，虚线后为主机地址</li>
<li><strong>IP地址和子网掩码进行与运算，结果是网络地址</strong>（即主机号全0是网络地址）</li>
<li>将运算结果中的网络地址不变，<strong>主机地址变为1，结果就是广播地址</strong></li>
<li>地址范围就是含在本网段内的所有主机</li>
</ul>
<p>网络地址+1即为第一个主机地址，广播地址-1即为最后一个主机地址，<br>由此可以看出地址范围是： 网络地址+1 至 广播地址-1</p>
<ul>
<li>主机的数量=2^二进制位数的主机-2</li>
</ul>
<p>减2是因为主机不包括网络地址和广播地址。</p>
<p><strong>示例</strong><br>一个主机的IP地址是202.112.14.137，掩码是255.255.255.224，要求计算这个主机所在网络的网络地址和广播地址</p>
<h2 id="根据子网掩码可以分割网络号-主机号"><a href="#根据子网掩码可以分割网络号-主机号" class="headerlink" title="根据子网掩码可以分割网络号+主机号"></a>根据子网掩码可以分割网络号+主机号</h2><hr>
<p><code>255.255.255.224</code> 转二进制：</p>
<blockquote>
<p>11111111 11111111 11111111 11100000</p>
</blockquote>
<p>网络号有27位，主机号有5位</p>
<p>网络地址就是：把IP地址转成二进制和子网掩码进行与运算</p>
<p>11001010 01110000 00001110 10001001</p>
<p>IP地址&amp;子网掩码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11001010 01110000 00001110 10001001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11111111 11111111 11111111 11100000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11001010 01110000 00001110 10000000</span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
<li>2</li>
<li>3</li>
<li>4</li>
<li>5</li>
<li>6</li>
<li>7</li>
</ul>
<p>即：202.112.14.128</p>
<h2 id="计算广播地址"><a href="#计算广播地址" class="headerlink" title="计算广播地址"></a>计算广播地址</h2><hr>
<p>广播地址：网络地址的主机位全部变成1 ，10011111 即159 即：202.112.14.159</p>
<h2 id="主机数"><a href="#主机数" class="headerlink" title="主机数"></a>主机数</h2><hr>
<p>主机号有5位，那么这个地址中，就只能有25−2=3025−2=30个主机</p>
<p>因为其中全0作为网络地址，全1作为广播地址</p>
<h1 id="根据每个网络的主机数量进行子网地址的规划和计算子网掩码"><a href="#根据每个网络的主机数量进行子网地址的规划和计算子网掩码" class="headerlink" title="根据每个网络的主机数量进行子网地址的规划和计算子网掩码"></a>根据每个网络的主机数量进行子网地址的规划和计算子网掩码</h1><hr>
<p>这也可按上述原则进行计算。</p>
<p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是<br>10＋1＋1＋1＝13<br>注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。<br>因为13小于16（16等于2的4次方），所以主机位为4位。</p>
<p>而 256－16＝240 所以该子网掩码为255.255.255.240。</p>
<p>如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为：<br>14＋1＋1＋1＝17<br>17.大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224</p>
<p>5） 主机的数量</p>
<h1 id="206-110-4-0-18被划分成16个子网，每个子网掩码？"><a href="#206-110-4-0-18被划分成16个子网，每个子网掩码？" class="headerlink" title="206 110 4 0/18被划分成16个子网，每个子网掩码？"></a>206 110 4 0/18被划分成16个子网，每个子网掩码？</h1><hr>
<p>（划分成16个子网，根据子网掩码/18就表示有18个1，就要从的IP地址的主机位借4位来用作网络位！）</p>
<p>子网掩码是255.255.252.0</p>
<p>每个子网可以容纳的主机数是1024台。</p>
<p>下面我来给你详细解答：</p>
<p>206.110.1.0 /18 由最后的那个/18，我们可以知道这个IP已经规定了它的网络位是18位，它默认的子网掩码就是11111111.11111111.11 | 000000.00000000(其中1代表网络位,0代表主机位)</p>
<p>可以看出我们可以操作的位数就是后面的14个0，也就是说我们可以在地面划分出几位作为子网的网络位，进而来划分子网。要求是切分成16个子网，我们知道2的4次方刚好等于16，这就说明子网网络位的位数是4位，那14-4=10就是子网的主机位。所以上面我写的那串二进制就可以变成：11111111.11111111.111111 | 00.00000000(其中1代表网络位,0代表主机位)</p>
<h1 id="ip段-数字-如192-168-0-1-24是什么意思"><a href="#ip段-数字-如192-168-0-1-24是什么意思" class="headerlink" title="ip段/数字-如192.168.0.1/24是什么意思?"></a>ip段/数字-如192.168.0.1/24是什么意思?</h1><hr>
<p>后面这个数字标示了我们的网络号的位数，也就是子网掩码中前多少号为1</p>
<p>129.168.1.1 /24 这个24就是告诉我们网络号是24位</p>
<p>也就相当于告诉我们了</p>
<p>子网掩码是：<code>11111111 11111111 11111111 00000000</code></p>
<p>即：<code>255.255.255.0</code></p>
<p>172.16.10.33/27 中的/27</p>
<p>也就是说子网掩码是<code>255.255.255.224</code> 即27个全1</p>
<blockquote>
<p>11111111 11111111 11111111 11100000</p>
</blockquote>
<p>VLSM 与CIDR的比较/什么是CIDR/什么是VLSM<br><strong>CIDR : netmask 缩短 VLSM: netmask 增长</strong></p>
<p>使用CIDR聚合地址的方法与使用VLSM划分子网的方法类似。在使用VLSM划分子网时，将原来分类IP地址中的主机位按照需要划出一部分作为网络位使用；而在使用CIDR聚合地址时，则是将原来分类IP地址中的网络位划出一部分作为主机位使用。</p>
<p>++++++++++++++++++++++++++++++++++++++++++++++</p>
<p><strong>什么是VLSM</strong>?</p>
<p>VLSM提出供了在一个主类(A、B、C类)网络内包含多个子网掩码的能力，以及对一个子网的再进行子网划分的能力。它的优点如下：</p>
<p>1：对IP地址更为有效的使用-如果不采用VLSM，公司将被限制为在一个A、B、C类网络号内只能使用一个子网掩码；<br>2：路由归纳的能力更强-VLSM允许在编址计划中有更多的体系分层，因此可以在路由表内进行更好的路由归纳。</p>
<p>变长子网掩码(VLSM)的作用:节约IP地址空间;减少路由表大小.使用VLSM时,所采用的路由协议必须能够支持它。</p>
<p>++++++++++++++++++++++++++++++++++++++++++++++</p>
<p><strong>什么是路由归纳</strong> ？<br>在大型互连网络中，存在着成百上千的网络。在这环境中，一般不希望路由器在它的路由表中保存所有的这些路由。路由归纳（也被子称为路由聚合或超网 supernetting）可以减少路由器必须保存的路由条目数量，因为它是在一个归纳地址中代表一系列网络号的一种方法。<br>在大型 、复杂的网络中使用路由归纳的另一个优点是它可以使其它路由器免受网络拓朴结构变化的影响。只有在就用了一个正确的地址规划时，路由归纳才能可行和最有效，在子网环境中，当网络地址是以2的指数形式的连续区块时，路由归纳是最有效的。</p>
<p>路 由选择协议根据共享网络地址部分来归纳或聚合路由。无类别路由选择协议—OSPF和EIGRP-支持基于子网地址，包括VLSM编者按址的路由归纳。 有类别路由选择协议- RIPv1和IGRP-自动地在有类别网络的边界上归纳路由。有类别路由选择协议不支持在任何其它比特边界上的路由归纳，而无类别路由选择协议支持在任何 比特边界上的路由归纳。<br>因为路由表的条目少了，路由归纳可以减少对路由器内存的占用，减少路由选择协议造成的网络流量。</p>
<p>网络中的路由归纳能够正确的工作，必须满足下面要求：<br>1:多个IP地址必须共享相同的高位比特；<br>2:路由选择协议必须根据32比特的IP地址和高达32比特的前缀长度来作出路由转发决定<br>3:路由更新必须将前缀长度（子网掩码）与32比特的IP地址一起传输。</p>
<p>++++++++++++++++++++++++++++++++++++++++++++++</p>
<p><strong>无类别域间路由</strong>（CIDR）<br>CIDR是开发用于帮助减缓IP地址和路由表增大问题的一项技术。CIDR（Classless Inter-Domain Routing，无类域间路由）的基本思想是取消IP地址的分类结构，将多个地址块聚合在一起生成一个更大的网络，以包含更多的主机。CIDR支持路由聚 合，能够将路由表中的许多路由条目合并为成更少的数目，因此可以限制路由器中路由表的增大，减少路由通告。同时，CIDR有助于IPv4地址的充分利用。 CIDR叫做无类域间路由,ISP常用这样的方法给客户分配地址,ISP提供给客户1个块(block size),类似这样:192.168.10.32/28,这排数字告诉你你的子网掩码是多少,/28代表多少位为1,最大/32.但是你必须知道的1点 是:不管是A类还是B类还是其他类地址,最大可用的只能为30/,即保留2位给主机位。</p>
<p>++++++++++++++++++++++++++++++++++++++++++++++</p>
<p>CIDR举例：</p>
<p>假设有一组C类地址为192.168.8.0－192.168.15.0，如果用CIDR将这组地址聚合为一个网络，其网络地址和子网掩码应该为：<br>　　A. 192.168.8.0/21<br>　　B. 192.168.8.0/20<br>　　C. 192.168.8.0/24<br>　　D. 192.168.8.15/24</p>
<p>KEY：A<br>　　要求将192.168.8.0－192.168.15.0这组C类地址聚合为一个网络，我们先将C类地址的第三个八位组转换成二进制：</p>
<p>点分十进制 将第三个八位组转换成二进制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.8.0 	192.168.00001 000.0</span><br><span class="line">192.168.9.0 	192.168.00001 001.0</span><br><span class="line">192.168.10.0 	192.168.00001 010.0</span><br><span class="line">192.168.11.0 	192.168.00001 011.0</span><br><span class="line">192.168.12.0 	192.168.00001 100.0</span><br><span class="line">192.168.13.0 	192.168.00001 101.0</span><br><span class="line">192.168.14.0 	192.168.00001 110.0</span><br><span class="line">192.168.15.0 	192.168.00001 111.0</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<p>从上表中可以看出，只要将网络位的低三位划分出来作为主机位，这些C类地址就被聚合在一个网络之中。因此，聚合后的网络地址应该为192.168.8.0/21，正确答案为A。</p>
<p><strong>主机地址只代表一个主机，只有网络地址才有聚合的意义</strong>。</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>ccna5</title>
    <url>/2020/05/10/ccna5/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>











<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>ccna7</title>
    <url>/2020/05/10/ccna7/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>











<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>ccna6</title>
    <url>/2020/05/10/ccna6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>











<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>crawler爬虫</title>
    <url>/2020/04/27/crawler/</url>
    <content><![CDATA[<h2 id="爬虫入门"><a href="#爬虫入门" class="headerlink" title="爬虫入门"></a>爬虫入门</h2><p>pip3 install requests selenium beautifulsoup4 pyquery pymysql pymongo redis flask django jupyter</p>
<p>安装各种库，安装MongoDB，redis，anaconda，pycharm，Python3</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#带参数get请求</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.get(<span class="string">'https://httpbin.org/get?name=jackson&amp;age=100'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.text)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=&#123;<span class="string">'name'</span>:<span class="string">'ap'</span>,<span class="string">'age'</span>:<span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.get(<span class="string">'https://httpbin.org/get'</span>,params=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#解析json</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.get(<span class="string">'https://httpbin.org/get'</span>,params=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.json)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.loads(response.text))<span class="comment">#以上两个打印一样</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(response.json()))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">#获取二进制数据,可以保持图片视频</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.get(<span class="string">"https://github.com/favicon.ico"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(response.text),type(response.content))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt; &lt;<span class="title">class</span> '<span class="title">bytes</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(response.text)</span>#一堆乱码</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(response.content)</span>#一堆16进制数字</span></span><br><span class="line"><span class="class">#保存二进制图片视频</span></span><br><span class="line">&gt;&gt;&gt; response=requests.get("https://github.com/favicon.ico")</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'favicon.ico'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:<span class="comment">#命名为favicoc</span></span><br><span class="line"><span class="meta">... </span>    f.write(response.content)</span><br><span class="line"><span class="meta">... </span>    f.close()</span><br><span class="line"><span class="comment">#添加headers</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>headers=&#123;<span class="string">'User-Agent'</span>:<span class="string">'。。。一堆码读出来的'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.get(<span class="string">"https://www.zhihu.com/explore"</span>,headers=headers)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#基本post请求</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=&#123;<span class="string">'name'</span>:<span class="string">'ap'</span>,<span class="string">'age'</span>:<span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.post(<span class="string">'https://httpbin.org/post'</span>,data=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.text)</span><br><span class="line"><span class="comment">#headers post,报表表单</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=&#123;<span class="string">'name'</span>:<span class="string">'ap'</span>,<span class="string">'age'</span>:<span class="number">99</span>&#125;</span><br><span class="line">headers=&#123;<span class="string">'User-Agent'</span>:<span class="string">'。。。一堆码读出来的'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.post(<span class="string">"https://httpbin.org/post"</span>,data=data,headers=headers)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.json())</span><br><span class="line"></span><br><span class="line"><span class="comment">#response属性</span></span><br></pre></td></tr></table></figure>

<p>#找headers <a href="https://mkyong.com/computer-tips/how-to-view-http-headers-in-google-chrome/" target="_blank" rel="noopener">https://mkyong.com/computer-tips/how-to-view-http-headers-in-google-chrome/</a></p>
<p>找到最下面的User-Agent: Mozilla 。。。</p>
<h2 id="看到python非常全资料-python3爬虫实战-课时09"><a href="#看到python非常全资料-python3爬虫实战-课时09" class="headerlink" title="看到python非常全资料/python3爬虫实战/课时09"></a>看到python非常全资料/python3爬虫实战/课时09</h2>]]></content>
  </entry>
  <entry>
    <title>ccna8</title>
    <url>/2020/05/10/ccna8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>











<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>github新手入门</title>
    <url>/2020/05/09/github/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>


<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-91f530111cfb1937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img"></p>
<p>GitHub是基于git实现的代码托管。git是目前最好用的版本控制系统了，非常受欢迎，比之svn更好。</p>
<p>GitHub可以免费使用，并且快速稳定。即使是付费帐户，每个月不超过10美刀的费用也非常便宜。</p>
<p>利用GitHub，你可以将项目存档，与其他人分享交流，并让其他开发者帮助你一起完成这个项目。优点在于，他支持多人共同完成一个项目，因此你们可以在同一页面对话交流。</p>
<p>创建自己的项目，并备份，代码不需要保存在本地或者服务器，GitHub做得非常理想。</p>
<p>学习Git也有很多好处。他被视为一个预先维护过程，你可以按自己的需要恢复、提交出现问题,或者您需要恢复任何形式的代码，可以避免很多麻烦。Git最好的特性之一是能够跟踪错误，这让使用Github变得更加简单。Bugs可以公开，你可以通过Github评论，提交错误。</p>
<p>在GitHub页面，你可以直接开始，而不需要设置主机或者DNS。</p>
<p>对于我来说，我可以在公司和家编辑同样的一套代码了，用U盘或者网盘都好麻烦的说</p>
<p>理论说太多容易忘，来实践实践吧。</p>
<h2 id="一-创建-github-repository-仓库"><a href="#一-创建-github-repository-仓库" class="headerlink" title="一. 创建 github repository(仓库)"></a>一. 创建 github repository(仓库)</h2><h4 id="1-登录-github"><a href="#1-登录-github" class="headerlink" title="1. 登录 github"></a>1. 登录 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2F" target="_blank" rel="noopener">github</a></h4><h4 id="2-创建-repository-仓库"><a href="#2-创建-repository-仓库" class="headerlink" title="2. 创建 repository(仓库)"></a>2. 创建 repository(仓库)</h4><p>为啥要叫 repository(仓库)？我起初也纳闷，叫代码库不更简单明了么？ 但仔细一琢磨，仓库一般都是放粮食的吧，这是把代码当作饱腹之物，多有爱，瞬间觉得这冰冷冷的代码充满了查克拉。</p>
<p>扯远了，来看怎么创建仓库</p>
<p>看到右上角 “+” 没? 点击选择 “New repository”</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-a9214d983f3a748b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/301" alt="img"></p>
<p>下面是创建仓库信息，只有名字是必填项</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-6a9e89e7c89d2b35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/789" alt="img"></p>
<p>创建成功后，可以看到自己的仓库地址。它还介绍了github仓库的常用指令, 这个指令需要在本地安装 git 客户端</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">　　git init <span class="comment">// 把这个目录变成Git可以管理的仓库</span></span><br><span class="line">　　git <span class="keyword">add</span> README.md <span class="comment">// 文件添加到仓库</span></span><br><span class="line">　　git <span class="keyword">add</span> . <span class="comment">// 不但可以跟单一文件，还可以跟通配符，更可以跟目录。一个点就把当前目录下所有未追踪的文件全部add了 </span></span><br><span class="line">　　git commit -m <span class="string">"first commit"</span> <span class="comment">// 把文件提交到仓库</span></span><br><span class="line">　　git remote <span class="keyword">add</span> origin git@github.com:wangjiax9/practice.git <span class="comment">// 关联远程仓库</span></span><br><span class="line">　　git push -u origin master <span class="comment">// 把本地库的所有内容推送到远程库上</span></span><br></pre></td></tr></table></figure>

<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-7106c26b6e83ecb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/860" alt="img"></p>
<h2 id="二-安装-git-客户端"><a href="#二-安装-git-客户端" class="headerlink" title="二. 安装 git 客户端"></a>二. 安装 git 客户端</h2><h4 id="1-下载-git"><a href="#1-下载-git" class="headerlink" title="1. 下载 git"></a>1. 下载 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgit-scm.com%2F" target="_blank" rel="noopener">git</a></h4><p><img src="https:////upload-images.jianshu.io/upload_images/4804567-42874577806d037f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/356" alt="img"></p>
<h4 id="2-安装客户端"><a href="#2-安装客户端" class="headerlink" title="2. 安装客户端"></a>2. 安装客户端</h4><p><img src="https:////upload-images.jianshu.io/upload_images/4804567-9c365772c80c0308.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/503" alt="img"></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-4ff227fa2d21f846.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/503" alt="img"></p>
<p>选择安装路径，千万别选带中文的路径，有时候会引起不必要的误会</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-185e4ce580d41016.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/503" alt="img"></p>
<p>选择安装组件，按默认的来就好了</p>
<p>1）图标组件(Addition icons) : 选择是否创建快速启动栏图标 或者 是否创建桌面快捷方式;<br>2）桌面浏览(Windows Explorer integration) : 浏览源码的方法, 单独的上下文浏览 只使用bash 或者 只用Git GUI工具; 高级的上下文浏览方法 使用git-cheetah plugin插件;<br>3）关联配置文件(Associate .git*) : 是否关联git配置文件, 该配置文件主要显示文本编辑器的样式;<br>4）关联shell脚本文件(Associate .sh) : 是否关联Bash命令行执行的脚本文件;<br>5）使用TrueType编码 : 在命令行中是否使用TruthType编码, 该编码是微软和苹果公司制定的通用编码;</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-3f09255ea4d9c116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/503" alt="img"></p>
<p>设置开始菜单中快捷方式的目录名称，默认就好，下一步吧</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-75155711e0c84f0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/503" alt="img"></p>
<p>设置环境变量 : 选择使用什么样的命令行工具, 一般情况下我们默认使用Git Bash即可, 默认选择;<br>1）Git自带 : 使用Git自带的Git Bash命令行工具;<br>2）系统自带CMD : 使用Windows系统的命令行工具;</p>
<p>3） 二者都有 : 上面二者同时配置, 但是注意, 这样会将windows中的find.exe 和 sort.exe工具覆盖, 如果不懂这些尽量不要选择;</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-4f2bc47bad57fafb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/503" alt="img"></p>
<p>选择换行格式 ，依然是默认就好。<br>1）检查出windows格式转换为unix格式 : 将windows格式的换行转为unix格式的换行在进行提交;<br>2）检查出原来格式转为unix格式 : 不管什么格式的, 一律转为unix格式的换行在进行提交;<br>3）不进行格式转换 : 不进行转换, 检查出什么, 就提交什么;</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-6027491640922fb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/503" alt="img"></p>
<p>选择终端模拟器，依然默认就好<br>1）使用MinTTY，就是在Windows开了一个简单模拟Linux命令环境的窗口Git Bash<br>2）使用windows的系统的命令行程序cmd.exe</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-c8c82ac44f1078bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/503" alt="img"></p>
<p>选择默认就好，不用文件系统缓存</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-c81762a8dcfabc2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/503" alt="img"></p>
<p>安装ing…</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-ba2f419011476815.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/503" alt="img"></p>
<p>安装成功</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-e95635f037f910ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/503" alt="img"></p>
<h4 id="3-绑定用户"><a href="#3-绑定用户" class="headerlink" title="3. 绑定用户"></a>3. 绑定用户</h4><p>打开git-bash.exe，在桌面快捷方式/开始菜单/安装目录中<br>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识，用户和邮箱为你github注册的账号和邮箱<br><code>git config --global user.name &quot;Your Name&quot;</code><br><code>git config --global user.email &quot;your_email@example.com&quot;</code><br>注: <a href="https://links.jianshu.com/go?to=mailto%3Ayour_email%40example.com" target="_blank" rel="noopener">your_email@example.com</a> 的部分请改成你在创建账户时用的邮箱地址</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-365223d5e05e546e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/445" alt="img"></p>
<p>这个命令会在 C:\Users\Administator （Administator为电脑用户名，每个人不同）目录下生成 .gitconfig 文件</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-ea24a13bbfa47d9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/491" alt="img"></p>
<p>PS: 下面代码是为了记住用户名和密码, 不用每次都输入, 需要的直接添加保存即可</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">credential</span>]</span><br><span class="line">    helper = store</span><br></pre></td></tr></table></figure>

<p>当然, 还有其他方法保存, 可以直接在git bash 中执行命令：</p>
<ul>
<li>记住密码十五分钟<br><code>git config --global credential.helper cache</code></li>
<li>自定义记住的时间 (单位: 秒)<br><code>git config credential.helper &#39;cache --timeout=3600&#39;</code></li>
<li>永久记住<br><code>git config --global credential.helper store</code></li>
</ul>
<p>最后再输入一次账号密码就可以保存了</p>
<h2 id="三-为-Github-账户设置-SSH-key"><a href="#三-为-Github-账户设置-SSH-key" class="headerlink" title="三. 为 Github 账户设置 SSH key"></a>三. 为 Github 账户设置 SSH key</h2><p>众所周知 ssh key 是加密传输。</p>
<p>加密传输的算法有好多，git 使用 rsa，rsa 要解决的一个核心问题是，如何使用一对特定的数字，使其中一个数字可以用来加密，而另外一个数字可以用来解密。这两个数字就是你在使用 git 和 github 的时候所遇到的 public key 也就是公钥以及 private key 私钥。</p>
<p>其中，公钥就是那个用来加密的数字，这也就是为什么你在本机生成了公钥之后，要上传到 github 的原因。从 github 发回来的，用那公钥加密过的数据，可以用你本地的私钥来还原。</p>
<p>如果你的 key 丢失了，不管是公钥还是私钥，丢失一个都不能用了，解决方法也很简单，重新再生成一次，然后在 github.com 里再设置一次就行</p>
<h4 id="1-生成-SSH-Key"><a href="#1-生成-SSH-Key" class="headerlink" title="1. 生成 SSH Key"></a>1. 生成 SSH Key</h4><p>首先检查是否已生成密钥 <code>cd ~/.ssh</code><br><code>ls</code> 如果有3个文件，则密钥已经生成，id_rsa.pub 就是公钥</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-5498a20ffa73930e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/246" alt="img"></p>
<p>也可以打开我的电脑 <code>C:\Users\Administator\.ssh</code> （Administator为电脑用户名，每个人不同）里面找到</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-0e4b2a3011fbe48f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/310" alt="img"></p>
<p>如果没有生成，那么通过 <code>$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code> 来生成<br>注: <a href="https://links.jianshu.com/go?to=mailto%3Ayour_email%40example.com" target="_blank" rel="noopener">your_email@example.com</a> 的部分请改成你在创建账户时用的邮箱地址</p>
<p>1）是路径确认，直接按回车存默认路径即可<br>2）直接回车键，这里我们不使用密码进行登录, 用密码太麻烦;<br>3）直接回车键</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-d98a9822c8b3c1a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/563" alt="img"></p>
<p>生成成功后，去对应目录 <code>C:\Users\Administator\.ssh</code> （Administator为电脑用户名，每个人不同）用记事本打开 id_rsa.pub，得到 ssh key公钥</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-6a5385b8058460ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/572" alt="img"></p>
<h4 id="2-为-github-账号配置-ssh-key"><a href="#2-为-github-账号配置-ssh-key" class="headerlink" title="2. 为 github 账号配置 ssh key"></a>2. 为 github 账号配置 ssh key</h4><p>切换到 github，展开个人头像的小三角，点击settings</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-fbb65dded578867c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/210" alt="img"></p>
<p>然后打开 SSH and GPG keys 菜单， 点击 New SSH key 新增密钥</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-fbc32170d3eabe91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1071" alt="img"></p>
<p>标题建议和仓库名一致, 便于区分. 接着将 id_rsa.pub 文件中 key 粘贴到此，最后 Add SSH key 生成密钥</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-f2ce071d1a7a83a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1137" alt="img"></p>
<p>如此，github账号的SSH keys配置完成</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-acb564e011a085d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/755" alt="img"></p>
<h2 id="四-上传本地项目到-github"><a href="#四-上传本地项目到-github" class="headerlink" title="四. 上传本地项目到 github"></a>四. 上传本地项目到 github</h2><ol>
<li><p>创建一个本地项目</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-8d5e957b140acb96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/331" alt="img"></p>
</li>
<li><p>建立本地仓库<br>再来复习一下创建新仓库的指令：</p>
</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">　　git init <span class="comment">// 把这个目录变成Git可以管理的仓库</span></span><br><span class="line">　　git <span class="keyword">add</span> README.md <span class="comment">// 文件添加到仓库</span></span><br><span class="line">　　git <span class="keyword">add</span> . <span class="comment">// 不但可以跟单一文件，还可以跟通配符，更可以跟目录。一个点就把当前目录下所有未追踪的文件全部add了 </span></span><br><span class="line">　　git commit -m <span class="string">"first commit"</span> <span class="comment">// 把文件提交到仓库</span></span><br><span class="line">　　git remote <span class="keyword">add</span> origin git@github.com:wangjiax9/practice.git <span class="comment">// 关联远程仓库</span></span><br><span class="line">　　git push -u origin master <span class="comment">// 把本地库的所有内容推送到远程库上</span></span><br></pre></td></tr></table></figure>

<p>首先，进入到 beautifulDay 项目目录，还记得创建仓库成功后的那个页面吧，指令都在呢<br>然后执行指令：<code>git init</code></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-2cbb5b522bb54a59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/494" alt="img"></p>
<p>初始化成功后你会发现项目里多了一个隐藏文件夹.git<br>这个目录是Git用来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-661c2653f4048f02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/372" alt="img"></p>
<p>接着，将所有文件添加到仓库<br>执行指令：<code>git add .</code></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-14d44118fb8427ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/393" alt="img"></p>
<p>然后把文件提交到仓库，双引号内是提交注释<br>执行指令：<code>git commit -m &quot;提交文件&quot;</code></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-039a8943ff8646dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/403" alt="img"></p>
<p>如此本地仓库建立好了</p>
<h4 id="3-关联-github-仓库"><a href="#3-关联-github-仓库" class="headerlink" title="3. 关联 github 仓库"></a>3. 关联 github 仓库</h4><p>到 github beautifulDay 仓库复制仓库地址</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-c0791897b8f96123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/710" alt="img"></p>
<p>然后执行指令：<code>git remote add origin git@github.com:wangjiax9/beautifulDay.git</code></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-c2bb63381e149659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/477" alt="img"></p>
<h4 id="4-上传本地代码"><a href="#4-上传本地代码" class="headerlink" title="4. 上传本地代码"></a>4. 上传本地代码</h4><p>执行指令：<code>git push -u origin master</code><br>敲一个：yes， 然后回车</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-4c9a70c59144e803.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/566" alt="img"></p>
<p>到此，本地代码已经推送到github仓库了，我们现在去 github 仓库看看</p>
<p>咦！奇怪了，我的目录呢？这个坑突然冒出来是不是印象很深刻呢~<br>注意咯：git是不能管理空的文件夹的，文件夹里必须有文件才能add</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-1d97e42bce22c48c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1019" alt="img"></p>
<p>好，我们来试一下，我在examples里新建了一个 test1.html 文件</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-de78eb46a358ab4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/184" alt="img"></p>
<p>执行指令添加文件-&gt;提交文件-&gt;推送文件<br><code>git add .</code><br><code>git commit -m &quot;提交test1.html&quot;</code><br><code>git push -u origin master</code></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-dddf7ead2824152a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/571" alt="img"></p>
<p>然后刷新一下 github，你会看到，examples 文件夹出来了</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-3f94e660e0d7b5f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/994" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作者：小贤笔记<br>链接：<a href="https://www.jianshu.com/p/bf95d885978e" target="_blank" rel="noopener">https://www.jianshu.com/p/bf95d885978e</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>ccna9</title>
    <url>/2020/05/10/ccna9/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>











<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>gre1</title>
    <url>/2020/05/14/gre1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>



<p>\1. It is a paradox of the Victorians that they were both _____ and, through their empire, cosmopolitan.<br> A. capricious<br> B. insular</p>
<p>C. mercenary D. idealistic<br> E. intransigent</p>
<p>\2. My grandma has a strong belief in all things _____: she insists, for example, that the house in which she lived as a child was haunted.<br> A. clamorous<br> B. invidious</p>
<p>C. numinous D. empirical E. sonorous</p>
<p>\3. The (i)<strong><strong>_ of molecular oxygen on Earth-sized planets around other stars in the universe would not be (ii)_</strong></strong> sign of life: molecular oxygen can be a signature of photosynthesis (a biotic process) or merely of the rapid escape of water from the upper reaches of a planetary atmosphere (an abiotic process).</p>
<p>\4. Given the (i)<strong><strong>_ the committees and the (ii)_</strong></strong> nature of its investigation, it would be unreasonable to gainsay the committee’s conclusions at first glance.</p>
<p>\5. The skin of the poison dart frog contains deadly poisons called batrachotoxins. But the (i)<strong><strong>_ of the toxins has remained an enigma, as the frog does not (ii)_</strong></strong> them. Now an analysis suggests that the melyrid beetle is the source. Collected beetle specimens all contained batrachotoxins, suggesting that these beetles are (iii)_____ by the frogs.</p>
<table>
<thead>
<tr>
<th>A. dearth</th>
<th>D. a controversial</th>
</tr>
</thead>
<tbody><tr>
<td>B. presumption</td>
<td>E. an unambiguous</td>
</tr>
<tr>
<td>C. detection</td>
<td>F. a possible</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>A. sterling reputation of</th>
<th>D. superficial</th>
</tr>
</thead>
<tbody><tr>
<td>B. lack of finding of</td>
<td>E. spontaneous</td>
</tr>
<tr>
<td>C. ad hoc existence of</td>
<td>F. exhaustive</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>A. effect</th>
<th>D. pressure</th>
<th>G. eaten</th>
</tr>
</thead>
<tbody><tr>
<td>B. origin</td>
<td>E. produce</td>
<td>H. neutralized</td>
</tr>
<tr>
<td>C. purpose</td>
<td>F. suffer from</td>
<td>I. poisoned</td>
</tr>
</tbody></table>
<p>微信公众号:张巍⽼老老师GRE 第 8 ⻚页</p>
<p>真经GRE GRE填空机经1250题 难度分级版</p>
<p>\6. Now that photographic prints have become a popular field for collecting, auctions are becoming more (i)<strong><strong><em>. It is not just the entry of new collectors into the field that is causing this intensification. Established collectors’ interests are also becoming more (ii)</em></strong></strong>. Those who once concentrated on the work of either the nineteenth-century pioneers or the twentieth-century modernists are now keen to have (iii)_____ collections.</p>
<p>\7. The beauty of the scientific approach is that even when individual researchers do _____ bias or partiality, others can correct them using a framework of evidence on which everyone broadly agrees.<br> A. overreact to</p>
<p>B. deviate from C. succumb to D. recoil from E. yield to</p>
<p>F. shrink from</p>
<p>\8. The reconstruct known work is beautiful and also probably _____: it is the only Hebrew verse written by a woman.<br> A. singular<br> B. unique</p>
<p>C. archaic<br> D. counterfeit E. valuable<br> F. fake</p>
<p>\9. In a book that inclines to _____, an epilogue arguing that ballet is dead arrives simply as one more overstatement.<br> A. pessimism<br> B. misinterpretation</p>
<p>C. imprecision D. vagueness E. exaggeration F. hyperbole</p>
<p>\10. The political upheaval caught most people by surprise: despite the _____ warnings of some commentators, it had never seemed that imminent.<br> A. stern<br> B. prescient</p>
<p>C. prophetic D. indifferent E. repeated F. apathetic</p>
<table>
<thead>
<tr>
<th>A. competitive</th>
<th>D. fickle</th>
<th>G. comprehensive</th>
</tr>
</thead>
<tbody><tr>
<td>B. tedious</td>
<td>E. wide-ranging</td>
<td>H. legitimate</td>
</tr>
<tr>
<td>C. exclusive</td>
<td>F. antiquarian</td>
<td>I. impressive</td>
</tr>
</tbody></table>
<p>微信公众号:张巍⽼老老师GRE</p>
<p>第 9 ⻚页</p>
<p>真经GRE GRE填空机经1250题 难度分级版 section 2 easy</p>
<p>\1. Among the Meakambut people of Papua New Guinea, legends are associated with specific caves in the Sepik region, and these legends are _____: only the cave owner can share its secrets.<br> A. impenetrable</p>
<p>B. immutable<br> C. proprietary<br> D. didactic<br> E. self-perpetuating</p>
<p>\2. We often regard natural phenomena like rainfall as mysterious and unpredictable; although for short time spans and particular places they appear so, in fact on a truly global scale, nature has been a model of _____.<br> A. reliability</p>
<p>B. diversity<br> C. complexity D. plasticity<br> E. discontinuity</p>
<p>\3. The economic recovery was somewhat lopsided: (i)<strong><strong>_ in some of the industrial economies while (ii)_</strong></strong> in others of them.</p>
<p>\4. Although trains may use energy more (i)<strong><strong>_ than do automobiles, the latter move only when they contain at least one occupant, whereas railway carriages spend a considerable amount of time running up and down the tracks (ii)_</strong></strong>, or nearly so.</p>
<p>\5. Most capuchin monkey conflict involves such a (i)<strong><strong>_ repertoire of gestural and vocal signals that it is difficult for researchers to tease apart the meanings of the individual signals. This (ii)_</strong></strong> is (iii)_____ by the fact that many signals seem to shift in meaning according to the context in which they are produced and the developmental stage of the individuals producing them.</p>
<table>
<thead>
<tr>
<th>A. unexpected</th>
<th>D. robust</th>
</tr>
</thead>
<tbody><tr>
<td>B. feeble</td>
<td>E. turbulent</td>
</tr>
<tr>
<td>C. swift</td>
<td>F. predictable</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>A. lavishly</th>
<th>D. vacant</th>
</tr>
</thead>
<tbody><tr>
<td>B. efficiently</td>
<td>E. unimpeded</td>
</tr>
<tr>
<td>C. routinely</td>
<td>F. overlooked</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>A. precise</th>
<th>D. problem</th>
<th>G. augmented</th>
</tr>
</thead>
<tbody><tr>
<td>B. rich</td>
<td>E. opportunity</td>
<td>H. ameliorated</td>
</tr>
<tr>
<td>C. straightforward</td>
<td>F. oversight</td>
<td>I. anticipated</td>
</tr>
</tbody></table>
<p>微信公众号:张巍⽼老老师GRE 第 10 ⻚页</p>
<p>真经GRE GRE填空机经1250题 难度分级版</p>
<p>\6. Within the culture as a whole, the natural sciences have been so successful that the word “scientific” is often used in (i)<strong><strong>_ manner: it is often assumed that to call something “scientific” is to imply that its reliability has been (ii)_</strong></strong> by methods whose results cannot reasonably be (iii)_____.</p>
<p>\7. Members of the union’s negotiating team insisted on several changes to the company’s proposal before they would support it, making it clear that they would _____ no compromise.<br> A. disclose<br> B. reject</p>
<p>C. brook<br> D. tolerate E. repudiate F. weigh</p>
<p>\8. Wilson is wont to emphasize the _____ of ants: how ants with full stomachs will regurgitate liquid food for those without, or how the old will fight so the young can survive.<br> A. beneficence<br> B. altruism</p>
<p>C. unpredictability D. intelligence<br> E. fecundity<br> F. fertility</p>
<p>\9. During the Renaissance, the use of optical lenses, which were capable of projecting images onto blank canvases, greatly aided artists by allowing them to accurately observe and depict the external world; in other words, these lenses were instrumental in conveying _____.<br> A. idealism</p>
<p>B. optimism<br> C. ambition<br> D. realism<br> E. sanguinity<br> F. verisimilitude</p>
<p>\10. The professor’s habitual air of _____ was misleading front, concealing amazing reserves of patience and a deep commitment to his students’ learning.<br> A. cordiality<br> B. irascibility</p>
<p>C. disorganization D. conviviality<br> E. diffidence<br> F. exasperation</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>git命令大全</title>
    <url>/2020/05/09/github1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>注: 文章摘自: IT大飞说 - 掘金</p>
</blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/4804567-3243cbd5978fa871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/980" alt="img"></p>
<h2 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> user.name <span class="string">"Your Name"</span> <span class="comment">// Git 姓名</span></span><br><span class="line">git config --<span class="keyword">global</span> user.email <span class="string">"email@example.com"</span> <span class="comment">// Git 邮箱</span></span><br></pre></td></tr></table></figure>

<h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">init</span></span><br></pre></td></tr></table></figure>

<h2 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h2><p>提交至本地 “暂存区” (.git/index)</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个文件添加至仓库</span></span><br><span class="line">git <span class="keyword">add</span> README.md</span><br><span class="line"><span class="comment">// 整个目录添加至仓库, 会忽略 .gitignore 把任何文件都加入</span></span><br><span class="line">git <span class="keyword">add</span> *</span><br><span class="line"><span class="comment">// 整个目录添加至仓库, 会根据 .gitignore 做过滤</span></span><br><span class="line">git <span class="keyword">add</span> .</span><br></pre></td></tr></table></figure>

<h2 id="提交暂存区的文件至本地仓库"><a href="#提交暂存区的文件至本地仓库" class="headerlink" title="提交暂存区的文件至本地仓库"></a>提交暂存区的文件至本地仓库</h2><p>将已添加的文件提交至本地 Git 仓库 (默认 master 分支)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会弹出一个 Vim 编辑器输入内容后再提交</span></span><br><span class="line">git commit</span><br><span class="line"><span class="comment">// 直接输入内容并提交</span></span><br><span class="line">git commit -m <span class="string">"feat: 修改 xx 文件"</span></span><br></pre></td></tr></table></figure>

<h2 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<h2 id="比较当前文件的修改"><a href="#比较当前文件的修改" class="headerlink" title="比较当前文件的修改"></a>比较当前文件的修改</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git diff <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="查看历史提交记录"><a href="#查看历史提交记录" class="headerlink" title="查看历史提交记录"></a>查看历史提交记录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<h2 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h2><p>在 Git 中, 用 <code>HEAD</code> 表示当前版本. 上一个版本就是 <code>HEAD^</code>, 上上一个版本就是 <code>HEAD^^</code>, 以此类推…</p>
<p>如果需要回退几十个版本的话可以这样写：<code>HEAD~50</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<p>如果你回退完版本又后悔了, 一般情况下是回不来的.</p>
<p>但如果你可以找到之前 <code>commit id</code> 的话，也是可以的</p>
<p><code>commit id</code> (版本号) 就是一个使用 SHA1 计算出来的一个非常大的十六进制数字, 提交时看到的一大串类似 <code>3628164...882e1e0</code> 的就是了</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">git reset --hard + commit <span class="keyword">id</span></span><br></pre></td></tr></table></figure>

<p>如果忘记 <code>commit id</code> 的话可以执行下一步命令找回</p>
<h2 id="查看历史命令记录"><a href="#查看历史命令记录" class="headerlink" title="查看历史命令记录"></a>查看历史命令记录</h2><p>会将你之前所有的操作类型及相关信息打印出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>

<h2 id="查看文件提交前后的区别"><a href="#查看文件提交前后的区别" class="headerlink" title="查看文件提交前后的区别"></a>查看文件提交前后的区别</h2><p>查看工作区和版本库里面最新版本文件的区别，也可以不加 <code>HEAD</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>

<h2 id="丢弃工作区的修改"><a href="#丢弃工作区的修改" class="headerlink" title="丢弃工作区的修改"></a>丢弃工作区的修改</h2><p>适用于工作区修改没有 <code>add</code> 的文件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">git checkout -- <span class="xml"><span class="tag">&lt;<span class="name">file</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="丢弃暂存区的文件"><a href="#丢弃暂存区的文件" class="headerlink" title="丢弃暂存区的文件"></a>丢弃暂存区的文件</h2><p>适用于暂存区已经 <code>add</code> 的文件</p>
<p>他会将暂存区的修改放回到工作区中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git reset HEAD <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">rm <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后提交即可</p>
<p>如果不小心删错了, 且还没有提交的话使用下面命令即可恢复删除</p>
<p>注意它只能恢复最近版本提交的修改, 你工作区的修改是不能被恢复的</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">git checkout -- <span class="xml"><span class="tag">&lt;<span class="name">file</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="创建SSH-key"><a href="#创建SSH-key" class="headerlink" title="创建SSH key"></a>创建SSH key</h2><p>一般本地 Git 仓库和远程 Git 仓库之间的传输是通过 SSH 加密的, 所以我们可以将其生成的公钥添加到 Git 服务端的设置中即可, 这样 Git 就可以知道是你提交的了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ssh-keygen</span> <span class="selector-tag">-t</span> <span class="selector-tag">rsa</span> <span class="selector-tag">-C</span> "<span class="selector-tag">youremail</span><span class="keyword">@example</span>.com"</span><br></pre></td></tr></table></figure>

<h2 id="与远程仓库协作"><a href="#与远程仓库协作" class="headerlink" title="与远程仓库协作"></a>与远程仓库协作</h2><h5 id="与远程库关联"><a href="#与远程库关联" class="headerlink" title="与远程库关联"></a>与远程库关联</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">add</span> origin git@github.com:shenxianhui/vue-test.git</span><br></pre></td></tr></table></figure>

<h5 id="删除本地库与远程库的关联"><a href="#删除本地库与远程库的关联" class="headerlink" title="删除本地库与远程库的关联"></a>删除本地库与远程库的关联</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure>

<p>作用：有时候我们需要关联其他远程库，需要先删除旧的关联，再添加新的关联，因为如果你已经关联过了就不能在关联了，不过想关联多个远程库也是可以的，前提是你的本地库没有关联任何远程库，操作如下：</p>
<ul>
<li>先关联Github远程库：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">add</span> github git@github.com:shenxianhui/vue-test.git</span><br></pre></td></tr></table></figure>

<ul>
<li>再关联码云远程库：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">add</span> gitee git@gitee.com:shenxianhui/vue-test.git</span><br></pre></td></tr></table></figure>

<p>现在，我们用 <code>git remote -v</code> 查看远程库的关联信息，如果看到两组关联信息就说明关联成功了</p>
<p>如果要推送到GitHub，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push github master</span><br></pre></td></tr></table></figure>

<p>如果要推送到码云，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push gitee master</span><br></pre></td></tr></table></figure>

<h2 id="将远程库中的更改合并到当前分支中"><a href="#将远程库中的更改合并到当前分支中" class="headerlink" title="将远程库中的更改合并到当前分支中"></a>将远程库中的更改合并到当前分支中</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git pull <span class="tag">&lt;<span class="name">远程主机名</span>&gt;</span> <span class="tag">&lt;<span class="name">远程分支名</span>&gt;</span>:<span class="tag">&lt;<span class="name">本地分支名</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>比如，要取回 <code>origin</code> 主机的 <code>next</code> 分支，与本地的 <code>master</code> 分支合并</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">pull</span> <span class="selector-tag">origin</span> <span class="selector-tag">next</span><span class="selector-pseudo">:master</span></span><br></pre></td></tr></table></figure>

<p>如果远程分支 <code>next</code> 要与当前分支合并，则冒号后面的部分可以省略</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">git pull origin <span class="keyword">next</span></span><br></pre></td></tr></table></figure>

<p>实质上，这等同于先做 <code>git fetch</code>，再执行 <code>git merge</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git merge origin/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>

<h2 id="从远程库获取分支-标签"><a href="#从远程库获取分支-标签" class="headerlink" title="从远程库获取分支 / 标签"></a>从远程库获取分支 / 标签</h2><p>更新远程所有分支到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure>

<h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><p><strong>注意：第一次提交需要加一个参数 <code>-u</code>, 以后不需要</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="克隆一个远程库"><a href="#克隆一个远程库" class="headerlink" title="克隆一个远程库"></a>克隆一个远程库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:shenxianhui/vue-test.git</span><br></pre></td></tr></table></figure>

<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><ul>
<li>创建一个分支 <code>branch1</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch branch1</span><br></pre></td></tr></table></figure>

<ul>
<li>切换到 <code>branch1</code> 分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout branch1</span><br></pre></td></tr></table></figure>

<ul>
<li>创建并切换到 <code>branch1</code> 分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b branch1</span><br></pre></td></tr></table></figure>

<ul>
<li>查看分支</li>
</ul>
<p>提示：显示的结果中，其中有一个分支前有个*号，表示的是当前所在的分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<ul>
<li>将 <code>branch1</code> 合并到当前分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge branch1</span><br></pre></td></tr></table></figure>

<ul>
<li>删除分支 <code>branch1</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d branch1</span><br></pre></td></tr></table></figure>

<h2 id="查看提交历史记录"><a href="#查看提交历史记录" class="headerlink" title="查看提交历史记录"></a>查看提交历史记录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>命令可以看到分支合并图</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph</span><br></pre></td></tr></table></figure>

<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>禁用 Fast forward 模式合并分支</p>
<p>默认 Git 合并分支时使用的是 Fast forward 模式, 删除分支后会丢掉分支信息, 所以我们需要强制禁用此模式来合并</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge --no-ff -m <span class="string">"merge"</span> branch1</span><br></pre></td></tr></table></figure>

<p>补充内容：实际开发中分支管理的策略</p>
<ul>
<li><code>master</code> 分支应该是非常稳定的, 也就是仅用来发布新版本, 平时不能在上面提交</li>
<li>我们可以新开一个 <code>dev</code> 分支, 也就是说 <code>dev</code> 分支是不稳定的. 到版本发布时, 再把 <code>dev</code> 分支合并到 <code>master</code>上，在 <code>master</code> 分支发布新版本</li>
<li>你和你的协作者平时都在 <code>dev</code> 分支上提交, 每个人都有自己的分支, 时不时地往 <code>dev</code> 分支上合并就可以了</li>
</ul>
<h2 id="保存工作现场"><a href="#保存工作现场" class="headerlink" title="保存工作现场"></a>保存工作现场</h2><p>作用：当你需要去修改其他内容时，这时候你的工作还没有做完，先临时保存起来，等干完其他事之后，再回来回复现场，再继续干活；为什么？因为暂存区是公用的，如果不通过 stash 命令隐藏，会带到其它分支去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>

<p>查看已经保存的工作现场列表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git stash <span class="built_in">list</span></span><br></pre></td></tr></table></figure>

<p>恢复工作现场 (恢复并从 <code>stash list</code> 删除)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">git stash pop</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">git stash apply</span><br></pre></td></tr></table></figure>

<p>恢复工作现场，但 <code>stash</code> 内容并不删除，如果你需要删除执行如下命令</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">git stash <span class="built_in">drop</span></span><br></pre></td></tr></table></figure>

<p>恢复指定的 stash</p>
<p>说明：其中 <code>stash@{0}</code> 为 <code>git stash list</code> 中的一种编号</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">stash</span> <span class="selector-tag">apply</span> <span class="selector-tag">stash</span>@&#123;0&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除一个没有被合并过的分支"><a href="#删除一个没有被合并过的分支" class="headerlink" title="删除一个没有被合并过的分支"></a>删除一个没有被合并过的分支</h2><p>实际开发中，添加一个新 <code>feature</code>, 最好新建一个分支, 如果要丢弃这个没有被合并过的分支, 可以通过下面的命令强行删除</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git branch -D <span class="tag">&lt;<span class="name">name</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="查看远程库的信息"><a href="#查看远程库的信息" class="headerlink" title="查看远程库的信息"></a>查看远程库的信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>

<p>显示更详细的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<h2 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git push origin master <span class="comment">// 推送 master 分支到远程库</span></span><br><span class="line">git push origin branch1 <span class="comment">// 推送branch1到远程库</span></span><br></pre></td></tr></table></figure>

<h2 id="创建本地分支"><a href="#创建本地分支" class="headerlink" title="创建本地分支"></a>创建本地分支</h2><p>如果远程库中有分支, <code>clone</code> 之后默认只有 <code>master</code> 分支的, 所以需要执行如上命令来创建本地分支才能与远程的分支关联起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b branch1 origin&#x2F;branch1</span><br></pre></td></tr></table></figure>

<h2 id="本地与远程分支关联"><a href="#本地与远程分支关联" class="headerlink" title="本地与远程分支关联"></a>本地与远程分支关联</h2><p>如果你本地新建的 <code>branch1</code> 分支，远程库中也有一个 <code>branch1</code> 分支 (别人创建的), 而刚好你也没有提交过到这个分支, 即没有关联过. 这时会报一个 “no tracking information” 信息，通过下面命令关联即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --<span class="built_in">set</span>-upstream branch1 origin/branch1</span><br></pre></td></tr></table></figure>

<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git tag &lt;name&gt; <span class="comment">// 例: git tag v1.0</span></span><br></pre></td></tr></table></figure>

<p>查看所有标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>

<p>对历史提交打 tag</p>
<p>先使用 <code>$ git log --pretty=oneline --abbrev-commit</code> 命令找到历史提交的 <code>commit id</code></p>
<p>例如对 <code>commit id</code> 为 “123456” 的提交打一个 tag</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">tag</span> <span class="selector-tag">v0</span><span class="selector-class">.9</span> 123456</span><br></pre></td></tr></table></figure>

<p>查看标签信息</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">show</span> &lt;tagname&gt;</span><br></pre></td></tr></table></figure>

<p>创建带有说明的标签，用 <code>-a</code> 指定标签名，<code>-m</code> 指定说明文字，”123456” 为 <code>commit id</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">tag</span> <span class="selector-tag">-a</span> <span class="selector-tag">v1</span><span class="selector-class">.0</span> <span class="selector-tag">-m</span> "<span class="selector-tag">V1</span><span class="selector-class">.0</span> <span class="selector-tag">released</span>" 123456</span><br></pre></td></tr></table></figure>

<p>用私钥签名一个标签</p>
<p>签名采用 PGP 签名，因此，必须先要安装 gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错，具体请参考GnuPG帮助文档配置Key；</p>
<p>作用：用 PGP 签名的标签是不可伪造的，因为可以验证 PGP 签名</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">tag</span> <span class="selector-tag">-s</span> <span class="selector-tag">v2</span><span class="selector-class">.0</span> <span class="selector-tag">-m</span> "<span class="selector-tag">signed</span> <span class="selector-tag">V2</span><span class="selector-class">.0</span> <span class="selector-tag">released</span>" 345678</span><br></pre></td></tr></table></figure>

<p>删除标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git tag -d <span class="tag">&lt;<span class="name">tagname</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>删除远程库中的标签</p>
<p>比如要删除远程库中的 V1.0 标签，分两步</p>
<ul>
<li>先删除本地标签</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">tag</span> <span class="selector-tag">-d</span> <span class="selector-tag">V1</span><span class="selector-class">.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>再推送删除</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">git push origin <span class="symbol">:refs/tags/V1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>推送标签到远程库</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git push origin <span class="tag">&lt;<span class="name">tagname</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>推送所有标签到远程库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>

<h2 id="自定义Git设置"><a href="#自定义Git设置" class="headerlink" title="自定义Git设置"></a>自定义Git设置</h2><p>Git 显示颜色，会让命令输出看起来更清晰、醒目</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> color.ui <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>设置命令别名</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> <span class="keyword">alias</span>.st status</span><br></pre></td></tr></table></figure>

<p>说明：<code>--global</code> 表示全局，即设置完之后全局生效，<code>st</code> 表示别名，<code>status</code> 表示原始名</p>
<p>好了，现在敲 <code>git st</code> 就相当于是 <code>git status</code> 命令了，是不是方便？</p>
<p>当然还有其他命令可以简写，这里举几个：很多人都用 <code>co</code> 表示 <code>checkout</code>，<code>ci</code> 表示 <code>commit</code>，<code>br</code> 表示 <code>branch</code>…根据自己的喜好可以设置即可，个人觉得不是很推荐使用别名的方式</p>
<p>推荐一个比较丧心病狂的别名设置</p>
<p>效果自己去体会…</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> <span class="keyword">alias</span>.lg <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br></pre></td></tr></table></figure>

<p>其他说明：<br>配置的时候加上 <code>--global</code> 是针对当前用户起作用的，如果不加只对当前的仓库起作用<br>每个仓库的 Git 配置文件都放在 <code>.git/config</code> 文件中，我们可以打开对其中的配置作修改，可以删除设置的别名<br>而当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件 <code>.gitconfig</code> 中，我们也可以对其进行配置和修改</p>
<h2 id="忽略文件规则"><a href="#忽略文件规则" class="headerlink" title="忽略文件规则"></a>忽略文件规则</h2><p>在 Git 工作区的根目录下创建一个特殊的 <code>.gitignore</code> 文件，然后把要忽略的文件名或者相关规则填进去，Git就会自动忽略这些文件<br>如果你想添加一个被 <code>.gitignore</code> 忽略的文件到 Git 中，但发现是添加不了的，所以我们可以强制添加</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span> -f &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>或者我们可以检查及修改 <code>.gitignore</code> 文件的忽略规则</p>
<p>Git 会告诉我们具体的 <code>.gitignore</code> 文件中的第几行规则忽略了该文件，这样我们就知道应该修改哪个规则了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git check-ignore -v <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如何忽略已经提交到远程库中的文件？<br>如果你已经将一些文件提交到远程库中了，然后你想忽略掉此文件，然后在 <code>.gitignore</code> 文件中添加忽略，然而你会发现并没有生效，因为 Git 添加忽略时只有对没有跟踪的文件才生效，也就是说你没有 add 过和提交过的文件才生效</p>
<p>比如说：我们要忽略 <code>.idea</code> 目录，先删除已经提交到本地库的文件目录</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">rm</span> <span class="selector-tag">--cached</span> <span class="selector-class">.idea</span></span><br></pre></td></tr></table></figure>

<p>如果提示：<code>fatal: not removing &#39;.idea&#39; recursively without -r</code><br>加个参数 -r 即可强制删除</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">rm</span> <span class="selector-tag">-r</span> <span class="selector-tag">--cached</span> <span class="selector-class">.idea</span></span><br></pre></td></tr></table></figure>

<p>然后，执行 <code>git status</code> 会提示你已经删除 <code>.idea</code> 目录了，然后执行 <code>commit</code> 再 <code>push</code> 就可以了，此时的 <code>.idea</code> 目录是没有被跟踪的，将 <code>.idea</code> 目录添加到 <code>.gitignore</code> 文件中就可以忽略了</p>
<p>作者：小贤笔记<br>链接：<a href="https://www.jianshu.com/p/dd7f18ed0bb1" target="_blank" rel="noopener">https://www.jianshu.com/p/dd7f18ed0bb1</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>How to use Hexo? Find out!</title>
    <url>/2020/04/17/hello-world/</url>
    <content><![CDATA[<h1 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h1><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure>

<p>Initializes a website. If no <code>folder</code> is provided, Hexo will set up the website in the current directory.</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>Creates a new article. If no <code>layout</code> is provided, Hexo will use the <code>default_layout</code> from <a href="https://hexo.io/docs/configuration" target="_blank" rel="noopener">_config.yml</a>. If the <code>title</code> contains spaces, surround it with quotation marks.</p>
<table>
<thead>
<tr>
<th align="left">Option</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>, <code>--path</code></td>
<td align="left">Post path. Customize the path of the post.</td>
</tr>
<tr>
<td align="left"><code>-r</code>, <code>--replace</code></td>
<td align="left">Replace the current post if existed.</td>
</tr>
<tr>
<td align="left"><code>-s</code>, <code>--slug</code></td>
<td align="left">Post slug. Customize the URL of the post.</td>
</tr>
</tbody></table>
<p>By default, Hexo will use the title to define the path of the file. For pages, it will create a directory of that name and an <code>index.md</code> file in it. Use the <code>--path</code> option to override that behaviour and define the file path:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me &quot;About me&quot;</span><br></pre></td></tr></table></figure>

<p>will create <code>source/about/me.md</code> file with the title “About me” set in the front matter.</p>
<p>Please note that the title is mandatory. For example, this will not result in the behaviour you might expect:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me</span><br></pre></td></tr></table></figure>

<p>will create the post <code>source/_posts/about/me.md</code> with the title “page” in the front matter. This is because there is only one argument (<code>page</code>) and the default layout is <code>post</code>.</p>
<h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>Generates static files.</p>
<table>
<thead>
<tr>
<th align="left">Option</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-d</code>, <code>--deploy</code></td>
<td align="left">Deploy after generation finishes</td>
</tr>
<tr>
<td align="left"><code>-w</code>, <code>--watch</code></td>
<td align="left">Watch file changes</td>
</tr>
<tr>
<td align="left"><code>-b</code>, <code>--bail</code></td>
<td align="left">Raise an error if any unhandled exception is thrown during generation</td>
</tr>
<tr>
<td align="left"><code>-f</code>, <code>--force</code></td>
<td align="left">Force regenerate</td>
</tr>
<tr>
<td align="left"><code>-c</code>, <code>--concurrency</code></td>
<td align="left">Maximum number of files to be generated in parallel. Default is infinity</td>
</tr>
</tbody></table>
<h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>Publishes a draft.</p>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>Starts a local server. By default, this is at <code>http://localhost:4000/</code>.</p>
<table>
<thead>
<tr>
<th align="left">Option</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>, <code>--port</code></td>
<td align="left">Override default port</td>
</tr>
<tr>
<td align="left"><code>-s</code>, <code>--static</code></td>
<td align="left">Only serve static files</td>
</tr>
<tr>
<td align="left"><code>-l</code>, <code>--log</code></td>
<td align="left">Enable logger. Override logger format.</td>
</tr>
</tbody></table>
<h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>Deploys your website.</p>
<table>
<thead>
<tr>
<th align="left">Option</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-g</code>, <code>--generate</code></td>
<td align="left">Generate before deployment</td>
</tr>
</tbody></table>
<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>

<p>Renders files.</p>
<table>
<thead>
<tr>
<th align="left">Option</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-o</code>, <code>--output</code></td>
<td align="left">Output destination</td>
</tr>
</tbody></table>
<h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/docs/migration" target="_blank" rel="noopener">Migrates</a> content from other blog systems.</p>
<h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>

<p>Cleans the cache file (<code>db.json</code>) and generated files (<code>public</code>).</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure>

<p>Lists all routes.</p>
<h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure>

<p>Displays version information.</p>
<h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><h3 id="Safe-mode"><a href="#Safe-mode" class="headerlink" title="Safe mode"></a>Safe mode</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure>

<p>Disables loading plugins and scripts. Try this if you encounter problems after installing a new plugin.</p>
<h3 id="Debug-mode"><a href="#Debug-mode" class="headerlink" title="Debug mode"></a>Debug mode</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure>

<p>Logs verbose messages to the terminal and to <code>debug.log</code>. Try this if you encounter any problems with Hexo. If you see errors, please <a href="https://github.com/hexojs/hexo/issues/new" target="_blank" rel="noopener">raise a GitHub issue</a>.</p>
<h3 id="Silent-mode"><a href="#Silent-mode" class="headerlink" title="Silent mode"></a>Silent mode</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure>

<p>Silences output to the terminal.</p>
<h3 id="Customize-config-file-path"><a href="#Customize-config-file-path" class="headerlink" title="Customize config file path"></a>Customize config file path</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --config custom.yml</span><br></pre></td></tr></table></figure>

<p>Uses a custom config file (instead of <code>_config.yml</code>). Also accepts a comma-separated list (no spaces) of JSON or YAML config files that will combine the files into a single <code>_multiconfig.yml</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --config custom.yml,custom2.json</span><br></pre></td></tr></table></figure>

<h3 id="Display-drafts"><a href="#Display-drafts" class="headerlink" title="Display drafts"></a>Display drafts</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure>

<p>Displays draft posts (stored in the <code>source/_drafts</code> folder).</p>
<h3 id="Customize-CWD"><a href="#Customize-CWD" class="headerlink" title="Customize CWD"></a>Customize CWD</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --cwd &#x2F;path&#x2F;to&#x2F;cwd</span><br></pre></td></tr></table></figure>

<p>Customizes the path of current working directory.</p>
]]></content>
  </entry>
  <entry>
    <title>hexo搭建博客</title>
    <url>/2020/05/09/hexo/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>体验更加排版请访问原文链接：<a href="http://blog.liuxianan.com/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">http://blog.liuxianan.com/build-blog-website-by-hexo-github.html</a></p>
<p>使用github pages服务搭建博客的好处有：</p>
<ol>
<li>全是静态文件，访问速度快；</li>
<li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li>
<li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li>
<li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li>
<li>博客内容可以轻松打包、转移、发布到其它平台；</li>
<li>等等；</li>
</ol>
<h2 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1. 准备工作"></a>1.1. 准备工作</h2><p>在开始一切之前，你必须已经：</p>
<ul>
<li>有一个github账号，没有的话去注册一个；</li>
<li>安装了node.js、npm，并了解相关基础知识；</li>
<li>安装了git for windows（或者其它git客户端）</li>
</ul>
<p>本文所使用的环境：</p>
<ul>
<li>Windows8.1</li>
<li><a href="mailto:node.js@5.5.0">node.js@5.5.0</a></li>
<li><a href="mailto:git@1.9.2">git@1.9.2</a></li>
<li><a href="mailto:hexo@3.2.2">hexo@3.2.2</a></li>
</ul>
<h1 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h1><h2 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1. 创建仓库"></a>2.1. 创建仓库</h2><p>新建一个名为<code>你的用户名.github.io</code>的仓库，比如说，如果你的github用户名是test，那么你就新建<code>test.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io/" target="_blank" rel="noopener">http://test.github.io</a> 了，是不是很方便？</p>
<p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p>
<p>几个注意的地方：</p>
<ol>
<li>注册的邮箱一定要验证，否则不会成功；</li>
<li>仓库名字必须是：<code>username.github.io</code>，其中<code>username</code>是你的用户名；</li>
<li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；</li>
</ol>
<p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p>
<h2 id="2-2-绑定域名"><a href="#2-2-绑定域名" class="headerlink" title="2.2. 绑定域名"></a>2.2. 绑定域名</h2><p>当然，你不绑定域名肯定也是可以的，就用默认的 <code>xxx.github.io</code> 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。</p>
<p>首先你要注册一个域名，域名注册以前总是推荐去<code>godaddy</code>，现在觉得其实国内的阿里云也挺不错的，价格也不贵，毕竟是大公司，放心！</p>
<p>绑定域名分2种情况：带www和不带www的。</p>
<p>域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下<code>你的用户名.github.io</code>的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向<code>你的用户名.github.io</code>，这样可以保证无论是否添加www都可以访问，如下：</p>
<p><img src="http://image.liuxianan.com/201608/20160823_191336_238_8683.png" alt="img"></p>
<p>然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试：</p>
<ul>
<li>如果你填写的是没有www的，比如 mygit.me，那么无论是访问 <a href="http://www.mygit.me/" target="_blank" rel="noopener">http://www.mygit.me</a> 还是 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a> ，都会自动跳转到 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a></li>
<li>如果你填写的是带www的，比如 <a href="http://www.mygit.me" target="_blank" rel="noopener">www.mygit.me</a> ，那么无论是访问 <a href="http://www.mygit.me/" target="_blank" rel="noopener">http://www.mygit.me</a> 还是 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a> ，都会自动跳转到 <a href="http://www.mygit.me/" target="_blank" rel="noopener">http://www.mygit.me</a></li>
<li>如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 <a href="http://abc.mygit.me/" target="_blank" rel="noopener">http://abc.mygit.me</a> 没问题，但是访问 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a> ，不会自动跳转到 <a href="http://abc.mygit.me/" target="_blank" rel="noopener">http://abc.mygit.me</a></li>
</ul>
<p>另外说一句，在你绑定了新域名之后，原来的<code>你的用户名.github.io</code>并没有失效，而是会自动跳转到你的新域名。</p>
<h1 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h1><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/. ssh <span class="comment">#检查本机已存在的ssh密钥</span></span><br></pre></td></tr></table></figure>

<p>如果提示：No such file or directory 说明你是第一次使用git。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure>

<p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_143914_495_9084.png" alt="img"></p>
<p>将刚复制的内容粘贴到key那里，title随便填，保存。</p>
<h2 id="3-1-测试是否成功"><a href="#3-1-测试是否成功" class="headerlink" title="3.1. 测试是否成功"></a>3.1. 测试是否成功</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com # 注意邮箱地址不用改</span><br></pre></td></tr></table></figure>

<p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p>
<blockquote>
<p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
</blockquote>
<p>看到这个信息说明SSH已配置成功！</p>
<p>此时你还需要配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;liuxianan&quot;&#x2F;&#x2F; 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  &quot;xxx@qq.com&quot;&#x2F;&#x2F; 填写你的github注册邮箱</span><br></pre></td></tr></table></figure>

<p>具体这个配置是干嘛的我没仔细深究。</p>
<h1 id="使用hexo写博客"><a href="#使用hexo写博客" class="headerlink" title="使用hexo写博客"></a>使用hexo写博客</h1><h2 id="4-1-hexo简介"><a href="#4-1-hexo简介" class="headerlink" title="4.1. hexo简介"></a>4.1. hexo简介</h2><p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p>
<p>官网： <a href="http://hexo.io/" target="_blank" rel="noopener">http://hexo.io</a><br>github: <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a></p>
<h2 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2. 原理"></a>4.2. 原理</h2><p>由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。</p>
<h2 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3. 注意事项"></a>4.3. 注意事项</h2><p>安装之前先来说几个注意事项：</p>
<ol>
<li>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；</li>
<li>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导；</li>
<li>hexo有2种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个<code>theme</code>下的；</li>
</ol>
<h2 id="4-4-安装"><a href="#4-4-安装" class="headerlink" title="4.4. 安装"></a>4.4. 安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>

<h2 id="4-5-初始化"><a href="#4-5-初始化" class="headerlink" title="4.5. 初始化"></a>4.5. 初始化</h2><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是<code>F:\Workspaces\hexo</code>，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /f/Workspaces/hexo/</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_115922_773_1148.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g <span class="comment"># 生成</span></span><br><span class="line">$ hexo s <span class="comment"># 启动服务</span></span><br></pre></td></tr></table></figure>

<p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_120700_028_2426.png" alt="img"></p>
<p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：</p>
<p><a href="http://blog.liuxianan.com/windows-port-bind.html" target="_blank" rel="noopener">http://blog.liuxianan.com/windows-port-bind.html</a></p>
<p>第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑，打开时就是这个样子：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_132443_202_6848.png" alt="img"></p>
<h2 id="4-6-修改主题"><a href="#4-6-修改主题" class="headerlink" title="4.6. 修改主题"></a>4.6. 修改主题</h2><p>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题</a>。</p>
<p>个人比较喜欢的2个主题：<a href="https://github.com/pinggod/hexo-theme-jekyll" target="_blank" rel="noopener">hexo-theme-jekyll</a> 和 <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia</a>。</p>
<p>首先下载这个主题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /f/Workspaces/hexo/</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>

<p>下载后的主题都在这里：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_134500_245_0912.png" alt="img"></p>
<p>修改<code>_config.yml</code>中的<code>theme: landscape</code>改为<code>theme: yilia</code>，然后重新执行<code>hexo g</code>来重新生成。</p>
<p>如果出现一些莫名其妙的问题，可以先执行<code>hexo clean</code>来清理一下public的内容，然后再来重新生成和发布。</p>
<h2 id="4-7-上传之前"><a href="#4-7-上传之前" class="headerlink" title="4.7. 上传之前"></a>4.7. 上传之前</h2><p>在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。</p>
<h2 id="4-8-上传到github"><a href="#4-8-上传到github" class="headerlink" title="4.8. 上传到github"></a>4.8. 上传到github</h2><p>如果你一切都配置好了，发布上传很容易，一句<code>hexo d</code>就搞定，当然关键还是你要把所有东西配置好。</p>
<p>首先，<code>ssh key</code>肯定要配置好。</p>
<p>其次，配置<code>_config.yml</code>中有关deploy的部分：</p>
<p>正确写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:liuxianan&#x2F;liuxianan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>错误写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: github</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;liuxianan&#x2F;liuxianan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行<code>hexo d</code>的话一般会报如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Deployer not found: github 或者 Deployer not found: git</span><br></pre></td></tr></table></figure>

<p>原因是还需要安装一个插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>其它命令不确定，部署这个命令一定要用git bash，否则会提示<code>Permission denied (publickey).</code></p>
<p>打开你的git bash，输入<code>hexo d</code>就会将本次有改动的代码全部提交，没有改动的不会：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_140441_769_5024.png" alt="img"></p>
<h2 id="4-9-保留CNAME、README-md等文件"><a href="#4-9-保留CNAME、README-md等文件" class="headerlink" title="4.9. 保留CNAME、README.md等文件"></a>4.9. 保留CNAME、README.md等文件</h2><p>提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_141037_580_8035.png" alt="img"></p>
<p>由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。</p>
<h2 id="4-10-常用hexo命令"><a href="#4-10-常用hexo命令" class="headerlink" title="4.10. 常用hexo命令"></a>4.10. 常用hexo命令</h2><p>常见命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>

<p>缩写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &#x3D;&#x3D; hexo new</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy</span><br></pre></td></tr></table></figure>

<p>组合命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure>

<h2 id="4-11-config-yml"><a href="#4-11-config-yml" class="headerlink" title="4.11. _config.yml"></a>4.11. _config.yml</h2><p>这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。</p>
<p>需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。</p>
<h2 id="4-12-写博客"><a href="#4-12-写博客" class="headerlink" title="4.12. 写博客"></a>4.12. 写博客</h2><p>定位到我们的hexo根目录，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &#39;my-first-blog&#39;</span><br></pre></td></tr></table></figure>

<p>hexo会帮我们在<code>_posts</code>下生成相关md文件：</p>
<p><img src="http://image.liuxianan.com/201608/20160823_183047_352_1475.png" alt="img"></p>
<p>我们只需要打开这个文件就可以开始写博客了，默认生成如下内容：</p>
<p><img src="http://image.liuxianan.com/201608/20160823_183325_470_9306.png" alt="img"></p>
<p>当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。</p>
<p>一般完整格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: postName #文章页面上的显示名称，一般是中文</span><br><span class="line">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: 默认分类 #分类</span><br><span class="line">tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class="line">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">以下是正文</span><br></pre></td></tr></table></figure>

<p>那么<code>hexo new page &#39;postName&#39;</code>命令和<code>hexo new &#39;postName&#39;</code>有什么区别呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;my-second-blog&quot;</span><br></pre></td></tr></table></figure>

<p>生成如下：</p>
<p><img src="http://image.liuxianan.com/201608/20160823_184852_854_6502.png" alt="img"></p>
<p>最终部署时生成：<code>hexo\public\my-second-blog\index.html</code>，但是它不会作为文章出现在博文目录。</p>
<h3 id="4-12-1-写博客工具"><a href="#4-12-1-写博客工具" class="headerlink" title="4.12.1. 写博客工具"></a>4.12.1. 写博客工具</h3><p>那么用什么工具写博客呢？这个我还没去找，以前自己使用editor.md简单弄了个，大家有好用的hexo写博客工具可以推荐个。</p>
<h3 id="4-12-2-如何让博文列表不显示全部内容"><a href="#4-12-2-如何让博文列表不显示全部内容" class="headerlink" title="4.12.2. 如何让博文列表不显示全部内容"></a>4.12.2. 如何让博文列表不显示全部内容</h3><p>默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？</p>
<p>答案是在合适的位置加上``即可，例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 前言</span></span><br><span class="line"></span><br><span class="line">使用github pages服务搭建博客的好处有：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>全是静态文件，访问速度快；</span><br><span class="line"><span class="bullet">2. </span>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</span><br><span class="line"><span class="bullet">3. </span>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--more--&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="bullet">4. </span>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</span><br><span class="line"><span class="bullet">5. </span>博客内容可以轻松打包、转移、发布到其它平台；</span><br><span class="line"><span class="bullet">6. </span>等等；</span><br></pre></td></tr></table></figure>

<p>最终效果：</p>
<p><img src="http://image.liuxianan.com/201608/20160823_184633_653_1893.png" alt="img"></p>
<h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>可以访问我的git博客来查看效果： <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a></p>
<p>不过呢，其实这个博客我只是拿来玩一玩的，没打算真的把它当博客，因为我已经有一个自己的博客了，哈哈！正因如此，本文仅限入门学习，关于hexo搭建个人博客的更高级玩法大家可以另找教程。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/zhcncn/p/4097881.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhcncn/p/4097881.html</a></p>
<p><a href="http://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="noopener">http://www.jianshu.com/p/05289a4bc8b2</a></p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>java</title>
    <url>/2020/04/18/java/</url>
    <content><![CDATA[<h2 id="Java-learning-Experience"><a href="#Java-learning-Experience" class="headerlink" title="Java learning Experience"></a>Java learning Experience</h2><p>I am learning Java right now, so I will keep updating my status about java.</p>
<p>I like Java, believe it or not, the JVM is so amazing, this artcile will not cover knowledge about java, just some learing experience.</p>
]]></content>
  </entry>
  <entry>
    <title>WELCOME MY HONOR!</title>
    <url>/2020/04/17/intro/</url>
    <content><![CDATA[<p>This is Jackson Blog, i am a Robot.</p>
<p>If you are interested in my Blog, share with your friend. If you need some ebook or resource about Java, python, email me at <a href="mailto:3470341918@qq.com">3470341918@qq.com</a>. </p>
<p>Welcome to go to my blog, <a href="https://jackson-cmd.github.io" target="_blank" rel="noopener">https://jackson-cmd.github.io</a>.</p>
<p><video src='https://media.5yun.org/video/14874.mp4' 
       type='video/mp4' 
       controls='controls'  
       preload="auto"
       width='100%' 
       height='100%'><br></video></p>
]]></content>
  </entry>
  <entry>
    <title>linux基础（42-59集）</title>
    <url>/2020/04/26/linux3/</url>
    <content><![CDATA[<h2 id="P42远程管理常用命令"><a href="#P42远程管理常用命令" class="headerlink" title="P42远程管理常用命令"></a>P42远程管理常用命令</h2><h3 id="关机重启shutdown"><a href="#关机重启shutdown" class="headerlink" title="关机重启shutdown"></a>关机重启shutdown</h3><p>Linux shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。</p>
<p>使用权限：系统管理者。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shutdown [-t seconds] [-rkhncfF] time [message]</span><br></pre></td></tr></table></figure>

<p>shutdown now 立即关机</p>
<p>shutdown +10 10分钟后关机</p>
<p><strong>参数说明</strong>：</p>
<ul>
<li>-t seconds : 设定在几秒钟之后进行关机程序。</li>
<li>-k : 并不会真的关机，只是将警告讯息传送给所有使用者。</li>
<li>-r : 关机后重新开机。（常用，一定要加，不加会启动不了了）</li>
<li>-h : 关机后停机。</li>
<li>-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。</li>
<li>-c : 取消目前已经进行中的关机动作。（常用，取消之前动作）</li>
<li>-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。</li>
<li>-F : 关机时，强迫进行 fsck 动作。</li>
<li>time : 设定关机的时间。</li>
<li>message : 传送给所有使用者的警告讯息。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>立即关机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># shutdown -h now</span><br></pre></td></tr></table></figure>

<p>指定 10 分钟后关机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># shutdown -h 10</span><br></pre></td></tr></table></figure>

<p>重新启动计算机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># shutdown -r now</span><br></pre></td></tr></table></figure>



<h3 id="查看或配置网卡信息"><a href="#查看或配置网卡信息" class="headerlink" title="查看或配置网卡信息"></a>查看或配置网卡信息</h3><h3 id="Ifconfig"><a href="#Ifconfig" class="headerlink" title="Ifconfig"></a>Ifconfig</h3><p>网卡：一个专门负责网络通讯的硬件设备。</p>
<p>Linux ifconfig命令用于显示或设置网络设备。</p>
<p>ifconfig可设置网络设备的状态，或是显示目前的设置。</p>
<p>ifconfig | grep inet： 查看网卡对应IP地址</p>
<p>ifconfig：查看网卡配置信息</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig [网络设备][down up -allmulti -arp -promisc][add&lt;地址&gt;][del&lt;地址&gt;][&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;][io_addr&lt;I&#x2F;O地址&gt;][irq&lt;IRQ地址&gt;][media&lt;网络媒介类型&gt;][mem_start&lt;内存地址&gt;][metric&lt;数目&gt;][mtu&lt;字节&gt;][netmask&lt;子网掩码&gt;][tunnel&lt;地址&gt;][-broadcast&lt;地址&gt;][-pointopoint&lt;地址&gt;][IP地址]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>add&lt;地址&gt; 设置网络设备IPv6的IP地址。</li>
<li>del&lt;地址&gt; 删除网络设备IPv6的IP地址。</li>
<li>down 关闭指定的网络设备。</li>
<li>&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt; 设置网络设备的类型与硬件地址。</li>
<li>io_addr&lt;I/O地址&gt; 设置网络设备的I/O地址。</li>
<li>irq&lt;IRQ地址&gt; 设置网络设备的IRQ。</li>
<li>media&lt;网络媒介类型&gt; 设置网络设备的媒介类型。</li>
<li>mem_start&lt;内存地址&gt; 设置网络设备在主内存所占用的起始地址。</li>
<li>metric&lt;数目&gt; 指定在计算数据包的转送次数时，所要加上的数目。</li>
<li>mtu&lt;字节&gt; 设置网络设备的MTU。</li>
<li>netmask&lt;子网掩码&gt; 设置网络设备的子网掩码。</li>
<li>tunnel&lt;地址&gt; 建立IPv4与IPv6之间的隧道通信地址。</li>
<li>up 启动指定的网络设备。</li>
<li>-broadcast&lt;地址&gt; 将要送往指定地址的数据包当成广播数据包来处理。</li>
<li>-pointopoint&lt;地址&gt; 与指定地址的网络设备建立直接连线，此模式具有保密功能。</li>
<li>-promisc 关闭或启动指定网络设备的promiscuous模式。</li>
<li>[IP地址] 指定网络设备的IP地址。</li>
<li>[网络设备] 指定网络设备的名称。</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>显示网络设备信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ifconfig        </span><br><span class="line">eth0   Link encap:Ethernet HWaddr 00:50:56:0A:0B:0C </span><br><span class="line">     inet addr:192.168.0.3 Bcast:192.168.0.255 Mask:255.255.255.0</span><br><span class="line">     inet6 addr: fe80::250:56ff:fe0a:b0c&#x2F;64 Scope:Link</span><br><span class="line">     UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</span><br><span class="line">     RX packets:172220 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">     TX packets:132379 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">     collisions:0 txqueuelen:1000 </span><br><span class="line">     RX bytes:87101880 (83.0 MiB) TX bytes:41576123 (39.6 MiB)</span><br><span class="line">     Interrupt:185 Base address:0x2024 </span><br><span class="line"></span><br><span class="line">lo    Link encap:Local Loopback </span><br><span class="line">     inet addr:127.0.0.1 Mask:255.0.0.0</span><br><span class="line">     inet6 addr: ::1&#x2F;128 Scope:Host</span><br><span class="line">     UP LOOPBACK RUNNING MTU:16436 Metric:1</span><br><span class="line">     RX packets:2022 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">     TX packets:2022 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">     collisions:0 txqueuelen:0 </span><br><span class="line">     RX bytes:2459063 (2.3 MiB) TX bytes:2459063 (2.3 MiB)</span><br></pre></td></tr></table></figure>

<p>启动关闭指定网卡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ifconfig eth0 down</span><br><span class="line"># ifconfig eth0 up</span><br></pre></td></tr></table></figure>

<p>为网卡配置和删除IPv6地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ifconfig eth0 add 33ffe:3240:800:1005::2&#x2F; 64 &#x2F;&#x2F;为网卡诶之IPv6地址</span><br><span class="line"></span><br><span class="line"># ifconfig eth0 del 33ffe:3240:800:1005::2&#x2F; 64 &#x2F;&#x2F;为网卡删除IPv6地址</span><br></pre></td></tr></table></figure>

<p>用ifconfig修改MAC地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ifconfig eth0 down &#x2F;&#x2F;关闭网卡</span><br><span class="line"># ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE &#x2F;&#x2F;修改MAC地址</span><br><span class="line"># ifconfig eth0 up &#x2F;&#x2F;启动网卡</span><br><span class="line"># ifconfig eth1 hw ether 00:1D:1C:1D:1E &#x2F;&#x2F;关闭网卡并修改MAC地址 </span><br><span class="line"># ifconfig eth1 up &#x2F;&#x2F;启动网卡</span><br></pre></td></tr></table></figure>

<p>配置IP地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ifconfig eth0 192.168.1.56 </span><br><span class="line">&#x2F;&#x2F;给eth0网卡配置IP地址</span><br><span class="line"># ifconfig eth0 192.168.1.56 netmask 255.255.255.0 </span><br><span class="line">&#x2F;&#x2F; 给eth0网卡配置IP地址,并加上子掩码</span><br><span class="line"># ifconfig eth0 192.168.1.56 netmask 255.255.255.0 broadcast 192.168.1.255</span><br><span class="line">&#x2F;&#x2F; 给eth0网卡配置IP地址,加上子掩码,加上个广播地址</span><br></pre></td></tr></table></figure>

<p>启用和关闭ARP协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ifconfig eth0 arp  &#x2F;&#x2F;开启</span><br><span class="line"># ifconfig eth0 -arp  &#x2F;&#x2F;关闭</span><br></pre></td></tr></table></figure>

<p>设置最大传输单元</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ifconfig eth0 mtu 1500 </span><br><span class="line">&#x2F;&#x2F;设置能通过的最大数据包大小为 1500 bytes</span><br></pre></td></tr></table></figure>

<h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h3><p>ping ip地址：检查目标主机连接是否正常</p>
<p>ping 本地ip：检查本地ip是否正常。（一般127.0.0.1是本地回环地址，用了检查本机网卡是否正常，localhost）</p>
<p>ping用来检查计算机间网络是否通畅，数值越大，速度越慢，ping一下计算机看是否开着</p>
<p>Linux ping命令用于检测主机。</p>
<p>执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping [-dfnqrRv][-c&lt;完成次数&gt;][-i&lt;间隔秒数&gt;][-I&lt;网络界面&gt;][-l&lt;前置载入&gt;][-p&lt;范本样式&gt;][-s&lt;数据包大小&gt;][-t&lt;存活数值&gt;][主机名称或IP地址]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-d 使用Socket的SO_DEBUG功能。</li>
<li>-c&lt;完成次数&gt; 设置完成要求回应的次数。</li>
<li>-f 极限检测。</li>
<li>-i&lt;间隔秒数&gt; 指定收发信息的间隔时间。</li>
<li>-I&lt;网络界面&gt; 使用指定的网络接口送出数据包。</li>
<li>-l&lt;前置载入&gt; 设置在送出要求信息之前，先行发出的数据包。</li>
<li>-n 只输出数值。</li>
<li>-p&lt;范本样式&gt; 设置填满数据包的范本样式。</li>
<li>-q 不显示指令执行过程，开头和结尾的相关信息除外。</li>
<li>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。</li>
<li>-R 记录路由过程。</li>
<li>-s&lt;数据包大小&gt; 设置数据包的大小。</li>
<li>-t&lt;存活数值&gt; 设置存活数值TTL的大小。</li>
<li>-v 详细显示指令的执行过程。</li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>检测是否与主机连通</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ping www.w3cschool.cc &#x2F;&#x2F;ping主机</span><br><span class="line">PING aries.m.alikunlun.com (114.80.174.110) 56(84) bytes of data.</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.025 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.036 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.034 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.034 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;5 ttl&#x3D;64 time&#x3D;0.028 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;6 ttl&#x3D;64 time&#x3D;0.028 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;7 ttl&#x3D;64 time&#x3D;0.034 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;8 ttl&#x3D;64 time&#x3D;0.034 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;9 ttl&#x3D;64 time&#x3D;0.036 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;10 ttl&#x3D;64 time&#x3D;0.041 ms</span><br><span class="line"></span><br><span class="line">--- aries.m.alikunlun.com ping statistics ---</span><br><span class="line">10 packets transmitted, 30 received, 0% packet loss, time 29246ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.021&#x2F;0.035&#x2F;0.078&#x2F;0.011 ms</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;需要手动终止Ctrl+C</span><br></pre></td></tr></table></figure>

<p>指定接收包的次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ping -c 2 www.w3cschool.cc</span><br><span class="line">PING aries.m.alikunlun.com (114.80.174.120) 56(84) bytes of data.</span><br><span class="line">64 bytes from 114.80.174.120: icmp_seq&#x3D;1 ttl&#x3D;54 time&#x3D;6.18 ms</span><br><span class="line">64 bytes from 114.80.174.120: icmp_seq&#x3D;2 ttl&#x3D;54 time&#x3D;15.4 ms</span><br><span class="line"></span><br><span class="line">--- aries.m.alikunlun.com ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1016ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 6.185&#x2F;10.824&#x2F;15.464&#x2F;4.640 ms</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;收到两次包后，自动退出</span><br></pre></td></tr></table></figure>

<p>多参数使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ping -i 3 -s 1024 -t 255 g.cn &#x2F;&#x2F;ping主机</span><br><span class="line">PING g.cn (203.208.37.104) 1024(1052) bytes of data.</span><br><span class="line">1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq&#x3D;0 ttl&#x3D;243 time&#x3D;62.5 ms</span><br><span class="line">1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq&#x3D;1 ttl&#x3D;243 time&#x3D;63.9 ms</span><br><span class="line">1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq&#x3D;2 ttl&#x3D;243 time&#x3D;61.9 ms</span><br><span class="line"></span><br><span class="line">--- g.cn ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 6001ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 61.959&#x2F;62.843&#x2F;63.984&#x2F;0.894 ms, pipe 2</span><br><span class="line">[root@linux ~]# </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-i 3 发送周期为 3秒 -s 设置发送包的大小 -t 设置TTL值为 255</span><br></pre></td></tr></table></figure>

<h2 id="P47-52远程登录和复制文件（ssh）"><a href="#P47-52远程登录和复制文件（ssh）" class="headerlink" title="P47-52远程登录和复制文件（ssh）"></a>P47-52远程登录和复制文件（ssh）</h2><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh:"></a>ssh:</h3><p>Security shell, 数据传输加密，压缩</p>
<p>ssh [-p port] user@remote</p>
<p>user是远程机器上的用户名，如果不指定的话默认当前用户。</p>
<p>remote是远程机器的地址，可以是ip/域名，或者是后面会提到的别名。</p>
<p>port是ssh server的监听端口， 如果不指定，默认22.</p>
<p>windows下载：putty和xshell</p>
<p>使用exit退出用户登录</p>
<p><strong>ip：ip是是分配给网络上使用IP协议的设备的数字标签。</strong>我们现在经常使用的是 ipv4， 由32位二进制数字组成，常以XXX.XXX.XXX.XXX形式表现。</p>
<p><strong>域名：是由一串用“点”分隔的字符组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。</strong>如 i.cnblogs.com。</p>
<p>域名按域名系统（DNS）的规则流程组成。在DNS中注册的任何名称都是域名。域名用于各种网络环境和应用程序特定的命名和寻址目的。</p>
<p>域名和ip有区别也有联系，域名通常都会和IP绑定起来，通过访问域名来访问网络主机上的服务。ip地址通常是指主机，而域名通常表示一个网站。一个域名可以绑定到多个ip，多个域名也可以绑定到一个ip。</p>
<p><strong>域名系统（DNS）：因特网上作为域名和ip地址相互映射的分布式数据库，能使用户更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址。通过主机名，最终得到该主机名对应的ip地址的过程叫做域名解析。 DNS协议运行在UDP协议之上，端口号53。</strong></p>
<p><strong>端口号：端口，（英语：port），主要分为物理端口和逻辑端口。</strong>我们一般说的都是逻辑端口，用于区分不同的服务。因为网络中一台主机只有一个IP，但是一个主机可以提供多个服务，端口号就用于区分一个主机上的不同服务。一个IP地址的端口通过16bit进行编号，最多可以有65536个端口，标识是从0<del>65535。**端口号分为公认端口（0</del>1023）、注册端口（1024<del>49151）和动态端口（49152</del>65535）。**我们自己的服务一般都绑定在注册端口上。</p>
<p><strong>跨域：</strong>在 HTML 中，<code>,</code>, <code>,</code>, <code>,</code> 等标签以及 Ajax 都可以指向一个资源地址，<strong>而所谓的跨域请求就是指</strong>：当前发起请求的域与该请求指向的资源所在的域不一样。<strong>这里的域指的是这样的一个概念：我们认为若协议 + 域名 + 端口号均相同，那么就是同域。</strong></p>
<h3 id="常见的端口号及其用途"><a href="#常见的端口号及其用途" class="headerlink" title="常见的端口号及其用途"></a><a href="https://www.cnblogs.com/innershare/p/10749981.html" target="_blank" rel="noopener">常见的端口号及其用途</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一些常见的端口号及其用途如下：</span><br><span class="line">21端口：FTP 文件传输服务（常用）</span><br><span class="line">22端口：SSH 端口（常用）</span><br><span class="line">23端口：TELNET 终端仿真服务</span><br><span class="line">25端口：SMTP 简单邮件传输服务</span><br><span class="line">53端口：DNS 域名解析服务</span><br><span class="line">80端口：HTTP 超文本传输服务，web端口（常用）</span><br><span class="line">110端口：POP3 “邮局协议版本3”使用的端口</span><br><span class="line">443端口：HTTPS 加密的超文本传输服务（常用）</span><br><span class="line">1433端口：MS SQL*SERVER数据库 默认端口号</span><br><span class="line">1521端口：Oracle数据库服务</span><br><span class="line">1863端口：MSN Messenger的文件传输功能所使用的端口</span><br><span class="line">3306端口：MYSQL 默认端口号（常用）</span><br><span class="line">3389端口：Microsoft RDP 微软远程桌面使用的端口</span><br><span class="line">5631端口：Symantec pcAnywhere 远程控制数据传输时使用的端口</span><br><span class="line">5632端口：Symantec pcAnywhere 主控端扫描被控端时使用的端口</span><br><span class="line">5000端口：MS SQL Server使用的端口</span><br><span class="line">8000端口：腾讯QQ</span><br></pre></td></tr></table></figure>

<p>   SSH(远程连接工具)连接原理：ssh服务是一个守护进程(demon)，系统后台监听客户端的连接，ssh服务端的进程名为sshd,负责实时监听客户端的请求(IP 22端口)，包括公共秘钥等交换等信息。</p>
<p>ssh服务端由2部分组成： openssh(提供ssh服务)  openssl(提供加密的程序)</p>
<p>ssh的客户端可以用 XSHELL，Securecrt, Mobaxterm等工具进行连接</p>
<h3 id="SSH的工作机制"><a href="#SSH的工作机制" class="headerlink" title="SSH的工作机制"></a>SSH的工作机制</h3><p>   服务器启动的时候自己产生一个密钥(768bit公钥)，本地的ssh客户端发送连接请求到ssh服务器，服务器检查连接点客户端发送的数据和IP地址，确认合法后发送密钥(768bits)给客户端，此时客户端将本地私钥(256bit)和服务器的公钥(768bit)结合成密钥对key(1024bit),发回给服务器端，建立连接通过key-pair数据传输。    </p>
<h3 id="SSH的加密技术"><a href="#SSH的加密技术" class="headerlink" title="SSH的加密技术"></a>SSH的加密技术</h3><p>加密技术：传输过程，数据加密。<br>1.SSH1没有对客户端的秘钥进行校验，很容易被植入恶意代码<br>2.SSH2增加了一个确认联机正确性的Diffe_Hellman机制，每次数据的传输，Server都会检查数据来源的正确性，避免黑客入侵。<br> SSH2支持RSA和DSA密钥<br>    DSA:digital signature Algorithm 数字签名<br>    RSA:既可以数字签名又可以加密    </p>
<h3 id="SSH知识小结"><a href="#SSH知识小结" class="headerlink" title="SSH知识小结"></a>SSH知识小结</h3><p>  1.SSH是安全的加密协议，用于远程连接Linux服务器<br>  2.SSH的默认端口是22，安全协议版本是SSH2<br>  3.SSH服务器端主要包含2个服务功能SSH连接和SFTP服务器<br>  4.SSH客户端包含ssh连接命令和远程拷贝scp命令等 </p>
<h3 id="如何防止SSH登录入侵"><a href="#如何防止SSH登录入侵" class="headerlink" title="如何防止SSH登录入侵"></a>如何防止SSH登录入侵</h3><p>  1.密钥登录,更改端口<br>  2.牤牛阵法<br>  3.监听本地内网IP(ListenAddress 192.168.25.*)</p>
<h3 id="SSH功能大全"><a href="#SSH功能大全" class="headerlink" title="SSH功能大全"></a>SSH功能大全</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.登录          &#96;&#96;    &#96;&#96;ssh&#96; &#96;-p22 omd@192.168.25.137        &#96;&#96;  &#96;&#96;2.直接执行命令 --&gt;最好全路径          &#96;&#96;    &#96;&#96;ssh&#96; &#96;root@192.168.25.137 &#96;&#96;ls&#96; &#96;-ltr &#96;&#96;&#x2F;backup&#x2F;data&#96;            &#96;      &#96;&#96;&#x3D;&#x3D;&gt;&#96;&#96;ssh&#96; &#96;root@192.168.25.137 &#96;&#96;&#x2F;bin&#x2F;ls&#96; &#96;-ltr &#96;&#96;&#x2F;backup&#x2F;data&#96;        &#96;  &#96;&#96;3.查看已知主机           &#96;&#96;    &#96;&#96;cat&#96; &#96;&#x2F;root&#x2F;&#96;&#96;.&#96;&#96;ssh&#96;&#96;&#x2F;known_hosts&#96;&#96;  &#96;&#96;4.&#96;&#96;ssh&#96;&#96;远程执行&#96;&#96;sudo&#96;&#96;命令&#96;&#96;    &#96;&#96;ssh&#96; &#96;-t omd@192.168.25.137 &#96;&#96;sudo&#96; &#96;rsync&#96; &#96;hosts &#96;&#96;&#x2F;etc&#x2F;&#96; &#96;  &#96;&#96;5.&#96;&#96;scp&#96;        &#96;       &#96;&#96;1.功能  --&gt;远程文件的安全(加密)拷贝          &#96;&#96;         &#96;&#96;scp&#96; &#96;-P22 -r -p &#96;&#96;&#x2F;home&#x2F;omd&#x2F;h&#96;&#96;.txt omd@192.168.25.137:&#96;&#96;&#x2F;home&#x2F;omd&#x2F;&#96;        &#96;       &#96;&#96;2.&#96;&#96;scp&#96;&#96;知识小结          &#96;&#96;         &#96;&#96;scp&#96;&#96;是加密远程拷贝，&#96;&#96;cp&#96;&#96;为本地拷贝          &#96;&#96;         &#96;&#96;可以推送过去，也可以拉过来          &#96;&#96;         &#96;&#96;每次都是全量拷贝(效率不高，适合第一次)，增量拷贝用&#96;&#96;rsync&#96; &#96;  &#96;&#96;6.&#96;&#96;ssh&#96;&#96;自带的&#96;&#96;sftp&#96;&#96;功能        &#96;&#96;       &#96;&#96;1.Window和Linux的传输工具          &#96;&#96;         &#96;&#96;wincp  filezip          &#96;&#96;        &#96;&#96;sftp&#96; &#96;--&gt;基于&#96;&#96;ssh&#96;&#96;的安全加密传输          &#96;&#96;        &#96;&#96;samba  &#96;&#96;       &#96;&#96;2.&#96;&#96;sftp&#96;&#96;客户端连接          &#96;&#96;        &#96;&#96;sftp&#96; &#96;-oPort&#x3D;22 root@192.168.25.137          &#96;&#96;        &#96;&#96;put &#96;&#96;&#x2F;etc&#x2F;hosts&#96; &#96;&#x2F;tmp&#96;          &#96;        &#96;&#96;get &#96;&#96;&#x2F;etc&#x2F;hosts&#96; &#96;&#x2F;home&#x2F;omd&#96;  &#96;      &#96;&#96;3.&#96;&#96;sftp&#96;&#96;小结：          &#96;&#96;        &#96;&#96;1.linux下使用命令： &#96;&#96;sftp&#96; &#96;-oPort&#x3D;22 root@x.x.x.x          &#96;&#96;        &#96;&#96;2.put加客户端本地路径上传          &#96;&#96;        &#96;&#96;3.get下载服务器端内容到本地          &#96;&#96;        &#96;&#96;4.远程连接默认连接用户的家目录</span><br></pre></td></tr></table></figure>

<h3 id="ssh常见命令参数"><a href="#ssh常见命令参数" class="headerlink" title="ssh常见命令参数"></a>ssh常见命令参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usage: &#96;&#96;ssh&#96; &#96;[-1246AaCfgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]&#96;&#96;      &#96;&#96;[-D [bind_address:]port] [-e escape_char] [-F configfile]&#96;&#96;      &#96;&#96;[-i identity_file] [-L [bind_address:]port:host:hostport]&#96;&#96;      &#96;&#96;[-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]&#96;&#96;      &#96;&#96;[-R [bind_address:]port:host:hostport] [-S ctl_path]&#96;&#96;      &#96;&#96;[-W host:port] [-w local_tun[:remote_tun]]&#96;&#96;      &#96;&#96;[user@]&#96;&#96;hostname&#96; &#96;[&#96;&#96;command&#96;&#96;]</span><br></pre></td></tr></table></figure>

<h3 id="关于后台ssh服务的相关"><a href="#关于后台ssh服务的相关" class="headerlink" title="关于后台ssh服务的相关"></a>关于后台ssh服务的相关</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询openssl软件&#96;&#96;  &#96;&#96;rpm -qa openssh openssl&#96;&#96;# 查询sshd进程&#96;&#96;  &#96;&#96;ps&#96; &#96;-ef | &#96;&#96;grep&#96; &#96;ssh&#96;&#96;    &#96;&#96;--&gt; &#96;&#96;&#x2F;usr&#x2F;sbin&#x2F;sshd&#96;&#96;# 查看ssh端口&#96;&#96;  &#96;&#96;netstat&#96; &#96;-lntup | &#96;&#96;grep&#96; &#96;ssh&#96; &#96;  &#96;&#96;ss | &#96;&#96;grep&#96; &#96;ssh&#96;        &#96;(效果同上，同下，好用)&#96;&#96;  &#96;&#96;netstat&#96; &#96;-a | &#96;&#96;grep&#96; &#96;ssh&#96;&#96;(记住这个)&#96;&#96;  &#96;&#96;netstat&#96; &#96;-lnt | &#96;&#96;grep&#96; &#96;22  &#x3D;&#x3D;&gt; 查看22端口有没有开&#96;&#96;&#x2F;ssh&#96;&#96;服务有没有开启&#96;&#96;  &#96;&#96;技巧： &#96;&#96;netstat&#96; &#96;-lnt | &#96;&#96;grep&#96; &#96;ssh&#96; &#96;| &#96;&#96;wc&#96; &#96;-l --&gt;只要大于2个就是&#96;&#96;ssh&#96;&#96;服务就是好的&#96;&#96;# 查看ssh的秘钥目录&#96;&#96;  &#96;&#96;ll &#96;&#96;&#x2F;root&#x2F;&#96;&#96;.&#96;&#96;ssh&#96;&#96;&#x2F;known_hosts&#96; &#96;# 当前用户家目录的.ssh目录下&#96;&#96;# ssh的配置文件&#96;&#96;  &#96;&#96;cat&#96; &#96;&#x2F;etc&#x2F;ssh&#x2F;sshd_config&#96;  &#96;# ssh服务的关闭&#96;&#96;  &#96;&#96;service sshd stop&#96;&#96;# ssh服务的开启：&#96;&#96;  &#96;&#96;service sshd start&#96;&#96;# ssh服务的重启&#96;&#96;  &#96;&#96;service sshd reload  [停止进程后重启] &#x3D;&#x3D;&gt; 推荐&#96;&#96;  &#96;&#96;service sshd restart  [干掉进程后重启] &#x3D;&#x3D;&gt; 不推荐&#96;&#96;# ssh远程登录&#96;&#96;  &#96;&#96;ssh&#96; &#96;192.168.1.100   &#96;&#96;# 默认利用当前宿主用户的用户名登录&#96;&#96;  &#96;&#96;ssh&#96; &#96;omd@192.168.1.100 &#96;&#96;# 利用远程机的用户登录&#96;&#96;  &#96;&#96;ssh&#96; &#96;omd@192.168.1.100 -o stricthostkeychecking&#x3D;no &#96;&#96;# 首次登陆免输yes登录&#96;&#96;  &#96;&#96;ssh&#96; &#96;omd@192.168.1.100 &#96;&#96;&quot;ls &#x2F;home&#x2F;omd&quot;&#96; &#96;# 当前服务器A远程登录服务器B后执行某个命令&#96;&#96;  &#96;&#96;ssh&#96; &#96;omd@192.168.1.100 -t &#96;&#96;&quot;sh &#x2F;home&#x2F;omd&#x2F;ftl.sh&quot;&#96; &#96;# 当前服务器A远程登录服务器B后执行某个脚本</span><br></pre></td></tr></table></figure>



<p><a href="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235424314-1763487959.png" target="_blank" rel="noopener"><img src="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235425105-243399260.png" alt="image"></a></p>
<h3 id="ssh免密设置"><a href="#ssh免密设置" class="headerlink" title="ssh免密设置"></a>ssh免密设置</h3><p>1、进入用户的家目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]&#96;&#96;# cd &#x2F;root&#x2F;.ssh&#x2F;       【root用户就在root目录下的.ssh目录】&#96;&#96;[root@localhost ~]&#96;&#96;# cd &#x2F;home&#x2F;omd&#x2F;.ssh&#x2F;  【普通用户就是在家目录下的.ssh目录】</span><br></pre></td></tr></table></figure>

<p><a href="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235425480-983102625.png" target="_blank" rel="noopener"><img src="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235425878-2009080640.png" alt="image"></a></p>
<p>2、根据DSA算法生成私钥和公钥【默认建立在当前用户的家目录】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost .&#96;&#96;ssh&#96;&#96;]&#96;&#96;# ssh-keygen -t dsa   # 一路回车即可&#96;&#96;        &#96;&#96;id_dsa     --&gt;私钥(钥匙) &#96;&#96;        &#96;&#96;id_dsa.pub   --&gt;公钥(锁)</span><br></pre></td></tr></table></figure>

<p><a href="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235426240-141091905.png" target="_blank" rel="noopener"><img src="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235426686-779103595.png" alt="image"></a></p>
<p>3.拷贝公钥给目标服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost .&#96;&#96;ssh&#96;&#96;]&#96;&#96;# ssh-copy-id -i id_dsa.pub omd@192.168.25.110       【 使用ssh登录的默认端口22】&#96;&#96;[root@localhost .&#96;&#96;ssh&#96;&#96;]&#96;&#96;# ssh-copy-id -i id_dsa.pub –p 666 omd@192.168.25.120  【使用ssh登录设置的端口666】</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/519608/201808/519608-20180812120135470-239324972.png" alt="img"></p>
<p>\4. 查看目标服务器生成的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[omd@localhost .&#96;&#96;ssh&#96;&#96;]$ ll &#96;&#96;&#x2F;home&#x2F;omd&#x2F;&#96;&#96;.&#96;&#96;ssh&#96;&#96;&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>

<p><a href="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235427845-1655006958.png" target="_blank" rel="noopener"><img src="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235428167-614741798.png" alt="image"></a></p>
<p>\5. 免密码登录目标服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh&#96; &#96;omd@192.168.25.110</span><br></pre></td></tr></table></figure>

<p>\6. 总结一下钥匙和锁的关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.多个钥匙开一把锁&#96;&#96;   &#96;&#96;把id_dsa.pub 复制给各个服务器&#96; &#96;2.一个钥匙开duobasuo&#96;&#96;   &#96;&#96;把id_dsa 传给各个服务器&#96;&#96;   &#96;&#96;把id_dsa 传给自己</span><br></pre></td></tr></table></figure>

<h3 id="ssh排查问题"><a href="#ssh排查问题" class="headerlink" title="ssh排查问题"></a>ssh排查问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.判断物理链路是否通 &#96;&#96;ping&#96; &#96;192.168.25.130   线路 | 防火墙 | 是否同一个网的&#96;&#96;      &#96;&#96;ping&#96;  &#96;本身是icmp协议&#96;&#96;2.判断服务是否正常</span><br><span class="line">telnet 192.168.25.130 22</span><br><span class="line">3.Linux防火墙</span><br><span class="line">service iptables status &#x3D;&#x3D;&gt; &#96;&#96;&#x2F;etc&#x2F;init&#96;&#96;.d&#96;&#96;&#x2F;iptables&#96; &#96;status　　</span><br><span class="line">4.打开&#96;&#96;ssh&#96;&#96;的调测进行观察</span><br><span class="line">ssh&#96; &#96;-vvv omd@192.168.1.100</span><br></pre></td></tr></table></figure>

<h3 id="SSH批量分发与管理方案小结"><a href="#SSH批量分发与管理方案小结" class="headerlink" title="SSH批量分发与管理方案小结"></a>SSH批量分发与管理方案小结</h3><p>1.利用root做ssh key验证</p>
<blockquote>
<p>优点：简单，易用<br>  缺点：安全性能差，无法禁止root远程连接</p>
</blockquote>
<p>2.利用普通用户omd        –&gt;推荐</p>
<blockquote>
<p>  思路：把要分发的文件拷贝到服务器用户的家目录，然后利用sudo提权拷贝分发的文件和对应目录<br>  优点：安全<br>  缺点：复杂，配置麻烦<br>  1.sudo提权<br>    echo ‘omd   All=(All)   NOPASSWD:/usr/bin/rsync’ &gt;&gt; /etc/sudoers<br>    visudo -c<br>    grep omd /etc/sudoers<br>  2.ssh分发到服务器的家目录<br>    ssh -p22 -r /etc/hosts <a href="mailto:omd@192.168.25.137">omd@192.168.25.137</a>:~<br>  3.ssh使用sudo复制到目标服务器的/etc<br>    ssh -t <a href="mailto:omd@192.168.25.137">omd@192.168.25.137</a> sudo rsync hosts /etc/</p>
</blockquote>
<p>3.拓展方案2，不用sudo，而是设置suid对固定命令提权</p>
<blockquote>
<p> 优点：相当安全<br>    缺点：复杂，安全性较差，任何人都可以处理带有suid权限的命令<br>    1.which rsync<br>    2.chmod 4755 /usr/bin/rsync    </p>
</blockquote>
<h3 id="ssh章节小结"><a href="#ssh章节小结" class="headerlink" title="ssh章节小结"></a>ssh章节小结</h3><p>  1.ssh远程的加密连接协议，相关软件openssh,openssl<br>  2.默认端口22<br>  3.ssh版本协议<br>  4.服务器ssh连接，ftp连接，sshd守护进程，开机启动<br>  5.ssh客户端重要命令：ssh(用户登录&amp;&amp;远程命令),scp,sftp,<br>  6.安全验证方式：口令，密钥 学习原理<br>  7.ssh服务优化：改端口，改监听，no root,no empty,no DNS,<br>  8.ssh密钥对，公钥在服务器端，私钥在客户端</p>
<h3 id="修改ssh服务的启动文件sshd的几个点"><a href="#修改ssh服务的启动文件sshd的几个点" class="headerlink" title="修改ssh服务的启动文件sshd的几个点"></a>修改ssh服务的启动文件sshd的几个点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1-1修改 &#96;&#96;&#x2F;etc&#x2F;ssh&#x2F;sshd_config&#96;&#96;     GSSAPIAuthentication &#96;&#96;yes&#96;  &#96;解决一台服务器管理多个&#96;&#96;ssh&#96;&#96;服务&#96;&#96;  &#96;&#96;UseDNS no 加快响应速度因为在内网环境下&#96;&#96;  &#96;&#96;PermitRootLogin no 不运行root用户直接登录&#96;&#96;  &#96;&#96;Port 11544 更改访问端口号&#96;&#96;  &#96;&#96;ListenAddress 192.168.25.130 只监听内网的IP&#96;&#96;  &#96;&#96;Match User anoncvs   当前环境允许登录的用户&#96;&#96;  &#96;&#96;PermitRootLogin no   是否允许root用户登录，一般不允许开&#96;&#96;1-2重启服务&#96;&#96;  &#96;&#96;service sshd restart    写入命令进内存&#96;&#96;  &#96;&#96;service sshd reload(优先) reload是一个平滑的访问，不影响用户使用&#96;&#96;1-3查看连接端口&#96;&#96;  &#96;&#96;netstat&#96; &#96;-an | &#96;&#96;grep&#96; &#96;EST</span><br></pre></td></tr></table></figure>

<h3 id="SSH跳过HostKeyChecking，不用输入yes"><a href="#SSH跳过HostKeyChecking，不用输入yes" class="headerlink" title="SSH跳过HostKeyChecking，不用输入yes"></a><strong>SSH跳过</strong>HostKeyChecking，不用输入yes</h3><p>SSH跳过输入ssh跳过RSA key fingerprint输入yes/no</p>
<p>在配置大量的节点之间需要ssh连通的时候，如果自动复制很多节点，都需要输入yes，两两节点之间都要互通一次，这样会造成很大的麻烦</p>
<p><strong>解决1；</strong>修改配置文件/etc/ssh/ssh_config</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">找 到 # StrictHostKeyChecking ask &#96;&#96;修改为：StrictHostKeyChecking &#96;&#96;no</span><br></pre></td></tr></table></figure>

<p><strong>解决2：</strong> 添加参数 –o 【o=option】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.25.133 -o &#96;&#96;&quot;StrictHostKeyChecking no&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/519608/201808/519608-20180811164712431-1409487808.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -o &#96;&#96;&quot;StrictHostKeyChecking no&quot;&#96; &#96;newfile.txt &#96;&quot;mailto:root@192.168.25.133:&#x2F;root&quot;&#96;&#96;&gt;root@192.168.25.133:&#x2F;root</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/519608/201808/519608-20180811164724290-117606623.png" alt="img"></p>
<h2 id="P53-55远程登录和复制文件（scp）"><a href="#P53-55远程登录和复制文件（scp）" class="headerlink" title="P53-55远程登录和复制文件（scp）"></a>P53-55远程登录和复制文件（scp）</h2><p>scp：secure copy </p>
<p>指定端口-P port：注意是大写的P, port是指定数据传输用到的端口号（常用）</p>
<p>Linux scp 命令用于 Linux 之间复制文件和目录。</p>
<p>scp 是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。</p>
<p>scp 是加密的，<a href="https://www.runoob.com/linux/linux-comm-rcp.html" target="_blank" rel="noopener">rcp</a> 是不加密的，scp 是 rcp 的加强版。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]</span><br><span class="line">[-l limit] [-o ssh_option] [-P port] [-S program]</span><br><span class="line">[[user@]host1:]file1 [...] [[user@]host2:]file2</span><br></pre></td></tr></table></figure>

<p>简易写法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp [可选参数] file_source file_target</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li>-1： 强制scp命令使用协议ssh1</li>
<li>-2： 强制scp命令使用协议ssh2</li>
<li>-4： 强制scp命令只使用IPv4寻址</li>
<li>-6： 强制scp命令只使用IPv6寻址</li>
<li>-B： 使用批处理模式（传输过程中不询问传输口令或短语）</li>
<li>-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li>
<li>-p：保留原文件的修改时间，访问时间和访问权限。</li>
<li>-q： 不显示传输进度条。</li>
<li>-r： 递归复制整个目录。(常用)</li>
<li>-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li>
<li>-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li>
<li>-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li>
<li>-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li>
<li>-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。</li>
<li>-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，</li>
<li>-P port：注意是大写的P, port是指定数据传输用到的端口号（常用）</li>
<li>-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li>
</ul>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><h4 id="1、从本地复制到远程"><a href="#1、从本地复制到远程" class="headerlink" title="1、从本地复制到远程"></a>1、从本地复制到远程</h4><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_username@remote_ip:remote_file </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_ip:remote_file</span><br></pre></td></tr></table></figure>



<ul>
<li>第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名； </li>
<li>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；</li>
</ul>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3 </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3</span><br></pre></td></tr></table></figure>

<p>复制目录命令格式： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp -r local_folder remote_ip:remote_folder</span><br></pre></td></tr></table></figure>

<ul>
<li>第1个指定了用户名，命令执行后需要再输入密码；</li>
<li>第2个没有指定用户名，命令执行后需要输入用户名和密码；</li>
</ul>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; </span><br><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;</span><br></pre></td></tr></table></figure>

<p>上面命令将本地 music 目录复制到远程 others 目录下。</p>
<h4 id="2、从远程复制到本地"><a href="#2、从远程复制到本地" class="headerlink" title="2、从远程复制到本地"></a>2、从远程复制到本地</h4><p>从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例 </p>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 </span><br><span class="line">scp -r www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; &#x2F;home&#x2F;space&#x2F;music&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>1.如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#scp 命令使用端口号 4588</span><br><span class="line">scp -P 4588 remote@www.runoob.com:&#x2F;usr&#x2F;local&#x2F;sin.sh &#x2F;home&#x2F;administrator</span><br></pre></td></tr></table></figure>

<p>2.使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。</p>
<h2 id="（scp-remote-to-local）："><a href="#（scp-remote-to-local）：" class="headerlink" title="（scp remote to local）："></a>（scp remote to local）：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r XXX@atlas.cselabs.umn.edu:~&#x2F;Desktop&#x2F;p3-code ~&#x2F;Desktop：</span><br></pre></td></tr></table></figure>



<h2 id="（scp-local-to-remote）"><a href="#（scp-local-to-remote）" class="headerlink" title="（scp local to remote）:"></a>（scp local to remote）:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r  ~&#x2F;Desktop&#x2F;C++CODE xxx@ipaddress: ~&#x2F;Desktop</span><br></pre></td></tr></table></figure>

<p>df -h:查看磁盘容量</p>
<p>Windows没有scp命令，需要安装PuTTy，用pscp命令或者安装FileZilla使用FTP进行文件传输。</p>
<h2 id="P56-59（ssh高级）"><a href="#P56-59（ssh高级）" class="headerlink" title="P56-59（ssh高级）"></a>P56-59（ssh高级）</h2><h3 id="免密码登录和配置别名"><a href="#免密码登录和配置别名" class="headerlink" title="免密码登录和配置别名"></a>免密码登录和配置别名</h3><p>ssh配置都在用户家目录下的.ssh目录下</p>
<p>ls -alh, 找到.ssh隐藏文件，如何cd进入，然后ls -alh看known_hosts，可以看到已经有的连接。</p>
<h3 id="免密码登录："><a href="#免密码登录：" class="headerlink" title="免密码登录："></a>免密码登录：</h3><p>步骤：1. 配置公钥: ssh-keygen即可生成ssh钥匙，一路回车即可</p>
<p>​            2.上传公钥到服务器：ssh-copy-id -p port user@remote, 可以让服务器记住公钥。</p>
<p>ssh是什么？ssh (SSH client) is a program for logging into a remote machine and for executing commands on a remote machine. （自己翻译哈）</p>
<p>讲ssh服务的用法之前得需要知道这个服务是否已经开启</p>
<p>查看ssh服务是否开启的命令:systemctl status sshd。输入这个命令之后，会得到如下的一个提示</p>
<p><img src="https://img-blog.csdn.net/20150118231938468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHh1cWlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>第二行最后一个单词disabled表示sshd服务开机不自动启动</p>
<p>第三行inactive（dead）表示sshd服务当前是关闭的</p>
<p>现在我们来开启sshd服务，输入systemctl start sshd，然后再输入systemctl status sshd查看结果</p>
<p><img src="https://img-blog.csdn.net/20150118232419468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHh1cWlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>现在我们可以看到第三行是active（running），这表示sshd服务当前是开启的，但仍然是开机不启动。不过，这并不影响我们使用sshd，至于如何管理这些服务，并不在我们本节讨论范围内。</p>
<p>ssh可以干什么，举个例子，我现在有个朋友电脑出了点问题，但是现在他在北京，我在西安 ，为给他修个电脑，我不划算去北京吧，怎么办？用ssh。</p>
<p>首先得知道他的ip地址，然后登录他的root用户，用命令：ssh root@<strong><em>.</em></strong>.<em>.**</em>  星号代表ip</p>
<p><img src="https://img-blog.csdn.net/20150118234218989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHh1cWlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>输入完命令后，会有一个提示，问你是否确信连接？输入yes，再然后输入他root的密码，就进入他的电脑了。但这样有个不好的地方，我知道了他root的密码，那以后岂不是可以在他的电脑上为所欲为了，这样他肯定是不愿意的，我要是不小心删掉了他珍藏多年的种子，他肯定会杀了我。</p>
<p>######我现在是他的身份#####</p>
<p>  那在这种情况下，他应该怎么办？（ps：我现在以他的身份来做）可以先给自己的电脑上一把锁，然后需要进入你电脑的人一把钥匙，你不想让别人进的时候把锁删掉就行了。那具体怎么做呢？</p>
<p>第一步：删除/root/.ssh/下的所有东西，如果没有.shh文件夹，建立一个。</p>
<p>第二步：在.ssh文件夹下，建立钥匙，使用命令ssh-keygen</p>
<p><img src="https://img-blog.csdn.net/20150119000500906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHh1cWlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>输入命令后，第一个提示问你存在哪里，默认就好，直接回车。第二个问题让你输入一个密码，这个密码就是以后别人在拥有私钥的情况下，进入你主机需要的密码。输入完再输入一次，就会生成一个钥匙跟一把锁。</p>
<p><img src="https://img-blog.csdn.net/20150119000931595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHh1cWlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>id_rsa叫私钥，也就是钥匙，id_rsa.pub叫公钥。</p>
<p>第三步：用锁来锁定本机的哪个用户，以root为例，命令是ssh-copy-id root@<strong><em>.</em></strong>.<em>.**</em>  id为本机的id。回车之后会提示你是否连接？回答yes就行，然后会提示你输入要锁定用户的密码，现在要锁定root ，那就输入root密码就行。</p>
<p>第四步：谁想连本机，把私钥发给谁就行，比如说，我发给一个叫playsand的用户。命令是：</p>
<p> scp id_rsa playsand@<strong><em>.</em></strong>.<em>.**</em>:/home/playsand/.ssh 这个星号代表的是playsand用户的id，后面代表的是存储路径，一定要在playsand下建立一个.ssh目录，如果有，则将里面内容清空。</p>
<p>#####现在我是playsand用户#####</p>
<p>在自己的.ssh目录下，输入ssh root@<strong><em>.</em></strong>.<em>.**</em> id是root的id，回车之后会提示你是否连接？回答yes，然后会提示输入密码，这个密码就是上面第二步设定的密码，输入之后，就进入了。如果输入错了，系统会提示你输入root的密码，同样，输入root密码也可以进入，这就跟刚开始一样。</p>
<p>#####现在我是root用户####</p>
<p>在这里有几个小小的设置：</p>
<p>1.让别人登录自己的root用户是件很危险的事，怎么能让别人怎么都登录不了自己的root用户呢；</p>
<p>编辑ssh_config文件(vim /etc/ssh/ssh_config),将#PermitRootLogin yes改成PermitRootLogin no(大约在48行)，推出保存之后，重启以下ssh服务（systemctl reload sshd）</p>
<p>2.要是不认识的人或者有恶意的人不小心得到了私钥和密码，对于本机来说很危险，可以设置白名单，让指定的人可以登录；</p>
<p>同样vim /etc/ssh/ssh_config,找一个空行写下：allowusers 指定用户名，这样只有指定的用户可以登录本机。e.g：allowusers playsand  就是允许playsand用户登录，其他用户都登录不了，同理，重启下ssh服务。</p>
<p>3.让别人知道登录自己的root密码或者用户密码总是不安全的，怎样让别人只能通过私钥密码登录？</p>
<p>同样vim /etc/ssh/ssh_config,将passwordAuthentication yes 改成passwordAuthentication no ，这样，别人只能通过私钥密码登录本机。修改完重启ssh服务。</p>
<p>使用ssh登录服务器的时候，需要输入ip地址、端口、用户名、密码等信息，比较麻烦，容易输错。还好，通过客户端和服务器的配置参数，可实现免密码快速登录。服务器可通过保存客户端的公钥，用于验证客户端的身份，从而省去输入密码的步骤。客户端也可通过配置服务器参数来简化登录命令。<br>本文主要是记录了ssh面密码快速登录的配置过程，主要分为以下几个步骤。</p>
<ol>
<li>客户端生成密钥，包括私钥和公钥。</li>
<li>在服务器中配置客户端的公钥。</li>
<li>在客户端配置服务器登录相关参数。</li>
</ol>
<p>本文示例中的服务器ip地址为192.168.1.1，ssh端口为22。</p>
<h2 id="客户端生成密钥"><a href="#客户端生成密钥" class="headerlink" title="客户端生成密钥"></a>客户端生成密钥</h2><p>客户端生成密钥的方法很简单，只需要使用ssh-keygen命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>生成密钥过程中，建议采用默认值，只需要按三次回车之后，就会再～/.ssh目录下生成密钥文件，其中，id_rsa为私钥，id_rsa.pub为公钥。 </p>
<h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>服务器的~/.ssh/authorized_keys文件保存可快速连接的客户端的公钥。只需把客户端生成的id_rsa.pub文件的内容拷贝到authorized_keys文件的末尾。拷贝的方法有：</p>
<ol>
<li>直接拷贝。由于id_rsa.pub和authorized_keys都是文本文件，可通过拷贝命令直接拷贝。</li>
<li>把id_rsa.pub上传到服务器，然后再把内容添加到authorized_keys文件中。<br>在客户端把文件上传到服务器的用户目录的操作命令如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp ~&#x2F;.ssh&#x2F;id_rsa.pub root@192.168.1.1:</span><br></pre></td></tr></table></figure>

<p>在服务器操作的命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>


<p>配置好之后，登录服务器就不再需要密码了。 </p>
<h2 id="在客户端配置服务器登录相关参数"><a href="#在客户端配置服务器登录相关参数" class="headerlink" title="在客户端配置服务器登录相关参数"></a>在客户端配置服务器登录相关参数</h2><p>除了密码之外，登录时，还需要配置ip地址、端口、用户等信息，也比较繁琐。可通过客户端的~/.ssh/config配置服务器的相关参数简化登录命令。<br>config文件的配置内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host server</span><br><span class="line">Hostname 192.168.1.1</span><br><span class="line">Port 22</span><br><span class="line">User bingoli</span><br></pre></td></tr></table></figure>


<p>其中，Host为服务器的名称，输入登录命令时使用，后续登录只需要记住这个名字就可以；Hostname为服务器的ip地址；Port为ssh的端口；User为服务器的用户名。配置好相关参数之后，就可以使用简化的命令登录服务器了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh server</span><br></pre></td></tr></table></figure>

<h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>在本地.ssh文件夹下vi config，然后</p>
<p>Host school</p>
<p>​    HostName ip地址</p>
<p>​    User xxxx</p>
<p>​    Port 22</p>
]]></content>
  </entry>
  <entry>
    <title>C++入门</title>
    <url>/2020/05/08/c-all/</url>
    <content><![CDATA[<h1 id="C-如何运行"><a href="#C-如何运行" class="headerlink" title="C++如何运行"></a>C++如何运行</h1><h2 id="g-应用说明"><a href="#g-应用说明" class="headerlink" title="g++ 应用说明"></a>g++ 应用说明</h2><p>程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc main.cpp -lstdc++ -o main</span><br><span class="line">#意思是-l std c++</span><br></pre></td></tr></table></figure>

<p>下面是一个保存在文件 helloworld.cpp 中一个简单的 C++ 程序的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最简单的编译方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ g++ helloworld.cpp</span><br></pre></td></tr></table></figure>

<p>由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;a.out</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>通常我们使用 <strong>-o</strong> 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ g++ helloworld.cpp -o helloworld</span><br></pre></td></tr></table></figure>

<p>执行 helloworld:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;helloworld</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>如果是多个 C++ 代码文件，如 runoob1.cpp、runoob2.cpp，编译命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ g++ runoob1.cpp runoob2.cpp -o runoob</span><br></pre></td></tr></table></figure>

<p>生成一个 runoob 可执行文件。</p>
<p>g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -g -Wall -std&#x3D;c++11 main.cpp</span><br></pre></td></tr></table></figure>

<h3 id="g-常用命令选项"><a href="#g-常用命令选项" class="headerlink" title="g++ 常用命令选项"></a>g++ 常用命令选项</h3><table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-ansi</td>
<td align="left">只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td>
</tr>
<tr>
<td align="left">-c</td>
<td align="left">只编译并生成目标文件。</td>
</tr>
<tr>
<td align="left">-DMACRO</td>
<td align="left">以字符串”1”定义 MACRO 宏。</td>
</tr>
<tr>
<td align="left">-DMACRO=DEFN</td>
<td align="left">以字符串”DEFN”定义 MACRO 宏。</td>
</tr>
<tr>
<td align="left">-E</td>
<td align="left">只运行 C 预编译器。</td>
</tr>
<tr>
<td align="left">-g</td>
<td align="left">生成调试信息。GNU 调试器可利用该信息。</td>
</tr>
<tr>
<td align="left">-IDIRECTORY</td>
<td align="left">指定额外的头文件搜索路径DIRECTORY。</td>
</tr>
<tr>
<td align="left">-LDIRECTORY</td>
<td align="left">指定额外的函数库搜索路径DIRECTORY。</td>
</tr>
<tr>
<td align="left">-lLIBRARY</td>
<td align="left">连接时搜索指定的函数库LIBRARY。</td>
</tr>
<tr>
<td align="left">-m486</td>
<td align="left">针对 486 进行代码优化。</td>
</tr>
<tr>
<td align="left">-o</td>
<td align="left">FILE 生成指定的输出文件。用在生成可执行文件时。</td>
</tr>
<tr>
<td align="left">-O0</td>
<td align="left">不进行优化处理。</td>
</tr>
<tr>
<td align="left">-O</td>
<td align="left">或 -O1 优化生成代码。</td>
</tr>
<tr>
<td align="left">-O2</td>
<td align="left">进一步优化。</td>
</tr>
<tr>
<td align="left">-O3</td>
<td align="left">比 -O2 更进一步优化，包括 inline 函数。</td>
</tr>
<tr>
<td align="left">-shared</td>
<td align="left">生成共享目标文件。通常用在建立共享库时。</td>
</tr>
<tr>
<td align="left">-static</td>
<td align="left">禁止使用共享连接。</td>
</tr>
<tr>
<td align="left">-UMACRO</td>
<td align="left">取消对 MACRO 宏的定义。</td>
</tr>
<tr>
<td align="left">-w</td>
<td align="left">不生成任何警告信息。</td>
</tr>
<tr>
<td align="left">-Wall</td>
<td align="left">生成所有警告信息。</td>
</tr>
</tbody></table>
<h1 id="C-注释"><a href="#C-注释" class="headerlink" title="C++ 注释"></a>C++ 注释</h1><p>程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。</p>
<p>C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。</p>
<p>C++ 注释以 /* 开始，以 */ 终止。例如：</p>
<p>/* 这是注释 <em>/  /</em> C++ 注释也可以 * 跨行 */</p>
<p>注释也能以 // 开始，直到行末为止。</p>
<p> 块注释符（/<em>…</em>/）是不可以嵌套使用的。</p>
<p>此外，我们还可以使用 <strong>#if 0 … #endif</strong> 来实现注释，且可以实现嵌套，格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if 0</span><br><span class="line">   code</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>你可以把 <strong>#if 0</strong> 改成 <strong>#if 1</strong> 来执行 <strong>code</strong> 的代码。</p>
<p>这种形式对程序调试也可以帮助，测试时使用 <strong>#if 1</strong> 来执行测试代码，发布后使用 <strong>#if 0</strong> 来屏蔽测试代码。</p>
<p><strong>#if</strong> 后可以是任意的条件语句。</p>
<p>下面的代码如果 condition 条件为 true 执行 code1 ，否则执行 code2。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if condition</span><br><span class="line">  code1</span><br><span class="line">#else</span><br><span class="line">  code2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h1 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C++ 数据类型"></a>C++ 数据类型</h1><h2 id="基本的内置类型"><a href="#基本的内置类型" class="headerlink" title="基本的内置类型"></a>基本的内置类型</h2><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">布尔型</td>
<td align="left">bool</td>
</tr>
<tr>
<td align="left">字符型</td>
<td align="left">char</td>
</tr>
<tr>
<td align="left">整型</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">浮点型</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">双浮点型</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">无类型</td>
<td align="left">void</td>
</tr>
<tr>
<td align="left">宽字符型</td>
<td align="left">wchar_t</td>
</tr>
</tbody></table>
<p>其实 wchar_t 是这样来的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef short int wchar_t;&#x2F;&#x2F;占2或4字节</span><br></pre></td></tr></table></figure>

<p>所以 wchar_t 实际上的空间是和 short int 一样。</p>
<p>一些基本类型可以使用一个或多个类型修饰符进行修饰：</p>
<ul>
<li><p>signed</p>
</li>
<li><p>unsigned</p>
</li>
<li><p>short：带short都是2字节</p>
</li>
<li><p>long</p>
</li>
<li><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">位</th>
<th align="left">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td align="left">1 个字节</td>
<td align="left">-128 到 127 或者 0 到 255</td>
</tr>
<tr>
<td align="left">unsigned char</td>
<td align="left">1 个字节</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left">signed char</td>
<td align="left">1 个字节</td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td align="left">4 个字节</td>
<td align="left">0 到 4294967295</td>
</tr>
<tr>
<td align="left">signed int</td>
<td align="left">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">short int</td>
<td align="left">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="left">unsigned short int</td>
<td align="left">2 个字节</td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="left">signed short int</td>
<td align="left">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="left">long int</td>
<td align="left">4 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left">signed long int</td>
<td align="left">8 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left">unsigned long int</td>
<td align="left">8 个字节</td>
<td align="left">0 到 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">4 个字节</td>
<td align="left">精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">8 个字节</td>
<td align="left">双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td>
</tr>
<tr>
<td align="left">long double</td>
<td align="left">16 个字节</td>
<td align="left">长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td>
</tr>
<tr>
<td align="left">wchar_t</td>
<td align="left">2 或 4 个字节</td>
<td align="left">1 个宽字符</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="typedef-声明"><a href="#typedef-声明" class="headerlink" title="typedef 声明"></a>typedef 声明</h2><p>您可以使用 <strong>typedef</strong> 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef type newname;</span><br></pre></td></tr></table></figure>

<p>例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int feet;</span><br></pre></td></tr></table></figure>

<p>现在，下面的声明是完全合法的，它创建了一个整型变量 distance：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feet distance;</span><br></pre></td></tr></table></figure>

<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>
<p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p>
<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum 枚举名&#123; </span><br><span class="line">     标识符[&#x3D;整型常数], </span><br><span class="line">     标识符[&#x3D;整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[&#x3D;整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure>

<p>如果枚举没有初始化, 即省掉”=整型常数”时, 则从第一个标识符开始。</p>
<p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum color &#123; red, green, blue &#125; c;</span><br><span class="line">c &#x3D; blue;</span><br></pre></td></tr></table></figure>

<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，<strong>green</strong> 的值为 5。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum color &#123; red, green&#x3D;5, blue &#125;;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>blue</strong> 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。</p>
<h1 id="C-变量类型"><a href="#C-变量类型" class="headerlink" title="C++ 变量类型"></a>C++ 变量类型</h1><p>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。</p>
<p>基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bool</td>
<td align="left">存储值 true 或 false。</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">通常是一个字符（八位）。这是一个整数类型。</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">对机器而言，整数的最自然的大小。</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。<img src="https://www.runoob.com/wp-content/uploads/2014/09/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png" alt="img"></td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">双精度浮点值。双精度是1位符号，11位指数，52位小数。<img src="https://www.runoob.com/wp-content/uploads/2014/09/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.png" alt="img"></td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">表示类型的缺失。</td>
</tr>
<tr>
<td align="left">wchar_t</td>
<td align="left">宽字符类型。</td>
</tr>
</tbody></table>
<p>C++ 也允许定义各种其他类型的变量，比如<strong>枚举、指针、数组、引用、数据结构、类</strong>等等，这将会在后续的章节中进行讲解。</p>
<h2 id="C-中的变量定义"><a href="#C-中的变量定义" class="headerlink" title="C++ 中的变量定义"></a>C++ 中的变量定义</h2><p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type variable_list;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>type</strong> 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，<strong>variable_list</strong> 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。</p>
<p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p>
<h2 id="C-中的变量声明"><a href="#C-中的变量声明" class="headerlink" title="C++ 中的变量声明"></a>C++ 中的变量声明</h2><p>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<p>当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 <strong>extern</strong> 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>尝试下面的实例，其中，变量在头部就已经被声明，但它们是在主函数内被定义和初始化的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 变量声明</span><br><span class="line">extern int a, b;</span><br><span class="line">extern int c;</span><br><span class="line">extern float f;</span><br><span class="line">  </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 变量定义</span><br><span class="line">  int a, b;</span><br><span class="line">  int c;</span><br><span class="line">  float f;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; 实际初始化</span><br><span class="line">  a &#x3D; 10;</span><br><span class="line">  b &#x3D; 20;</span><br><span class="line">  c &#x3D; a + b;</span><br><span class="line"> </span><br><span class="line">  cout &lt;&lt; c &lt;&lt; endl ;</span><br><span class="line"> </span><br><span class="line">  f &#x3D; 70.0&#x2F;3.0;</span><br><span class="line">  cout &lt;&lt; f &lt;&lt; endl ;</span><br><span class="line"> </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30</span><br><span class="line">23.3333</span><br></pre></td></tr></table></figure>

<p>同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数声明</span><br><span class="line">int func();</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 函数调用</span><br><span class="line">    int i &#x3D; func();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 函数定义</span><br><span class="line">int func()</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>现在才算理解声明和定义的区别了：</strong></p>
<p>定义包含了声明，但是声明不包含定义，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 0;     &#x2F;&#x2F;定义并声明了变量 a</span><br><span class="line">extern int a;  &#x2F;&#x2F;只是声明了有一个变量 a 存在，具体 a 在哪定义的，需要编译器编译的时候去找。</span><br></pre></td></tr></table></figure>

<p>函数也是类似，定义的时候同时声明。但如果只是声明，编译器只知道有这么个函数，具体函数怎么定义的要编译器去找。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void fun1();  &#x2F;&#x2F;函数声明</span><br><span class="line"></span><br><span class="line">void fun1()&#123;  &#x2F;&#x2F;函数定义</span><br><span class="line">    cout&lt;&lt;&quot;fun1&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C/C++ 编译 cpp 文件是从上往下编译，所以 main 函数里面调用其他函数时，如果其他函数在 main 函数的下面，则要在 main 函数上面先声明这个函数。</p>
<p>或者把 main 函数放在最下面，这个不仅限于 main 函数，其他函数的调用都是如此。被调用的函数要在调用的函数之前声明。</p>
<p>用 extern 声明外部变量是不能进行初始化：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/20180617101214118.png" alt="img"></p>
<p>为什么会这样呢？因为 <strong>extern int a;</strong> 只是声明而不是定义，声明是不会为变量开辟内存空间的，自然无法对其进行初始化的操作</p>
<h2 id="C-中的左值（Lvalues）和右值（Rvalues"><a href="#C-中的左值（Lvalues）和右值（Rvalues" class="headerlink" title="C++ 中的左值（Lvalues）和右值（Rvalues)"></a>C++ 中的左值（Lvalues）和右值（Rvalues)</h2><p>C++ 中有两种类型的表达式：</p>
<ul>
<li><strong>左值（lvalue）：</strong>指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>
<li><strong>右值（rvalue）：</strong>术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>
</ul>
<p>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int g &#x3D; 20;</span><br></pre></td></tr></table></figure>

<p>但是下面这个就不是一个有效的语句，会生成编译时错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 &#x3D; 20;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>linux基础（81-100集）</title>
    <url>/2020/04/26/linux5/</url>
    <content><![CDATA[<h2 id="P81-87（系统信息）"><a href="#P81-87（系统信息）" class="headerlink" title="P81-87（系统信息）"></a>P81-87（系统信息）</h2><h3 id="01-时间和日期"><a href="#01-时间和日期" class="headerlink" title="01.时间和日期"></a>01.时间和日期</h3><p>​    date：查看系统日期</p>
<p>​    cal：calendar查看日历，-y选项可以查看一年日历</p>
<h3 id="02-磁盘信息"><a href="#02-磁盘信息" class="headerlink" title="02.磁盘信息"></a>02.磁盘信息</h3><p>​    df -h：disk free显示磁盘剩余空间</p>
<p>​    du -h[目录名]：disk usage显示目录下文件大小（-h以人性化方式显示文件大小）</p>
<p>​    /看根目录</p>
<h3 id="03-进程信息"><a href="#03-进程信息" class="headerlink" title="03. 进程信息"></a>03. 进程信息</h3><p>当前正在执行的一个程序是进程</p>
<p>​    ps aux：process status查看进程的详细状况</p>
<p>​    top：动态显示运行中的进程并且排序</p>
<p>​    kill [-9] 进程代号：终止指定代号进程，-9是强制终止</p>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>Linux ps命令用于显示当前进程 (process) 的状态。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps [options] [--help]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义</li>
<li>-A 列出所有的行程</li>
<li>-w 显示加宽可以显示较多的资讯</li>
<li>-au 显示较详细的资讯</li>
<li>-aux 显示所有包含其他使用者的行程（</li>
<li>au(x) 输出格式 :（常用）</li>
<li>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</li>
<li>USER: 行程拥有者</li>
<li>PID: pid</li>
<li>%CPU: 占用的 CPU 使用率</li>
<li>%MEM: 占用的记忆体使用率</li>
<li>VSZ: 占用的虚拟记忆体大小</li>
<li>RSS: 占用的记忆体大小</li>
<li>TTY: 终端的次要装置号码 (minor device number of tty)</li>
<li>STAT: 该行程的状态:</li>
<li>D: 无法中断的休眠状态 (通常 IO 的进程)</li>
<li>R: 正在执行中</li>
<li>S: 静止状态</li>
<li>T: 暂停执行</li>
<li>Z: 不存在但暂时无法消除</li>
<li>W: 没有足够的记忆体分页可分配</li>
<li>&lt;: 高优先序的行程</li>
<li>N: 低优先序的行程</li>
<li>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)</li>
<li>START: 行程开始时间</li>
<li>TIME: 执行的时间</li>
<li>COMMAND:所执行的指令</li>
<li>x：显示没有控制终端的进程（会显示很多）</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ps -A 显示进程信息</span><br><span class="line">PID TTY     TIME CMD</span><br><span class="line">  1 ?    00:00:02 init</span><br><span class="line">  2 ?    00:00:00 kthreadd</span><br><span class="line">  3 ?    00:00:00 migration&#x2F;0</span><br><span class="line">  4 ?    00:00:00 ksoftirqd&#x2F;0</span><br><span class="line">  5 ?    00:00:00 watchdog&#x2F;0</span><br><span class="line">  6 ?    00:00:00 events&#x2F;0</span><br><span class="line">  7 ?    00:00:00 cpuset</span><br><span class="line">  8 ?    00:00:00 khelper</span><br><span class="line">  9 ?    00:00:00 netns</span><br><span class="line">  10 ?    00:00:00 async&#x2F;mgr</span><br><span class="line">  11 ?    00:00:00 pm</span><br><span class="line">  12 ?    00:00:00 sync_supers</span><br><span class="line">  13 ?    00:00:00 bdi-default</span><br><span class="line">  14 ?    00:00:00 kintegrityd&#x2F;0</span><br><span class="line">  15 ?    00:00:02 kblockd&#x2F;0</span><br><span class="line">  16 ?    00:00:00 kacpid</span><br><span class="line">  17 ?    00:00:00 kacpi_notify</span><br><span class="line">  18 ?    00:00:00 kacpi_hotplug</span><br><span class="line">  19 ?    00:00:27 ata&#x2F;0</span><br><span class="line">……省略部分结果</span><br><span class="line">30749 pts&#x2F;0  00:00:15 gedit</span><br><span class="line">30886 ?    00:01:10 qtcreator.bin</span><br><span class="line">30894 ?    00:00:00 qtcreator.bin </span><br><span class="line">31160 ?    00:00:00 dhclient</span><br><span class="line">31211 ?    00:00:00 aptd</span><br><span class="line">31302 ?    00:00:00 sshd</span><br><span class="line">31374 pts&#x2F;2  00:00:00 bash</span><br><span class="line">31396 pts&#x2F;2  00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>显示指定用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ps -u root &#x2F;&#x2F;显示root进程用户信息</span><br><span class="line"> PID TTY     TIME CMD</span><br><span class="line">  1 ?    00:00:02 init</span><br><span class="line">  2 ?    00:00:00 kthreadd</span><br><span class="line">  3 ?    00:00:00 migration&#x2F;0</span><br><span class="line">  4 ?    00:00:00 ksoftirqd&#x2F;0</span><br><span class="line">  5 ?    00:00:00 watchdog&#x2F;0</span><br><span class="line">  6 ?    00:00:00 events&#x2F;0</span><br><span class="line">  7 ?    00:00:00 cpuset</span><br><span class="line">  8 ?    00:00:00 khelper</span><br><span class="line">  9 ?    00:00:00 netns</span><br><span class="line">  10 ?    00:00:00 async&#x2F;mgr</span><br><span class="line">  11 ?    00:00:00 pm</span><br><span class="line">  12 ?    00:00:00 sync_supers</span><br><span class="line">  13 ?    00:00:00 bdi-default</span><br><span class="line">  14 ?    00:00:00 kintegrityd&#x2F;0</span><br><span class="line">  15 ?    00:00:02 kblockd&#x2F;0</span><br><span class="line">  16 ?    00:00:00 kacpid</span><br><span class="line">……省略部分结果</span><br><span class="line">30487 ?    00:00:06 gnome-terminal</span><br><span class="line">30488 ?    00:00:00 gnome-pty-helpe</span><br><span class="line">30489 pts&#x2F;0  00:00:00 bash</span><br><span class="line">30670 ?    00:00:00 debconf-communi </span><br><span class="line">30749 pts&#x2F;0  00:00:15 gedit</span><br><span class="line">30886 ?    00:01:10 qtcreator.bin</span><br><span class="line">30894 ?    00:00:00 qtcreator.bin </span><br><span class="line">31160 ?    00:00:00 dhclient</span><br><span class="line">31211 ?    00:00:00 aptd</span><br><span class="line">31302 ?    00:00:00 sshd</span><br><span class="line">31374 pts&#x2F;2  00:00:00 bash</span><br><span class="line">31397 pts&#x2F;2  00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>显示所有进程信息，连同命令行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ps -ef &#x2F;&#x2F;显示所有命令，连带命令行</span><br><span class="line">UID    PID PPID C STIME TTY     TIME CMD</span><br><span class="line">root     1   0 0 10:22 ?    00:00:02 &#x2F;sbin&#x2F;init</span><br><span class="line">root     2   0 0 10:22 ?    00:00:00 [kthreadd]</span><br><span class="line">root     3   2 0 10:22 ?    00:00:00 [migration&#x2F;0]</span><br><span class="line">root     4   2 0 10:22 ?    00:00:00 [ksoftirqd&#x2F;0]</span><br><span class="line">root     5   2 0 10:22 ?    00:00:00 [watchdog&#x2F;0]</span><br><span class="line">root     6   2 0 10:22 ?    &#x2F;usr&#x2F;lib&#x2F;NetworkManager</span><br><span class="line">……省略部分结果</span><br><span class="line">root   31302 2095 0 17:42 ?    00:00:00 sshd: root@pts&#x2F;2 </span><br><span class="line">root   31374 31302 0 17:42 pts&#x2F;2  00:00:00 -bash</span><br><span class="line">root   31400   1 0 17:46 ?    00:00:00 &#x2F;usr&#x2F;bin&#x2F;python &#x2F;usr&#x2F;sbin&#x2F;aptd</span><br><span class="line">root   31407 31374 0 17:48 pts&#x2F;2  00:00:00 ps -ef</span><br></pre></td></tr></table></figure>

<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>（Linux top命令用于实时显示 process 的动态。（好玩哪）</p>
<p>使用权限：所有使用者。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s</li>
<li>q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行</li>
<li>c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来</li>
<li>s : 安全模式，将交谈式指令取消, 避免潜在的危机</li>
<li>i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程</li>
<li>n : 更新的次数，完成后将会退出 top</li>
<li>b : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>显示进程信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># top</span><br></pre></td></tr></table></figure>

<p>显示完整命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># top -c</span><br></pre></td></tr></table></figure>

<p>以批处理模式显示程序信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># top -b</span><br></pre></td></tr></table></figure>

<p>以累积模式显示程序信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># top -S</span><br></pre></td></tr></table></figure>

<p>设置信息更新次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top -n 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;表示更新两次后终止更新显示</span><br></pre></td></tr></table></figure>

<p>设置信息更新时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># top -d 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;表示更新周期为3秒</span><br></pre></td></tr></table></figure>

<p>显示指定的进程信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># top -p 139</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示进程号为139的进程信息，CPU、内存占用率等</span><br></pre></td></tr></table></figure>

<p>显示更新十次后退出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top -n 10</span><br></pre></td></tr></table></figure>

<p>使用者将不能利用交谈式指令来对行程下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top -s</span><br></pre></td></tr></table></figure>

<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>Linux kill命令用于删除执行中的程序或工作。</p>
<p>kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或jobs指令查看。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill [-s &lt;信息名称或编号&gt;][程序]　或　kill [-l &lt;信息编号&gt;]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-l &lt;信息编号&gt; 　若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称。</li>
<li>-s &lt;信息名称或编号&gt; 　指定要送出的信息。</li>
<li>[程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。</li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>杀死进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># kill 12345</span><br></pre></td></tr></table></figure>

<p>强制杀死进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># kill -KILL 123456</span><br></pre></td></tr></table></figure>

<p>发送SIGHUP信号，可以使用一下信号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># kill -HUP pid</span><br></pre></td></tr></table></figure>

<p>彻底杀死进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># kill -9 123456</span><br></pre></td></tr></table></figure>

<p>显示信号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># kill -l</span><br><span class="line">1) SIGHUP     2) SIGINT     3) SIGQUIT     4) SIGILL     5) SIGTRAP</span><br><span class="line">6) SIGABRT     7) SIGBUS     8) SIGFPE     9) SIGKILL    10) SIGUSR1</span><br><span class="line">11) SIGSEGV    12) SIGUSR2    13) SIGPIPE    14) SIGALRM    15) SIGTERM</span><br><span class="line">16) SIGSTKFLT    17) SIGCHLD    18) SIGCONT    19) SIGSTOP    20) SIGTSTP</span><br><span class="line">21) SIGTTIN    22) SIGTTOU    23) SIGURG    24) SIGXCPU    25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM    27) SIGPROF    28) SIGWINCH    29) SIGIO    30) SIGPWR</span><br><span class="line">31) SIGSYS    34) SIGRTMIN    35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9    44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1    64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>杀死指定用户所有进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#kill -9 $(ps -ef | grep hnlinux) &#x2F;&#x2F;方法一 过滤出hnlinux用户进程 </span><br><span class="line">#kill -u hnlinux &#x2F;&#x2F;方法二</span><br></pre></td></tr></table></figure>

<h2 id="P88-92（其他命令）"><a href="#P88-92（其他命令）" class="headerlink" title="P88-92（其他命令）"></a>P88-92（其他命令）</h2><h3 id="1-查找文件"><a href="#1-查找文件" class="headerlink" title="1.查找文件"></a>1.查找文件</h3><p>​    find</p>
<p>Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find   path   -option   [   -print ]   [ -exec   -ok   command ]   &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong> :</p>
<p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p>
<p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</p>
<p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p>
<p>-amin n : 在过去 n 分钟内被读取过</p>
<p>-anewer file : 比文件 file 更晚被读取过的文件</p>
<p>-atime n : 在过去n天内被读取过的文件</p>
<p>-cmin n : 在过去 n 分钟内被修改过</p>
<p>-cnewer file :比文件 file 更新的文件</p>
<p>-ctime n : 在过去n天内被修改过的文件</p>
<p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p>
<p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p>
<p>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写（常用）</p>
<p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。</p>
<p>d: 目录</p>
<p>c: 字型装置文件</p>
<p>b: 区块装置文件</p>
<p>p: 具名贮列</p>
<p>f: 一般文件</p>
<p>l: 符号连结</p>
<p>s: socket</p>
<p>-pid n : process id 是 n 的文件</p>
<p>你可以使用 ( ) 将运算式分隔，并使用下列运算。</p>
<p>exp1 -and exp2</p>
<p>! expr</p>
<p>-not expr</p>
<p>exp1 -or exp2</p>
<p>exp1, exp2</p>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>将目前目录及其子目录下所有延伸档名是 c 的文件列出来。（经典）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find . -name &quot;*.c&quot;</span><br></pre></td></tr></table></figure>

<p>将目前目录其其下子目录中所有一般文件列出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find . -type f</span><br></pre></td></tr></table></figure>

<p>将目前目录及其子目录下所有最近 20 天内更新过的文件列出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find . -ctime -20</span><br></pre></td></tr></table></figure>

<p>查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find &#x2F;var&#x2F;log -type f -mtime +7 -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find . -type f -perm 644 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find &#x2F; -type f -size 0 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h3 id="2-软链接（类似快捷方式）"><a href="#2-软链接（类似快捷方式）" class="headerlink" title="2. 软链接（类似快捷方式）"></a>2. 软链接（类似快捷方式）</h3><p>ln -s 被链接的源文件 起的文件名</p>
<p>ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。这个命令最常用的参数是-s,具体用法是：ln -s 源文件 目标文件。当 我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的 目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>
<p>例如：ln -s /bin/less /usr/local/bin/less </p>
<p>-s 是代号（symbolic）的意思。 </p>
<p>这 里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接又软链接 和硬链接两种，软链接就是ln -s ** *<em>,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln *</em> **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。<br>如果你用ls察看一个目录时，发现有的文件后面有一个@的符号，那就是一个用ln命令生成的文件，用ls -l命令去察看，就可以看到显示的link的路径了。 </p>
<p>不加-s是硬链接，ls -l可以查看硬链接数</p>
<p>ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同不的链接，这个命令最常用的参数是-s，具体用法是：ln –s 源文件 目标文件。<br>　　当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。例如：ln –s /bin/less /usr/local/bin/less<br>　　-s 是代号（symbolic）的意思。<br>　　这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接又 软链接和硬链接两种，软链接就是ln –s ** *<em>，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln *</em> **，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。<br>　　如果你用ls察看一个目录时，发现有的文件后面有一个@的符号，那就是一个用ln命令生成的文件，用ls –l命令去察看，就可以看到显示的link的路径了。<br>　　指令详细说明<br>　　指令名称 : ln<br>　　使用权限 : 所有使用者<br>　　使用方式 : ln [options] source dist，其中 option 的格式为 :<br>　　[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}]<br>　　[–help] [–version] [–]<br>　　说明 : Linux/Unix 档案系统中，有所谓的连结(link)，我们可以将其视为档案的别名，而连结又可分为两种 : 硬连结(hard link)与软连结(symbolic link)，硬连结的意思是一个档案可以有多个名称，而软连结的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬连结是存在同一个档 案系统中，而软连结却可以跨越不同的档案系统。<br>　　ln source dist 是产生一个连结(dist)到 source，至于使用硬连结或软链结则由参数决定。<br>　　不论是硬连结或软链结都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p>
<p>Linux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。</p>
<p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln [参数][源文件或目录][目标文件或目录]</span><br></pre></td></tr></table></figure>

<p>其中参数的格式为</p>
<p>[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}]</p>
<p>[–help] [–version] [–]</p>
<p><strong>命令功能</strong> :<br>Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。</p>
<p>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p>
<p><strong>软链接</strong>：（用绝对路径）</p>
<ul>
<li>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</li>
<li>2.软链接可以 跨文件系统 ，硬链接不可以</li>
<li>3.软链接可以对一个不存在的文件名进行链接</li>
<li>4.软链接可以对目录进行链接</li>
</ul>
<p><strong>硬链接</strong>：</p>
<ul>
<li>1.硬链接，以文件副本的形式存在。但不占用实际空间。</li>
<li>2.不允许给目录创建硬链接</li>
<li>3.硬链接只有在同一个文件系统中才能创建</li>
</ul>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p><strong>必要参数</strong>：</p>
<ul>
<li>-b 删除，覆盖以前建立的链接</li>
<li>-d 允许超级用户制作目录的硬链接</li>
<li>-f 强制执行</li>
<li>-i 交互模式，文件存在则提示用户是否覆盖</li>
<li>-n 把符号链接视为一般目录</li>
<li>-s 软链接(符号链接)（常用）</li>
<li>-v 显示详细的处理过程</li>
</ul>
<p><strong>选择参数</strong>：</p>
<ul>
<li>-S “-S&lt;字尾备份字符串&gt; “或 “–suffix=&lt;字尾备份字符串&gt;”</li>
<li>-V “-V&lt;备份方式&gt;”或”–version-control=&lt;备份方式&gt;”</li>
<li>–help 显示帮助信息</li>
<li>–version 显示版本信息</li>
</ul>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>给文件创建软链接，为log2013.log文件创建软链接link2013，如果log2013.log丢失，link2013将失效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s log2013.log link2013</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost test]# ll</span><br><span class="line">-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log</span><br><span class="line">[root@localhost test]# ln -s log2013.log link2013</span><br><span class="line">[root@localhost test]# ll</span><br><span class="line">lrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -&gt; log2013.log</span><br><span class="line">-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log</span><br></pre></td></tr></table></figure>

<p>给文件创建硬链接，为log2013.log创建硬链接ln2013，log2013.log与ln2013的各项属性相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln log2013.log ln2013</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost test]# ll</span><br><span class="line">lrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -&gt; log2013.log</span><br><span class="line">-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log</span><br><span class="line">[root@localhost test]# ln log2013.log ln2013</span><br><span class="line">[root@localhost test]# ll</span><br><span class="line">lrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -&gt; log2013.log</span><br><span class="line">-rw-r--r-- 2 root bin      61 11-13 06:03 ln2013</span><br><span class="line">-rw-r--r-- 2 root bin      61 11-13 06:03 log2013.log</span><br></pre></td></tr></table></figure>

<h2 id="P93（软链接硬链接）"><a href="#P93（软链接硬链接）" class="headerlink" title="P93（软链接硬链接）"></a>P93（软链接硬链接）</h2><p>linux中文件名和文件数据分开存储</p>
<p>删除文件，软链接自动删除，文件数据自动删除，硬链接不会删除，文件数据还可以硬链接读取，几乎不会用硬链接。</p>
<h2 id="P94-97打包压缩"><a href="#P94-97打包压缩" class="headerlink" title="P94-97打包压缩"></a>P94-97打包压缩</h2><p>windows中：rar</p>
<p>mac中：zip</p>
<p>linux：tar.gz</p>
<p>Linux tar命令用于备份文件。</p>
<p>tar是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p>
<p>tar -cvf 打包文件.tar 被打包文件/路径… #打包</p>
<p>tar -xvf 打包文件.tar#解压</p>
<h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b &lt;区块数目&gt;][-C &lt;目的目录&gt;][-f &lt;备份文件&gt;][-F &lt;Script文件&gt;][-K &lt;文件&gt;][-L &lt;媒体容量&gt;][-N &lt;日期时间&gt;][-T &lt;范本文件&gt;][-V &lt;卷册名称&gt;][-X &lt;范本文件&gt;][-&lt;设备编号&gt;&lt;存储密度&gt;][--after-date&#x3D;&lt;日期时间&gt;][--atime-preserve][--backuup&#x3D;&lt;备份方式&gt;][--checkpoint][--concatenate][--confirmation][--delete][--exclude&#x3D;&lt;范本样式&gt;][--force-local][--group&#x3D;&lt;群组名称&gt;][--help][--ignore-failed-read][--new-volume-script&#x3D;&lt;Script文件&gt;][--newer-mtime][--no-recursion][--null][--numeric-owner][--owner&#x3D;&lt;用户名称&gt;][--posix][--erve][--preserve-order][--preserve-permissions][--record-size&#x3D;&lt;区块数目&gt;][--recursive-unlink][--remove-files][--rsh-command&#x3D;&lt;执行指令&gt;][--same-owner][--suffix&#x3D;&lt;备份字尾字符串&gt;][--totals][--use-compress-program&#x3D;&lt;执行指令&gt;][--version][--volno-file&#x3D;&lt;编号文件&gt;][文件或目录...]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-A或–catenate 新增文件到已存在的备份文件。</li>
<li>-b&lt;区块数目&gt;或–blocking-factor=&lt;区块数目&gt; 设置每笔记录的区块数目，每个区块大小为12Bytes。</li>
<li>-B或–read-full-records 读取数据时重设区块大小。</li>
<li>-c或–create 建立新的备份文件。</li>
<li>-C&lt;目的目录&gt;或–directory=&lt;目的目录&gt; 切换到指定的目录。</li>
<li>-d或–diff或–compare 对比备份文件内和文件系统上的文件的差异。</li>
<li>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt; 指定备份文件。</li>
<li>-F&lt;Script文件&gt;或–info-script=&lt;Script文件&gt; 每次更换磁带时，就执行指定的Script文件。</li>
<li>-g或–listed-incremental 处理GNU格式的大量备份。</li>
<li>-G或–incremental 处理旧的GNU格式的大量备份。</li>
<li>-h或–dereference 不建立符号连接，直接复制该连接所指向的原始文件。</li>
<li>-i或–ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。</li>
<li>-k或–keep-old-files 解开备份文件时，不覆盖已有的文件。</li>
<li>-K&lt;文件&gt;或–starting-file=&lt;文件&gt; 从指定的文件开始还原。</li>
<li>-l或–one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。</li>
<li>-L&lt;媒体容量&gt;或-tape-length=&lt;媒体容量&gt; 设置存放每体的容量，单位以1024 Bytes计算。</li>
<li>-m或–modification-time 还原文件时，不变更文件的更改时间。</li>
<li>-M或–multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li>
<li>-N&lt;日期格式&gt;或–newer=&lt;日期时间&gt; 只将较指定日期更新的文件保存到备份文件里。</li>
<li>-o或–old-archive或–portability 将资料写入备份文件时使用V7格式。</li>
<li>-O或–stdout 把从备份文件里还原的文件输出到标准输出设备。</li>
<li>-p或–same-permissions 用原来的文件权限还原文件。</li>
<li>-P或–absolute-names 文件名使用绝对名称，不移除文件名称前的”/“号。</li>
<li>-r或–append 新增文件到已存在的备份文件的结尾部分。</li>
<li>-R或–block-number 列出每个信息在备份文件中的区块编号。</li>
<li>-s或–same-order 还原文件的顺序和备份文件内的存放顺序相同。</li>
<li>-S或–sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。</li>
<li>-t或–list 列出备份文件的内容。</li>
<li>-T&lt;范本文件&gt;或–files-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。</li>
<li>-u或–update 仅置换较备份文件内的文件更新的文件。</li>
<li>-U或–unlink-first 解开压缩文件还原文件之前，先解除文件的连接。</li>
<li>-v或–verbose 显示指令执行过程。</li>
<li>-V&lt;卷册名称&gt;或–label=&lt;卷册名称&gt; 建立使用指定的卷册名称的备份文件。</li>
<li>-w或–interactive 遭遇问题时先询问用户。</li>
<li>-W或–verify 写入备份文件后，确认文件正确无误。</li>
<li>-x或–extract或–get 从备份文件中还原文件。</li>
<li>-X&lt;范本文件&gt;或–exclude-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。</li>
<li>-z或–gzip或–ungzip 通过gzip指令处理备份文件。</li>
<li>-Z或–compress或–uncompress 通过compress指令处理备份文件。</li>
<li>-&lt;设备编号&gt;&lt;存储密度&gt; 设置备份用的外围设备编号及存放数据的密度。</li>
<li>–after-date=&lt;日期时间&gt; 此参数的效果和指定”-N”参数相同。</li>
<li>–atime-preserve 不变更文件的存取时间。</li>
<li>–backup=&lt;备份方式&gt;或–backup 移除文件前先进行备份。</li>
<li>–checkpoint 读取备份文件时列出目录名称。</li>
<li>–concatenate 此参数的效果和指定”-A”参数相同。</li>
<li>–confirmation 此参数的效果和指定”-w”参数相同。</li>
<li>–delete 从备份文件中删除指定的文件。</li>
<li>–exclude=&lt;范本样式&gt; 排除符合范本样式的文件。</li>
<li>–group=&lt;群组名称&gt; 把加入设备文件中的文件的所属群组设成指定的群组。</li>
<li>–help 在线帮助。</li>
<li>–ignore-failed-read 忽略数据读取错误，不中断程序的执行。</li>
<li>–new-volume-script=&lt;Script文件&gt; 此参数的效果和指定”-F”参数相同。</li>
<li>–newer-mtime 只保存更改过的文件。</li>
<li>–no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</li>
<li>–null 从null设备读取文件名称。</li>
<li>–numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。</li>
<li>–owner=&lt;用户名称&gt; 把加入备份文件中的文件的拥有者设成指定的用户。</li>
<li>–posix 将数据写入备份文件时使用POSIX格式。</li>
<li>–preserve 此参数的效果和指定”-ps”参数相同。</li>
<li>–preserve-order 此参数的效果和指定”-A”参数相同。</li>
<li>–preserve-permissions 此参数的效果和指定”-p”参数相同。</li>
<li>–record-size=&lt;区块数目&gt; 此参数的效果和指定”-b”参数相同。</li>
<li>–recursive-unlink 解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</li>
<li>–remove-files 文件加入备份文件后，就将其删除。</li>
<li>–rsh-command=&lt;执行指令&gt; 设置要在远端主机上执行的指令，以取代rsh指令。</li>
<li>–same-owner 尝试以相同的文件拥有者还原文件。</li>
<li>–suffix=&lt;备份字尾字符串&gt; 移除文件前先行备份。</li>
<li>–totals 备份文件建立后，列出文件大小。</li>
<li>–use-compress-program=&lt;执行指令&gt; 通过指定的指令处理备份文件。</li>
<li>–version 显示版本信息。</li>
<li>–volno-file=&lt;编号文件&gt; 使用指定文件内的编号取代预设的卷册编号。</li>
</ul>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>压缩文件 非打包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># touch a.c       </span><br><span class="line"># tar -czvf test.tar.gz a.c   &#x2F;&#x2F;压缩 a.c文件为test.tar.gz</span><br><span class="line">a.c</span><br></pre></td></tr></table></figure>

<p>列出压缩文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -tzvf test.tar.gz </span><br><span class="line">-rw-r--r-- root&#x2F;root     0 2010-05-24 16:51:59 a.c</span><br></pre></td></tr></table></figure>

<p>解压文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -xzvf test.tar.gz </span><br><span class="line">a.c</span><br></pre></td></tr></table></figure>

<p>Linux 常用的压缩与解压缩命令有：tar、gzip、gunzip、bzip2、bunzip2、compress 、uncompress、 zip、 unzip、rar、unrar 等。</p>
<hr>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>最常用的打包命令是 tar，使用 tar 程序打出来的包我们常称为 tar 包，tar 包文件的命令通常都是以 .tar 结尾的。生成 tar 包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲 tar 命令的基本用法。</p>
<p>tar 命令的选项有很多(用 man tar 可以查看到)，但常用的就那么几个选项，下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -cf all.tar *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件打成一个名为 all.tar 的包。-c 是表示产生新的包，-f 指定包的文件名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -rf all.tar *.gif</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .gif 的文件增加到 all.tar 的包里面去，-r 是表示增加文件的意思。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -uf all.tar logo.gif</span><br></pre></td></tr></table></figure>

<p>这条命令是更新原来 tar 包 all.tar 中 logo.gif 文件，-u 是表示更新文件的意思。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -tf all.tar</span><br></pre></td></tr></table></figure>

<p>这条命令是列出 all.tar 包中所有文件，-t 是列出文件的意思。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -xf all.tar</span><br></pre></td></tr></table></figure>

<p>这条命令是解出 all.tar 包中所有文件，-x 是解开的意思。</p>
<p>以上就是 tar 的最基本的用法。为了方便用户在打包解包的同时可以压缩或解压文件，tar 提供了一种特殊的功能。这就是 tar 可以在打包或解包的同时调用其它的压缩程序，比如调用 gzip、bzip2 等。</p>
<h3 id="1-tar调用"><a href="#1-tar调用" class="headerlink" title="1) tar调用"></a>1) tar调用</h3><p>gzip 是 GNU 组织开发的一个压缩程序，.gz 结尾的文件就是 gzip 压缩的结果。与 gzip 相对的解压程序是 gunzip。tar 中使用 -z 这个参数来调用gzip。下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -czf all.tar.gz *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件打成一个 tar 包，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包，包名为 all.tar.gz。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -xzf all.tar.gz</span><br></pre></td></tr></table></figure>

<p>这条命令是将上面产生的包解开。</p>
<h3 id="2-tar-调用-bzip2"><a href="#2-tar-调用-bzip2" class="headerlink" title="2) tar 调用 bzip2"></a>2) tar 调用 bzip2</h3><p>bzip2 是一个压缩能力更强的压缩程序，.bz2 结尾的文件就是 bzip2 压缩的结果。</p>
<p>与 bzip2 相对的解压程序是 bunzip2。tar 中使用 -j 这个参数来调用 gzip。下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -cjf all.tar.bz2 *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件打成一个 tar 包，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，包名为 all.tar.bz2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -xjf all.tar.bz2</span><br></pre></td></tr></table></figure>

<p>这条命令是将上面产生的包解开。</p>
<h3 id="3-tar-调用-compress"><a href="#3-tar-调用-compress" class="headerlink" title="3)tar 调用 compress"></a>3)tar 调用 compress</h3><p>compress 也是一个压缩程序，但是好象使用 compress 的人不如 gzip 和 bzip2 的人多。.Z 结尾的文件就是 bzip2 压缩的结果。与 compress 相对的解压程序是 uncompress。tar 中使用 -Z 这个参数来调用 compress。下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -cZf all.tar.Z *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件打成一个 tar 包，并且将其用 compress 压缩，生成一个 uncompress 压缩过的包，包名为 all.tar.Z。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -xZf all.tar.Z</span><br></pre></td></tr></table></figure>

<p>这条命令是将上面产生的包解开。</p>
<p>有了上面的知识，你应该可以解开多种压缩文件了，下面对于 tar 系列的压缩文件作一个小结：</p>
<p><strong>1) 对于.tar结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xf all.tar</span><br></pre></td></tr></table></figure>

<p><strong>2) 对于 .gz 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -d all.gz</span><br><span class="line">gunzip all.gz</span><br></pre></td></tr></table></figure>

<p><strong>3)对于 .tgz 或 .tar.gz 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xzf all.tar.gz</span><br><span class="line">tar -xzf all.tgz</span><br></pre></td></tr></table></figure>

<p><strong>4) 对于 .bz2 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bzip2 -d all.bz2</span><br><span class="line">bunzip2 all.bz2</span><br></pre></td></tr></table></figure>

<p><strong>5) 对于 tar.bz2 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xjf all.tar.bz2</span><br></pre></td></tr></table></figure>

<p><strong>6) 对于 .Z 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uncompress all.Z</span><br></pre></td></tr></table></figure>

<p><strong>7) 对于 .tar.Z 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xZf all.tar.z</span><br></pre></td></tr></table></figure>

<p>另外对于 Windows 下的常见压缩文件 .zip 和 .rar，Linux 也有相应的方法来解压它们：</p>
<p><strong>1) 对于 .zip</strong></p>
<p>linux 下提供了 zip 和 unzip 程序，zip 是压缩程序，unzip 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># zip all.zip *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件压缩成一个 zip 包:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># unzip all.zip</span><br></pre></td></tr></table></figure>

<p>这条命令是将 all.zip 中的所有文件解压出来。</p>
<p><strong>2) 对于 .rar</strong></p>
<p>要在 linux 下处理 .rar 文件，需要安装 RAR for Linux。下载地址：<a href="http://www.rarsoft.com/download.htm，下载后安装即可。" target="_blank" rel="noopener">http://www.rarsoft.com/download.htm，下载后安装即可。</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -xzpvf rarlinux-x64-5.6.b5.tar.gz</span><br><span class="line"># cd rar </span><br><span class="line"># make</span><br></pre></td></tr></table></figure>

<p>这样就安装好了，安装后就有了 rar 和 unrar 这两个程序，rar 是压缩程序，unrar 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># rar a all *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件压缩成一个 rar 包，名为 all.rar，该程序会将 .rar 扩展名将自动附加到包名后。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># unrar e all.rar</span><br></pre></td></tr></table></figure>

<p>这条命令是将 all.rar 中的所有文件解压出来：</p>
<hr>
<h2 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h2><p><strong>tar</strong></p>
<p>-C 解压缩到指定目录，且目录必须存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c: 建立压缩档案 </span><br><span class="line">-x：解压 </span><br><span class="line">-t：查看内容 </span><br><span class="line">-r：向压缩归档文件末尾追加文件 </span><br><span class="line">-u：更新原压缩包中的文件</span><br></pre></td></tr></table></figure>

<p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-z：有gzip属性的 </span><br><span class="line">-j：有bz2属性的 </span><br><span class="line">-Z：有compress属性的 </span><br><span class="line">-v：显示所有过程 </span><br><span class="line">-O：将文件解开到标准输出</span><br></pre></td></tr></table></figure>

<p>下面的参数 -f 是必须的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</span><br></pre></td></tr></table></figure>

<p># tar -cf all.tar *.jpg </p>
<p>这条命令是将所有 .jpg 的文件打成一个名为 all.tar 的包。-c 是表示产生新的包，-f 指定包的文件名。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -rf all.tar *.gif</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .gif 的文件增加到 all.tar 的包里面去。-r 是表示增加文件的意思。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -uf all.tar logo.gif</span><br></pre></td></tr></table></figure>

<p>这条命令是更新原来 tar 包 all.tar 中 logo.gif 文件，-u 是表示更新文件的意思。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -tf all.tar</span><br></pre></td></tr></table></figure>

<p>这条命令是列出 all.tar 包中所有文件，-t 是列出文件的意思。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -xf all.tar</span><br></pre></td></tr></table></figure>

<p>这条命令是解出 all.tar 包中所有文件，-x 是解开的意思。</p>
<p><strong>压缩</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar –cvf jpg.tar *.jpg       &#x2F;&#x2F; 将目录里所有jpg文件打包成 tar.jpg </span><br><span class="line">tar –czf jpg.tar.gz *.jpg    &#x2F;&#x2F; 将目录里所有jpg文件打包成 jpg.tar 后，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包，命名为 jpg.tar.gz </span><br><span class="line">tar –cjf jpg.tar.bz2 *.jpg   &#x2F;&#x2F; 将目录里所有jpg文件打包成 jpg.tar 后，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，命名为jpg.tar.bz2 </span><br><span class="line">tar –cZf jpg.tar.Z *.jpg     &#x2F;&#x2F; 将目录里所有 jpg 文件打包成 jpg.tar 后，并且将其用 compress 压缩，生成一个 umcompress 压缩过的包，命名为jpg.tar.Z </span><br><span class="line">rar a jpg.rar *.jpg          &#x2F;&#x2F; rar格式的压缩，需要先下载 rar for linux </span><br><span class="line">zip jpg.zip *.jpg            &#x2F;&#x2F; zip格式的压缩，需要先下载 zip for linux</span><br></pre></td></tr></table></figure>

<p><strong>解压</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar –xvf file.tar         &#x2F;&#x2F; 解压 tar 包 （常用）</span><br><span class="line">tar -xzvf file.tar.gz     &#x2F;&#x2F; 解压 tar.gz </span><br><span class="line">tar -xjvf file.tar.bz2    &#x2F;&#x2F; 解压 tar.bz2 </span><br><span class="line">tar –xZvf file.tar.Z      &#x2F;&#x2F; 解压 tar.Z </span><br><span class="line">unrar e file.rar          &#x2F;&#x2F; 解压 rar </span><br><span class="line">unzip file.zip            &#x2F;&#x2F; 解压 zip</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、*.tar 用 tar –xvf 解压 </span><br><span class="line">2、*.gz 用 gzip -d或者gunzip 解压 </span><br><span class="line">3、*.tar.gz和*.tgz 用 tar –xzf 解压 </span><br><span class="line">4、*.bz2 用 bzip2 -d或者用bunzip2 解压 </span><br><span class="line">5、*.tar.bz2用tar –xjf 解压 </span><br><span class="line">6、*.Z 用 uncompress 解压 </span><br><span class="line">7、*.tar.Z 用tar –xZf 解压 </span><br><span class="line">8、*.rar 用 unrar e解压 </span><br><span class="line">9、*.zip 用 unzip 解压</span><br></pre></td></tr></table></figure>

<h3 id="压缩-解压缩"><a href="#压缩-解压缩" class="headerlink" title="压缩/解压缩"></a>压缩/解压缩</h3><p>总结：tar -cvf tar -xvf（一对）（打包解压）</p>
<p>​            tar -zcvf tar-zxvf(一对) （压缩解压）</p>
<p>​            tar -zcvf 打包文件.tar.gz 被压缩文件/路径 #压缩</p>
<p>​            tar -zxvf 打包文件.tar.gz #压缩文件  </p>
<p>​            tar -zxvf 打包文件.tar.gz -C 目标路径 #解压到指定路径</p>
<p>gzip：压缩（和tar一起用：打包压缩）</p>
<p>Linux gzip命令用于压缩文件。</p>
<p>gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best&#x2F;fast][文件...] 或 gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best&#x2F;fast][目录]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-a或–ascii 　使用ASCII文字模式。</li>
<li>-c或–stdout或–to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。</li>
<li>-d或–decompress或—-uncompress 　解开压缩文件。</li>
<li>-f或–force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。</li>
<li>-h或–help 　在线帮助。</li>
<li>-l或–list 　列出压缩文件的相关信息。</li>
<li>-L或–license 　显示版本与版权信息。</li>
<li>-n或–no-name 　压缩文件时，不保存原来的文件名称及时间戳记。</li>
<li>-N或–name 　压缩文件时，保存原来的文件名称及时间戳记。</li>
<li>-q或–quiet 　不显示警告信息。</li>
<li>-r或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。</li>
<li>-S&lt;压缩字尾字符串&gt;或—-suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。</li>
<li>-t或–test 　测试压缩文件是否正确无误。</li>
<li>-v或–verbose 　显示指令执行过程。</li>
<li>-V或–version 　显示版本信息。</li>
<li>-&lt;压缩效率&gt; 　压缩效率是一个介于1－9的数值，预设值为”6”，指定愈大的数值，压缩效率就会愈高。</li>
<li>–best 　此参数的效果和指定”-9”参数相同。</li>
<li>–fast 　此参数的效果和指定”-1”参数相同。</li>
</ul>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>压缩文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@runoob.com a]# ls &#x2F;&#x2F;显示当前目录文件</span><br><span class="line">a.c b.h d.cpp</span><br><span class="line">[root@runoob.com a]# gzip * &#x2F;&#x2F;压缩目录下的所有文件</span><br><span class="line">[root@runoob.com a]# ls &#x2F;&#x2F;显示当前目录文件</span><br><span class="line">a.c.gz    b.h.gz    d.cpp.gz</span><br><span class="line">[root@runoob.com a]#</span><br></pre></td></tr></table></figure>

<p>接范例1， 列出详细的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@runoob.com a]# gzip -dv * &#x2F;&#x2F;解压文件，并列出详细信息</span><br><span class="line">a.c.gz:     0.0% -- replaced with a.c</span><br><span class="line">b.h.gz:     0.0% -- replaced with b.h</span><br><span class="line">d.cpp.gz:     0.0% -- replaced with d.cpp</span><br><span class="line">[root@runoob.com a]#</span><br></pre></td></tr></table></figure>

<p>接范例1，显示压缩文件的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@runoob.com a]# gzip -l *</span><br><span class="line">     compressed    uncompressed ratio uncompressed_name</span><br><span class="line">         24          0  0.0% a.c</span><br><span class="line">         24          0  0.0% b.h</span><br><span class="line">         26          0  0.0% d.cpp</span><br></pre></td></tr></table></figure>

<h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p>Linux bzip2命令是.bz2文件的压缩程序。</p>
<p>bzip2像gzip一样，tar打包，bzip2压缩tar后文件，扩展名 .tar.bz2</p>
<p>压缩文件 tar -jcvf 打包文件.tar.bz2 被压缩文件/路径</p>
<p>解压 tar -jxvf 打包文件.tar.bz2</p>
<p>-C 解压缩到指定目录，且目录必须存在</p>
<p>bzip2采用新的压缩演算法，压缩效果比传统的LZ77/LZ78压缩演算法来得好。若没有加上任何参数，bzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。</p>
<h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bzip2 [-cdfhkLstvVz][--repetitive-best][--repetitive-fast][- 压缩等级][要压缩的文件]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-c或–stdout 　将压缩与解压缩的结果送到标准输出。</li>
<li>-d或–decompress 　执行解压缩。</li>
<li>-f或–force 　bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖，请使用此参数。</li>
<li>-h或–help 　显示帮助。</li>
<li>-k或–keep 　bzip2在压缩或解压缩后，会删除原始的文件。若要保留原始文件，请使用此参数。</li>
<li>-s或–small 　降低程序执行时内存的使用量。</li>
<li>-t或–test 　测试.bz2压缩文件的完整性。</li>
<li>-v或–verbose 　压缩或解压缩文件时，显示详细的信息。</li>
<li>-z或–compress 　强制执行压缩。</li>
<li>-L,–license,</li>
<li>-V或–version 　显示版本信息。</li>
<li>–repetitive-best 　若文件中有重复出现的资料时，可利用此参数提高压缩效果。</li>
<li>–repetitive-fast 　若文件中有重复出现的资料时，可利用此参数加快执行速度。</li>
<li>-压缩等级 　压缩时的区块大小。</li>
</ul>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>解压.bz2文件 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@w3cschool.cc ~]# bzip2 -v temp.bz2 &#x2F;&#x2F;解压文件显示详细处理信息</span><br></pre></td></tr></table></figure>

<p>压缩文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@w3cschool.cc ~]# bzip2 -c a.c b.c c.c</span><br></pre></td></tr></table></figure>

<p>检查文件完整性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@w3cschool.cc ~]# bzip2 -t temp.bz2</span><br></pre></td></tr></table></figure>

<h2 id="P98-100软件安装"><a href="#P98-100软件安装" class="headerlink" title="P98-100软件安装"></a>P98-100软件安装</h2><p>apt是advanced packaging tool，linux下安装管理工具</p>
<p>sudo apt install 软件包#安装</p>
<p>sudo apt remove 软件包名#卸载</p>
<p>sudo apt upgrade#更新</p>
<p>sudo apt install htop#查看当前进程，输入htop即可</p>
]]></content>
  </entry>
  <entry>
    <title>TCP/IP的十大密码</title>
    <url>/2020/05/10/network1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>复制自：<a href="https://www.cnblogs.com/zhangyinhua/" target="_blank" rel="noopener">https://www.cnblogs.com/zhangyinhua/</a></p>
<p><strong>阅读目录(Content)</strong></p>
<ul>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_label0" target="_blank" rel="noopener">一、TCP/IP模型</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_label1" target="_blank" rel="noopener">二、数据链路层</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_label2" target="_blank" rel="noopener">三、网络层</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_lab2_2_0" target="_blank" rel="noopener">3.1、IP协议</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_lab2_2_1" target="_blank" rel="noopener">3.2.ARP及RARP协议</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_lab2_2_2" target="_blank" rel="noopener">3.3、 ICMP协议</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_label3" target="_blank" rel="noopener">四、ping</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_label4" target="_blank" rel="noopener">五、Traceroute</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_label5" target="_blank" rel="noopener">六、TCP/UDP</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_label6" target="_blank" rel="noopener">七、DNS</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_label7" target="_blank" rel="noopener">八、TCP连接的建立与终止</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_label8" target="_blank" rel="noopener">九、TCP流量控制</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_label9" target="_blank" rel="noopener">十、TCP拥塞控制</a></p>
</li>
</ul>
<p>这段时间 有一点心很浮躁，不过希望自己马上要矫正过来。好好学习编程！这段时间我想好好地研究一下TCP/IP协议和网络传输这块！加油</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="一、TCP-IP模型"><a href="#一、TCP-IP模型" class="headerlink" title="一、TCP/IP模型"></a>一、TCP/IP模型</h1><p>TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。</p>
<p>基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/10/0b66939f772a466814a408df10587d52?imageView2/0/w/1280/h/960" alt="img"><br>TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。</p>
<p>第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。<br><img src="https://user-gold-cdn.xitu.io/2017/8/10/32269df6363944b0df8fe99204e92c91?imageView2/0/w/1280/h/960" alt="img"><br>上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。</p>
<p>出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。<br><img src="https://user-gold-cdn.xitu.io/2017/8/10/7f693d4add34644a6268e0e11bec2cb7?imageView2/0/w/1280/h/960" alt="img"><br>上图以HTTP协议为例，具体说明。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="二、数据链路层"><a href="#二、数据链路层" class="headerlink" title="二、数据链路层"></a>二、数据链路层</h1><p>物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。 数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址，一个主机会有一个MAC地址)。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/10/65691336b87c5ed17079deb7618ca6a8?imageView2/0/w/1280/h/960" alt="img"></p>
<ul>
<li>封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源MAC地址和目的MAC地址。</li>
<li>透明传输:零比特填充、转义字符。</li>
<li>可靠传输: 在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。</li>
<li>差错检测(CRC):接收者检测错误,如果发现差错，丢弃该帧。</li>
</ul>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="三、网络层"><a href="#三、网络层" class="headerlink" title="三、网络层"></a>三、网络层</h1><h2 id="3-1、IP协议"><a href="#3-1、IP协议" class="headerlink" title="3.1、IP协议"></a>3.1、IP协议</h2><p>IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。</p>
<h5 id="1）IP地址"><a href="#1）IP地址" class="headerlink" title="1）IP地址"></a>1）IP地址</h5><p>在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。</p>
<p>32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。</p>
<p>A类IP地址: 0.0.0.0<del>127.0.0.0<br>B类IP地址:128.0.0.1</del>191.255.0.0<br>C类IP地址:192.168.0.0~239.255.255.0</p>
<h5 id="2）-IP协议头"><a href="#2）-IP协议头" class="headerlink" title="2） IP协议头"></a>2） IP协议头</h5><p><img src="https://user-gold-cdn.xitu.io/2017/8/10/dbb082d9806de01f5653423917a1f71b?imageView2/0/w/1280/h/960" alt="img"><br>这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。<br>这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。</p>
<h2 id="3-2-ARP及RARP协议"><a href="#3-2-ARP及RARP协议" class="headerlink" title="3.2.ARP及RARP协议"></a>3.2.ARP及RARP协议</h2><p>ARP 是根据IP地址获取MAC地址的一种协议。</p>
<p>ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。</p>
<p>如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，</p>
<p>如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。</p>
<p>而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。</p>
<p>RARP协议的工作与此相反，不做赘述。</p>
<h2 id="3-3、-ICMP协议"><a href="#3-3、-ICMP协议" class="headerlink" title="3.3、 ICMP协议"></a>3.3、 ICMP协议</h2><p>IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。</p>
<p>当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="四、ping"><a href="#四、ping" class="headerlink" title="四、ping"></a>四、ping</h1><p>ping可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。</p>
<p>例如：当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下:</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/10/7491c4c023725cf51a3992ad52dabed2?imageView2/0/w/1280/h/960" alt="img"><br>ping这个单词源自声纳定位，而这个程序的作用也确实如此，它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。</p>
<p>ping程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping给出来了传送的时间和TTL的数据。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="五、Traceroute"><a href="#五、Traceroute" class="headerlink" title="五、Traceroute"></a>五、Traceroute</h1><p>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。</p>
<p>Traceroute的原理是非常非常的有意思，它收到到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器IP。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/10/7c83af15e316ea6a54c255c01bbabcd6?imageView2/0/w/1280/h/960" alt="img"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="六、TCP-UDP"><a href="#六、TCP-UDP" class="headerlink" title="六、TCP/UDP"></a>六、TCP/UDP</h1><p>TCP/UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/10/ec2e805a6ad5eedb10ad44d1f50a85d5?imageView2/0/w/1280/h/960" alt="img"></p>
<h5 id="面向报文"><a href="#面向报文" class="headerlink" title="面向报文"></a>面向报文</h5><p>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。</p>
<h5 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h5><p>面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。</p>
<p>关于拥塞控制，流量控制，是TCP的重点，后面讲解。</p>
<p>TCP和UDP协议的一些应用</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/10/c857965c70a17d8d0cd8819b59e989c9?imageView2/0/w/1280/h/960" alt="img"></p>
<h4 id="什么时候应该使用TCP？"><a href="#什么时候应该使用TCP？" class="headerlink" title="什么时候应该使用TCP？"></a>什么时候应该使用TCP？</h4><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p>
<h4 id="什么时候应该使用UDP？"><a href="#什么时候应该使用UDP？" class="headerlink" title="什么时候应该使用UDP？"></a>什么时候应该使用UDP？</h4><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="七、DNS"><a href="#七、DNS" class="headerlink" title="七、DNS"></a>七、DNS</h1><p>DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="八、TCP连接的建立与终止"><a href="#八、TCP连接的建立与终止" class="headerlink" title="八、TCP连接的建立与终止"></a>八、TCP连接的建立与终止</h1><h4 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1.三次握手"></a>1.三次握手</h4><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/10/6023cb46caf6ef8cdcc253cc9c827e40?imageView2/0/w/1280/h/960" alt="img"></p>
<p>第一次握手： 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p>
<p>第二次握手： 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手： 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p>
<h5 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h5><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
<p>具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
<h4 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2.四次挥手"></a>2.四次挥手</h4><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/10/1fd63f511dd955e462bcdd3946e880bf?imageView2/0/w/1280/h/960" alt="img"><br>第一次分手： 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p>
<p>第二次分手： 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p>
<p>第三次分手： 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p>
<p>第四次分手： 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p>
<h5 id="为什么要四次分手？"><a href="#为什么要四次分手？" class="headerlink" title="为什么要四次分手？"></a>为什么要四次分手？</h5><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p>
<h5 id="为什么要等待2MSL？"><a href="#为什么要等待2MSL？" class="headerlink" title="为什么要等待2MSL？"></a>为什么要等待2MSL？</h5><p>MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。<br>原因有二：</p>
<ul>
<li>保证TCP协议的全双工连接能够可靠关闭</li>
<li>保证这次连接的重复数据段从网络中消失</li>
</ul>
<p>第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p>
<p>第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="九、TCP流量控制"><a href="#九、TCP流量控制" class="headerlink" title="九、TCP流量控制"></a>九、TCP流量控制</h1><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p>
<p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/10/550bceefdb7fdae79e66be6344823aed?imageView2/0/w/1280/h/960" alt="img"><br>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。</p>
<p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7594365.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="十、TCP拥塞控制"><a href="#十、TCP拥塞控制" class="headerlink" title="十、TCP拥塞控制"></a>十、TCP拥塞控制</h1><h4 id="1-慢开始和拥塞避免"><a href="#1-慢开始和拥塞避免" class="headerlink" title="1.慢开始和拥塞避免"></a>1.慢开始和拥塞避免</h4><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。</p>
<p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
<h5 id="慢开始算法："><a href="#慢开始算法：" class="headerlink" title="慢开始算法："></a>慢开始算法：</h5><p>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。<br>因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。</p>
<p>通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/10/36b302f09a560f622a3309dce5b7fd06?imageView2/0/w/1280/h/960" alt="img"><br>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p>
<p>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p>
<p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下：</p>
<ul>
<li><p>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</p>
</li>
<li><p>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p>
</li>
<li><p>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p>
<h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
</li>
</ul>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。</p>
<p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/10/2c82284519ea113f72892100ce419ec4?imageView2/0/w/1280/h/960" alt="img"></p>
<h4 id="2-快重传和快恢复"><a href="#2-快重传和快恢复" class="headerlink" title="2.快重传和快恢复"></a>2.快重传和快恢复</h4><h5 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h5><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/10/d425c45f8fa29c2512b598d80532495c?imageView2/0/w/1280/h/960" alt="img"><br>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。</p>
<p>显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。</p>
<p>但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。</p>
<p>快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。</p>
<p>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p>
<h5 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h5><p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p>
<ul>
<li><ul>
<li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。</li>
<li>与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。<br><img src="https://user-gold-cdn.xitu.io/2017/8/10/3433ebaf7ed0550bf33cb9a10b34e2f7?imageView2/0/w/1280/h/960" alt="img"></li>
</ul>
</li>
</ul>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>linux基础（1-18集）</title>
    <url>/2020/04/25/linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="linux-100集"><a href="#linux-100集" class="headerlink" title="linux 100集"></a>linux 100集</h1><h2 id="P3：操作系统作用"><a href="#P3：操作系统作用" class="headerlink" title="P3：操作系统作用"></a>P3：操作系统作用</h2><p>操作系统作用：1. 直接操作硬件 2把操作硬件的代码封装成一个个系统调用，供其他使用。</p>
<p>操作系统，与硬件交互。操作系统作用：操作系统位于底层硬件与用户之间，是两者沟通的桥梁。用户可以通过操作系统的用户界面，输入命令。操作系统则对命令进行解释，驱动硬件设备，实现用户要求。以现代标准而言，一个标准PC的操作系统应该提供以下的功能：</p>
<p>1、进程管理。又称处理器管理，其主要任务是对处理器的时间进行合理分配、对处理器的运行实施有效的管理。</p>
<p>2、存储器管理。由于多道程序共享内存资源，所以存储器管理的主要任务是对存储器进行分配、保护和扩充。</p>
<p>3、设备管理。根据确定的设备分配原则对设备进行分配，使设备与主机能够并行工作，为用户提供良好的设备使用界面。</p>
<p>4、文件管理。有效地管理文件的存储空间，合理地组织和管理文件系统，为文件访问和文件保护提供更有效的方法及手段。</p>
<p>5、用户接口。用户操作计算机的界面称为用户接口（或用户界面），通过用户接口，用户只需进行简单操作，就能实现复杂的应用处理。</p>
<p>例：听音乐，把硬盘中文件加载内存，然后声卡对音频数据解码，然后解码后数据给音响。这些都是操作系统做的。</p>
<h2 id="P4-10：历史简介"><a href="#P4-10：历史简介" class="headerlink" title="P4-10：历史简介"></a>P4-10：历史简介</h2><p>桌面操作系统：Windows（用户多，安全性较差，稳定性较差），Linux（应用软件少）， macOS（开发人员用）</p>
<p>服务器操作系统：Linux（安全，稳定，免费，占有率高，一般公司服务器都是Linux）（维护机房计算机，在远程维护），Windows Server（微软付费的，占有率低）</p>
<p>嵌入式操作系统：Linux（）</p>
<p>系统设备操作系统：iOS，Android</p>
<p>虚拟机：通过软件模拟具有完整硬件系统功能的，运行在一个完全隔离环境中的完整计算机系统。</p>
<p>Ken Thompson, 1969运行space travel，用汇编写了Unix原型，老爷子后来用B语言写了Unix</p>
<p>Dennis M.Ritchie发明了c语言，然后两个人一起重写了Unix。</p>
<p>unix version7 后unix不在开源源代码，因为ken老爷子喜欢走后门，让贝尔实验室很不爽。</p>
<p>Linux出现了，Linus老爷子来了，用GNU的bash当开发环境，gcc做compiler，编写了linux内核。</p>
<p>Linux两个版本：内核版本和发行版本。</p>
<p><u>终端命令</u>调系统调用，<u>系统调用</u>与硬件交互。</p>
<p>内核版本：kernel，Linux内核：内核只有一个<br>        linux内核是一种开放源码的操作系统，由Linux Torvalds负责维护，提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。</p>
<p>Linux发行版：<br>        linux发行版基于linux内核源码，将Linux系统的内核与外围实用程序(Utilities)软件和文档包装起来，并提供一些系统安装界面和系统配置、设定与管理工具，就构成了一种发行版本(distribution)，Linux的发行版本其实就是Linux核心再加上外围的实用程序组成的一个大软件包。</p>
<p>linux主要发行版：</p>
<p>Fedora Core、Debian、Mandrake、Ubuntu、Red Hat Linux、SuSE、Linux Mint、Gentoo、CentOS、</p>
<h2 id="P11：Linux文件目录"><a href="#P11：Linux文件目录" class="headerlink" title="P11：Linux文件目录"></a>P11：Linux文件目录</h2><p>windows每个驱动器都有根目录，前身是单用户操作系统</p>
<p>unix/linux是多用户操作系统，ubuntu目录：</p>
<p>/是根目录：/bin, /etc, /home, /lib, /usr</p>
<p>在/home中有/python, /laowang, 在这两个用户中都有/Desktop, /Documents, /Downloads, 各人各家，不会干扰别人。linux没有盘符概念</p>
<p>/bin: /usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。</p>
<p>/boot：放置linux系统启动时用到的一些文件。/boot/vmlinuz 为 linux 的内核文件，以及 /boot/gurb。建议单独分区，分区大小100M即可</p>
<p>/dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。</p>
<p>/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d修改配置文件之前记得备份。</p>
<p>注：/etc/X11 存放与 x windows 有关的设置。</p>
<p>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，<del>表示当前用户的家目录，</del>edu 表示用户 edu 的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据</p>
<p>/lib: /usr/lib: /usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为 /lib/modules。</p>
<p>/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。如加载硬盘于 /disk 中，此目录下就会自动产生目录 /disk/lost+found</p>
<p>/mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。</p>
<p>/opt：给主机额外安装软件所摆放的目录。如：FC4使用的Fedora 社群开发软件，如果想要自行安装新的 KDE 桌面软件，可以将该软件安装在该目录下。以前的 Linux 系统中，习惯放置在 /usr/local 目录下</p>
<p>/proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。</p>
<p>/root：系统管理员root的家目录，系统第一个启动的分区为 /，所以最好将 /root和 /放置在一个分区下。</p>
<p>/sbin: /usr/sbin: /usr/local/sbin：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能”查看”而不能设置和使用。</p>
<p>/tmp：一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下</p>
<p>/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。</p>
<p>/usr：应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录，使用 man ls 时会查询 /usr/share/man/man1/ls.1.gz 的内容建议单独分区，设置较大的磁盘空间</p>
<p>/var：放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。建议单独分区，设置较大的磁盘空间</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h3><p>Linux 对数据文件(<em>.mp3、</em>.bmp)，程序文件(<em>.c、</em>.h、*.o)，设备文件（LCD、触摸屏、鼠标），网络文件( socket ) 等的管理都抽象为文件，使用统一的方式方法管理。</p>
<p>文件分类：</p>
<p>1）普通文件( 数据文件 )</p>
<p>普通文件是用于存放数据、程序等信息的文件，一般都长期地存放在外存储器（磁盘）中。普通文件又分为文本文件和二进制文件。</p>
<p>2）目录文件</p>
<p>目录文件是文件系统中一个目录所包含的目录项所组成的文件。</p>
<p>3）设备文件</p>
<p>设备文件是用于为操作系统与设备提供连接的一种文件。在Linux系统中将设备作为文件来处理，操作设备就像是操作普通文件一样。每一个设备对应一个设备文件，存放在 /dev 目录中。</p>
<p>5）链接文件</p>
<p>似于 windows 下的快捷方式，链接又可以分为软链接（符号链接）和硬链接。</p>
<p>6）管道文件</p>
<p>管道文件主要用于在进程间传递数据的一种特殊文件。</p>
<p>7）套接口文件</p>
<p>主要用于不同计算机间网络通信的一种特殊文件。</p>
<p><strong>【常见目录说明】</strong></p>
<table>
<thead>
<tr>
<th>目录</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>/bin</td>
<td>存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里。</td>
</tr>
<tr>
<td>/etc</td>
<td>存放系统管理和配置文件</td>
</tr>
<tr>
<td>/home</td>
<td>存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示</td>
</tr>
<tr>
<td>/usr</td>
<td>用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。/usr/x11r6 存放x window的目录/usr/bin 众多的应用程序  /usr/sbin 超级用户的一些管理程序  /usr/doc linux文档  /usr/include linux下开发和编译应用程序所需要的头文件  /usr/lib 常用的动态链接库和软件包的配置文件  /usr/man 帮助文档  /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里  /usr/local/bin 本地增加的命令  /usr/local/lib 本地增加的库</td>
</tr>
<tr>
<td>/opt</td>
<td>额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。</td>
</tr>
<tr>
<td>/proc</td>
<td>虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。</td>
</tr>
<tr>
<td>/root</td>
<td>超级用户（系统管理员）的主目录（特权阶级^o^）</td>
</tr>
<tr>
<td>/sbin</td>
<td>存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。</td>
</tr>
<tr>
<td>/dev</td>
<td>用于存放设备文件。</td>
</tr>
<tr>
<td>/mnt</td>
<td>系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。</td>
</tr>
<tr>
<td>/boot</td>
<td>存放用于系统引导时使用的各种文件</td>
</tr>
<tr>
<td>/lib</td>
<td>存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。</td>
</tr>
<tr>
<td>/tmp</td>
<td>用于存放各种临时文件，是公用的临时文件存储点。</td>
</tr>
<tr>
<td>/var</td>
<td>用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。</td>
</tr>
<tr>
<td>/lost+found</td>
<td>这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里</td>
</tr>
</tbody></table>
<h2 id="P13-17-LInux终端命令"><a href="#P13-17-LInux终端命令" class="headerlink" title="P13-17.LInux终端命令"></a>P13-17.LInux终端命令</h2><p>terminal放大字体：ctrl + shift + =；缩小字体： ctrl + -</p>
<p>linux常用命令：ls, pwd, cd, touch, mkdir, rm, clear.</p>
<p>对应：list, print work directory, change directory, touch(创建文件，例如java，txt文件), mkdir(创建目录)马克directory，clear（清屏), rmdir(删除目录)</p>
<p>终端命令格式：command [options] [parameter]</p>
<p>Linux中的rm －r 和rm －R区别为：用途不同道、范围不同、数量不同。</p>
<p>一、用途不同</p>
<p>1、rm －r ：rm －r 只能用于删除文件，不能用于删除文件夹。</p>
<p>2、rm －R：rm －R既能用于删除文件，也能用于删除文件夹。</p>
<p>二、范围不同内</p>
<p>1、rm －容r ：rm －r的删除范围是删除当前输入位置的文件。</p>
<p>2、rm －R：rm －R的删除范围是删除当前输入的目录文件夹里文件及其子目录里的文件。</p>
<p><strong>系统信息</strong><br>arch 显示机器的处理器架构<br>uname -m 显示机器的处理器架构<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS </p>
<p><strong>关机 (系统的关机、重启以及登出 )</strong><br>shutdown -h now 关闭系统<br>init 0 关闭系统<br>telinit 0 关闭系统<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启<br>reboot 重启<br>logout 注销 </p>
<p><strong>文件和目录</strong><br>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构<br>lstree 显示文件和目录由根目录开始的树形结构<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录 </p>
<p>cp -r dir1 dir2 复制一个目录及子目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) </p>
<p><strong>文件搜索</strong><br>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径 </p>
<p><strong>挂载一个文件系统</strong><br>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 </p>
<p><strong>磁盘空间</strong><br>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </p>
<p><strong>用户和群组</strong><br>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 </p>
<p><strong>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong><br>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位 </p>
<p><strong>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong><br>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性 </p>
<p><strong>打包和压缩文件</strong><br>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包 </p>
<p><strong>RPM 包 - （Fedora, Redhat及类似系统）</strong><br>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 </p>
<p><strong>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</strong><br>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件 </p>
<p><strong>DEB 包 (Debian, Ubuntu 以及类似系统)</strong><br>dpkg -i package.deb 安装/更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 </p>
<p><strong>APT 软件工具 (Debian, Ubuntu 以及类似系统)</strong><br>apt-get install package_name 安装/更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 </p>
<p><strong>查看文件内容</strong><br>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容 </p>
<p><strong>文本处理</strong><br>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行<br>sed ‘/ <em>#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ *$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 </p>
<p><strong>字符设置和文件格式转换</strong><br>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>recode -l | more 显示所有允许的转换格式 </p>
<p><strong>文件系统分析</strong><br>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 </p>
<p><strong>初始化一个文件系统</strong><br>mkfs /dev/hda1 在hda1分区创建一个文件系统<br>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>fdformat -n /dev/fd0 格式化一个软盘<br>mkswap /dev/hda3 创建一个swap文件系统 </p>
<p><strong>SWAP文件系统</strong><br>mkswap /dev/hda3 创建一个swap文件系统<br>swapon /dev/hda3 启用一个新的swap文件系统<br>swapon /dev/hda2 /dev/hdb3 启用两个swap分区 </p>
<p><strong>备份</strong><br>dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份<br>dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份<br>restore -if /tmp/home0.bak 还原一个交互式备份<br>rsync -rogpav –delete /home /tmp 同步两边的目录<br>rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync<br>rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作<br>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>find /home/user1 -name ‘<em>.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>find /var/log -name ‘</em>.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 </p>
<p><strong>光盘</strong><br>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>cdrecord –scanbus 扫描总线以识别scsi通道<br>dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD </p>
<p><strong>网络 - （以太网和WIFI无线</strong>）<br>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>dhclient eth0 以dhcp模式启用 ‘eth0’<br>route -n show routing table<br>route add -net 0/0 gw IP_Gateway configura default gateway<br>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’<br>route del 0/0 gw IP_gateway remove static route<br>echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing<br>hostname show hostname of system<br>host <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>ip link show show link status of all interfaces<br>mii-tool eth0 show link status of ‘eth0’<br>ethtool eth0 show statistics of network card ‘eth0’<br>netstat -tup show all active network connections and their PID<br>netstat -tupl show all network services listening on the system and their PID<br>tcpdump tcp port 80 show all HTTP traffic<br>iwlist scan show wireless networks<br>iwconfig eth1 show configuration of a wireless network card<br>hostname show hostname<br>host <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>whois <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup on Whois database </p>
<p><strong>JPS工具</strong></p>
<p>jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。</p>
<p>  我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。</p>
<p>   <strong>使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。</strong></p>
<p><strong>jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path.</strong></p>
<p>$&gt; <strong>jps</strong><br>23991 Jps<br>23789 BossMain<br>23651 Resin</p>
<p>比较常用的参数：</p>
<p><strong>-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数</strong><br>$&gt; <strong>jps -q</strong><br>28680<br>23789<br>23651</p>
<p><strong>-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null</strong></p>
<p>$&gt; <strong>jps -m</strong><br>28715 Jps -m<br>23789 BossMain<br>23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log</p>
<p><strong>-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名</strong></p>
<p>$&gt; <strong>jps -l</strong><br>28729 sun.tools.jps.Jps<br>23789 com.asiainfo.aimc.bossbi.BossMain<br>23651 com.caucho.server.resin.Resin</p>
<p><strong>-v 输出传递给JVM的参数</strong></p>
<p>$&gt; <strong>jps -v</strong><br>23789 BossMain<br>28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd</p>
<p>k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m<br>23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -</p>
<p>Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl</p>
<p><strong>sudo jps看到的进程数量最全</strong></p>
<p><strong>jps 192.168.0.77</strong></p>
<p><strong>列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099</strong></p>
<p><strong>（前提是远程服务器提供jstatd服务）</strong></p>
<p><strong>注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。</strong></p>
<h2 id="P18"><a href="#P18" class="headerlink" title="P18"></a>P18</h2><p>查阅命令帮助信息，command –help, man command.</p>
<p>系统中会有单独的man文件，命令百<br>man term<br>等同于<br>less [manpath]/term.X[.gz] // X为1-8中的数，视term而定<br>就是说，如果系统没有安装对度应man文件，哪怕term命令完全正常，知man term都没结果（同样，只要安装了man文件，哪怕没term命令，也可以得到道一大堆东西）。内<br>而–help参数将会显示可执行程序自带的信息，这些信容息是嵌入到程序本身的（所以–help信息较简短）。man是在系统安装的时候安装了狠制多的文档，可以在系统的目录doc下找到，如果软件有配套的页面，就可以使用man来查找，<br>而 help是软件编写百人员在编写的时候提供了内置的查询参数，查询的参数在程序里度面。也就是说man查询的结果是在程序外面，而help 查询出来的内容在程序里面。</p>
<p>man是一个详细的介绍，help是一个命令选项的简单介绍</p>
<p>man的用法：man    -&gt;&gt;manual    ###man是手册缩写<br>man man            #####查看man命令的帮助<br>man passwd        ###查看passwd命令的帮助</p>
<p>man的级别<br>1    系统命令<br>2    系统接口<br>3    函数库<br>4    特殊文件，比如设备文件<br>5    文件<br>6    游戏<br>7    系统的软件包<br>8    系统管理命令<br>9    内核</p>
<p>man 5 passwd    ##查看/etc/passwd文件的帮助<br>man 1 passwd    ##查看passwd命令的帮助，1可以省略</p>
<p>man页面的快捷方式<br>上下键            ##向上或向下一行<br>pageup|pagedown        ##向下一个屏幕或者向上一个屏幕<br>d|u            ##向下或者向上半个屏幕<br>G|gg            ##跳转页面到man最下面或最上面<br>/关键字            ##搜索关键字，关键字会高亮显示，n向下匹配，N向上<br>q            ##退出帮助页面</p>
]]></content>
  </entry>
  <entry>
    <title>TCP/IP四层</title>
    <url>/2020/05/10/network10/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>复制自：<a href="https://www.cnblogs.com/zhangyinhua" target="_blank" rel="noopener">https://www.cnblogs.com/zhangyinhua</a></p>
<p><strong>阅读目录(Content)</strong></p>
<ul>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7617027.html#_label0" target="_blank" rel="noopener">一、TCP/IP参考模型概述</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7617027.html#_lab2_0_0" target="_blank" rel="noopener">1.1、TCP/IP参考模型的层次结构</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7617027.html#_label1" target="_blank" rel="noopener">二、TCP/IP四层功能概述 </a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7617027.html#_lab2_1_0" target="_blank" rel="noopener">2.1、主机到网络层　　</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7617027.html#_lab2_1_1" target="_blank" rel="noopener">2.2、网络互连层　　</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7617027.html#_lab2_1_2" target="_blank" rel="noopener">2.3、传输层　　</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7617027.html#_lab2_1_3" target="_blank" rel="noopener">2.3、应用层　</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7617027.html#_label2" target="_blank" rel="noopener">三、TCP/IP报文格式</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7617027.html#_lab2_2_0" target="_blank" rel="noopener">3.1、IP报文格式</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7617027.html#_lab2_2_1" target="_blank" rel="noopener">3.2、TCP数据段格式</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7617027.html#_lab2_2_2" target="_blank" rel="noopener">3.3、UDP数据段格式</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7617027.html#_lab2_2_3" target="_blank" rel="noopener">3.4、套接字</a></li>
</ul>
</li>
</ul>
<p>前言</p>
<p>　　在这里有一个问题，有的书上说TCP/IP是四层有的却说是五层。其实这个问题我也上网查了一下资料。</p>
<p>　　tcp/ip是事实标准，分4层。osi模型是国际标准，分7层。讲课的时候，一般把他们综合起来讲，就说是5层。他把网络接口层分开为数据链路层和物理层了。</p>
<p>　　我们探讨一下为什么ISO七层模型不适用而大部分都是使用的是TCP/IP四层模型呀？</p>
<p>　　OSI的七层协议体系结构的概念清楚，理论也比较完整，但它既复杂又不实用，TCP/IP体系结构则不同，它现在已经得到了非常广泛的应用，TCP/IP是一个四层的体系结构，</p>
<p>　　它包含应用层、运输层、网际层和网络接口层（用网际层这个名字是强调这一层是为了解决不同网络的互连问题 ），不过从实质来讲，TCP/IP只有最上面的三层，因为最下面的网络接口层基本上和一般的通信链路的功能上没有多大差别，</p>
<p>　　对于计算机网络来说，这一层并没有什么特别新的具体的内容，因此在学习计算机网络原理是往往采用折中的办法，即综合OSI和TCP/IP的优点，采用一种只有五层协议的体系结构</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201710/999804-20171001114604465-1898375290.png" alt="img"> </p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7617027.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="一、TCP-IP参考模型概述"><a href="#一、TCP-IP参考模型概述" class="headerlink" title="一、TCP/IP参考模型概述"></a>一、TCP/IP参考模型概述</h1><p>ISO制定的OSI参考模型的过于庞大、复杂招致了许多批评。与此对照，由技术人员自己开发的TCP/IP协议栈获得了更为广泛的应用。如下图，是TCP/IP参考模型和OSI参考模型的对比示意图。</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201710/999804-20171001114823903-1286665985.png" alt="img"></p>
<h2 id="1-1、TCP-IP参考模型的层次结构"><a href="#1-1、TCP-IP参考模型的层次结构" class="headerlink" title="1.1、TCP/IP参考模型的层次结构"></a>1.1、TCP/IP参考模型的层次结构</h2><p>　　TCP/IP协议栈是美国国防部高级研究计划局计算机网（Advanced Research Projects Agency Network，ARPANET）和其后继因特网使用的参考模型。ARPANET是由美国国防部（U.S．Department of Defense，DoD）赞助的研究网络。</p>
<p>　　最初，它只连接了美国境内的四所大学。随后的几年中，它通过租用的电话线连接了数百所大学和政府部门。最终ARPANET发展成为全球规模最大的互连网络-因特网。最初的ARPANET于1990年永久性地关闭。　　<br>　　TCP/IP参考模型分为四个层次：应用层、传输层、网络互连层和主机到网络层。如下图所示。</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201710/999804-20171001115004262-305600873.png" alt="img"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7617027.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="二、TCP-IP四层功能概述"><a href="#二、TCP-IP四层功能概述" class="headerlink" title="二、TCP/IP四层功能概述"></a>二、TCP/IP四层功能概述</h1><p>　　在TCP/IP参考模型中，去掉了OSI参考模型中的会话层和表示层（这两层的功能被合并到应用层实现）。同时将OSI参考模型中的数据链路层和物理层合并为主机到网络层。下面，分别介绍各层的主要功能。</p>
<h2 id="2-1、主机到网络层"><a href="#2-1、主机到网络层" class="headerlink" title="2.1、主机到网络层　　"></a>2.1、主机到网络层　　</h2><p>　　网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，</p>
<p>　　然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。<br>　　实际上TCP/IP参考模型没有真正描述这一层的实现，只是要求能够提供给其上层-网络互连层一个访问接口，以便在其上传递IP分组。由于这一层次未被定义，所以其具体的实现方法将随着网络类型的不同而不同。　</p>
<h2 id="2-2、网络互连层"><a href="#2-2、网络互连层" class="headerlink" title="2.2、网络互连层　　"></a>2.2、网络互连层　　</h2><p>　　网络互连层是整个TCP/IP协议栈的核心。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。　　<br>　　网络互连层定义了分组格式和协议，即IP协议（Internet Protocol）。　　<br>　　网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。</p>
<h2 id="2-3、传输层"><a href="#2-3、传输层" class="headerlink" title="2.3、传输层　　"></a>2.3、传输层　　</h2><p>  在TCP/IP模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。即：传输控制协议TCP（transmission control protocol）和用户数据报协议UDP（user datagram protocol）。　　<br>　　TCP协议是一个面向连接的、可靠的协议。它将一台主机发出的字节流无差错地发往互联网上的其他主机。在发送端，它负责把上层传送下来的字节流分成报文段并传递给下层。</p>
<p>　　在接收端，它负责把收到的报文进行重组后递交给上层。TCP协议还要处理端到端的流量控制，以避免缓慢接收的接收方没有足够的缓冲区接收发送方发送的大量数据。　　<br>　　UDP协议是一个不可靠的、无连接协议，主要适用于不需要对报文进行排序和流量控制的场合。　　</p>
<h2 id="2-3、应用层"><a href="#2-3、应用层" class="headerlink" title="2.3、应用层　"></a>2.3、应用层　</h2><p>　　　TCP/IP模型将OSI参考模型中的会话层和表示层的功能合并到应用层实现。　　<br>　　应用层面向不同的网络应用引入了不同的应用层协议。其中，有基于TCP协议的，如文件传输协议（File Transfer Protocol，FTP）、虚拟终端协议（TELNET）、超文本链接协议（Hyper Text Transfer Protocol，HTTP），也有基于UDP协议的。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7617027.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="三、TCP-IP报文格式"><a href="#三、TCP-IP报文格式" class="headerlink" title="三、TCP/IP报文格式"></a>三、TCP/IP报文格式</h1><h2 id="3-1、IP报文格式"><a href="#3-1、IP报文格式" class="headerlink" title="3.1、IP报文格式"></a>3.1、IP报文格式</h2><p>　　IP协议是TCP/IP协议族中最为核心的协议。它提供不可靠、无连接的服务，也即依赖其他层的协议进行差错控制。</p>
<p>　　在局域网环境，IP协议往往被封装在以太网帧中传送。而所有的TCP、UDP、ICMP、IGMP数据都被封装在IP数据报中传送。如下图所示：<br>　　　　<img src="https://images.cnblogs.com/cnblogs_com/bluetzar/IPPackage.jpg" alt="img"><br>　　　　　　　　TCP/IP报文封装</p>
<p>　　　　<img src="https://images.cnblogs.com/cnblogs_com/bluetzar/IPPackageHead.jpg" alt="img"></p>
<p>　　　　　　　　　　IP头部（报头）格式：（RFC 791）</p>
<p>　　分析：　　　</p>
<p>　　　　1）版本（Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100。　　<br>　　　　2）报头长度（Internet Header Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节。　　　　　　　　</p>
<p>　　　　3）服务类型（Type of Service ，TOS）字段：占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。第4至第7比特分别代表延迟、吞吐量、可靠性和花费。<br>　　　　　　当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。<br>　　　　　　例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0）。<br>　　　　　　实际上，大部分主机会忽略这个字段，但一些动态路由协议如OSPF（Open Shortest Path First Protocol）、IS-IS（Intermediate System to Intermediate System Protocol）可以根据这些字段的值进行路由决策。</p>
<p>　　　　4）总长度字段：占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节。　　<br>　　　　5）标志字段：占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1。　　<br>　　　　6）标志位字段：占3比特。标志一份数据报是否要求分段。　　<br>　　　　7）段偏移字段：占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据报开始的位置。　　<br>　　　　8）生存期（TTL：Time to Live）字段：占8比特。用来设置数据报最多可以经过的路由器数。由发送数据的源主机设置，通常为32、64、128等。每经过一个路由器，其值减1，直到0时该数据报被丢弃。　　<br>　　　　9）协议字段：占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等。　　<br>　　　　10）头部校验和字段：占16比特。内容是根据IP头部计算得到的校验和码。计算方法是：对头部中每个16比特进行二进制反码求和。（和ICMP、IGMP、TCP、UDP不同，IP不对头部后的数据进行校验）。　　<br>　　　　11）源IP地址、目标IP地址字段：各占32比特。用来标明发送IP数据报文的源主机地址和接收IP报文的目标主机地址。　　<br>　　　　12）可选项字段：占32比特。用来定义一些任选项：如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。可选项字段的长度必须是32比特的整数倍，如果不足，必须填充0以达到此长度要求。</p>
<h2 id="3-2、TCP数据段格式"><a href="#3-2、TCP数据段格式" class="headerlink" title="3.2、TCP数据段格式"></a>3.2、TCP数据段格式</h2><p>　　TCP是一种可靠的、面向连接的字节流服务。源主机在传送数据前需要先和目标主机建立连接。然后，在此连接上，被编号的数据段按序收发。同时，要求对每个数据段进行确认，保证了可靠性。</p>
<p>　　如果在指定的时间内没有收到目标主机对所发数据段的确认，源主机将再次发送该数据段。　　<br>　　　　<img src="https://images.cnblogs.com/cnblogs_com/bluetzar/TCPPackageHead.jpg" alt="img"></p>
<p>　　　　　　　　　　　　TCP头部结构（RFC 793、1323）</p>
<p>　　分析：</p>
<p>　　　　1）源、目标端口号字段：占16比特。TCP协议通过使用”端口”来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，操作系统动态地为客户端的应用程序分配端口号。</p>
<p>　　　　　　在服务器端，每种服务在”众所周知的端口”（Well-Know Port）为用户提供服务。<br>　　　　2）顺序号字段：占32比特。用来标识从TCP源端向TCP目标端发送的数据字节流，它表示在这个报文段中的第一个数据字节。　　<br>　　　　3）确认号字段：占32比特。只有ACK标志为1时，确认号字段才有效。它包含目标端所期望收到源端的下一个数据字节。　　<br>　　　　4）头部长度字段：占4比特。给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。　　<br>　　　　5）标志位字段（U、A、P、R、S、F）：占6比特。各比特的含义如下：　　<br>　　　　　　URG：紧急指针（urgent pointer）有效。　　<br>　　　　　　ACK：确认序号有效。　　<br>　　　　　　PSH：接收方应该尽快将这个报文段交给应用层。　　<br>　　　　　　RST：重建连接。　　<br>　　　　　　SYN：发起一个连接。　　<br>　　　　　　FIN：释放一个连接。　　<br>　　　　6）窗口大小字段：占16比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。　　<br>　　　　7）TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。　　<br>　　　　8）紧急指针字段：占16比特。它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。　　<br>　　　　9）选项字段：占32比特。可能包括”窗口扩大因子”、”时间戳”等选项。</p>
<h2 id="3-3、UDP数据段格式"><a href="#3-3、UDP数据段格式" class="headerlink" title="3.3、UDP数据段格式"></a>3.3、UDP数据段格式</h2><p>　　UDP是一种不可靠的、无连接的数据报服务。源主机在传送数据前不需要和目标主机建立连接。数据被冠以源、目标端口号等UDP报头字段后直接发往目的主机。这时，每个数据段的可靠性依靠上层协议来保证。在传送数据较少、较小的情况下，UDP比TCP更加高效。　　<br>　　　　<img src="https://images.cnblogs.com/cnblogs_com/bluetzar/UDPPackageHead.jpg" alt="img"></p>
<p>　　　　　　　　UDP头部结构（RFC 793、1323）</p>
<p>　　分析：<br>　　　　1）源、目标端口号字段：占16比特。作用与TCP数据段中的端口号字段相同，用来标识源端和目标端的应用进程。　　<br>　　　　2）长度字段：占16比特。标明UDP头部和UDP数据的总长度字节。　　<br>　　　　3）校验和字段：占16比特。用来对UDP头部和UDP数据进行校验。和TCP不同的是，对UDP来说，此字段是可选项，而TCP数据段中的校验和字段是必须有的。</p>
<h2 id="3-4、套接字"><a href="#3-4、套接字" class="headerlink" title="3.4、套接字"></a>3.4、套接字</h2><p>　　在每个TCP、UDP数据段中都包含源端口和目标端口字段。有时，我们把一个IP地址和一个端口号合称为一个套接字（Socket），而一个套接字对（Socket pair）可以唯一地确定互连网络中每个TCP连接的双方（客户IP地址、客户端口号、服务器IP地址、服务器端口号）。<br>　　<br>　　　　<img src="https://images.cnblogs.com/cnblogs_com/bluetzar/Socket.jpg" alt="img"><br> 　　　　　　　　　常见协议和对应的服务端口号</p>
<p>　　注意：不同的应用层协议可能基于不同的传输层协议，如FTP、TELNET、SMTP协议基于可靠的TCP协议。TFTP、SNMP、RIP基于不可靠的UDP协议。　　<br>　　同时，有些应用层协议占用了两个不同的端口号，如FTP的20、21端口，SNMP的161、162端口。这些应用层协议在不同的端口提供不同的功能。如FTP的21端口用来侦听用户的连接请求，而20端口用来传送用户的文件数据。</p>
<p>　　再如，SNMP的161端口用于SNMP管理进程获取SNMP代理的数据，而162端口用于SNMP代理主动向SNMP管理进程发送数据。　　<br>　　还有一些协议使用了传输层的不同协议提供的服务。如DNS协议同时使用了TCP 53端口和UDP 53端口。DNS协议在UDP的53端口提供域名解析服务，在TCP的53端口提供DNS区域文件传输服务。</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>物理层详解</title>
    <url>/2020/05/10/network3/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>复制自：<a href="https://www.cnblogs.com/zhangyinhua" target="_blank" rel="noopener">https://www.cnblogs.com/zhangyinhua</a></p>
<p><strong>阅读目录(Content)</strong></p>
<ul>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_label0" target="_blank" rel="noopener">一、物理层概述</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_label1" target="_blank" rel="noopener">二、数据通信基础知识</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_1_0" target="_blank" rel="noopener">2.1、数据通信模型</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_1_1" target="_blank" rel="noopener">2.2、常用术语</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_1_2" target="_blank" rel="noopener">3.3、信道与传输方式</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_1_3" target="_blank" rel="noopener">3.4、基带信号与带通信号　</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_1_4" target="_blank" rel="noopener">3.5、编码与调制</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_label2" target="_blank" rel="noopener">四、物理层下的传输媒体</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_2_0" target="_blank" rel="noopener">4.1、导向传输媒体</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_2_1" target="_blank" rel="noopener">4.2、非导向传输媒体</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_label3" target="_blank" rel="noopener">五、信道复用技术</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_3_0" target="_blank" rel="noopener">5.1、频分复用　</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_3_1" target="_blank" rel="noopener">5.2、时分复用</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_3_2" target="_blank" rel="noopener">5.3、统计时分复用</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_3_3" target="_blank" rel="noopener">5.4、波分复用</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_label4" target="_blank" rel="noopener">六、数字传输系统</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_label5" target="_blank" rel="noopener">七、宽带接入技术</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_5_0" target="_blank" rel="noopener">7.1、电话网线拨号接入</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_5_1" target="_blank" rel="noopener">7.2、数字用户线接入</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_5_2" target="_blank" rel="noopener">7.3、光纤同轴混合网接入　　HFC</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_5_3" target="_blank" rel="noopener">7.4、光纤接入</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_5_4" target="_blank" rel="noopener">7.5、以太网接入</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_lab2_5_5" target="_blank" rel="noopener">7.6、无线网接入　</a></li>
</ul>
</li>
</ul>
<p><strong>前言</strong></p>
<p>　　在前面说了一下，计算机网络的大概内容，没有去深刻的去了解它，这篇文章给大家分享一下物理层！</p>
<p>　　我们知道ISO模型是七层，TCP/IP模型是五层，而tcp/ip协议只将七层概括为4层，我们将学习其中的5层， 应用层(包括表示层，会话层)、传输层、网络层、数据链路层、物理层。</p>
<p>　　　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928153021184-102798648.png" alt="img"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="一、物理层概述"><a href="#一、物理层概述" class="headerlink" title="一、物理层概述"></a>一、物理层概述</h1><p>　　解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体  （通俗的讲就是传输的数据是通过何种方式，以什么形态传输的，</p>
<p>　　　　类似于我们说话，别人是如何听到的，通过的就是声波，计算机传数据，又是怎么样吧数据带过去的呢，）</p>
<p>　　主要任务：确定与传输媒体的接口的一些特性，即 机械特性、电气特性、功能特性、过程特性　　　　</p>
<p>　　　　机械特性：接口形状、大小、引线数量等，通俗讲也就是网线的水晶头的设计等一些规定</p>
<p>　　　　电气特性：规定电压范围（-5V~+5V）等 在网线中传输时所用的电压范围</p>
<p>　　　　过程特性：也称规程特性 规定建立连接时各个相关部件的工作步骤</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="二、数据通信基础知识"><a href="#二、数据通信基础知识" class="headerlink" title="二、数据通信基础知识"></a>二、数据通信基础知识</h1><h2 id="2-1、数据通信模型"><a href="#2-1、数据通信模型" class="headerlink" title="2.1、数据通信模型"></a>2.1、数据通信模型</h2><p>　　源点、发送器、接受器、终点 和 源系统 – 传输系统 — 目的系统 的对应关系</p>
<p>　　PC机要发的数据会转换为010101，数字比特流就代表着010101传给调制解调器，调制解调器将数字比特流转换为模拟信号，通过公用电话网传到很远的目的地去。然后逆过来解析成原数据就行了</p>
<p>　　提到的数字比特流、模拟信号之后会讲解到，这样，我们就大概了解了数据通信的模型了，大概知道数据是转换成哪种形势传到目标中。</p>
<p>　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928153517544-1952982953.png" alt="img"></p>
<h2 id="2-2、常用术语"><a href="#2-2、常用术语" class="headerlink" title="2.2、常用术语"></a>2.2、常用术语</h2><p>　　1）通信的目的是传送信息</p>
<p>　　2）·数据：运送信息的实体</p>
<p>　　3）信号：数据的电气或电磁的表现 通俗讲就是通过电气或者电磁的一些表现形式来代表我们的数据，这就是我们说的信号，电气、电磁，比如一些电磁波等</p>
<p>　　　　数字信号：代表消息的参数的取值是离散的，下面就是数字信号，通过一高一低，不连续的波。</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928153847887-585324346.png" alt="img"></p>
<p>　　　　模拟信号：代表信息的参数的取值是连续的，下面就是模拟信号， 有高有低，但是是连续的波</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928153943262-1594686726.png" alt="img"></p>
<p>　　4）码元：在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元。 太理论的语言，看了跟没看一样，其实码元很简单，看下图，在数字信号中，带着0或者1的波形就是一个码元</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928154015731-1780488422.png" alt="img"></p>
<p>　　　　码元长度：每一个码元都是通过一段时间间隔来表示， 这个时间间隔就是码元长度</p>
<p>　　　　注意：1码元可以携带nbit的信息量，并不是1码元就只能代表1bit的信息量，可以是nbit，也就是说上面1码元就代表0或1这样1bit的信息量.</p>
<h2 id="3-3、信道与传输方式"><a href="#3-3、信道与传输方式" class="headerlink" title="3.3、信道与传输方式"></a>3.3、信道与传输方式</h2><p>　　信道一般表示向一个方向传送信息的媒体，所以平常说的通信线路往往包含一条发送信息的信道和一条接受信息的信道</p>
<p>　　1）单工通信：也就是单向通信，只能有一个方向的通信而没有反方向的交互</p>
<p>　　2）半双工通信：也就是能双向通信，但是不能同时通信，一方在发送数据，另一方必须接受数据，等待对方发完，然后自己才能发，例如，电视里面军方的对讲机，都是只有等待一方说完话，另外一方才能说话。</p>
<p>　　3）全双工通信：相对于半双工通信来讲，就是能同时通信且双向，例如，电话。</p>
<h2 id="3-4、基带信号与带通信号"><a href="#3-4、基带信号与带通信号" class="headerlink" title="3.4、基带信号与带通信号　"></a>3.4、基带信号与带通信号　</h2><p>　　1）基带信号：即基本频带信号，来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号，基带信号就是发出的直接表达了要传输的信息的信号，</p>
<p>　　　　例如：我们说话的声波就是基带信号</p>
<p>　　2）带通信号：把基带信号经过载波调制后，把信号的频率范围移到较高的频段以便在信道中传输</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928154648106-521641122.png" alt="img"></p>
<h2 id="3-5、编码与调制"><a href="#3-5、编码与调制" class="headerlink" title="3.5、编码与调制"></a>3.5、编码与调制</h2><p>　　1）编码：人们将数字数据转换为数字信号的过程称为编码</p>
<p>　　2）调制：将数字数据转换为模拟信号的过程称为调制</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="四、物理层下的传输媒体"><a href="#四、物理层下的传输媒体" class="headerlink" title="四、物理层下的传输媒体"></a>四、物理层下的传输媒体</h1><p>通俗的讲：前面我们知道了数据是以什么形态传输的，但是我们不知道该种形态就在什么上面传输呢？分两种：导向传输媒体 和 非导向传输媒体</p>
<h2 id="4-1、导向传输媒体"><a href="#4-1、导向传输媒体" class="headerlink" title="4.1、导向传输媒体"></a>4.1、导向传输媒体</h2><p>　　1）双绞线</p>
<p>　　　　屏蔽双绞线STP</p>
<p>　　　　无屏蔽双绞线UTP</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928155420465-1000958623.png" alt="img"></p>
<p>　　2）同轴电缆　　</p>
<p>　　　　50Ω同轴电缆，用于数字传输，由于多用于基带传输，也叫基带同轴电缆</p>
<p>　　　　75Ω同轴电缆，用于模拟传输，即宽带同轴电缆</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928155543497-1494848775.png" alt="img"></p>
<p>　　这两种普通的网线（直通线 和 交叉线）</p>
<p>　　直通线：具体的线序制作方法是：双绞线夹线顺序是两边一致，统一都是：1：白橙、2：橙、3：白绿、4：蓝、5：白蓝、6：绿、7：白棕、8：棕。</p>
<p>　　　　　　注意两端都是同样的线序且一一对应。这就是100M网线的做线标准，即568B标准，也就是我们平常所说的正线或标准线、直通线</p>
<p>　　　　　　直通线应用最广泛，这种类型的以太网电缆用来实现下列连接:</p>
<p>　　　　　　　　　　　　主机到交换机或集线器</p>
<p>　　　　　　　　　　　　路由器到交换机或集线器</p>
<p>　　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928160036403-1105963817.png" alt="img"></p>
<p>　　交叉线：就相当于直通线是一一对应，而交叉线就不一样，1对3 2对4 等</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928160444981-555480473.png" alt="img"></p>
<p>　　3）光缆</p>
<p>　　　　　　光纤长什么样子</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928164129762-976198451.png" alt="img"></p>
<p>　　　　工作原理：就是通过光的折射，在里面传播，直到光出来。</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928164244903-2082728975.png" alt="img"></p>
<p>　　　　具体光在其中是怎么传播的，看下图就知道了。</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928164436528-106149375.png" alt="img"></p>
<p>　　　　光纤分多模光纤和单模光纤</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928164544715-243944076.png" alt="img"></p>
<p>　　　　区别：单模光纤指只能传输一种电磁波模式，多模光纤只可以传输多个电磁波模式，实际上单模光纤和多模光纤之分，也就是纤芯的直径之分。单模光纤细，多模光纤粗。</p>
<p>　　　　　　　　在有线电视网络中使用的光纤全是单模光纤，其传播特性好，带宽可达10GHZ，可以在一根光纤中传输60套PAL—D电视节目</p>
<h2 id="4-2、非导向传输媒体"><a href="#4-2、非导向传输媒体" class="headerlink" title="4.2、非导向传输媒体"></a>4.2、非导向传输媒体</h2><p>　　非导向传输媒体就是指自由空间，其中的电磁波传输被称为无线传输。 通俗来讲，就是通过无线，不用那种固态的媒体，在空气中自由传播，在空气中传播的波很多，如何分别呢，就是通过每个波的频率不一样</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928164858403-296019497.png" alt="img"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="五、信道复用技术"><a href="#五、信道复用技术" class="headerlink" title="五、信道复用技术"></a>五、信道复用技术</h1><p>复用：通过下图，就可以很容易知道什么是复用，就是同时公用一条信道来进行传输信息。信道复用技术：频分复用、时分复用、统计时分复用、波分复用</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928165056325-582172267.png" alt="img"></p>
<h2 id="5-1、频分复用"><a href="#5-1、频分复用" class="headerlink" title="5.1、频分复用　"></a>5.1、频分复用　</h2><p>　　用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带(这个是一个范围，例如下图)</p>
<p>　　所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928165309731-1554676708.png" alt="img"></p>
<p>　　分析：</p>
<p>　　　　　发送数据：</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928165554965-2121202453.png" alt="img"></p>
<p>　　　　接受数据：</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928165651590-1775475222.png" alt="img"></p>
<h2 id="5-2、时分复用"><a href="#5-2、时分复用" class="headerlink" title="5.2、时分复用"></a>5.2、时分复用</h2><p>　　按时间轮流分配带宽资源给不同的用户，每个用户只在分配的时间里使用线路传输数据。</p>
<p>　　 通俗来讲：就是每个用户都有自己的时间段来传输数据，没到自己时间就需要等待，直到属于自己的传输时间段的到来，周期性的周转</p>
<p>　　特点：在信道中，每个资源都有先后顺序，并且不会乱，一直是按照一定的顺序传输数据。</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928165917106-1763923698.png" alt="img"></p>
<p>　　　　缺点：计算机数据的突发性质，用户对分配的子信道的利用率不高，因为不知道什么时候通道就会发送数据，可能别的通道都不发数据，就一个通道需要发送，但也还是要等待一定的时间，即使信道是空的。</p>
<h2 id="5-3、统计时分复用"><a href="#5-3、统计时分复用" class="headerlink" title="5.3、统计时分复用"></a>5.3、统计时分复用</h2><p>　　是对时分复用的一种改进，它能完善时分复用 对信道的利用率不高这个缺点，</p>
<p>　　原理：就是在每个要发送的数据上面做一个特殊的标记，而不是通过一个多路复用器，周期性的发送数据， 给每个要发送的数据</p>
<p>　　　　　　放入STDM帧中，让STDM帧带着数据发送过去，而接受的话，只需要分析STDM帧就行了。 </p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928170152044-1587738372.png" alt="img"></p>
<p>　　</p>
<p>　　注意：时分复用 又称同步时分复用，统计十分复用 称为 异布时分复用。 因为某一个用户所占用的时间间隙并不是周期性的出现。</p>
<h2 id="5-4、波分复用"><a href="#5-4、波分复用" class="headerlink" title="5.4、波分复用"></a>5.4、波分复用</h2><p>　　波分复用就是光的频分复用</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928170314012-1426093120.png" alt="img"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="六、数字传输系统"><a href="#六、数字传输系统" class="headerlink" title="六、数字传输系统"></a>六、数字传输系统</h1><p>PCM(脉冲编码调制)技术：将模拟电话信号转换为数字信号的一种技术。 </p>
<p>有两种PCM技术：北美的24路PCM(T1) 1.544M/s、 欧洲的30路PCM(E1) 我国采用的是E1 2.048M/S</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7607633.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="七、宽带接入技术"><a href="#七、宽带接入技术" class="headerlink" title="七、宽带接入技术"></a>七、宽带接入技术</h1><h2 id="7-1、电话网线拨号接入"><a href="#7-1、电话网线拨号接入" class="headerlink" title="7.1、电话网线拨号接入"></a>7.1、电话网线拨号接入</h2><p>　　老式的拨号联网方式，因为速度最高只能达到56kb/s</p>
<p>　　工作原理：通过将计算机发出的信号转换为音频信号，因为要通过电话网线来传播数据，所以这样转换来转换去，达到的上网速率太低，虽然方便，但实用性不强， 不能同时上网和打电话。</p>
<h2 id="7-2、数字用户线接入"><a href="#7-2、数字用户线接入" class="headerlink" title="7.2、数字用户线接入"></a>7.2、数字用户线接入</h2><p>　　DSL：数字用户线 　xDSL：用数字技术对现有的模拟电话用户线进行改造，在DSL上加了x 表示不同的数字用户线技术。</p>
<p>　　这个其实就是改善了电话网拨号接入的缺点，能同时上网和打电话，并且网速提高了很多，</p>
<p>　　工作原理：xDSL 技术就把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。这样一来，就互不干扰了。通过频率的高低来区分是电话还是网络数据。</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928170831919-1988875426.png" alt="img">)<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928170902294-304477157.png" alt="img"></p>
<p>　　举例：ADSL的接入网 </p>
<p>　　　　上行和下行带宽做成不对称的。指的是上行信道和下行信道，具体看DMT调制技术中的解释。　　　　　　　　　　　　　　　　　　　</p>
<p>　　　　ADSL 在用户线的两端各安装一个 ADSL 调制解调器。目的就是为了区分低频和高频</p>
<p>　　　　我国目前采用的方案是离散多音调 DMT (Discrete Multi-Tone)调制技术</p>
<p>　　　　　　DMT 调制技术采用频分复用的方法，把 40 kHz 以上一直到 1.1 MHz 的高端频谱划分为许多的子信道，其中 25 个子信道用于上行信道，而 249个子信道用于下行信道。</p>
<p>　　　　　　每个子信道占据 4 kHz 带宽,并使用不同的载波（即不同的音调）进行数字调制。这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据。</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928171121044-1619475971.png" alt="img"></p>
<p>　　　　　　接入网的工作原理图</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928171153575-1390296441.png" alt="img"></p>
<h2 id="7-3、光纤同轴混合网接入-HFC"><a href="#7-3、光纤同轴混合网接入-HFC" class="headerlink" title="7.3、光纤同轴混合网接入　　HFC"></a>7.3、光纤同轴混合网接入　　HFC</h2><p>　　CATV：树形拓扑结构的同轴电缆网络，采用模拟技术的频分复用对电视节目的单向传输，</p>
<p>　　HFC对CATV的基础上进行改造，从而开发出的一种居民宽带接入网。</p>
<p>　　特点：</p>
<p>　　　　HFC网的主干线路采用光纤，将原CATV网中的同轴电缆主干部分该换位光纤，并且使用的是模拟光纤技术，</p>
<p>　　　　每个家庭都要安装一个用户接口盒</p>
<p>　　　　 HFC 网具有比 CATV 网更宽的频谱，且具有双向传输功能</p>
<p>　　　　光纤结点(光分配结点)，同轴电缆分别是那些，看下图</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928171355934-927349929.png" alt="img"></p>
<h2 id="7-4、光纤接入"><a href="#7-4、光纤接入" class="headerlink" title="7.4、光纤接入"></a>7.4、光纤接入</h2><p>　　FTTx（光纤到…）：实现宽带居民接入网的方案，这里字母x可代表不同的意思</p>
<p>　　FTTH：光纤到家，光纤一直铺设到用户家庭可能是居民接入网最后的解决方法(155Mb/s)</p>
<p>　　FTTB：光纤到大楼，光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。</p>
<p>　　FTTC：从路边到各用户可使用星形结构双绞线作为传输媒体(155Mb/s)</p>
<h2 id="7-5、以太网接入"><a href="#7-5、以太网接入" class="headerlink" title="7.5、以太网接入"></a>7.5、以太网接入</h2><p>　　局域网，大学校园、大型企业、各种政府通过内部的局域网，然后再让局域网接入到因特网。</p>
<h2 id="7-6、无线网接入"><a href="#7-6、无线网接入" class="headerlink" title="7.6、无线网接入　"></a>7.6、无线网接入　</h2><p>　　前面都是有线接入，现在很多都使用无线联网，手机、笔记本等都用无线连，很方便</p>
<p>　　从1G 到 2G 到 3G 到现在的 4G时代，每一代的特点不一样，马上就要出5G了。</p>
<p>　　1G：蜂窝移动通信只能够模拟话音通信，跟那个电话网拨号接入类似，网速很慢很慢</p>
<p>　　2G：以数字话音通信为主，也能提供短信，收发邮件，浏览网页的数据通信功能</p>
<p>　　3G：3G时代，记得以前用的网页版QQ，就是要一直刷新也能接受信息，哈哈，</p>
<p>　　4G：网速很快，能达到1M~2M之间的速度。</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>TCP/IP总概述</title>
    <url>/2020/05/10/network2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>复制自：<a href="https://www.cnblogs.com/zhangyinhua/" target="_blank" rel="noopener">https://www.cnblogs.com/zhangyinhua/</a></p>
<p><strong>阅读目录(Content)</strong></p>
<ul>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_label0" target="_blank" rel="noopener">一、局域网、广域网和Internet</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_lab2_0_0" target="_blank" rel="noopener">1.1、局域网</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_lab2_0_1" target="_blank" rel="noopener">1.2、广域网</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_lab2_0_2" target="_blank" rel="noopener">1.3、Internet</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_label1" target="_blank" rel="noopener">二、计算机数据之间通信的过程</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_lab2_1_0" target="_blank" rel="noopener">2.1、路由器的功能（转发收到的分组）</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_label2" target="_blank" rel="noopener">三、OSI参考模型</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_lab2_2_0" target="_blank" rel="noopener">3.1、OSI参考模型概述</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_lab2_2_1" target="_blank" rel="noopener">3.2、各层功能概述</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_label3" target="_blank" rel="noopener">四、TCP/IP五层模型</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_label4" target="_blank" rel="noopener">五、OSI参考模型和TCP/IP协议</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_label5" target="_blank" rel="noopener">六、计算机上的各种性能指标解释</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_lab2_5_0" target="_blank" rel="noopener">6.1、速率</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_lab2_5_1" target="_blank" rel="noopener">6.2、带宽</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_lab2_5_2" target="_blank" rel="noopener">6.3、吞吐量</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_lab2_5_3" target="_blank" rel="noopener">6.4、时延</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_lab2_5_4" target="_blank" rel="noopener">6.5、时延带宽积</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_lab2_5_5" target="_blank" rel="noopener">6.6、往返时间</a></li>
</ul>
</li>
</ul>
<p><strong>前言</strong></p>
<p>　　在一段时间里，都很想知道一台电脑怎么跟另一台电脑通信的，我发送一个qq给女朋友，怎么准确的发送过去的，又是怎么接受消息的。</p>
<p>　　接下来一段时间给大家慢慢分享关于计算机网络的相关知识。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="一、局域网、广域网和Internet"><a href="#一、局域网、广域网和Internet" class="headerlink" title="一、局域网、广域网和Internet"></a>一、局域网、广域网和Internet</h1><h2 id="1-1、局域网"><a href="#1-1、局域网" class="headerlink" title="1.1、局域网"></a>1.1、局域网</h2><p>　　1）概述</p>
<p>　　局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现<br>　　　　文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。<br>　　局域网（Local Area Network，LAN）是在一个局部的地理范围内（如一个学校、工厂和机关内），一般是方圆几千米以内，将各种计算机，外部设备和数据库等互相联接起来组成的计算机通信网。<br>　　　　它可以通过数据通信网或专用数据电路，与远方的局域网、数据库或处理中心相连接，构成一个较大范围的信息处理系统。局域网可以实现文件管理、应用软件共享、打印机共享、<br>　　　　扫描仪共享、工作组内的日程安排、电子邮件和传真通信服务等功能。<br>　　　　局域网严格意义上是封闭型的。它可以由办公室内几台甚至上千上万台计算机组成。决定局域网的主要技术要素为：网络拓扑，传输介质与介质访问控制方法。</p>
<p>　　2）特点　</p>
<p>　　覆盖范围较小、自己花钱买设备来组件小型网络，宽带固定，自己维护 </p>
<p>　　覆盖范围小：相比于整个internet来讲，局域网肯定很小了，例如，校园网、企业网，覆盖范围也就那么一点</p>
<p>　　宽带固定：因为是局域网，范围小，网络部拥堵，几乎就是有多少带宽，趋于稳定</p>
<p>　　自己花钱买设备维护：比如以下的是校园网， 三个教室，每个教室都有电脑，每台电脑都连自己教室里的交换机，接入交换机又连到学校里一个更大的汇聚交换机，汇聚交换机连接外面的网络，</p>
<p>　　　　　　　　　　　　校园内每间教室或者每个用网的地方都是如此来上网的，这样学校自己花钱买的交换机， 自己来维护自己学校里面的网络。</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170926172231214-561393725.png" alt="img"></p>
<h2 id="1-2、广域网"><a href="#1-2、广域网" class="headerlink" title="1.2、广域网"></a>1.2、广域网</h2><p>　　1）概述</p>
<p>　　广域网（WAN，Wide Area Network）也称远程网（long haul network ）。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，<br>　　　　它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。<br>　　覆盖的范围比局域网（LAN）和城域网（MAN）都广。广域网的通信子网主要使用分组交换技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，<br>　　　　它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如因特网（Internet）是世界范围内最大的广域网。<br>　　广域网是由许多交换机组成的，交换机之间采用点到点线路连接，几乎所有的点到点通信方式都可以用来建立广域网，<br>　　　　包括租用线路、光纤、微波、卫星信道。而广域网交换机实际上就是一台计算机，有处理器和输入/输出设备进行数据包的收发处理。</p>
<p>　　2）举例生活：距离远 花钱租带宽　</p>
<p>　　看下图，我们不管哪个地方上网，都必须联网，上网能访问一些网站，跟别人聊天，为什么呢？<br>　　因为有一些ISP在帮我们做牵线工作。ISP(Internet Service Provider)因特网服务提供商，电信、联通、移动等，它们在各个地方埋网线，有自己的主机、 然后我们出钱连入他们的网络，<br>　　就能访问上网了。有一些网站站点放在电信机房中，我们电信网去访问，就会比较快，因为通往主机那边的地址的方式很多，如果电信网访问放在联通主机房中的网址，则相对会受到影响。</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170926173018557-1976643567.png" alt="img"></p>
<h2 id="1-3、Internet"><a href="#1-3、Internet" class="headerlink" title="1.3、Internet"></a>1.3、Internet</h2><p>　　Internet，中文正式译名为因特网，又叫做国际互联网。它是由那些使用公用语言互相通信的计算机连接而成的全球网络。一旦你连接到它的任何一个节点上，就意味着您的计算机已经连入Internet网上了。<br>　　Internet目前的用户已经遍及全球，有超过几亿人在使用Internet，并且它的用户数还在以等比级数上升。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="二、计算机数据之间通信的过程"><a href="#二、计算机数据之间通信的过程" class="headerlink" title="二、计算机数据之间通信的过程"></a>二、计算机数据之间通信的过程</h1><h2 id="2-1、路由器的功能（转发收到的分组）"><a href="#2-1、路由器的功能（转发收到的分组）" class="headerlink" title="2.1、路由器的功能（转发收到的分组）"></a>2.1、路由器的功能（转发收到的分组）</h2><p>　　1）什么是分组？ </p>
<p>　　发送一段数据，将该段数据进行分组发送，而不是一次性全发送完。</p>
<p>　　2）什么是分组交换？</p>
<p>　　　　在网路中，路由器跟路由器之间有一定的距离， 我们计算机要发送一段数据出去，首先将数据分成n个分组，在每个分组前特定的头部，就成了数据包。 </p>
<p>　　然后将数据包发送到路由器，通过路由器来接受这些数据包，然后一部分一部分的发送，接受，在发送其中一个数据包的过程中，占用了其中的道路，发送完这一个，</p>
<p>　　就释放，并不是一直占用该资源，直到传输结束，在其接受或发送数据时，也可以接受或发送别的数据，看先接受谁，就先发送谁，其实就是一个队列。</p>
<p>　　3）分组交换、电路交换、报文交换的区别？</p>
<p>　　电路交换：就是电话线， A打给B ，AB之间的电话线就接通了，那么不管他两说没说话，说多久，直到挂断之前，该线都是在占用之中。</p>
<p>　　报文交换：一次性发送完整的数据，那么该段路就被占用，传完就释放，然后接下一步的传送。直到到达目的地</p>
<p>　　分组交换：高效、灵活、迅速、可靠。</p>
<p>　　4）图解</p>
<p>　　　　情景： 1号计算机和2号计算机组成局域网， 主机1、主机2、主机3就相当于电信的主机，网页都存在在主机中</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170926190517153-604569624.png" alt="img"></p>
<p>　　　　4.1）ip地址跟MAC地址：　　　</p>
<p>　　　　　　每个计算机都有自己独特的ip地址，全球独一无二，跟电话一样，有些电话是 031-开头 有些地区是079开头， 这是分地区的，ip地址也是一样，</p>
<p>　　　　　　mac地址：每台计算机上都有一个物理地址，也是独有的。在网卡上面，路由器也有mac地址。</p>
<p>　　　　4.2）号计算机如何通过<a href="http://www.baidu.com来访问到百度的主页：">www.baidu.com来访问到百度的主页：</a></p>
<p>　　　　　　每台计算机上都有DNS解析器， 通过DNS将域名解析成对应地址，</p>
<p>　　　　　　路由器每次识别目标ip地址，以此来更改原mac地址和下一步目标的mac地址</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170926190845294-739300859.png" alt="img"></p>
<p>　　　　4.3）主机如何将网页数据发回请求的计算机：　　　</p>
<p>　　　　　　第一步：将要返回的数据分成N份<br>　　　　　　第二步：每次将发送几份到缓存中，缓存就相当于队列，先进先出，缓存中发一份发回请求的计算机<br>　　　　　　第三步：计算机接到第一份，返回一个数据，让主机发送下一份，然后将缓存中刚才发送的那一份删除<br>　　　　　　第四步；如果中途数据丢包，则从缓存中继续发送刚才不成功那一份，直到接收到请求的计算机发回的确认数据。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="三、OSI参考模型"><a href="#三、OSI参考模型" class="headerlink" title="三、OSI参考模型"></a>三、OSI参考模型</h1><h2 id="3-1、OSI参考模型概述"><a href="#3-1、OSI参考模型概述" class="headerlink" title="3.1、OSI参考模型概述"></a>3.1、OSI参考模型概述</h2><p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170926193646450-1006921087.png" alt="img"></p>
<p>　　OSI（Open Systems Interconnection Reference Model）OSI/RM  简称 OSI 开放系统互连参考模型，通俗的将就是我们说的7层协议的体系结构</p>
<p>　　OSI七层模型的划分：</p>
<p>　　OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互连系统参考模型。</p>
<p>　　每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170926191902762-385218165.png" alt="img"></p>
<h2 id="3-2、各层功能概述"><a href="#3-2、各层功能概述" class="headerlink" title="3.2、各层功能概述"></a>3.2、各层功能概述</h2><p>　　在这里我们简单描述一下各层的功能，不详细深究，因为每一层实际都是一个复杂的层。整个过程以公司A和公司B的一次商业报价单发送为例子进行讲解。</p>
<p>　　注意：这七层是在发送数据到网线之前，在计算机中内部就已经经过了这7层，不是在传输过程中才慢慢经过这7层的。</p>
<p>　　1）应用层　</p>
<p>　　　　OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</p>
<p>​    　 例子 ：实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询价单，等等。</p>
<p>　　2）表示层</p>
<p>　　 　表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，</p>
<p>　　　　用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>
<p>　　　　例子：由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。</p>
<p>　　　　　　　同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。</p>
<p>　　3）会话层</p>
<p>　　　　 会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。 </p>
<p>　　　　例子：会话层的同事拿到表示层的同事转换后资料，（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。</p>
<p>　　　　　　　他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。</p>
<p>　　　　　　　准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。 </p>
<p>　　4）传输层</p>
<p>　　　　 传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，</p>
<p>　　　　使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。 </p>
<p>　　　　例子： 传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局。</p>
<p>　　5）网络层</p>
<p>　　　　 本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。</p>
<p>　　　　 就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p>
<p>　　　　例子： 网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），</p>
<p>　　　　　　  首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。</p>
<p>　　6）数据链路层　　　　</p>
<p>　　　　将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。<br>　　　　数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。<br>　　　　MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p>
<p>　　7）物理层</p>
<p>　　　　实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。<br>　　　　常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。<br>　　　　例子： 快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。</p>
<h2 id="3-3、各层通信的特点"><a href="#3-3、各层通信的特点" class="headerlink" title="3.3、各层通信的特点"></a>3.3、各层通信的特点</h2><p>　　通信特点：对等通信   </p>
<p>　　对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170926193520262-505125461.png" alt="img"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="四、TCP-IP五层模型"><a href="#四、TCP-IP五层模型" class="headerlink" title="四、TCP/IP五层模型"></a>四、TCP/IP五层模型</h1><p> TCP/IP五层协议和OSI的七层协议对应关系如下　　</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170926193906653-945700629.png" alt="img"></p>
<p>在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170926194002684-1345147242.png" alt="img"></p>
<p>在每一层实现的协议也各不同，即每一层的服务也不同.下图列出了每层主要的协议。其中每层中具体的协议。</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170926194048637-1078586652.png" alt="img"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="五、OSI参考模型和TCP-IP协议"><a href="#五、OSI参考模型和TCP-IP协议" class="headerlink" title="五、OSI参考模型和TCP/IP协议"></a>五、OSI参考模型和TCP/IP协议</h1><p>　　1）OSI参考模型和TCP/IP协议图</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170926194238294-2065707228.png" alt="img"></p>
<p>　　2）发送数据：数据的封装，各个层次都做了什么事情</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170926194416481-1695150738.png" alt="img"></p>
<p>　　3）数据封装后的样子</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170926194526950-147330535.png" alt="img"></p>
<p>　　4）接受数据，解封装</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170926194652356-395554952.png" alt="img"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7598603.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="六、计算机上的各种性能指标解释"><a href="#六、计算机上的各种性能指标解释" class="headerlink" title="六、计算机上的各种性能指标解释"></a>六、计算机上的各种性能指标解释</h1><p>速率、带宽、吞吐量、时延、时延带宽积、往返时间、利用率</p>
<h2 id="6-1、速率"><a href="#6-1、速率" class="headerlink" title="6.1、速率"></a>6.1、速率</h2><p>　　在计算机与计算机之间通信时传输数据位数的速率 单位 bit/s 1 bit也就是 1 位</p>
<p>　　byte 与 bit 的区别和换算</p>
<p>　　　　byte：字节 　　　bit：位</p>
<p>　　　　1byte = 8bit</p>
<p>　　按字节换算</p>
<p>　　　　1 k = 1024byte　　M与byte之间的换算是1024</p>
<p>　　　　1M = 1024K　　　</p>
<p>　　按位换算</p>
<p>　　　　1kb = 1000bit</p>
<p>　　　　1Mb = 1000Kb</p>
<p>　　　　1Gb = 1000Mb</p>
<p>　　问题一：我们人们常说的我的网络是8M 为什么下载速度只有1M/S呢？</p>
<p>　　　　这里的8M，单位是Mb，也就是按位来算的， 而下载速度是按字节算的 8M = 8000Kb = 8000，000bit = 1000，000 byte ≈1000kb ≈1M</p>
<p>　　　　所以一般都市直接除以8，8M的网络下载速度就是1M/s 100M的网下载速度也就10M/s</p>
<h2 id="6-2、带宽"><a href="#6-2、带宽" class="headerlink" title="6.2、带宽"></a>6.2、带宽</h2><p>　　接口支持最高的传输速率， 也就是我们的带宽是8M， 带宽是100M. 就是最高支持一次传输8M，自己换算一下，能传多个位。 </p>
<h2 id="6-3、吞吐量"><a href="#6-3、吞吐量" class="headerlink" title="6.3、吞吐量"></a>6.3、吞吐量</h2><p>　　单位时间内通过某个网络的数据量</p>
<p>　　简单的说，就是通过一根网线一次性传输的多少个位，最高位就是带宽，但不是每次传输都达到了带宽值，有可能通过的只有3M，5M，都不一定，通过的量就是我们说的吞吐量　　　　　</p>
<h2 id="6-4、时延"><a href="#6-4、时延" class="headerlink" title="6.4、时延"></a>6.4、时延</h2><p>　　发送时延、传播时延、处理时延、排队时延</p>
<p>　　发送时延 = 数据块长度(bit)/信道宽度(bit/s)</p>
<p>　　过一个特定情景来讲解　　　　　　　　　　　　　　　　　　</p>
<p>　　　　A—————-路由器———————B</p>
<p>　　　　A发送0101010101(10bit)数据到B 带宽是10bit/s　　A距离B 100米 信号在信道上的传播速率 10米/s</p>
<p>　　　　当从开始发送1到最后一个0从A的网卡中出来结束，发送时延 = 10bit/10bit/s = 1s</p>
<p>　　传播时延 = 信道长度（米）/信号在信道上传播速率(米/秒)</p>
<p>　　传播时延：从A发送1开始，到路由器，接受最后一个0结束，这一段也算是传播时延，路由器到B之间也是 100/10 = 10秒。 在电线上花费的时间是10秒</p>
<p>　　排队时延：路由器接受数据，有一个缓冲区，相当于队列，数据到路由器，先到缓冲区排队等待路由器一个个接受数据，直到路由器开始接受第一个位，这就是排队时延，从路由器出来也需要排队时延</p>
<p>　　处理时延：路由器开始接受第一个位，这就开始处理数据了，到最后一个位接受完，这之间就是处理时延</p>
<h2 id="6-5、时延带宽积"><a href="#6-5、时延带宽积" class="headerlink" title="6.5、时延带宽积"></a>6.5、时延带宽积</h2><p>　　 其实也就是在信道中有多少位数据在其中，用的是带宽，也就是最高的数据。</p>
<p>　　传播时延 * 带宽　</p>
<h2 id="6-6、往返时间"><a href="#6-6、往返时间" class="headerlink" title="6.6、往返时间"></a>6.6、往返时间</h2><p>　　从A到B，在B返回数据到A，之间用了多少时间</p>
<p>　　使用命令 ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 从我们浏览器到存放百度地址的主机，然后返回数据到我们计算机需要的时间</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>linux基础（19-41集）</title>
    <url>/2020/04/25/linux%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<h1 id="linux-100集"><a href="#linux-100集" class="headerlink" title="linux 100集"></a>linux 100集</h1><h2 id="P19-22-文件和目录（ls常用选项）"><a href="#P19-22-文件和目录（ls常用选项）" class="headerlink" title="P19-22 文件和目录（ls常用选项）"></a>P19-22 文件和目录（ls常用选项）</h2><p>Linux中“./”在系统文件中表示绝对路径的意思。</p>
<p>linux系统中，所有的文件与目录都是由根目录/开始，不是以/开头的就是相对路径；</p>
<p>1、“.”表示当前目录，也可以用“./”表示；</p>
<p>2、“..”表示上一级目录，也可以用“../”表示；</p>
<p>3、“~” 代表用户自己的宿主目录；</p>
<p>4、“/”处于Linux文件系统树形结构的最顶端，我们称它为Linux文件系统的root，它是Linux文件系统的入口。</p>
<p>所有的目录、文件、设备都在/之下，它是Linux文件系统最顶层的唯一的目录；</p>
<p>自动不全：tab键</p>
<p>查看曾经用过命令：上下光标键，退出选择用ctrl+c</p>
<p>ls命令扩展：</p>
<p>最常用，.开头的文件为隐藏文件，需要-a才可以打开， ls -a才可以显示出来</p>
<p>.表示当前目录 </p>
<p>..表示上级目录， cd ..返回上一个目录</p>
<p>ls -l以列表方式显示文件详细信息</p>
<p>ls -h配合-l以人性化方式显示文件大小（文件大小用k，m表示，而不是byte，人易读）：ls -l -h或者 ls -lh</p>
<p>所以可以ls -alh</p>
<p>drw… 这里d是目录</p>
<h2 id="P23-文件和目录（ls常用通配符）"><a href="#P23-文件和目录（ls常用通配符）" class="headerlink" title="P23 文件和目录（ls常用通配符）"></a>P23 文件和目录（ls常用通配符）</h2><p>*：任意个数字符(0或多个)</p>
<p>？：任意一个字符，至少一个（只一个，不可为0）</p>
<p>[]:可匹配字符组任意一个</p>
<p>ls功能： 列出非目录的文件项，然后是每一个目录中的“可显示”文件（可理解为ls命令将本目录向下展开两级）</p>
<p>ls用法：ls  [参数]  [目录名]</p>
<p>​    （如过要显示当前目录的文件可不加目录名）</p>
<p>ls常用参数</p>
<p>   -a 显示所有文件，包含隐藏文件</p>
<p>   -A 显示所有文件，包含隐藏文件，但不包含.及..</p>
<p> -l  显示为long format（长格式），列出文件的类型、权限、链接数、owner、group、大 小，时间，名字</p>
<p>   -R  </p>
<p>   -d 不展开目录，只显示目录自身，一般与-l配合使用以显示目录自身的属性信息（只显示当前目录的内容）</p>
<p>   -1 数字1，成列显示内容</p>
<p>   -S 以文件大小排序显示，默认从大到小 -r后，从小到大</p>
<p>   -U 按存放顺序排序显示</p>
<p>   -X 按扩展名的首字母来排序</p>
<p>   -t  按mtime排序（先显示时间最近的）</p>
<p>   -ul  按atime排序（先显示时间最近的）</p>
<p>   -ct  按ctime排序（先显示时间最近的）</p>
<p>​     补充：</p>
<p>关于时间戳：</p>
<p>​     atime  访问时间</p>
<p>​     mtime 数据修改时间 （写入，修改数据mtime改变，mtime改变ctime必改变）</p>
<p>​     ctime  元数据修改时间 （修改权限的时候只有ctime改变）</p>
<p>​     可过“stat 文件路径”查看全部时间戳</p>
<p><strong>扩展**</strong>: 如何通过ls只显示指定格式的文件**</p>
<p>首先我们要了解什么是文件名通配符</p>
<p>Shell提供了一套完整的字符串模式匹配规则，或者称之为元字符，当s h e l l遇到上述字符时，就会把它们当作特殊字符，而不是文件名中的普通字符，这样用户就可以用它们来匹配相应的文件名，我理解这可以称为通配符。</p>
<p>常用通配符：</p>
<p>* 匹配0或多个任意字符</p>
<p>? 匹配任意1个字符</p>
<p>[  ]  当中括号内为几个确定字符时，表示匹配括号内任意一个字符，当中括号内为一个范围时表示匹配这个范围中的任意一个字符（中括号表示的是一个范围，匹配的是一个字符）</p>
<p>例：</p>
<p> [ab46e] 表示是a,b,4,6,e中的任意一个字符</p>
<p> [a-z] 表示aAbBcC……z（Linux中的默认编码顺序是一个小写字母一个大写字母即aAbBcC…..Z）</p>
<p>​     [A-Z] 表示AbBcC……Z</p>
<p>​    [a- Z] 表示所有大小写字母</p>
<p>​    [^ae] 表示即不是a也不是e的其他任意单一字符</p>
<p>[:lower:] 表示一个小写字母 </p>
<p>[:upper:] 表示一个大写字母</p>
<p>[:alpha:] 表示一个大小写字母 等同于[a-Z]</p>
<p>[:digit:]  表示任意一个数字 等同于[0-9]</p>
<p>[:alnum:] 表示任意一个字母或数字 等于[a-Z0-9]或[[:digit:][:alpha:]]</p>
<p>[:blank:]：一个水平空白字符</p>
<p>[:space:]：一个水平或垂直空白字符（文件名不可能包含回车，故此处使用与[:blank:]：效果相同）</p>
<p>通过ls命令和通配符查找指定格式的文件：</p>
<p> 格式：ls  [参数]  [目录名][通配符]</p>
<p>以下是一些例子：</p>
<p>\1. 查找/usr/share/man 目录下以m开头且以一个数字加x结尾的文件</p>
<p>命令：ls  -d  /usr/share/man/m*[0-9]x</p>
<p>运行结果：</p>
<p> <img src="https://images2018.cnblogs.com/blog/1440488/201807/1440488-20180714174106974-1962045890.png" alt="img"></p>
<p>解释：-d 只展开一级目录</p>
<p>   /usr/share/man/  目录路径</p>
<p> m*[0-9]x  m表示以m开头，[0-9]x表示以数字加x结尾,因为对文件的中间没</p>
<p>有加以限制所以用<em>代替中间部分，</em>表示任意个数的任意字符</p>
<p>\2. 查找root下的隐藏文件和目录</p>
<p>   命令： ls  -d  /root/.*</p>
<p>   运行结果：</p>
<p><img src="https://images2018.cnblogs.com/blog/1440488/201807/1440488-20180714174309686-515187362.png" alt="img"></p>
<p>解释：-d 只展开一级目录</p>
<p>   /root 目录路径</p>
<p>   因为Linux下以“.”开头的文件是隐藏文件，所以用“.”加上“*”来表示隐藏文件</p>
<p>\3. 查找/etc下所有以k开头，以一个小写字母结尾，且中间出现至少一位数字的文件</p>
<p>​    命令：ls  -d  /etc/k<em>[0-9]</em>[[:lower:]]</p>
<p>​    运行结果：</p>
<p> <img src="https://images2018.cnblogs.com/blog/1440488/201807/1440488-20180714174409329-147595255.png" alt="img"></p>
<p>解释：-d 只展开一级目录 </p>
<p>   /etc 目录路径</p>
<p>​    k表示以k开头，[0-9]表示一个数字，[[:lower:]]表示一个小写字母，因为[:lower:]表示为小写字母，也就是abcdefg…z，所以在[:lower:]外面加</p>
<p>   上[ ]以表示在这写子母中取任意一个，因为只规定了开头和结尾，对中间只要求至少出现一位数字，所以中间用*[0-9]*来表示</p>
<h2 id="P25-文件和目录（cd常用选项）"><a href="#P25-文件和目录（cd常用选项）" class="headerlink" title="P25 文件和目录（cd常用选项）"></a>P25 文件和目录（cd常用选项）</h2><p>cd </p>
<p>跳入test目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com]#cd testDir&#x2F;</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#ls</span><br><span class="line">file1  file2  file3</span><br></pre></td></tr></table></figure>

<p>跳至上层目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#cd ..</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com]#ls</span><br><span class="line">testDir</span><br></pre></td></tr></table></figure>

<p>跳至上上层目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#cd ..&#x2F;..&#x2F;</span><br><span class="line">[root@&#x2F;root]#ls</span><br></pre></td></tr></table></figure>

<p>跳入用户主目录: cd ~或者cd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#ls</span><br><span class="line">file1  file2  file3</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#cd ~&#x2F;</span><br><span class="line">[root@&#x2F;root]#pwd</span><br><span class="line">&#x2F;root</span><br></pre></td></tr></table></figure>

<p>使用绝对路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@&#x2F;root]#cd &#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#ls</span><br><span class="line">file1  file2  file3</span><br></pre></td></tr></table></figure>

<p>使用环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@&#x2F;root]#cd $TEST_PATH</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#ls</span><br><span class="line">file1  file2  file3</span><br></pre></td></tr></table></figure>

<p>跳入上次使用目录: cd -, 可以在最近两次工作目录间切换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@&#x2F;root]#pwd</span><br><span class="line">&#x2F;root</span><br><span class="line">[root@&#x2F;root]#cd -</span><br><span class="line">&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#</span><br></pre></td></tr></table></figure>

<h2 id="P26-文件和目录（相对路径绝对路径）"><a href="#P26-文件和目录（相对路径绝对路径）" class="headerlink" title="P26 文件和目录（相对路径绝对路径）"></a>P26 文件和目录（相对路径绝对路径）</h2><ul>
<li>绝对路径：路径的写法一定是由根目录 / 写起的，例如 /usr/local/mysql</li>
<li>相对路径：路径的写法不是由根目录 / 写起的，例如 首先用户进入到 /home，然后再进入到test，执行的命令为 “#cd /home,#cd test”。此时用户所在的路径为 /home/test。第一个cd命令后紧跟/home，前面有斜杠；而第二个cd命令后紧跟test，前面没有斜杠。<strong>这个test是相对于/home目录来讲的，所以称为相对路径</strong>。</li>
</ul>
<h2 id="P27-文件和目录（mkdir和touch）"><a href="#P27-文件和目录（mkdir和touch）" class="headerlink" title="P27 文件和目录（mkdir和touch）"></a>P27 文件和目录（mkdir和touch）</h2><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p>
<p>ls -l 可以显示档案的时间记录。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数说明</strong>：</li>
<li>a 改变档案的读取时间记录。</li>
<li>m 改变档案的修改时间记录。</li>
<li>c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。</li>
<li>f 不使用，是为了与其他 unix 系统的相容性而保留。</li>
<li>r 使用参考档的时间记录，与 –file 的效果一样。</li>
<li>d 设定时间与日期，可以使用各种不同的格式。</li>
<li>t 设定档案的时间记录，格式与 date 指令相同。</li>
<li>–no-create 不会建立新档案。</li>
<li>–help 列出指令格式。</li>
<li>–version 列出版本讯息。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用指令”touch”修改文件”testfile”的时间属性为当前系统时间，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ touch testfile                #修改文件的时间属性</span><br></pre></td></tr></table></figure>

<p>首先，使用ls命令查看testfile文件的属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#原来文件的修改时间为16:09  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile</span><br></pre></td></tr></table></figure>

<p>执行指令”touch”修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ touch testfile                #修改文件时间属性为当前系统时间  </span><br><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#修改后文件的时间属性为当前系统时间  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile</span><br></pre></td></tr></table></figure>

<p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ touch file            #创建一个名为“file”的新的空白文件</span><br></pre></td></tr></table></figure>

<p>Linux mkdir命令用于建立名称为 dirName 之子目录。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir [-p] dirName</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-p 确保目录名称存在，不存在的就建一个。</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>在工作目录下，建立一个名为 AAA 的子目录 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir AAA</span><br></pre></td></tr></table></figure>

<p>在工作目录下的 BBB 目录中，建立一个名为 Test 的子目录。 若 BBB 目录原本不存在，则建立一个。（注：本例若不加 -p，且原本 BBB目录不存在，则产生错误。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p BBB&#x2F;Test</span><br></pre></td></tr></table></figure>

<p>linux中文件目录不可以重名</p>
<h2 id="P28-文件和目录（rm）"><a href="#P28-文件和目录（rm）" class="headerlink" title="P28 文件和目录（rm）"></a>P28 文件和目录（rm）</h2><p>rm删除的不能恢复。Linux rm命令用于删除一个文件或者目录。</p>
<p>rm也可以使用通配符。</p>
<p>格式化电脑：rm -rf *</p>
<p>所有数据全部删除。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm [options] name...</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-i 删除前逐一询问确认。</li>
<li>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。（没有此文件也可以删除，不会报错）</li>
<li>-r 将目录及以下之档案亦逐一删除。（不加无法删目录）（用递归方法）</li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>删除文件可以直接使用rm命令，若删除目录则必须配合选项”-r”，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># rm  test.txt </span><br><span class="line">rm：是否删除 一般文件 &quot;test.txt&quot;? y  </span><br><span class="line"># rm  homework  </span><br><span class="line">rm: 无法删除目录&quot;homework&quot;: 是一个目录  </span><br><span class="line"># rm  -r  homework  </span><br><span class="line">rm：是否删除 目录 &quot;homework&quot;? y</span><br></pre></td></tr></table></figure>

<p>删除当前目录下的所有文件及目录，命令行为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm  -r  *</span><br></pre></td></tr></table></figure>

<p>文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。</p>
<h2 id="P29-35拷贝和移动文件"><a href="#P29-35拷贝和移动文件" class="headerlink" title="P29-35拷贝和移动文件"></a>P29-35拷贝和移动文件</h2><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>Linux tree命令用于以树状图列出目录的内容。</p>
<p>需要此指令安装：sudo snap install tree</p>
<p>tree <del>，家目录（</del>），全部显示出来。</p>
<p>执行tree指令，它会列出指定目录下的所有文件，包括子目录里的文件。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tree [-aACdDfFgilnNpqstux][-I &lt;范本样式&gt;][-P &lt;范本样式&gt;][目录...]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-a 显示所有文件和目录。</li>
<li>-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。</li>
<li>-C 在文件和目录清单加上色彩，便于区分各种类型。</li>
<li>-d 显示目录名称而非内容。（常用）</li>
<li>-D 列出文件或目录的更改时间。</li>
<li>-f 在每个文件或目录之前，显示完整的相对路径名称。</li>
<li>-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”/“,”=”,”@”,”|”号。</li>
<li>-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</li>
<li>-i 不以阶梯状列出文件或目录名称。</li>
<li>-L level 限制目录显示层级。</li>
<li>-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</li>
<li>-n 不在文件和目录清单加上色彩。</li>
<li>-N 直接列出文件和目录名称，包括控制字符。</li>
<li>-p 列出权限标示。</li>
<li>-P&lt;范本样式&gt; 只显示符合范本样式的文件或目录名称。</li>
<li>-q 用”?”号取代控制字符，列出文件和目录名称。</li>
<li>-s 列出文件或目录大小。</li>
<li>-t 用文件和目录的更改时间排序。</li>
<li>-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</li>
<li>-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</li>
</ul>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp [options] source dest</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp [options] source... directory</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</li>
<li>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</li>
<li>-f：覆盖已经存在的目标文件而不给出提示。</li>
<li>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。（常用）</li>
<li>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li>
<li>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。（常用）</li>
<li>-l：不复制文件，只是生成链接文件。</li>
</ul>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>使用指令”cp”将当前目录”test/“下的所有文件复制到新目录”newtest”下，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cp –r test&#x2F; newtest</span><br></pre></td></tr></table></figure>

<p>注意：用户使用该指令复制目录时，必须使用参数”-r”或者”-R”。</p>
<p>例 cp ~/Desktop/a.txt .       当前文件夹下</p>
<p>Linux mv 命令用来为文件或目录改名、或将文件或目录移入其它位置。</p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv [options] source dest</span><br><span class="line">mv [options] source... directory</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;（常用）</li>
<li>-f: 在 mv 操作要覆盖某已有的目标文件时不给任何指示;</li>
</ul>
<p>mv参数设置与运行结果</p>
<table>
<thead>
<tr>
<th align="left">命令格式</th>
<th align="left">运行结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mv 文件名 文件名</td>
<td align="left">将源文件名改为目标文件名</td>
</tr>
<tr>
<td align="left">mv 文件名 目录名</td>
<td align="left">将文件移动到目标目录</td>
</tr>
<tr>
<td align="left">mv 目录名 目录名</td>
<td align="left">目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名</td>
</tr>
<tr>
<td align="left">mv 目录名 文件名</td>
<td align="left">出错</td>
</tr>
</tbody></table>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>将文件 aaa 更名为 bbb :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv aaa bbb</span><br></pre></td></tr></table></figure>

<p>将info目录放入logs目录中。注意，如果logs目录不存在，则该命令将info改名为logs。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv info&#x2F; logs</span><br></pre></td></tr></table></figure>

<p>再如将/usr/student下的所有文件和目录移到当前目录下，命令行为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mv &#x2F;usr&#x2F;student&#x2F;*  .</span><br></pre></td></tr></table></figure>



<h2 id="P36-39查看文件内容命令"><a href="#P36-39查看文件内容命令" class="headerlink" title="P36-39查看文件内容命令"></a>P36-39查看文件内容命令</h2><p>cat， more， grep</p>
<h3 id="cat："><a href="#cat：" class="headerlink" title="cat："></a>cat：</h3><h4 id="concatenate-查看文件，创建文件，文件合并，追加文件内容等功能"><a href="#concatenate-查看文件，创建文件，文件合并，追加文件内容等功能" class="headerlink" title="concatenate: 查看文件，创建文件，文件合并，追加文件内容等功能"></a>concatenate: 查看文件，创建文件，文件合并，追加文件内容等功能</h4><p>cat 命令用于连接文件并打印到标准输出设备上。（适合内容少的文本内容）</p>
<h3 id="使用权限"><a href="#使用权限" class="headerlink" title="使用权限"></a>使用权限</h3><p>所有使用者</p>
<h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat [-AbeEnstTuv] [--help] [--version] fileName</span><br></pre></td></tr></table></figure>

<h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><p><strong>-n 或 –number</strong>：由 1 开始对所有输出的行数编号。（常用）</p>
<p><strong>-b 或 –number-nonblank</strong>：和 -n 相似，只不过对于空白行不编号。（常用）</p>
<p><strong>-s 或 –squeeze-blank</strong>：当遇到有连续两行以上的空白行，就代换为一行的空白行。</p>
<p><strong>-v 或 –show-nonprinting</strong>：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。</p>
<p><strong>-E 或 –show-ends</strong> : 在每行结束处显示 $。</p>
<p><strong>-T 或 –show-tabs</strong>: 将 TAB 字符显示为 ^I。</p>
<p><strong>-A, –show-all</strong>：等价于 -vET。</p>
<p><strong>-e：</strong>等价于”-vE”选项；</p>
<p><strong>-t：</strong>等价于”-vT”选项；</p>
<h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure>

<p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure>

<p>清空 /etc/test.txt 文档内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;dev&#x2F;null &gt; &#x2F;etc&#x2F;test.txt</span><br></pre></td></tr></table></figure>

<p>cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;dev&#x2F;fd0 &gt; OUTFILE</span><br></pre></td></tr></table></figure>

<p>相反的，如果想把 image file 写到软盘，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat IMG_FILE &gt; &#x2F;dev&#x2F;fd0</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：</p>
<ul>
<li><p>\1. OUTFILE 指输出的镜像文件名。</p>
</li>
<li><p>\2. IMG_FILE 指镜像文件。</p>
</li>
<li><p>\3. 若从镜像文件写回 device 时，device 容量需与相当。</p>
</li>
<li><p>\4. 通常用制作开机磁片。</p>
</li>
</ul>
<h3 id="more："><a href="#more：" class="headerlink" title="more："></a>more：</h3><p>Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。Enter键：一次滚动手册页的一行，f前滚一页，q退出，/word搜索word字符串</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more [-dlfpcsu] [-num] [+&#x2F;pattern] [+linenum] [fileNames..]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-num 一次显示的行数</li>
<li>-d 提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声</li>
<li>-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能</li>
<li>-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）</li>
<li>-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容</li>
<li>-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料</li>
<li>-s 当遇到有连续两行以上的空白行，就代换为一行的空白行</li>
<li>-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）</li>
<li>+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示</li>
<li>+num 从第 num 行开始显示</li>
<li>fileNames 欲显示内容的文档，可为复数个数</li>
</ul>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>逐页显示 testfile 文档内容，如有连续两行以上空白行则以一行空白行显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more -s testfile</span><br></pre></td></tr></table></figure>

<p>从第 20 行开始显示 testfile 之文档内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more +20 testfile</span><br></pre></td></tr></table></figure>

<h3 id="常用操作命令"><a href="#常用操作命令" class="headerlink" title="常用操作命令"></a>常用操作命令</h3><ul>
<li>Enter 向下n行，需要定义。默认为1行</li>
<li>Ctrl+F 向下滚动一屏</li>
<li>空格键 向下滚动一屏</li>
<li>Ctrl+B 返回上一屏</li>
<li>= 输出当前行的行号</li>
<li>：f 输出文件名和当前行的行号</li>
<li>V 调用vi编辑器</li>
<li>!命令 调用Shell，并执行命令 </li>
<li>q 退出more</li>
</ul>
<h3 id="grep：文本搜索工具"><a href="#grep：文本搜索工具" class="headerlink" title="grep：文本搜索工具"></a>grep：文本搜索工具</h3><p>Linux grep 命令用于查找文件里符合条件的字符串。</p>
<p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p>
<h3 id="常用2种模式查找："><a href="#常用2种模式查找：" class="headerlink" title="常用2种模式查找："></a>常用2种模式查找：</h3><p>^a: 行首，以a开头的行</p>
<p>ke$：行尾，以ke结尾的行</p>
<p> 例：gref ^f a.txt</p>
<h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><strong>-a 或 –text</strong> : 不要忽略二进制的数据。 </li>
<li><strong>-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt;</strong> : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。 </li>
<li><strong>-b 或 –byte-offset</strong> : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。 </li>
<li><strong>-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前的内容。 </li>
<li><strong>-c 或 –count</strong> : 计算符合样式的列数。 </li>
<li><strong>-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前后的内容。 </li>
<li><strong>-d &lt;动作&gt; 或 –directories=&lt;动作&gt;</strong> : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li>
<li><strong>-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt;</strong> : 指定字符串做为查找文件内容的样式。 </li>
<li><strong>-E 或 –extended-regexp</strong> : 将样式为延伸的正则表达式来使用。 </li>
<li><strong>-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt;</strong> : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 </li>
<li><strong>-F 或 –fixed-regexp</strong> : 将样式视为固定字符串的列表。 </li>
<li><strong>-G 或 –basic-regexp</strong> : 将样式视为普通的表示法来使用。 </li>
<li><strong>-h 或 –no-filename</strong> : 在显示符合样式的那一行之前，不标示该行所属的文件名称。 </li>
<li><strong>-H 或 –with-filename</strong> : 在显示符合样式的那一行之前，表示该行所属的文件名称。 </li>
<li><strong>-i 或 –ignore-case</strong> : 忽略字符大小写的差别。 （常用）</li>
<li><strong>-l 或 –file-with-matches</strong> : 列出文件内容符合指定的样式的文件名称。 </li>
<li><strong>-L 或 –files-without-match</strong> : 列出文件内容不符合指定的样式的文件名称。 </li>
<li><strong>-n 或 –line-number</strong> : 在显示符合样式的那一行之前，标示出该行的列数编号。 （显示匹配行及行号，常用）</li>
<li><strong>-o 或 –only-matching</strong> : 只显示匹配PATTERN 部分。 </li>
<li><strong>-q 或 –quiet或–silent</strong> : 不显示任何信息。 </li>
<li><strong>-r 或 –recursive</strong> : 此参数的效果和指定”-d recurse”参数相同。 </li>
<li><strong>-s 或 –no-messages</strong> : 不显示错误信息。 </li>
<li><strong>-v 或 –revert-match</strong> : 显示不包含匹配文本的所有行。 （求反，常用）</li>
<li><strong>-V 或 –version</strong> : 显示版本信息。 </li>
<li><strong>-w 或 –word-regexp</strong> : 只显示全字符合的列。 </li>
<li><strong>-x –line-regexp</strong> : 只显示全列符合的列。 </li>
<li><strong>-y</strong> : 此参数的效果和指定”-i”参数相同。</li>
</ul>
<p><a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener"><img src="https://www.runoob.com/images/up.gif" alt="Linux 命令大全"> Linux 命令大全</a></p>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>1、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep test *file</span><br></pre></td></tr></table></figure>

<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep test test* #查找前缀有“test”的文件包含“test”字符串的文件  </span><br><span class="line">testfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行  </span><br><span class="line">testfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行  </span><br><span class="line">testfile_2:Linux test #列出testfile_2 文件中包含test字符的行</span><br></pre></td></tr></table></figure>

<p>2、以递归的方式查找符合条件的文件。例如，查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串”update”的文件，并打印出该字符串所在行的内容，使用的命令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -r update &#x2F;etc&#x2F;acpi</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -r update &#x2F;etc&#x2F;acpi #以递归的方式查找“etc&#x2F;acpi”  </span><br><span class="line">#下包含“update”的文件  </span><br><span class="line">&#x2F;etc&#x2F;acpi&#x2F;ac.d&#x2F;85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.)  </span><br><span class="line">Rather than  </span><br><span class="line">&#x2F;etc&#x2F;acpi&#x2F;resume.d&#x2F;85-anacron.sh:# (Things like the slocate updatedb cause a lot of  </span><br><span class="line">IO.) Rather than  </span><br><span class="line">&#x2F;etc&#x2F;acpi&#x2F;events&#x2F;thinkpad-cmos:action&#x3D;&#x2F;usr&#x2F;sbin&#x2F;thinkpad-keys--update</span><br></pre></td></tr></table></figure>

<p>3、反向查找。前面各个例子是查找并打印出符合条件的行，通过”-v”参数可以打印出不符合条件行的内容。</p>
<p>查找文件名中包含 test 的文件中不包含test 的行，此时，使用的命令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v test *test*</span><br></pre></td></tr></table></figure>

<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep-v test* #查找文件名中包含test 的文件中不包含test 的行  </span><br><span class="line">testfile1:helLinux!  </span><br><span class="line">testfile1:Linis a free Unix-type operating system.  </span><br><span class="line">testfile1:Lin  </span><br><span class="line">testfile_1:HELLO LINUX!  </span><br><span class="line">testfile_1:LINUX IS A FREE UNIX-TYPE OPTERATING SYSTEM.  </span><br><span class="line">testfile_1:THIS IS A LINUX TESTFILE!  </span><br><span class="line">testfile_2:HELLO LINUX!  </span><br><span class="line">testfile_2:Linux is a free unix-type opterating system.</span><br></pre></td></tr></table></figure>

<h2 id="P40-41-echo"><a href="#P40-41-echo" class="headerlink" title="P40-41 echo"></a>P40-41 echo</h2><h3 id="用于字符串的输出"><a href="#用于字符串的输出" class="headerlink" title="用于字符串的输出"></a>用于字符串的输出</h3><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul>
<li>echo string</li>
</ul>
<h3 id="使用echo实现更复杂的输出格式控制"><a href="#使用echo实现更复杂的输出格式控制" class="headerlink" title="使用echo实现更复杂的输出格式控制"></a>使用echo实现更复杂的输出格式控制</h3><h3 id="1-显示普通字符串"><a href="#1-显示普通字符串" class="headerlink" title="1.显示普通字符串:"></a>1.显示普通字符串:</h3><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;It is a test&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这里的双引号完全可以省略，以下命令与上面实例效果一致：</span><br><span class="line"></span><br><span class="line">echo It is a test</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<h3 id="2-显示转义字符"><a href="#2-显示转义字符" class="headerlink" title="2.显示转义字符"></a>2.显示转义字符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;\&quot;It is a test\&quot;&quot;</span><br><span class="line">结果将是:</span><br><span class="line">&quot;It is a test&quot;</span><br><span class="line">同样，双引号也可以省略</span><br></pre></td></tr></table></figure>



<h3 id="3-显示变量"><a href="#3-显示变量" class="headerlink" title="3.显示变量"></a>3.显示变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</span><br><span class="line"></span><br><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">read name </span><br><span class="line">echo &quot;$name It is a test&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:</span><br><span class="line"></span><br><span class="line">[root@www ~]# sh test.sh</span><br><span class="line">OK                     #标准输入</span><br><span class="line">OK It is a test        #输出</span><br></pre></td></tr></table></figure>



<h3 id="4-显示换行"><a href="#4-显示换行" class="headerlink" title="4.显示换行"></a>4.显示换行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo -e &quot;OK! \n&quot; # -e 开启转义</span><br><span class="line">echo &quot;It it a test&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">OK!</span><br><span class="line"></span><br><span class="line">It it a test</span><br></pre></td></tr></table></figure>



<h3 id="5-显示不换行"><a href="#5-显示不换行" class="headerlink" title="5.显示不换行"></a>5.显示不换行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行</span><br><span class="line">echo &quot;It is a test&quot;</span><br><span class="line">输出结果：OK! It is a test</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<ul>
<li>转义</li>
</ul>
<p>　　　　\a 发出警告声； </p>
<p>　　　　\b 删除前一个字符； </p>
<p>　　　　\c 最后不加上换行符号； </p>
<p>　　　　\f 换行但光标仍旧停留在原来的位置； </p>
<p>　　　　\n 换行且光标移至行首； </p>
<p>　　　　\r 光标移至行首，但不换行； </p>
<p>　　　　\t 插入tab； </p>
<p>　　　　\v 与\f相同； </p>
<p>　　　　\ 插入\字符； </p>
<p>　　　　\nnn 插入nnn（八进制）所代表的ASCII字符；</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="6-显示结果定向至文件"><a href="#6-显示结果定向至文件" class="headerlink" title="6.显示结果定向至文件"></a>6.显示结果定向至文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;It is a test&quot; &gt; myfile</span><br></pre></td></tr></table></figure>



<h3 id="7-原样输出字符串，不进行转义或取变量-用单引号"><a href="#7-原样输出字符串，不进行转义或取变量-用单引号" class="headerlink" title="7.原样输出字符串，不进行转义或取变量(用单引号)"></a>7.原样输出字符串，不进行转义或取变量(用单引号)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;$name\&quot;&#39;</span><br><span class="line">输出结果：</span><br><span class="line">$name\&quot;</span><br></pre></td></tr></table></figure>



<h3 id="8-显示命令执行结果"><a href="#8-显示命令执行结果" class="headerlink" title="8.显示命令执行结果"></a>8.显示命令执行结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  echo &#96;date&#96;</span><br><span class="line">结果将显示当前日期</span><br><span class="line"></span><br><span class="line">Thu Jul 24 10:08:46 CST 2014</span><br></pre></td></tr></table></figure>

<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h1 id="Shell-输入-输出重定向"><a href="#Shell-输入-输出重定向" class="headerlink" title="Shell 输入/输出重定向"></a>Shell 输入/输出重定向</h1><p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p>
<p>重定向命令列表如下：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">command &gt; file</td>
<td align="left">将输出重定向到 file。</td>
</tr>
<tr>
<td align="left">command &lt; file</td>
<td align="left">将输入重定向到 file。</td>
</tr>
<tr>
<td align="left">command &gt;&gt; file</td>
<td align="left">将输出以追加的方式重定向到 file。</td>
</tr>
<tr>
<td align="left">n &gt; file</td>
<td align="left">将文件描述符为 n 的文件重定向到 file。（会覆盖）</td>
</tr>
<tr>
<td align="left">n &gt;&gt; file</td>
<td align="left">将文件描述符为 n 的文件以追加的方式重定向到 file。（不会覆盖）</td>
</tr>
<tr>
<td align="left">n &gt;&amp; m</td>
<td align="left">将输出文件 m 和 n 合并。</td>
</tr>
<tr>
<td align="left">n &lt;&amp; m</td>
<td align="left">将输入文件 m 和 n 合并。</td>
</tr>
<tr>
<td align="left">&lt;&lt; tag</td>
<td align="left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
</blockquote>
<hr>
<h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command1 &gt; file1</span><br></pre></td></tr></table></figure>

<p>上面这个命令执行command1然后将输出的内容存入file1。</p>
<p>注意任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用&gt;&gt;操作符。</p>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>执行下面的 who 命令，它将命令的完整的输出重定向在用户文件中(users):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ who &gt; users</span><br></pre></td></tr></table></figure>

<p>执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。</p>
<p>你可以使用 cat 命令查看文件内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat users</span><br><span class="line">_mbsetupuser console  Oct 31 17:35 </span><br><span class="line">tianqixin    console  Oct 31 17:35 </span><br><span class="line">tianqixin    ttys000  Dec  1 11:33</span><br></pre></td></tr></table></figure>

<p>输出重定向会覆盖文件内容，请看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;菜鸟教程：www.runoob.com&quot; &gt; users</span><br><span class="line">$ cat users</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;菜鸟教程：www.runoob.com&quot; &gt;&gt; users</span><br><span class="line">$ cat users</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command1 &lt; file1</span><br></pre></td></tr></table></figure>

<p>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</p>
<p>注意：输出重定向是大于号(&gt;)，输入重定向是小于号(&lt;)。</p>
<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>接着以上实例，我们需要统计 users 文件的行数,执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wc -l users</span><br><span class="line">       2 users</span><br></pre></td></tr></table></figure>

<p>也可以将输入重定向到 users 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  wc -l &lt; users</span><br><span class="line">       2</span><br></pre></td></tr></table></figure>

<p>注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command1 &lt; infile &gt; outfile</span><br></pre></td></tr></table></figure>

<p>同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。</p>
<h3 id="重定向深入讲解"><a href="#重定向深入讲解" class="headerlink" title="重定向深入讲解"></a>重定向深入讲解</h3><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>
<ul>
<li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li>
<li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li>
<li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li>
</ul>
<p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
<p>如果希望 stderr 重定向到 file，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ command 2 &gt; file</span><br></pre></td></tr></table></figure>

<p>如果希望 stderr 追加到 file 文件末尾，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ command 2 &gt;&gt; file</span><br></pre></td></tr></table></figure>

<p><strong>2</strong> 表示标准错误文件(stderr)。</p>
<p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ command &gt; file 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">$ command &gt;&gt; file 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>如果希望对 stdin 和 stdout 都重定向，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ command &lt; file1 &gt;file2</span><br></pre></td></tr></table></figure>

<p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。 </p>
<hr>
<h2 id="Here-Document"><a href="#Here-Document" class="headerlink" title="Here Document"></a>Here Document</h2><p>Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。 </p>
<p>它的基本的形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command &lt;&lt; delimiter</span><br><span class="line">    document</span><br><span class="line">delimiter</span><br></pre></td></tr></table></figure>

<p>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p>
<blockquote>
<p>注意：</p>
<ul>
<li>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</li>
<li>开始的delimiter前后的空格会被忽略掉。</li>
</ul>
</blockquote>
<h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><p>在命令行中通过 wc -l 命令计算 Here Document 的行数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wc -l &lt;&lt; EOF</span><br><span class="line">    欢迎来到</span><br><span class="line">    菜鸟教程</span><br><span class="line">    www.runoob.com</span><br><span class="line">EOF</span><br><span class="line">3          # 输出结果为 3 行</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>我们也可以将 Here Document 用在脚本中，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF</span><br><span class="line">欢迎来到</span><br><span class="line">菜鸟教程</span><br><span class="line">www.runoob.com</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>执行以上脚本，输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">欢迎来到</span><br><span class="line">菜鸟教程</span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="dev-null-文件"><a href="#dev-null-文件" class="headerlink" title="/dev/null 文件"></a>/dev/null 文件</h2><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ command &gt; &#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>

<p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。</p>
<p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ command &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
</blockquote>
<h2 id="P41"><a href="#P41" class="headerlink" title="P41"></a>P41</h2><p>echo和重定向一起用，例：echo hello &gt; a， 想hello输入a文件中</p>
<p>例 ls -lh &gt; a,   ls结果放入a内。&gt;&gt; 是追加。&gt;是覆盖</p>
<h3 id="管道："><a href="#管道：" class="headerlink" title="管道："></a>管道：</h3><p>Shell 还有一种功能，就是可以将两个或者多个命令（程序或者进程）连接到一起，把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了<strong>管道（pipe）</strong>。</p>
<p>Linux 管道使用竖线<code>|</code>连接多个命令，这被称为管道符。Linux 管道的具体语法格式如下：</p>
<p>command1 | command2<br>command1 | command2 [ | commandN… ]</p>
<p>当在两个命令之间设置管道时，管道符<code>|</code>左边命令的输出就变成了右边命令的输入。只要第一个命令向标准输出写入，而第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道。大部分的 Linux 命令都可以用来形成管道。</p>
<blockquote>
<p>这里需要注意，command1 必须有正确输出，而 command2 必须可以处理 command2 的输出结果；而且 command2 只能处理 command1 的正确输出结果，不能处理 command1 的错误信息。</p>
</blockquote>
<h2 id="为什么使用管道？"><a href="#为什么使用管道？" class="headerlink" title="为什么使用管道？"></a>为什么使用管道？</h2><p>我们先看下面一组命令，使用 mysqldump（一个数据库备份程序）来备份一个叫做 wiki 的数据库：</p>
<p>mysqldump -u root -p ‘123456’ wiki &gt; /tmp/wikidb.backup<br>gzip -9 /tmp/wikidb.backup<br>scp /tmp/wikidb.backup username@remote_ip:/backup/mysql/</p>
<p>上述这组命令主要做了如下任务：</p>
<ul>
<li>mysqldump 命令用于将名为 wike 的数据库备份到文件 /tmp/wikidb.backup；其中<code>-u</code>和<code>-p</code>选项分别指出数据库的用户名和密码。</li>
<li>gzip 命令用于压缩较大的数据库文件以节省磁盘空间；其中<code>-9</code>表示最慢的压缩速度最好的压缩效果。</li>
<li>scp 命令（secure copy，安全拷贝）用于将数据库备份文件复制到 IP 地址为 remote_ip 的备份服务器的 /backup/mysql/ 目录下。其中<code>username</code>是登录远程服务器的用户名，命令执行后需要输入密码。</li>
</ul>
<p>上述三个命令依次执行。然而，如果使用管道的话，你就可以将 mysqldump、gzip、ssh 命令相连接，这样就避免了创建临时文件 /tmp/wikidb.backup，而且可以同时执行这些命令并达到相同的效果。</p>
<p>使用管道后的命令如下所示：</p>
<p>mysqldump -u root -p ‘123456’ wiki | gzip -9 | ssh username@remote_ip “cat &gt; /backup/wikidb.gz”</p>
<p>这些使用了管道的命令有如下特点：</p>
<ul>
<li>命令的语法紧凑并且使用简单。</li>
<li>通过使用管道，将三个命令串联到一起就完成了远程 mysql 备份的复杂任务。</li>
<li>从管道输出的标准错误会混合到一起。</li>
</ul>
<p>上述命令的数据流如下图所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190416/1-1Z4161052294c.gif" alt="Linux Shell管道演示图"></p>
<h2 id="重定向和管道的区别"><a href="#重定向和管道的区别" class="headerlink" title="重定向和管道的区别"></a>重定向和管道的区别</h2><p>乍看起来，管道也有重定向的作用，它也改变了数据输入输出的方向，那么，管道和重定向之间到底有什么不同呢？</p>
<p>简单地说，重定向操作符&gt;将命令与文件连接起来，用文件来接收命令的输出；而管道符|将命令与命令连接起来，用第二个命令来接收第一个命令的输出。如下所示：</p>
<p>command &gt; file<br>command1 | command1</p>
<p>有些读者在学习管道时会尝试如下的命令，我们来看一下会发生什么：</p>
<p>command1 &gt; command2</p>
<p>答案是，有时尝试的结果将会很糟糕。这是一个实际的例子，一个 Linux 系统管理员以超级用户（root 用户）的身份执行了如下命令：</p>
<p>cd /usr/bin<br>ls &gt; less</p>
<p>第一条命令将当前目录切换到了大多数程序所存放的目录，第二条命令是告诉 Shell 用 ls 命令的输出重写文件 less。因为 /usr/bin 目录已经包含了名称为 less（less 程序）的文件，第二条命令用 ls 输出的文本重写了 less 程序，因此破坏了文件系统中的 less 程序。</p>
<p>这是使用重定向操作符错误重写文件的一个教训，所以在使用它时要谨慎。</p>
<h2 id="Linux管道实例"><a href="#Linux管道实例" class="headerlink" title="Linux管道实例"></a>Linux管道实例</h2><p>【实例1】将 ls 命令的输出发送到 grep 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ ls | grep log.txt</span><br><span class="line">log.txt</span><br></pre></td></tr></table></figure>

<p>上述命令是查看文件 log.txt 是否存在于当前目录下。</p>
<p>我们可以在命令的后面使用选项，例如使用<code>-al</code>选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ ls -al | grep log.txt</span><br><span class="line">-rw-rw-r--.  1 mozhiyan mozhiyan    0 4月  15 17:26 log.txt</span><br></pre></td></tr></table></figure>

<p>管道符<code>|</code>与两侧的命令之间也可以不存在空格，例如将上述命令写作<code>ls -al|grep log.txt</code>；然而我还是推荐在管道符<code>|</code>和两侧的命令之间使用空格，以增加代码的可读性。</p>
<p>我们也可以重定向管道的输出到一个文件，比如将上述管道命令的输出结果发送到文件 output.txt 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ ls -al | grep log.txt &gt;output.txt</span><br><span class="line">[c.biancheng.net]$ cat output.txt</span><br><span class="line">-rw-rw-r--.  1 mozhiyan mozhiyan    0 4月  15 17:26 log.txt</span><br></pre></td></tr></table></figure>


<p>【实例2】使用管道将 cat 命令的输出作为 less 命令的输入，这样就可以将 cat 命令的输出每次按照一个屏幕的长度显示，这对于查看长度大于一个屏幕的文件内容很有帮助。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;var&#x2F;log&#x2F;message | less</span><br></pre></td></tr></table></figure>


<p>【实例3】查看指定程序的进程运行状态，并将输出重定向到文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ ps aux | grep httpd &gt; &#x2F;tmp&#x2F;ps.output</span><br><span class="line">[c.biancheng.net]$ cat &#x2F;tem&#x2F;ps.output</span><br><span class="line">mozhiyan  4101     13776  0   10:11 pts&#x2F;3  00:00:00 grep httpd</span><br><span class="line">root      4578     1      0   Dec09 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19984    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19985    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19986    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19987    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19988    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19989    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19990    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19991    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br></pre></td></tr></table></figure>


<p>【实例4】显示按用户名排序后的当前登录系统的用户的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ who | sort</span><br><span class="line">mozhiyan :0           2019-04-16 12:55 (:0)</span><br><span class="line">mozhiyan pts&#x2F;0        2019-04-16 13:16 (:0)</span><br></pre></td></tr></table></figure>

<p>who 命令的输出将作为 sort 命令的输入，所以这两个命令通过管道连接后会显示按照用户名排序的已登录用户的信息。</p>
<p>【实例5】统计系统中当前登录的用户数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ who | wc -l</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h2 id="管道与输入重定向"><a href="#管道与输入重定向" class="headerlink" title="管道与输入重定向"></a>管道与输入重定向</h2><p>输入重定向操作符&lt;可以在管道中使用，以用来从文件中获取输入，其语法类似下面这样：</p>
<p>command1 &lt; input.txt | command2<br>command1 &lt; input.txt | command2 -option | command3</p>
<p>例如，使用 tr 命令从 os.txt 文件中获取输入，然后通过管道将输出发送给 sort 或 uniq 等命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ cat os.txt</span><br><span class="line">redhat</span><br><span class="line">suse</span><br><span class="line">centos</span><br><span class="line">ubuntu</span><br><span class="line">solaris</span><br><span class="line">hp-ux</span><br><span class="line">fedora</span><br><span class="line">centos</span><br><span class="line">redhat</span><br><span class="line">hp-ux</span><br><span class="line">[c.biancheng.net]$ tr a-z A-Z &lt;os.txt | sort</span><br><span class="line">CENTOS</span><br><span class="line">CENTOS</span><br><span class="line">FEDORA</span><br><span class="line">HP-UX</span><br><span class="line">HP-UX</span><br><span class="line">REDHAT</span><br><span class="line">REDHAT</span><br><span class="line">SOLARIS</span><br><span class="line">SUSE</span><br><span class="line">UBUNTU</span><br><span class="line">[c.biancheng.net]$ tr a-z A-Z &lt;os.txt | sort | uniq</span><br><span class="line">CENTOS</span><br><span class="line">FEDORA</span><br><span class="line">HP-UX</span><br><span class="line">REDHAT</span><br><span class="line">SOLARIS</span><br><span class="line">SUSE</span><br><span class="line">UBUNTU</span><br></pre></td></tr></table></figure>

<h2 id="管道与输出重定向"><a href="#管道与输出重定向" class="headerlink" title="管道与输出重定向"></a>管道与输出重定向</h2><p>你也可以使用重定向操作符&gt;或&gt;&gt;将管道中的最后一个命令的标准输出进行重定向，其语法如下所示：</p>
<p>command1 | command2 | … | commandN &gt; output.txt<br>command1 &lt; input.txt | command2 | … | commandN &gt; output.txt</p>
<p>【实例1】使用 mount 命令显示当前挂载的文件系统的信息，并使用 column 命令格式化列的输出，最后将输出结果保存到一个文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ mount | column -t &gt;mounted.txt</span><br><span class="line">[c.biancheng.net]$ cat mounted.txt</span><br><span class="line">proc         on  &#x2F;proc                  type  proc        (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">sysfs        on  &#x2F;sys                   type  sysfs       (rw,nosuid,nodev,noexec,relatime,seclabel)</span><br><span class="line">devtmpfs     on  &#x2F;dev                   type  devtmpfs    (rw,nosuid,seclabel,size&#x3D;496136k,nr_inodes&#x3D;124034,mode&#x3D;755)</span><br><span class="line">securityfs   on  &#x2F;sys&#x2F;kernel&#x2F;security   type  securityfs  (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">tmpfs        on  &#x2F;dev&#x2F;shm               type  tmpfs       (rw,nosuid,nodev,seclabel)</span><br><span class="line">devpts       on  &#x2F;dev&#x2F;pts               type  devpts      (rw,nosuid,noexec,relatime,seclabel,gid&#x3D;5,mode&#x3D;620,ptmxmode&#x3D;000)</span><br><span class="line">tmpfs        on  &#x2F;run                   type  tmpfs       (rw,nosuid,nodev,seclabel,mode&#x3D;755)</span><br><span class="line">tmpfs        on  &#x2F;sys&#x2F;fs&#x2F;cgroup         type  tmpfs       (rw,nosuid,nodev,noexec,seclabel,mode&#x3D;755)</span><br><span class="line">#####此处省略部分内容#####</span><br></pre></td></tr></table></figure>


<p>【实例2】使用 tr 命令将 os.txt 文件中的内容转化为大写，并使用 sort 命令将内容排序，使用 uniq 命令去除重复的行，最后将输出重定向到文件 ox.txt.new。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ cat os.txt</span><br><span class="line">redhat</span><br><span class="line">suse</span><br><span class="line">centos</span><br><span class="line">ubuntu</span><br><span class="line">solaris</span><br><span class="line">hp-ux</span><br><span class="line">fedora</span><br><span class="line">centos</span><br><span class="line">redhat</span><br><span class="line">hp-ux</span><br><span class="line">[c.biancheng.net]$ tr a-z A-Z &lt;os.txt | sort | uniq &gt;os.txt.new</span><br><span class="line">[c.biancheng.net]$ cat os.txt.new</span><br><span class="line">CENTOS</span><br><span class="line">FEDORA</span><br><span class="line">HP-UX</span><br><span class="line">REDHAT</span><br><span class="line">SOLARIS</span><br><span class="line">SUSE</span><br><span class="line">UBUNTU</span><br></pre></td></tr></table></figure>



<h3 id="管道"><a href="#管道" class="headerlink" title="管道 |"></a>管道 |</h3><p>linux允许讲一个命令的输出可以通过管道作为另一个命令的输入。（有用）</p>
<p>例： ls -lha ~| more: 用more查看</p>
<p>例： ls -lha ~| grep vi: 把match vi的输出，找出来。</p>
]]></content>
  </entry>
  <entry>
    <title>数据链路层1</title>
    <url>/2020/05/10/network4/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>复制自：<a href="https://www.cnblogs.com/zhangyinhua" target="_blank" rel="noopener">https://www.cnblogs.com/zhangyinhua</a></p>
<p>阅读目录(Content)**</p>
<ul>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7608173.html#_label0" target="_blank" rel="noopener">一、数据链路层概述</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7608173.html#_label1" target="_blank" rel="noopener">二、数据链路层的三个问题</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7608173.html#_lab2_1_0" target="_blank" rel="noopener">2.1、封装成帧</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7608173.html#_lab2_1_1" target="_blank" rel="noopener">2.2、透明传输</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7608173.html#_lab2_1_2" target="_blank" rel="noopener">2.3、差错检测</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7608173.html#_label2" target="_blank" rel="noopener">三、可靠传输</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7608173.html#_lab2_2_0" target="_blank" rel="noopener">3.1、停止等待协议</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7608173.html#_label3" target="_blank" rel="noopener">四、两种信道下的数据链路层</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7608173.html#_lab2_3_0" target="_blank" rel="noopener">4.1、点对点协议</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7608173.html#_lab2_3_1" target="_blank" rel="noopener">4.2、广播信道的数据链路层</a></li>
</ul>
</li>
</ul>
<p>前言</p>
<p>　　其实前面一堆讲的物理层的概念，会感觉特别的难理解，因为这是一个非常强大的计算机网络体系的底层知识，没有关系！我们大致了解一下就行了。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7608173.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="一、数据链路层概述"><a href="#一、数据链路层概述" class="headerlink" title="一、数据链路层概述"></a>一、数据链路层概述</h1><p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928193809950-1447379733.png" alt="img"></p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928194020294-559534854.png" alt="img"></p>
<p>　　这是百度的简介　</p>
<p>看图：理解一下，数据链路层之间的运输、数据链路层之间的信道</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928173627059-1905882554.png" alt="img"></p>
<p>　　链路：一条点到点的物理线路段，中间没有任何其他的交换结点，通俗的将，就是一根线，其中不经过任何东西，这样的就是链路，一条链路只是一条通路的一个组成部分</p>
<p>　　数据链路：除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。 通俗讲，就是经过了一些交换机呀，什么的。</p>
<p>　　　　　　　最终到达目的地，所有路段就是数据链路，而数据链路中就包含了多段链路。</p>
<p>　　适配器：也就是网卡，就是用来实现数据链路上一些协议。</p>
<p>　　帧：数据链路层上传送的就是帧</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928173936137-1414746580.png" alt="img"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7608173.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="二、数据链路层的三个问题"><a href="#二、数据链路层的三个问题" class="headerlink" title="二、数据链路层的三个问题"></a>二、数据链路层的三个问题</h1><p>封装成帧、透明传输、差错控制</p>
<p>讲解如何封装帧，封装完后帧的传输问题、传输到达目的地，如何检验该段帧是否完整</p>
<h2 id="2-1、封装成帧"><a href="#2-1、封装成帧" class="headerlink" title="2.1、封装成帧"></a>2.1、封装成帧</h2><p>　　数据链路层就是在ip数据报的前面和末尾加了一个首部和尾部来代表ip数据包的开始和结束，首部和尾部都是由8位二进制数表示的，可以一样也可以不一样。</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928182525856-1176225247.png" alt="img"></p>
<h2 id="2-2、透明传输"><a href="#2-2、透明传输" class="headerlink" title="2.2、透明传输"></a>2.2、透明传输</h2><p>　　有一个这样的问题， 在ip数据包中如果有一个跟帧尾部一样的8位二进制数，则会提前结束接受数据包，这样数据就被破坏了。出现了如下图这样的问题：</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928182708669-515435767.png" alt="img"></p>
<p>　　解决：通过在特殊字符前面增加一个转义字符 ESC， 就可以解决上面所遇到的问题，在接收端，将数据包中所有ESC的字符删除，</p>
<p>　　　　　　遇到两个ESC的，就删除第一个，这样一开始传输的时候有ESC转义字符，接受完就没了，所以说的是透明传输</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928182806122-734356031.png" alt="img"></p>
<h2 id="2-3、差错检测"><a href="#2-3、差错检测" class="headerlink" title="2.3、差错检测"></a>2.3、差错检测</h2><p>　　问题：传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。</p>
<p>　　为了检测传送的帧中ip数据包是否完整，是否没有被损坏，所以需要差错检测</p>
<p>　　解决：循环冗余检测CRC，截个图，把概念性的文字截下来，看到这个人都晕了，其实很简单。</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928183220450-1180825034.png" alt="img"></p>
<p>　　按照下图中的7步走，理解一下，然后再看上面的文字，就理解了</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928183254325-749599223.png" alt="img">　　</p>
<p>　　检测：</p>
<p>　　　　若得出的余数 R = 0，则判定这个帧没有差错，就接受(accept)。</p>
<p>　　　　若余数 R ≠ 0，则判定这个帧有差错，就丢弃</p>
<p>　　生成多项式：也很简单，例如上面的除数1101 就用P(X)=X3+X2+1　(X3是x的三次方的意思) 最高位是2的三次方，就是x的三次方这样算，例如，101101 P(X)=X5+X3+X2+1</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7608173.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="三、可靠传输"><a href="#三、可靠传输" class="headerlink" title="三、可靠传输"></a>三、可靠传输</h1><p>在有些情况下，我们需要数据链路层向上的网络层提供“可靠传输”的服务，就是发送端发送什么，在对应的接收端就收到什么， 前面的CRC只能检测出位数的差错，不能正确的检测出更精准的错误。</p>
<h2 id="3-1、停止等待协议"><a href="#3-1、停止等待协议" class="headerlink" title="3.1、停止等待协议"></a>3.1、停止等待协议</h2><p>　　停止等待就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。　　　　　　　</p>
<p>　　超时重传：解决上面如果数据分组或确认分组丢失时，发送方将会一直等待接收方的确认分组的问题，设置一个超时计时器，</p>
<p>　　　　　　　　若到了超时计时器所设置的重传时间，而发送方仍收不到接收方的任何确认分组，则会重传原来的分组。</p>
<p>　　重复分组：如果只使用超时重传来解决，不用发送确认分组，那么会出现重复分组的问题，就是当接收方收到分组后，发回确认分组时，确认分组丢失，</p>
<p>　　　　　　　　那么会触发超时重传，则接收方会收到两个重复的分组，这里需要注意的是，是确认分组丢失。第一次发送的分组已经正确接收了。</p>
<h2 id="3-2、停止等待算法"><a href="#3-2、停止等待算法" class="headerlink" title="3.2、停止等待算法"></a>3.2、停止等待算法</h2><p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928184101278-364914593.png" alt="img">)<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928184127169-796346714.png" alt="img"></p>
<p>　　画图分析一下：</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928184252825-1306293443.png" alt="img"></p>
<h2 id="3-2、退回N步协议"><a href="#3-2、退回N步协议" class="headerlink" title="3.2、退回N步协议"></a>3.2、退回N步协议</h2><p>　　其实跟停止等待协议差不多，只是使用的是流水线传输方式，发送方不间断的发送分组，每次发送的分组大小有限制，如果不限制，可能会使接收方或网络来不及处理这些分组，</p>
<p>　　导致分组的丢失，所以每次发送的分组大小可能是5，6或者更多。这种限制就是回退N步协议。</p>
<p>　　回退N步协议：利用发送窗口来限制发送方连续发送分组的个数。要是发送窗口为1就是我们上面所讨论的停止等待协议。</p>
<p>　　退回等待是怎么工作：</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928184517450-117176301.png" alt="img"></p>
<p>　　这个就是回退N步协议，根据这个原理图，也能看出，为什么叫回退N步协议了，在哪里出错了，就必须回退到哪里全部重传，为了解决这个，又有了选择重传协议</p>
<h2 id="3-3、选择重传协议"><a href="#3-3、选择重传协议" class="headerlink" title="3.3、选择重传协议"></a>3.3、选择重传协议</h2><p>　　改进回退N布协议， 方式都是一样， 在接受方必须逐一确认， 但是出现错误，只需要重传出现错误的那一个分组，不用全部重传，这里的全部，指的是在出现错误的分组之后的所有分组，前提是在同一个发送窗口中。</p>
<p>总结：不可靠的链路上，通过各种协议，就能达到可靠传输，来保证数据的准确性</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7608173.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="四、两种信道下的数据链路层"><a href="#四、两种信道下的数据链路层" class="headerlink" title="四、两种信道下的数据链路层"></a>四、两种信道下的数据链路层</h1><p>点对点信道的数据链路层、 广播信道的数据链路层</p>
<h2 id="4-1、点对点协议"><a href="#4-1、点对点协议" class="headerlink" title="4.1、点对点协议"></a>4.1、点对点协议</h2><p>　　概述：现在全世界使用的最多的数据链路层协议就是点对点协议PPP(Point to Point Protocol)，我们大多数用户使用的拨号电话线接入因特网时，一般使用的就是PPP协议</p>
<p>　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928185330294-867382243.png" alt="img"></p>
<p>　　1）PPP协议的特点　</p>
<p>·　　　　简单：接收方每接收一个帧，就进行CRC检验，检验正确，就收下，否则就丢弃，它是不可靠传输，所以这就是简单的原因</p>
<p>　　　　封装成帧：前一章已经讲过</p>
<p>　　　　多种网络层协议：数据链路层的上一层就是网络层，所以它同时支持多种网络层协议的运行</p>
<p>　　　　多种类型链路：比如，串行的、并行的，（串行：一个比特一个比特发送，只需要一条线路，并行：一次性传输n个比特，所以需要n条线路，所以叫并行）同步的、异步的（同步：以稳定的比特流</p>
<p>　　　　　　　　　　　　的形式传输 异步：以字节为独立的传输单位，字节跟字节之间的时间间隔不确定，但字节中的每个比特仍是同步的。），低速或高速、电或光，等不同类型的链路都能支持</p>
<p>　　　　差错检测：就是用CRC来检验</p>
<p>　　　　透明传输</p>
<p>　　　　检测连接状态：检测点跟点之间的连接状态，也就是在PC机和ISP之间的线路。</p>
<p>　　　　最大传送单位：PPP协议帧有最大的传送单元，发送的分组不能超过这个最大长度</p>
<p>　　　　网络层地址协商：使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址，通俗的讲，就是在分配IP地址时，就现需要这个协商才能解决</p>
<p>　　2）PPP协议的组成　</p>
<p>　　　　2.1）数据链路层可以用于异步串行或同步串行介质，通俗讲也就是可以适应多种性质的链路，有这种介质存在</p>
<p>　　　　2.2）使用LCP(链路控制协议)建立并维护数据链路连接， 也就是上面讲的一些维护链路连接、检测连接状态等功能，就是用它来实现的</p>
<p>　　　　2.3）网络控制协议(NCP)允许点到点连接上使用多种网络层协议，也就是因为跟网络层连接在一起，所以需要支持上一层的多种协议，这样才能完成一系列的功能，比如，网络层地址协商。</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928185904044-927531478.png" alt="img"></p>
<p>　　3）PPP协议帧格式</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928190025231-1932719506.png" alt="img"></p>
<p>　　4）PPP协议帧传输时透明输出问题</p>
<p>　　4.1）字节填充：</p>
<p>　　　　使用的是字节传输，也就是异步，所有的PPP帧的长度都是整数字节，所以会出现IP数据包中有字节跟开始结束标志字节相同的问题</p>
<p>　　　　解决： 标志字段 F = 0x7E　　　</p>
<p>　　　　　　IP数据包中出现0x7E字节 ： 转变为  0x7D、0x5E</p>
<p>　　　　　　IP数据包中出现0x7D：0x7D、0x5D　</p>
<p>　　　　IP数据包中出现ASCII码的控制字符，则在该控制字符前面加0x7D</p>
<p>　　4.2）零比特填充方法</p>
<p>　　　　使用的是比特流传输(一连串的比特连续传送)，也就是同步，PPP协议就采用零比特填充方法来实现透明传输。</p>
<p>　　5）PPP协议的工作流程</p>
<p>　　链路静止、链路建立、鉴别、网络层协议、链路打开、链路终止 大概流程图就是下面这个图这样：</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928191400637-978859538.png" alt="img"></p>
<p>　　　　六步的具体实现细节（验证了PPP协议的三个组成部分）：</p>
<p>　　　　1）链路静止到链路建立：用户拨号接通ISP拨号服务器后，就创建了PC机到ISP服务器的物理连接，这里面的细节就归咎于物理层的功劳了，</p>
<p>　　　　　　创建了一条怎么样的信道，通过什么传送数据，都是物理层需要做的事情。</p>
<p>　　　　2）链路建立到鉴别：建立了物理连接后，PPP中LCP(链路控制协议)就需要做事了，LCP协商一些配置选项(链路上的最大帧长，所使用的鉴别协议，或者不使用PPP帧中的地址和控制字段)，</p>
<p>　　　　　　如何跟ISP协商这些呢，就是通过发送LCP的配置请求帧，而ISP也可以发送几种响应，配置确认帧：所有选项都接受 配置否认帧：所有选项都理解但不能接受 配置拒绝帧：有的选项无法</p>
<p>　　　　　　识别或不能接受，需要协商。 通过一系列的协商后，此过程就结束了，就到了鉴别状态，如果协商失败，就直接回到链路静止状态。</p>
<p>　　　　3）鉴别到网络层协议：这里到达网络层协议之间做的事情就是鉴别身份，这里感觉还没学习到，大概就是鉴别一些用户的身份信息，比如交钱了没有等等吧，猜的。这一阶段可以去查查，估计之后</p>
<p>　　　　　　会遇得到。给出参考答案：只允许传送LCP协议的分组、鉴别协议的分组以及检测链路质量的分组。若使用口令鉴别协议PAP(Password Authentication Protocol)，则需要发起通信的一方发送身份标识符和口令。</p>
<p>　　　　　　系统可运行用户重试若干次。如果需要有更好的安全性，则可使用更加复杂的口令握手鉴别协议CHAP(Challenge-Handshake Authentication Protocol)。若鉴别身份失败，则转到链路终止状态(Link Dead)。</p>
<p>　　　　　　若鉴别成功，则进入网络层协议状态(Network-Layer Protocol)。</p>
<p>　　　　4）网络层协议到链路打开：前面已经经过了PPP协议的前两层，接下来就是NCP(网络控制协议)做事的时候了，这一阶段就是给PC机分配一个IP地址和对链路层进行网络层协议的设置，让链路层能支持网络层的工作</p>
<p>　　　　5）链路打开到链路终止：进行传输数据，如果传输完成，就发送终止请求分组，收到终止确认分组后，就到了终止状态，</p>
<p>　　　　6）链路终止到链路静止：当物理层没有载波时，就到静止状态</p>
<h2 id="4-2、广播信道的数据链路层"><a href="#4-2、广播信道的数据链路层" class="headerlink" title="4.2、广播信道的数据链路层"></a>4.2、广播信道的数据链路层</h2><p>　　讲解广播信道的知识，就必须要提到以太网，但是现在大多数人已经把以太网就当成局域网了，现在来说清楚以太网和局域网的区别</p>
<p>　　1）以太网和局域网的区别　</p>
<p>　　　　以太网是通信协议标准，该标准定义了在局域网（LAN）中采用的电缆类型和信号处理方法，比如有CSMA/CD协议，这个协议后面会讲到。</p>
<p>　　　　局域网：在较小范围内组建的网络，通过交换器什么的连接各个PC机，比如一个实验室，一栋楼，一个校园内，这都市局域网，拿网线将两台计算机连在一起，这也能算是局域网，</p>
<p>　　　　所以：以太网是一种局域网，而局域网却不一定是以太网，大多数局域网就是采用了以太网的这个标准，所以很多人就将局域网默认为以太网，这种说法是有点偏差的。</p>
<p>　　在局域网中，就采用的是广播信道</p>
<p>　　广播信道：就是一台PC机发送数据给另一台PC机，在同一个局域网中的计算机都能接收到该数据，这就像广播一样，所以这种就叫做广播信道。</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>数据链路层2</title>
    <url>/2020/05/10/network5/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>复制自：<a href="https://www.cnblogs.com/zhangyinhua" target="_blank" rel="noopener">https://www.cnblogs.com/zhangyinhua</a></p>
<p><strong>阅读目录(Content)</strong></p>
<ul>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_label0" target="_blank" rel="noopener">一、局域网</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_lab2_0_0" target="_blank" rel="noopener">1.1、局域网和以太网的区别和联系</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_lab2_0_1" target="_blank" rel="noopener">1.2、以太网常用的拓扑结构</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_label1" target="_blank" rel="noopener">二、CSMA/CD协议（半双工通信）</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_lab2_1_0" target="_blank" rel="noopener">2.1、概述</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_lab2_1_1" target="_blank" rel="noopener">2.2、详细描述</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_label2" target="_blank" rel="noopener">二、以太网信道利用率问题</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_lab2_2_0" target="_blank" rel="noopener">2.1、最大信道利用率</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_lab2_2_1" target="_blank" rel="noopener">三、PC机与PC机怎么找到对方</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_label3" target="_blank" rel="noopener">三、扩展以太网</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_lab2_3_0" target="_blank" rel="noopener">3.1、集线器</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_label4" target="_blank" rel="noopener">四、高速以太网</a></p>
</li>
</ul>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="一、局域网"><a href="#一、局域网" class="headerlink" title="一、局域网"></a>一、局域网</h1><h2 id="1-1、局域网和以太网的区别和联系"><a href="#1-1、局域网和以太网的区别和联系" class="headerlink" title="1.1、局域网和以太网的区别和联系"></a>1.1、局域网和以太网的区别和联系</h2><p>局域网：前面已经介绍了，其实就是学校里面、各个大的公司里，自己组件的一个小型网络，这种就属于局域网。</p>
<p>以太网：以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带局域网规范，是当今现有局域网采用的最通用的通信协议标准。</p>
<p>　　　　以太网络使用CSMA/CD（载波监听多路访问及冲突检测）技术，并以10M/S的速率运行在多种类型的电缆上。</p>
<p>联系：是以太网就一定是局域网，但是局域网不一定就是以太网。 因为以太网就是一个规范，而大多数局域网都使用这个规范，所以才有这个话。</p>
<h2 id="1-2、以太网常用的拓扑结构"><a href="#1-2、以太网常用的拓扑结构" class="headerlink" title="1.2、以太网常用的拓扑结构"></a>1.2、以太网常用的拓扑结构</h2><p>　　1）星状</p>
<p>　　　　这种结构的网络是各<a href="https://baike.baidu.com/item/工作站" target="_blank" rel="noopener">工作站</a>以星形方式连接起来的，网中的每一个节点设备都以中防节为中心，通过连接线与中心 节点相连，如果一个工作站需要传输数据，它首先必须通过中心节点。</p>
<p>　　　　由于在这种结构的网络系统中，中心节点是控制中心，任意两个节点间的<a href="https://baike.baidu.com/item/通信" target="_blank" rel="noopener">通信</a>最多只需两步，所以，能够传输速度快，并且网络构形简单、建网容易、便于控制和管理。但这种网络系统，</p>
<p>　　　　网络可靠性低，<a href="https://baike.baidu.com/item/网络共享" target="_blank" rel="noopener">网络共享</a>能力差，并且一旦中心节点出现故障则导致全网瘫痪。</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928194915965-1222870584.png" alt="img"></p>
<p>　　2）树形　　</p>
<p>　　　　树形结构网络是天然的分级结构，又被称为分级的集中式网络。其特点<br>　　　　是网络成本低，结构比较简单。在网络中，任意两个节点之间不产生<a href="https://baike.baidu.com/item/回路" target="_blank" rel="noopener">回路</a>，每个链路都支持双向传输，并且，网络中节点扩充方便、灵活，寻查链路路径比较简单。</p>
<p>　　　　但在这种结构网络系统中，除叶节点及其相连的链路外，任何一个工作站或链路产生故障会影响整个网络系统的正常运行。</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928195247169-1502379173.png" alt="img"></p>
<p>　　3）总线型</p>
<p>　　　　总线形结构网络是将各个节点设备和一根总线相连。网络中所有的节点工作站都是通过总线进行<a href="https://baike.baidu.com/item/信息" target="_blank" rel="noopener">信息</a>传输的。</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928195428559-235246537.png" alt="img"></p>
<p>　　4）环形　</p>
<p>　　　　环形结构是网络中各节点通过一条首尾相连的<a href="https://baike.baidu.com/item/通信链路" target="_blank" rel="noopener">通信链路</a>连接起来的一个闭合环形结构网。环形结构网络的结构也比较简单，系统中各工作站地位相等。</p>
<p>　　　　系统中通信<a href="https://baike.baidu.com/item/设备" target="_blank" rel="noopener">设备</a>和线路比较节省。在网中信息设有固定方向单向流动，两个工作站节点之间仅有一条通路，系统中无信道选择问题；某个结点的故障将导致物理瘫痪。</p>
<p>　　　　环网中，由于环路是封闭的，所以不便于扩充，系统响应延时长，且信息传输效率相对较低。</p>
<p><img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928195600590-678351288.png" alt="img"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="二、CSMA-CD协议（半双工通信）"><a href="#二、CSMA-CD协议（半双工通信）" class="headerlink" title="二、CSMA/CD协议（半双工通信）"></a>二、CSMA/CD协议（半双工通信）</h1><p>局域网是用广播信道的方式去传送数据，那么就会遇到问题，如果在局域网内有两个pc机同时在其中传播数据呢？就会发生碰撞，使两个数据都失效，那么如何解决这个问题呢，使用CSMA/CD协议来解决这类问题。</p>
<h2 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h2><p>　　1）多址接入</p>
<p>　　　　一种多址接入协议，许多站点以多址接入的方式链接在一根总线上，其实就是局域网中总线网这种形式。</p>
<p>　　2）载波监听</p>
<p>　　　　发送前监听，就是在发送数据前监听总线中是否有数据在传播，如果有就不发送。就是用电子技术检测总线上有没有其他计算机发送的数据信号。</p>
<p>　　3）碰撞检测</p>
<p>　　　　边发送边监听，在发送数据的中途也会监听总线中是否会有其它数据，当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。</p>
<p>　　　　当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。 所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”</p>
<p>　　　　检测到碰撞之后：　　　　　</p>
<p>　　　　　　在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</p>
<p>　　　　　　每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</p>
<p>　　　　　　通过例子也说明一下CSMA/CD协议会做哪些事情，借用下面这个图来说明问题</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928200359294-306129888.png" alt="img"></p>
<p>　　　　　　分析：</p>
<p>　　　　　　　　第一步：B向D发送数据，在发送数据前，由于采用的CSMA/CD协议，那么先会进行载波监听，看总线中是否有其他的数据传输(如果检测，通过物理层的一些电磁波等)。</p>
<p>　　　　　　　　第二步：如果没有，那么B就可以开始发送数据，由于B到D之间存在一定距离，那么在总线中传输数据也要时间，虽然很快，可能只需要十几微秒，在发送的的途中，遇到C向A发送数据，</p>
<p>　　　　　　　　　　　　由于B到D的数据还没传过来，那么C也就没监听到总线中有数据，所以也开始发，那么在途中两个数据就会相遇，这就形成了碰撞，在碰撞以后，两个电磁波叠加，在总线中传输，</p>
<p>　　　　　　　　　　　　那么会到C或者B时，就会知道电磁波的不同，从而发生了碰撞。这就是碰撞检测。</p>
<h2 id="2-2、详细描述"><a href="#2-2、详细描述" class="headerlink" title="2.2、详细描述"></a>2.2、详细描述</h2><p>　　1）解释名词</p>
<p>　　传播延时：<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928201111794-1443030176.png" alt="img"></p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928201056044-1441169231.png" alt="img"></p>
<p>　　争用期：发生碰撞所需要的最迟时间。在根据上面的大体分析，我们知道A到B之间的任意时刻都可能会发生碰撞，那么A确认发生碰撞要多久呢，那就是2t 了，传播时延是t，</p>
<p>　　　　　　可能正好到B那里就发生了碰撞，然后返回到A，又需要t的时间，那就是2t了，我们把这个2t时间就叫做争用期。</p>
<p>　　　　举例：在10Mb/s(传播速率)的以太网，争用期为51.2μs（微秒），那么在争用期内可发送64字节，及512bit的数据。怎么算来的呢？　　</p>
<p>　　　　　　10Mb/s = 10 000 Kb/s = 10 000 000 b/s (这里的换算是1000，指的是计算机网络中传输的多少位多少位，也就是0101这样的位数)</p>
<p>　　　　　　51.2μs = 0.0512 ms = 0.000 0512 s (1s = 1000ms = 1000 000 μs)</p>
<p>　　　　　　51.2μs能传多少bit呢？ 上面两个相乘就为 512bit 了，换算为字节，字节的换算是 1byte(字节) = 8bit(位) 所以 512/8=64byte(字节) 就这样算过来的。</p>
<p>　　最短有效帧：64字节，就是上面这样算的，发送了64个字节之后，肯定就不会发生碰撞，以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。</p>
<p>　　2）二进制指数类型退避算法</p>
<p>　　　　这个算法就是在发生碰撞后，pc机该如何处理，在什么时间后再次发送数据。</p>
<p>　　　　其实就是四部曲：　</p>
<p>　　　　　　第一步：确定基本退避时间，一般就是争用期2t</p>
<p>　　　　　　第二步：定义参数k K = Min[重传次数，10]</p>
<p>　　　　　　第三步：从整数集合中<img src="https://images2015.cnblogs.com/blog/874710/201611/874710-20161118165109607-266731860.png" alt="img">[0,1,…,(2的k次方 -1)]随机取一个数，记为r，重传所需要等待的时延就是r倍的基本退避时间(2rt)</p>
<p>　　　　　　第四步：当重传16次还不能成功则丢弃该帧，并向高层汇报</p>
<p>　　　　解释：其实这四步很简单，我来分析一下就会了，首先第一次传数据，重传次数为0，那么k=0，从整数集合中只有0这个值，那么r=0，等待的时延就是2rt=0，所以第一次传数据需要等待的时延就是0，</p>
<p>　　　　　　不需要等待，除非先检测到了有数据已经在传了，如果第一传数据发现碰撞，那么重传次数为1，那么k=1，整数集合中就有0，1两个值，随机取值，取到r=1，那么等待的时延就是2t，意思就是</p>
<p>　　　　　　在第一次发生碰撞后，需要等待2t的时间，才能在重新发送数据，也可能不需要等就直接发，r=0时。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="二、以太网信道利用率问题"><a href="#二、以太网信道利用率问题" class="headerlink" title="二、以太网信道利用率问题"></a>二、以太网信道利用率问题</h1><p>　　分析图：</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928202011122-609949332.png" alt="img"></p>
<p>　　分析：一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功(发送成功这段时间T0是指数据的发送时延，帧长为 L (bit)，数据发送速率为 C (b/s)，因而帧的发送时间为 L/C = T0 (s))，</p>
<p>　　　　　帧发出去以后，还要经过端到端的传播时延t，所有在真正占用信道的时间是 TO+t ，前面发生的碰撞损耗的时间，数据并没有占用信道，我们指真正占用信道的时间是指数据发送成功即不发生</p>
<p>　　　　  碰撞然后到达目的地的这段时间，而前面发生碰撞的时间，都市在浪费信道，每发送一帧需要的平均时间就是在信道中发生碰撞浪费的时间+上数据传输成功所用的占用期。不要理解错了。</p>
<p>　　公式和参数a的理解：　<img src="https://images2015.cnblogs.com/blog/874710/201611/874710-20161118170730435-1688609334.png" alt="img"> 首先理解一下信道利用率，借用上面的图，就是占用期在其图中的比例变大，则信道利用率就高。但是不确定前面发生了多少次碰撞，</p>
<p>　　　　　　　　　　　　只是一个平均的估算值，所以就定义了这个a的公式，用t/T0来代表信道利用率</p>
<p>　　1）a→0 表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。</p>
<p>　　　　a→0也就是t越小，而T0越大，发送时延尽可能大一点，而t传播时延尽可能小一点，现实意义就是数据在在信道中传播的时间如果很小很小，那么数据一发送，</p>
<p>　　　　就能在很少的时间里面检测出碰撞来了，那么在前面那张图中，花费在争用期(发生碰撞)的时间就少了，就能快点成功发送数据占的时间就长了了，那信道的利用率不就很高吗，</p>
<p>　　2）a 越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低</p>
<p>　　　　就是T0越小，而r很大，那发生一次碰撞就浪费了很多信道资源，因为在信道中传输无用的波占的时间太长了。而成功发送的占用期自然就变小了，所以信道利用率就越低了。</p>
<p>　　　　根据上面的分析信道利用率，就发现，影响信道利用率的就跟T0和t有关，也就是跟以太网的连线长度有关，所以才有在以太网中，有最远距离的限制，就是不能让t太大，</p>
<p>　　　　以至于a很大，信道利用率太低，还有发送的帧长也有最小帧长的限制，因为怕发送的数据帧太短，而发送速率就一定，那么发送时延T0就太小了，会让a的值越大，信道利用率就太低了。</p>
<h2 id="2-1、最大信道利用率"><a href="#2-1、最大信道利用率" class="headerlink" title="2.1、最大信道利用率"></a>2.1、最大信道利用率</h2><p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928211132075-384776676.png" alt="img"></p>
<p>　　理想的情况下就是不发生碰撞，一发送完数据，另一个数据就又发送，也就是一有空闲时间，就发送数据。这个时候，信道中一直有数据在传输，一刻也不停歇，那此时的信道利用率就是100了？</p>
<p>　　错误，这个想法是错的，举个例子就知道了。每帧用的时间就是下面图中这块，这块也就可以看成一段数据帧平均花费的时间，这里面所影响的因素就是发送时延T0和t传播时延了，一段数据帧平均花费的时间为1s，</p>
<p>　　这是已经固定了，但是其中的两个部分并没有确定，如果T0占的比例大，说明发送时延大，发送速率已经确定了，那么就肯定是发送的数据变多了，在信道中传输的bit更过，信道利用率不就更到了吗，通俗一点讲，</p>
<p>　　就是给了你1s的时间，你尽可能的多发些bit过去，那么你的传播时延就大了，那不就信道利用率的很高了吗，理想状态下考虑的因素跟那个现实考虑的因素不一样。</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928211205356-324379293.png" alt="img"></p>
<p>　　对CSMA/CD协议的讨论，大概就是这些内容了，刚才讨论的前提是已经知道谁发送给谁了，然后说的数据在传播过程中遇到的问题。</p>
<h2 id="三、PC机与PC机怎么找到对方"><a href="#三、PC机与PC机怎么找到对方" class="headerlink" title="三、PC机与PC机怎么找到对方"></a>三、PC机与PC机怎么找到对方</h2><p>用的就是MAC地址，在以太网中是如果封装数据帧来达到能够准确传输数据到目的地的呢？</p>
<p>MAC地址的格式：</p>
<p>　　　　48bit，6个字节，前3个字节是由管理机构给各个厂家分配的。也就是说如果有厂家想生产网卡这类需要mac地址的东西，必须先像管理机构申请前三位字节，</p>
<p>　　　　所以网卡上的前三个字节就代表着某个厂家，后三个字节就是由厂家自己来设定的。</p>
<p>每个网卡都拥有识别数据帧中mac地址的功能</p>
<p>数据帧格式：</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928211520137-1273778841.png" alt="img"></p>
<p>　　　　先不管前8个插入字节的意思，在以太网中，发送的数据帧最小要是64个字节，那这64个字节由哪些组成的呢，就是图中所示，6个目的MAC地址，6个源MAC地址，2个字节代表数据包的类型，</p>
<p>　　还有4个字节是FCS，用来进行CRC算法检测的，剩下的46个字节就是数据包最少要发送的字节数了，如果数据包实际发的少于46，那么会给这个数据包自动补充0，来达到需要的字节数。</p>
<p>　　　　然后说说插入的8个字节是什么意思？前7个字节用来使发送的数据帧的的比特同步，也叫作前同步码，最后一个字节，帧的开始定界符，也就是告诉接收方，从这个字节开始，后面是是MAC帧了。</p>
<p>　　 有人这个时候会问，既然有了帧开始定界符，为什么还要同步码？原因是，在接受MAC帧后，并不能马上识别出帧开始定界符，没有那么快的反应分辨出来，所以需要在前面加同步码，使接收方有反应的时间，</p>
<p>　　所以同步码都是1010101010101这样的bit。前7个字节的同步码跟最后一个字节中的前6个bit位相同。上面图中这里画的有点错误，圈错了，正确的是下面这样：</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928212200809-68985957.png" alt="img"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="三、扩展以太网"><a href="#三、扩展以太网" class="headerlink" title="三、扩展以太网"></a>三、扩展以太网</h1><p>集线器和网桥(多个接口的交换机)</p>
<h2 id="3-1、集线器"><a href="#3-1、集线器" class="headerlink" title="3.1、集线器"></a>3.1、集线器</h2><p>　　1）概述　　</p>
<p>　　集线器（HUB）属于数据通信系统中的基础设备，它和双绞线等传输介质一样，是一种不需任何软件支持或只需很少管理软件管理的硬件设备。它被广泛应用到各种场合。<strong>集线器工作在局域网(LAN)环境</strong>，</p>
<p>　　应用于OSI参考模型第一层，因此又被称为物理层设备。集线器内部采用了电器互联，当维护LAN的环境是逻辑总线或环型结构时，完全可以用集线器建立一个物理上的星型或树型网络结构。在这方面，集线器</p>
<p>　　所起的作用相当于多端口的中继器。其实，集线器实际上就是中继器的一种，其区别仅在于集线器能够提供更多的端口服务，所以集线器又叫多口中继器。<strong>HUB按照对输入信号的处理方式上，可以分为无源HUB、有源HUB、智能HUB。</strong></p>
<p>　　2）工作过程</p>
<p>　　集线器的工作过程是非常简单的，它可以这样的简单描述：首先是节点发信号到线路，集线器接收该信号，因信号在电缆传输中有衰减，<strong>集线器接收信号后将衰减的信号整形放大，最后集线器将放大的信号广播转发给其他所有端口。</strong></p>
<p>　　</p>
<p>　　就是只能够转发数据，来了就往接了集线器的PC机上发数据，其他什么差错校验呀，什么东西全都不做，</p>
<p>　　集线器的用法首先是下面这样</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928212435465-1812340623.png" alt="img"></p>
<p>　　然后想办法，改进成这样了</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928212456950-1568858435.png" alt="img">　</p>
<p>　　改完是有好处也有坏处</p>
<p>　　　　用集线器扩展局域网优点：</p>
<p>　　　　　　使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。</p>
<p>　　　　　　扩大了局域网覆盖的地理范围。</p>
<p>　　　　用集线器扩展局域网缺点：</p>
<p>　　　　　　碰撞域增大了，但总的吞吐量并未提高。</p>
<p>　　　　　　如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</p>
<p>　　由于集线器总有这样的缺点，所以网桥这个设备就出来了</p>
<h2 id="3-2、网桥"><a href="#3-2、网桥" class="headerlink" title="3.2、网桥"></a>3.2、网桥</h2><p>　　1）概述　　</p>
<p>　　　　也有人把“网桥”比喻成一个聪明的中继器（Repeater）。因为中继器只是对所接收的信号进行放大，然后直接发送到另一个端口连接的电缆上，主要用于扩展网络的物理连接范围；</p>
<p>　　而网桥除了可以扩展网络的物理连接范围外，还可以对MAC 地址进行分区，隔离不同物理网段之间的碰撞（也就是隔离“冲突域”）。集线器和中继器都是物理层设备，而网桥属于二层设备。<br>　　　　我们经常听到这样的说法，那就是“网桥”是一种可连接不同网段的二层网络设备（二层交换机也一样），一个端口可以连接一个网段。所以很多人总在纳闷，网桥怎么能连接不同网段呢？</p>
<p>　　其实这是因为大家对这里所说的“网段”并不理解。其实这里“网段”更准确地讲应该是叫“物理网段”，是指IP 地址属于同一网络地址段（也就是IP 地址中的网络ID一样），位于不同地理位置的不同LAN 分段，</p>
<p>　　是基于物理意义上的地理区域进行划分的。我们常说的网段是指IP 地址属于不同网络地址段的网络或子网，是一个三层概念，其实这应该叫做逻辑网段，是基于逻辑意义上的网络地址进行划分的。</p>
<p>　　（hzhsan:就是说这里的网段是物理网段，并不是我们平时说的IP网段，不关心三层上的概念）<br>　　　　无论是网桥，还是二层交换机，虽然每个端口可以连接一个网段，但是它们所连接的主机都在同一网络，或者同一子网中。如连接的主机位于不同办公室或者不同办公楼中，则可采用同一网络地址的两个或多个小LAN，</p>
<p>　　以组成一个可以统一管理的大LAN。但要注意的是，因为网桥只有两个端口，所以所连接的两个物理网段的主机通常就是由当时的集线器进行集中连接的（网桥端口通常不是直接连接主机的）。</p>
<p>　　软件中通常所说的桥接（如VMware中的桥接工作模式）也就是网桥的作用，它连接的也是同一网络或子网中的两个网段。<br>　　　　网桥都是只有两个端口吗？应该可以有多个端口吧？<br>　　　　答案：基本网桥只有两个端口，还有一种网桥叫做多口网桥，多口网桥有多个端口　</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928214637606-1168539342.png" alt="img">图1</p>
<p>　　2）优点</p>
<p>　　有两个优点，能识别mac地址，遇到陌生的mac地址，会在内部mac表中记录下该mac地址，下次再使用，就认识了</p>
<p>　　　　1.1）根据 MAC 帧的目的地址对收到的帧进行转发</p>
<p>　　　　2.2）过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口</p>
<p>　　3）网桥原理</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928212911622-459234442.png" alt="img">)<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928214748512-53992092.png" alt="img">图2</p>
<p>　　　　前面说到了网桥具有两种主要特性：一是可基于物理网段的MAC 地址进行学习，二是可以隔离冲突域。下面通过一个示例来进行解析。<br>　　假设图1 中所示的物理网段1 和物理网段2 中的主机都是通过集线器集中连接的，则这样这两个物理网段各自形成一个冲突域，因为集线器是采用共享介质传输的，</p>
<p>　　而网桥的背板信道不是共享的（每个端口的数据收发都有一条单独的信道），所以一个集线器就是一个冲突域。网桥的数据转发原理如图2所示。下面是具体的解析。<br>　　　　说明　MAC 地址表也就是通常所说的CAM（Content Addressable Memory，内容可寻址存储器）表，保存的是对应MAC 地址主机与所连接的交换机端口的映射。这个映射表项可以由管理员手动绑定创建，</p>
<p>　　也可以由交换机自动学习得到。在交换机上可以通过一些命令（如Cisco 交换机是使用show mac-address-table 命令）查看。下面是一个在交换机上查看MAC 地址和端口映射表的示例，其中列出了交换机中</p>
<p>　　为CPU 分配的静态（static）MAC 地址和通过学习功能自动学习得到的动态（dynamic）MAC 地址，其中的Ports 列显示的是对应MAC 地址主机所连接的端口，VLAN 列则为对应主机连接端口所属的VLAN。　　</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"> mac-address-table　</p>
<p>　　现假设图5-34 所示网络中的一台PC 要向另一台PC 发送数据。因为集线器也是物理层设备，不能识别帧中的MAC 地址，所以无论是哪台主机要发送数据，在集线器上都是以广播方式进行的，</p>
<p>　　连接该集线器上的所有节点都会收到这个广播帧，包括网桥连接到该集线器的端口。</p>
<p>　　　　1）当网桥收到集线器的广播帧后，网桥会把帧中的源MAC 地址和目的MAC 地址与网桥缓存中保存的MAC 地址表进行比较。</p>
<p>　　　　2）最初，网桥的缓存中是没有任何MAC 地址的，所以一开始它也不知道哪台主机在哪个物理网段上，收到的所有帧都直接以泛洪方式（也是复制原数据帧）转发到另一个端口上，</p>
<p>　　　　　　同时会把数据帧中的源MAC 地址所对应的物理网段记录下来（其实就是与对应的网桥端口对应起来）。</p>
<p>　　　　3）在数据帧被某个PC 机接收后，也会把对应目的MAC 地址所对应的物理网段记录在缓存中的MAC 表中。这样，经过多次这样的记录，就可以在MAC 地址表中把整个网络中各</p>
<p>　　　　　　主机MAC 地址与对应的物理网段全部记录下来。因为网桥的端口通常是连接集线器的，所以一个网桥端口会与多个主机MAC 地址进行映射。</p>
<p>　　　　4）当网桥收到的数据帧中源MAC 地址和目的MAC 地址都在网桥MAC 地址表中可以找到时，网桥会比较这两个MAC 地址是否属于同一个物理网段。如果是同一物理网段，</p>
<p>　　　　　　则网桥不会把该帧转发到下一个端口，直接丢弃，起到冲突域隔离作用。相反，如果两个MAC 地址不在同一物理网段，则网桥会把从一个物理网段发来的帧转发到连接</p>
<p>　　　　　　另一个物理网段上，然后再通过所连接的集线器进行复制方式的广播。</p>
<p>　　3）透明网桥　</p>
<p>　　　　局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的　　</p>
<p>　　　　是一种即插即用设备，其标准是 IEEE 802.1D</p>
<p>　　4）网桥的优点与缺点</p>
<p>　　优点：　　　</p>
<p>　　　　过滤通信量。</p>
<p>　　　　扩大了物理范围。</p>
<p>　　　　提高了可靠性。</p>
<p>　　　　可互连不同物理层、不同 MAC 子层和不同速率（如10 Mb/s 和 100 Mb/s 以太网）的局域网。</p>
<p>　　缺点：　　</p>
<p>　　　　存储转发增加了时延。</p>
<p>　　　　在MAC 子层并没有流量控制功能。</p>
<p>　　　　具有不同 MAC 子层的网段桥接在一起时时延更大。</p>
<p>　　　　网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7608818.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="四、高速以太网"><a href="#四、高速以太网" class="headerlink" title="四、高速以太网"></a>四、高速以太网</h1><p>从最早的使用集线器连接的以太网(CSMA/CD，半双工，10Mb/s)到使用网桥阶段的扩展以太网(CSMA/CD，半双工，10Mb/s或100Mb/s)到现在的高速以太网(半双工/全双工通信)。</p>
<h2 id="4-1、高速以太网"><a href="#4-1、高速以太网" class="headerlink" title="4.1、高速以太网"></a>4.1、高速以太网</h2><p>　　速率达到或超过100Mb/s的以太网</p>
<p>　　这个也没什么好讲的，就是在之前的基础上加强了很多东西，</p>
<p>　　　　速率提高了很多</p>
<p>　　　　从半双工通信到能使用全双工通信了(这个并不是说就抛弃了半双工，在星形拓扑结构中的局域网，也就使用CSMA/CD协议的半双工通信的方式，全双工就不使用该协议了)</p>
<p>　　　　传输距离可以增长，因为有了光纤(传输过程的稳定性)，速率增强很大，不止局限于局域网，扩展到了有城域网，广域网。</p>
<h2 id="4-2、10Gb-s以太网"><a href="#4-2、10Gb-s以太网" class="headerlink" title="4.2、10Gb/s以太网"></a>4.2、10Gb/s以太网</h2><p>　　1）概述</p>
<p>　　与 10 Mb/s，100 Mb/s 和 1 Gb/s 以太网的帧格式完全相同。</p>
<p>　　保留了 802.3 标准规定的以太网最小和最大帧长，便于升级。也就是最小64字节，最大是多少不知道。</p>
<p>　　不再使用铜线而只使用光纤作为传输媒体。</p>
<p>　　只工作在全双工方式，因此没有争用问题，也不使用 CSMA/CD 协议。</p>
<p>　　2）优点　　</p>
<p>　　　　成熟的技术</p>
<p>　　　　互操作性很好</p>
<p>　　　　在广域网中使用以太网时价格便宜。</p>
<p>　　　　统一的帧格式简化了操作和管理</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>应用层（DNS和HTTP）</title>
    <url>/2020/05/10/network8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>复制自：<a href="https://www.cnblogs.com/zhangyinhua" target="_blank" rel="noopener">https://www.cnblogs.com/zhangyinhua</a></p>
<p><strong>阅读目录(Content)</strong></p>
<ul>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7611420.html#_label0" target="_blank" rel="noopener">一、应用层概述</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7611420.html#_lab2_0_0" target="_blank" rel="noopener">1.1、应用层简介</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7611420.html#_lab2_0_1" target="_blank" rel="noopener">1.2、应用层中的应用软件分两种：客户/服务器和P2P体系结构</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7611420.html#_label1" target="_blank" rel="noopener">二、应用层协议之DNS协议</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7611420.html#_lab2_1_0" target="_blank" rel="noopener">2.1、DNS协议概述</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7611420.html#_lab2_1_1" target="_blank" rel="noopener">2.2、DNS协议工作过程</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7611420.html#_label2" target="_blank" rel="noopener">三 、应用层协议之HTTP协议</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7611420.html#_lab2_2_0" target="_blank" rel="noopener">3.1、HTTP协议简介</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7611420.html#_lab2_2_1" target="_blank" rel="noopener">3.2、统一资源定位符URL</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7611420.html#_lab2_2_2" target="_blank" rel="noopener">3.3、超文本传输协议</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7611420.html#_lab2_2_3" target="_blank" rel="noopener">3.4、请求和响应报文的格式</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7611420.html#_lab2_2_4" target="_blank" rel="noopener">3.5、HTTP协议功能</a></li>
</ul>
</li>
</ul>
<p>前言</p>
<p>到这一篇我已经把TCP/IP五层模型详细的说明了一遍，大体的从物理层到最上层的应用层做了一个大概的了解，其实总体学下来东西非常的多，我们需要经常的去系统性的去学习它。不然过一段时间就忘记了！</p>
<p>回顾一下前面的知识：</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929150555778-1593038196.png" alt="img"></p>
<p>　　OSI体系结构分为7层：物理层、链路层、网路层、传输层、会话层、表示层、应用层。</p>
<p>　　TCP/IP5层参考模型：物理层、数据链路层、网络层、传输层、应用层</p>
<p>　　TCP/IP的体系结构分为4层：网络接口层(物理层、链路层)、网际层(网络层IP)、传输层(UDP/TCP)、应用层(会话层、表示层、应用层)</p>
<p>　　原理体系结构：物理层、链路层、网络层、传输层、应用层(会话层+表示层+应用层)　　</p>
<p>　　　　OSI七层协议体系结构：优点：概念清楚，理论完整，缺点但是复杂而不实用</p>
<p>　　　　TCP/IP协议族四层，缺点：太简单，但被广泛使用</p>
<p>　　结合上面两个的优缺点，就有了5层协议的原理体系结构，即简洁又能把概念描述清楚。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7611420.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="一、应用层概述"><a href="#一、应用层概述" class="headerlink" title="一、应用层概述"></a>一、应用层概述</h1><h2 id="1-1、应用层简介"><a href="#1-1、应用层简介" class="headerlink" title="1.1、应用层简介"></a>1.1、应用层简介</h2><p>　　在百度中的介绍：</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929151612762-411546424.png" alt="img"></p>
<p>　　位于计算机网络体系结构的最上层，前面四层做的所有事情就是为了他服务，他也是设计和建立计算机网络的最终目的，通俗的讲，就是我们开发的应用软件，就处于这一层，</p>
<p>　　比如，QQ，浏览器访问网页，等等你看得到的应用软件都是在这一层，但是这些软件在运行的过程中，也需要依靠一些特定的协议才能完成相应的功能，</p>
<p>　　比如浏览器通过网址访问网页，其中是如何做到的，这就是我们所要学习的东西。</p>
<h2 id="1-2、应用层中的应用软件分两种：客户-服务器和P2P体系结构"><a href="#1-2、应用层中的应用软件分两种：客户-服务器和P2P体系结构" class="headerlink" title="1.2、应用层中的应用软件分两种：客户/服务器和P2P体系结构"></a>1.2、应用层中的应用软件分两种：客户/服务器和P2P体系结构</h2><p>　　1）客户/服务器(client/server)</p>
<p>　　　　这种类型，就是我们很熟悉的客户端，服务器模型，客户端请求服务器，服务器响应客户端这样的一种方式进行“交流”</p>
<p>　　2）P2P</p>
<p>　　　　也称为对等体系结构。P2P相当于每个人的电脑度可以当服务器，也可以当客户端，不单单限制于只能客户端访问服务器，</p>
<p>　　　　你自己的计算机可以去访问别人的计算机上的内容，别的同样可以访问你计算机上的内容，这样达到一种共享的状态。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7611420.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="二、应用层协议之DNS协议"><a href="#二、应用层协议之DNS协议" class="headerlink" title="二、应用层协议之DNS协议"></a>二、应用层协议之DNS协议</h1><h2 id="2-1、DNS协议概述"><a href="#2-1、DNS协议概述" class="headerlink" title="2.1、DNS协议概述"></a>2.1、DNS协议概述</h2><p>　　Domain Name System 域名系统。也可以叫做域名解析协议。在我们在浏览器访问网页的时候，通常度是用我们所熟悉的一连串有意义的英文字符标识，比如<a href="http://www.baidu.com、www.sohu.com等。" target="_blank" rel="noopener">www.baidu.com、www.sohu.com等。</a></p>
<p>　　但是我们学了前面的知识，计算机并不是通过这些字符串去找到对应的计算机，而是通过32位的二进制，也就是我们的IP地址来找。所以就有了DNS协议。他的作用就是将域名解析成对应的IP地址。</p>
<p>　　因为让我们人去记那些IP地址，很难记得住，所以就想办法让IP地址转变为了现在的域名，在进行访问的时候，只需要将域名解析为对应的IP地址就行了，这个域名也很有讲究，其中分为好多层域名，</p>
<p>　　是独一无二的。这里不细讲这个，只要我们知道，域名通过DNS能找到对应的IP地址就行了。</p>
<h2 id="2-2、DNS协议工作过程"><a href="#2-2、DNS协议工作过程" class="headerlink" title="2.2、DNS协议工作过程"></a>2.2、DNS协议工作过程</h2><p>　　1）通过域名访问网页</p>
<p>　　2）计算机会先将域名发送到一个解析域名的服务器上</p>
<p>　　　　2.1）在其服务器上有很多服务器，能解析各种各样的域名，比如有专门解析.org的，解析.com的，解析.net的。等等，最主要的有一个根域名服务器</p>
<p>　　　　2.2 ）域名解析(在服务器上查找IP地址)的过程有两种算法，迭代查询，递归查询。一般是两种查询的结合</p>
<p>　　　　2.3 ）本机计算机找到其中一台解析域名的服务器(可能是.com)，如果没有找到对应的IP地址，那么就会去找根域名服务器，根域名服务器知道所有的子服务器，</p>
<p>　　　　　　所以他肯定知道该域名所对应的IP地址在那个子服务器中，所以告诉第一次查询的服务器要他去另一台服务器上找，找到了，就将其返回给计算机，</p>
<p>　　　　　　以后在有另一台计算机也通过这个域名访问，那么第一台服务器会有原来的域名IP地址的缓存，就不用去找根服务器了。</p>
<p>　　3）找到了，就能找到我们要访问的服务器了。</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929152545044-57881135.png" alt="img"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7611420.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="三-、应用层协议之HTTP协议"><a href="#三-、应用层协议之HTTP协议" class="headerlink" title="三 、应用层协议之HTTP协议"></a>三 、应用层协议之HTTP协议</h1><h2 id="3-1、HTTP协议简介"><a href="#3-1、HTTP协议简介" class="headerlink" title="3.1、HTTP协议简介"></a>3.1、HTTP协议简介</h2><p>　　1）超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。<br>　　2）HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。</p>
<p>　　　（我们称这个客户端）叫用户代理（user agent）。应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个中间层，</p>
<p>　　　比如代理，网关，或者隧道（tunnels）。尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。 事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。</p>
<p>　　　HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。<br>　　3）通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，</p>
<p>　　   比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。</p>
<p>　　　HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。<br>　　4）通过HTTP或者HTTPS协议请求的资源由统一资源标示符（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。</p>
<h2 id="3-2、统一资源定位符URL"><a href="#3-2、统一资源定位符URL" class="headerlink" title="3.2、统一资源定位符URL"></a>3.2、统一资源定位符URL</h2><p>　　URL:统一资源定位符，通过下面格式，可以看出，就是用来定位我们所需要资源在服务器上的位置。</p>
<p>　　格式：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p>
<p>　　协议：http</p>
<p>　　主机：域名/IP地址，原理度一样，到头来还是会转换为IP地址，通过这个才能找到目标服务器</p>
<p>　　端口: 在传输层需要使用的，访问目的主机的哪个端口号。　</p>
<p>　　路径：精准的定位我们所需要的资源位置、　　　　</p>
<p>　　平常会省略协议和端口号，因为这些都是默认的，在访问主页时，路径也会省略。比如<a href="http://www.baidu.com这个默认进入百度的主页" target="_blank" rel="noopener">www.baidu.com这个默认进入百度的主页</a> 完整写法 <a href="http://www.baidu.com:80/index.html" target="_blank" rel="noopener">http://www.baidu.com:80/index.html</a> 。</p>
<h2 id="3-3、超文本传输协议"><a href="#3-3、超文本传输协议" class="headerlink" title="3.3、超文本传输协议"></a>3.3、超文本传输协议</h2><p>　　1）作用</p>
<p>　　　　怎样向服务器请求文档、服务器怎么把文档传送给浏览器，通俗点讲，就是我们想服务器访问网页资源时，服务器如何把网页上的东西传给我们。</p>
<p>　　客户端向服务器：请求报文　　　　服务器向客户端：响应报文</p>
<p>　　其实就是：在通过URL访问你服务器时，就会发送一个请求报文，告诉服务器需要哪些东西，服务器知道后，返回一个响应报文给客户端，其中就会带有一些网页信息。</p>
<p>　　　　　　 就是通过这个来达到传送网页资源的目的，现在来具体看看，请求报文和响应报文的格式。</p>
<h2 id="3-4、请求和响应报文的格式"><a href="#3-4、请求和响应报文的格式" class="headerlink" title="3.4、请求和响应报文的格式"></a>3.4、请求和响应报文的格式</h2><p>　　格式都一样，内容不一样。　</p>
<p>　　　　请求行　　　　　　　　　　　　响应行</p>
<p>　　　　请求头部　　　　　　　　　　　响应体</p>
<p>　　　　请求数据　　　　　　　　　　　响应数据</p>
<p>　　1）请求报文格式图</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170930120911044-1161831966.png" alt="img"></p>
<p>　　2）响应报文格式图</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170930120959903-1005309780.png" alt="img"></p>
<p>这个后面我会详细的写一篇文章类学习HTTP协议。</p>
<h2 id="3-5、HTTP协议功能"><a href="#3-5、HTTP协议功能" class="headerlink" title="3.5、HTTP协议功能"></a>3.5、HTTP协议功能</h2><p>　　　　HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，</p>
<p>　　还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>
<p>　　　　HTTP是客户端浏览器或其他程序与<a href="https://baike.baidu.com/item/Web服务" target="_blank" rel="noopener">Web服务</a>器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，</p>
<p>　　仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。</p>
<p>　　　　我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，<a href="https://baike.baidu.com/item/统一资源定位符" target="_blank" rel="noopener">统一资源定位符</a>)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在<br>　　浏览器的地址框中输入一个URL或是单击一个<a href="https://baike.baidu.com/item/超级链接" target="_blank" rel="noopener">超级链接</a>时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/2020/05/10/network6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>复制自：<a href="https://www.cnblogs.com/zhangyinhua" target="_blank" rel="noopener">https://www.cnblogs.com/zhangyinhua</a></p>
<p><strong>阅读目录(Content)</strong></p>
<ul>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_label0" target="_blank" rel="noopener">一、网络层概述</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_lab2_0_0" target="_blank" rel="noopener">1.1、网络层简介</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_label1" target="_blank" rel="noopener">二、网络层的基础知识</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_lab2_1_0" target="_blank" rel="noopener">2.1、ip地址</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_lab2_1_1" target="_blank" rel="noopener">2.2、ip地址的分类</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_lab2_1_2" target="_blank" rel="noopener">2.3、mac地址和ip地址的区别与联系</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_label2" target="_blank" rel="noopener">三、ARP协议</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_label3" target="_blank" rel="noopener">四、IP协议</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_lab2_3_0" target="_blank" rel="noopener">4.1、IP协议概述</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_lab2_3_1" target="_blank" rel="noopener">4.2、通过IP数据包格式认识IP协议</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_label4" target="_blank" rel="noopener">五、ICMP协议</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_lab2_4_0" target="_blank" rel="noopener">5.1、ICMP差错报告报文</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_lab2_4_1" target="_blank" rel="noopener">5.2、ICMP询问报文</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_label5" target="_blank" rel="noopener">六、IGMP协议</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_lab2_5_0" target="_blank" rel="noopener">6.1、概述</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_lab2_5_1" target="_blank" rel="noopener">6.2、多播　　</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_lab2_5_2" target="_blank" rel="noopener">6.3、IGMP协议工作流程</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_label6" target="_blank" rel="noopener">七、总结</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_lab2_6_0" target="_blank" rel="noopener">7.1、分析从主机A找到主机B的过程</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_lab2_6_1" target="_blank" rel="noopener">7.2、分析从主机A找到主机E的过程</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_lab2_6_2" target="_blank" rel="noopener">7.3、分析从主机A到主机E数据的形式</a></li>
</ul>
</li>
</ul>
<p><strong>前言</strong></p>
<p>前面给大家介绍了计算机网络的基本概述，物理层和数据链路层。这一篇给大家介绍面试中经常会被问到的网络层。在介绍之前我们回顾一下之前学习的知识！</p>
<p>　　CP/IP协议栈：物理层、链路层、网络层、传输层、应用层（会话层+表示层+应用层）</p>
<p>　　物理层：通过比特流在线路中传输来完成我们传输数据的目的，传输的方式很多种，传输的介质也很多中，光纤等</p>
<p>　　链路层：数据帧，在数据包(报)上加mac地址形成数据帧，其中的CRC检测原理用来检测数据的完整性，这一层用到的协议有PPP（点到点协议）、例如家中的拨号上网，</p>
<p>　　　　　　 CSMA/CD协议(广播协议)，在局域网中用的很多。其中会发生一系列的问题，和解决问题的办法。</p>
<p>　　网络层：数据包(报)，加上源ip地址和目标ip地址了。这一层的协议有四种，ARP（地址解析协议）、RARP(逆地址解析协议)、ICMP(网际控制报文协议)、IGMP(网际组管理协议)。</p>
<p>　　　　　　 这四种协议只是和IP协议配套使用，。在一章还能学到的是数据包的结构是怎么样的。什么是ip地址，为什么需要ip地址，怎么分配和区分ip地址的，这这一节我们度会讲解到。</p>
<p>　　传输层：这里会讲解到端口。常见的80端口，我们学习javaWeb时，使用Tomcat中，看到的是8080端口，浏览器使用的是80端口，这一节就会讲到端口是干嘛用的。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="一、网络层概述"><a href="#一、网络层概述" class="headerlink" title="一、网络层概述"></a>一、网络层概述</h1><h2 id="1-1、网络层简介"><a href="#1-1、网络层简介" class="headerlink" title="1.1、网络层简介"></a>1.1、网络层简介</h2><p>　　百度定义：</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928233007340-2050092694.png" alt="img"></p>
<p>　　功能目的：</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928233359669-2035398138.png" alt="img"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="二、网络层的基础知识"><a href="#二、网络层的基础知识" class="headerlink" title="二、网络层的基础知识"></a>二、网络层的基础知识</h1><h2 id="2-1、ip地址"><a href="#2-1、ip地址" class="headerlink" title="2.1、ip地址"></a>2.1、ip地址</h2><p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928233739450-1743368147.png" alt="img"></p>
<p>　　不就是一连串数组加.组成的吗，比如我们常常设置路由器时登录192.168.1.1。这个就是ip地址。那到底是什么样的呢？</p>
<p>　　ip地址就是32位，也就是4个字节组成，因为32位太长了，我们不好识别，所以每次将其分为8位一组，分成4组，然后在根据每组换算成10进制数组，组与组之间用.分隔开来。</p>
<p>　　举个例子：11111111，11111111，11111111，11111111就可以用255，255，255，255来表示了，所以每一组都是从0到255之间。现在在来看192.168.1.1这个ip地址，</p>
<p>　　　　　　　也能将其换成2进制来表示，只不过那样太麻烦，让人不易于看懂，所以就将其用10进制来表示。</p>
<p>　　ip地址的意义在哪里呢？</p>
<p>　　要上网就需要一个ip地址，这个ip地址不能和别人一样，独一无二，因为在网络上通信就是通过ip地址来找到你这台主机的，但是这个ip地址不是固定的，比如你在家拨号上网，</p>
<p>　　是A这个ip地址，下一次拨号，可能就不是A，变成B了，这要看你所在的网络给你分配了什么ip地址。如何通过ip查找到你，这个问题后面来讨论。</p>
<h2 id="2-2、ip地址的分类"><a href="#2-2、ip地址的分类" class="headerlink" title="2.2、ip地址的分类"></a>2.2、ip地址的分类</h2><p>　　既然每个人的ip地址都不一样，那一台主机怎么通过ip地址找到另一台主机的呢，茫茫人海，不可能一个个查找把，所以就有专门的人来管理和分配这个ip地址，看看以前怎么分的地址(了解)</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170928234128122-1717449504.png" alt="img">　</p>
<p>　　网络号由你所连的网决定，学校的局域网，公司的局域网，城市的广域网等，就是相当于先市、在区、在到村这样的。跟快递一样，你ip地址肯定也得这样分，先找到大的，然后慢慢一层层找下去。</p>
<p>　　A类地址：网络号有8位，第一位固定为0，127种，主机号有24位，那么就能给该类地址划分16777215个ip地址，也就1千多万个地址，意思就是比如你需要组建一个有1千多万台主机的网络，</p>
<p>　　　　　　 那么你就要去分配一个A类地址，要求给你一个网络号，然后其中1千多万的ip地址就由你自己分配了，最多也就只能分配127个这样的网络</p>
<p>　　B类：网络号、主机号16位，就能有65535个网络号和65535个主机号了。</p>
<p>　　C类：网络号有24位，也就能够分配1000多万个网络，但是主机号只有8位，也就是只能够自己分配254台主机最多</p>
<p>　　D类：用于多播，多播后面讲</p>
<p>　　E类：留着以后用</p>
<p>　　这就是我们老早以前所使用的ip地址，就是这样分的，这样看起来很合理啊，你看B类中，有那么多种，肯定够分了把，但是会暴露出一个问题就是，C类地址只能分配254台主机，</p>
<p>　　现在中小型网络那么多，都超过了254台电脑，如果A公司有1000台电脑，那他肯定要去分配B类地址，就造成了几万个的ip地址浪费了。这显然不是很合理。</p>
<p>　　</p>
<p>　　划分子网 = &lt;网络号&gt;+&lt;子网号&gt;+&lt;主机号&gt;</p>
<p>　　这是ip地址分类的第二大步，中间加了一个子网号，这样就加大了对上面的A类和B类地址的使用率。也就减少了A类和B类地址的浪费，但是也有问题就是C类地址不管怎么划分，</p>
<p>　　他所容纳的主机太小了，随着网路的扩增，人人度使用电脑，那么A类和B类迟早度会用光，所以就用到了我们现在的IP地址。</p>
<p>　　无分类编址 = &lt;网路前缀&gt;+&lt;主机号&gt;  这个就是我们现在用的ip地址的算法。</p>
<p>　　这个一看，跟第一种分类编址一样呀，其实很大的不同就在于分类编址的网络号不能变，是固定长度，而无分类编址通过网络前缀可变化，就能根据你需要多少个主机号来自由给你分配网络前缀了。</p>
<p>　　网络前缀：也就是用不定长的一连串1来表示ip地址的网络号。什么意思呢？</p>
<p>　　　　网络前缀：255.0.0.0 ip地址：192.168.1.1 那么该ip地址的前8位就属于网络号。</p>
<p>　　　　网络前缀：255.224.0.0 ip地址：192.255.1.1 因为255是8个1，224是111 00000 ，所以前11位表示网络号，也就是这个ip地址是处于192.224.0.0这个网络中，在这个网络中，能包含21个1转换为10进制这么多的主机。</p>
<p>　　这个网络前缀我们也称子网掩码，所以现在知道ip地址和我们的子网掩码什么意思了吗。</p>
<p>　　例如：已知ip地址141.14.72.24，所在网络的子网掩码是255.255.192.0，试求其网络地址？</p>
<p>　　　　子网掩码：255.255.192.0   11111111，11111111，11000000，00000000</p>
<p>　　　　ip地址：141.14.72.24      10001101，00001110，01001000，00011000</p>
<p>　　　　所以根据子网掩码知道ip地址的前18位为网络号，网络地址就为：10001101.00001110.01</p>
<p>　　所以根据子网掩码知道ip地址的前18位为网络号，网络地址就为：10001101.00001110.01000000.00000000 转换为10进制就是141.14.64.0， 能够存纳14位1也就是16383台主机。</p>
<p>　　(别问我怎么算的，肯定拿二进制转换器啊，不可能自己手算把，哈哈，二进制转10进制这么多怎么手算呢，记住特殊的，8个1就是255)</p>
<h2 id="2-3、mac地址和ip地址的区别与联系"><a href="#2-3、mac地址和ip地址的区别与联系" class="headerlink" title="2.3、mac地址和ip地址的区别与联系"></a>2.3、mac地址和ip地址的区别与联系</h2><p>　　1）mac地址概述</p>
<p>　　　　百度中定义：</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929000551575-1238725768.png" alt="img"></p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929000719575-1844362601.png" alt="img"></p>
<p>　　2）mac地址的作用　</p>
<p>　　　　谈起MAC地址，不得不说一下IP地址。IP地址工作在OSI参考模型的第三层网络层。两者之间分工明确，默契合作，完成通信过程。IP地址专注于网络层，</p>
<p>　　将数据包从一个网络转发到另外一个网络；而MAC地址专注于数据链路层，将一个数据帧从一个节点传送到相同链路的另一个节点。</p>
<p>　　　　在一个稳定的网络中，IP地址和MAC地址是成对出现的。如果一台计算机要和网络中另一外计算机通信，那么要配置这两台计算机的IP地址，MAC地址是网卡出厂时设定的，</p>
<p>　　这样配置的IP地址就和MAC地址形成了一种对应关系。在数据通信时，IP地址负责表示计算机的网络层地址，网络层设备（如路由器）根据IP地址来进行操作；MAC地址负责表示计算机的数据链路层地址，</p>
<p>　　数据链路层设备（如交换机）根据MAC地址来进行操作。IP和MAC地址映射关系是由这种ARP（Address Resolution Protocol，<a href="https://baike.baidu.com/item/地址解析协议" target="_blank" rel="noopener">地址解析协议</a>）协议完成。</p>
<p>　　　　IP地址就如同一个<a href="https://baike.baidu.com/item/职位" target="_blank" rel="noopener">职位</a>，而MAC地址则好像是去应聘这个职位的人才，职位既可以让甲坐，也可以让乙坐，同样的道理一个结点的IP地址对于<a href="https://baike.baidu.com/item/网卡" target="_blank" rel="noopener">网卡</a>是不做要求，基本上什么样的厂家都可以用，</p>
<p>　　也就是说IP地址与MAC地址并不存在着绑定关系。本身有的计算机流动性就比较强，正如同人才可以给不同的单位干活的道理一样的，人才的流动性是比较强的。职位和人才的对应关系就有点像是IP地址与MAC地址的对应关系。</p>
<p>　　比如，如果一个网卡坏了，可以被更换，而无须取得一个新的IP地址。如果一个IP<a href="https://baike.baidu.com/item/主机" target="_blank" rel="noopener">主机</a>从一个网络移到另一个网络，可以给它一个新的IP地址，而无须换一个新的网卡。当然MAC地址除了仅仅只有这个功能还是不够的，</p>
<p>　　就拿人类社会与网络进行类比，通过类比，我们就可以发现其中的类似之处，更好地理解MAC地址的作用。无论是局域网，还是<a href="https://baike.baidu.com/item/广域网" target="_blank" rel="noopener">广域网</a>中的计算机之间的通信，最终都表现为将<a href="https://baike.baidu.com/item/数据包" target="_blank" rel="noopener">数据包</a>从某种形式的链路上的初始<a href="https://baike.baidu.com/item/结点" target="_blank" rel="noopener">结点</a>出发，</p>
<p>　　从一个结点传递到另一个<a href="https://baike.baidu.com/item/结点" target="_blank" rel="noopener">结点</a>，最终传送到目的<a href="https://baike.baidu.com/item/结点" target="_blank" rel="noopener">结点</a>。<a href="https://baike.baidu.com/item/数据包" target="_blank" rel="noopener">数据包</a>在这些<a href="https://baike.baidu.com/item/节点" target="_blank" rel="noopener">节点</a>之间的移动都是由ARP负责将IP地址映射到MAC地址上来完成的。其实人类社会和<a href="https://baike.baidu.com/item/网络" target="_blank" rel="noopener">网络</a>也是类似的，试想在人际关系网络中，甲要捎个口信给丁，</p>
<p>　　就会通过乙和丙中转一下，最后由丙 转告给丁。在网络中，这个口信就好比是一个网络中的一个<a href="https://baike.baidu.com/item/数据包" target="_blank" rel="noopener">数据包</a>。<a href="https://baike.baidu.com/item/数据包" target="_blank" rel="noopener">数据包</a>在传送过程中会不断询问相邻<a href="https://baike.baidu.com/item/节点" target="_blank" rel="noopener">节点</a>的MAC地址，这个过程就好比是人类社会的口信传送过程。</p>
<p>　　相信通过这两个例子，我们就可以进一步理解MAC地址的作用。</p>
<p>　　3）mac地址和ip地址的区别　</p>
<p>　　IP地址和MAC地址相同点是它们都唯一，不同的特点主要有：<br>　　　　一是：对于网络上的某一设备，如一台计算机或一台路由器，其IP地址是基于网络拓扑设计出的，同一台设备或计算机上，改动IP地址是很容易的（但必须唯一），而MAC则是生产厂商烧录好的，</p>
<p>　　　　　　  一般不能改动。我们可以根据需要给一台主机指定任意的IP地址，如我们可以给局域网上的某台计算机分配IP地址为192.168.0.112 ，也可以将它改成192.168.0.200。</p>
<p>　　　　　　而任一网络设备（如网卡，路由器）一旦生产出来以后，其MAC地址不可由本地连接内的配置进行修改。如果一个计算机的网卡坏了，在更换网卡之后，该计算机的MAC地址就变了。<br>　　　　二是：长度不同。IP地址为32位，MAC地址为48位。<br>　　　　三是：分配依据不同。IP地址的分配是基于网络拓扑，MAC地址的分配是基于制造商。<br>　　　　四是：寻址协议层不同。IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。 数据链路层协议可以使数据从一个节点传递到相同链路的另一个节点上（通过MAC地址），</p>
<p>　　　　　　  而网络层协议使数据可以从一个网络传递到另一个网络上（ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而最终到达目的网络）。</p>
<p>　　4）两者关系</p>
<p>　　　　这两者的关系是什么呢？在网络中我们通过主机的ip地址，先找到他的网络地址，到达了网络地址后，然后通过该网络中的老大(路由器)来分析一下这个ip地址是你网路中的哪个主机，</p>
<p>　　　　这时，老大(路由器)就通过该目标ip地址改到对应主机的mac地址，既然知道了mac地址，就能找到该计算机了。就好比什么呢。路由器是每次分配给你的ip地址不一样，但是你的mac地址肯定不会变，</p>
<p>　　　　所以就根据ip地址找到你的mac地址。但是怎么找到的呢？就要通过网络层中的ARP(地址解析协议)协议了。</p>
<p>　　知道了基础的知识后，现在来讲解网络层的几个协议：</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929002500122-2057977063.png" alt="img"></p>
<p>　　RARP:逆地址解析协议(现在不单独讲这个了，所以我在图中画在红色圆圈内部，因为RARP已经被DHCP协议给包含了，DHCP协议在后面会讲解到)，所以我们下面讲的就4个协议。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="三、ARP协议"><a href="#三、ARP协议" class="headerlink" title="三、ARP协议"></a>三、ARP协议</h1><p>　　百度介绍：</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929100309731-515973451.png" alt="img"></p>
<p>　　地址解析协议：通过ip地址来解析主机的mac地址，是怎么个过程呢，拿局域网来说，一个局域网中有很多主机，主机A想和局域网中的主机B通话，但是只知道对方的ip地址，所以他就通过发广播，</p>
<p>给局域网中所有的主机，问这个ip地址是谁，主机B收到了这个信息，通过网络适配器(网卡)就发现自己是这个ip地址，然后就把自己的mac地址发给源主机，这样就知道了mac地址，就能够通信了。</p>
<p>　　类似的，在跨网络中就不是直接发广播了，先通过ip地址找到对应的网络地址，如何找到的对应的网络地址呢，通过路由器，每个路由器都有三层。网络层、链路层、物理层，也就是说最高能够识别网络层中的东西来，</p>
<p>那么路由器也就有ARP协议了，每个路由器都能识别出目标ip地址在哪个路由器上，这其中涉及到了很多算法，我们这里不做更多的解释，简单来说，路由器能根据目标ip地址找到下一跳路由器的mac地址，然后一步一步跳下去，</p>
<p>直到找到目标ip地址的网络地址的路由器，然后通过该路由器来找到目标ip地址的mac地址，这样就能够找到目标主机了。这就是ARP协议。</p>
<p>　　　　　　发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。<br>　　　　　　发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。<br>　　　　　　发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。<br>　　　　　　发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="四、IP协议"><a href="#四、IP协议" class="headerlink" title="四、IP协议"></a>四、IP协议</h1><h2 id="4-1、IP协议概述"><a href="#4-1、IP协议概述" class="headerlink" title="4.1、IP协议概述"></a>4.1、IP协议概述</h2><p>　　百度定义：</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929003508153-1142284506.png" alt="img"></p>
<p>　　其实IP的责任就是把数据从源地址传送到目的地。它不负责保证传送可靠性，流控制，包顺序和其它对于主机到主机协议来说很普通的服务。</p>
<h2 id="4-2、通过IP数据包格式认识IP协议"><a href="#4-2、通过IP数据包格式认识IP协议" class="headerlink" title="4.2、通过IP数据包格式认识IP协议"></a>4.2、通过IP数据包格式认识IP协议</h2><p>　　IP协议通过看一下IP数据包(报)的格式就知道IP协议是干嘛的了，就是来规定数据报的格式，以及定义的功能</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929003804434-2101323158.png" alt="img"></p>
<p>　　1）固定部分：20个字节，一行是4个字节，有5行，自己看清楚</p>
<p>　　　　1.1）第一行　　</p>
<p>　　　　　　版本：占4位，IP协议的版本，通信双方的IP协议版本要一致，普遍用IPv4，以后可能会用IPv6.</p>
<p>　　　　　　首部长度：占4位，可表示的最大十进制为15，单位是32位字(4个字节)，表示首部最长为60个字节，也就是说除去固定部分的20个字节，可选字段和填充最多能是40个字节。</p>
<p>　　　　　　区分服务：占8位，1个字节。有些要传输的数据要立马传达到对面，比如视频，语音这样的，不能跟邮件慢慢吞吞的达到对方一样，需要立马送达，这就是为什么需要这个区分服务了</p>
<p>　　　　　　总长度：占16位，2个字节。占首部+数据部分 的总长度是多少。数据帧最长不能超过1500个字节，数据包就不能一次性发太大，如果发的太大就要选择分片处理了。</p>
<p>　　　　1.2）第二行　　</p>
<p>　　　　　　标识：占16位，2个字节，一个计数器，每产生一个数据包，计数器就加1，当数据包被分片时，下面将会说到分片问题，所有分片后的数据包的标识度一样。这样相同的标识的数据包片就能够重新组合到一起</p>
<p>　　　　　　标志：占3位，第一位暂时没意义，第二位DF：不能分片的意思，为1时，不能分片，为0就可以分片 第三位MF 还有分片的意思，为0代表这是若干数据包中的最后一片</p>
<p>　　　　　　片偏移：占13位，在较长的分组在分片后，某片在原分组中的相对位置，几个例子，1111，1111，1111，1111 这16位，分成4个数据包分片来发，第一个数据包分片的片偏移为1，第二个为5，第三个为9，</p>
<p>　　　　　　　　　　第四个为13，就是这个意思，片偏移以8个字节为偏移单位，也就是说，每个分片的长度一定是8字节的整数倍，上面是以位来举例说明问题，实际上单位是8个字节为单位。</p>
<p>　　　　1.3）第三行　　</p>
<p>　　　　　　生存时间：也就是ping命令中显示的TTL字段，跳数限制，每经过一个路由器，就减1，当跳到0后，就丢弃该数据包。window系统的起始TTL为32、Linux64、xp：128</p>
<p>　　　　　　协议：占8位，数据包中数据部分使用的是什么协议，方便目的主机的IP层知道讲数据部分上交给哪个处理。(也就是下一章要将的TCP还是UDP协议)</p>
<p>　　　　　　首部检验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。</p>
<p>　　　　　　　　　　   不检验数据部分可减少计算的工作量。</p>
<p>　　　　1.4）第四行</p>
<p>　　　　　　源地址：占32为，也就是源IP地址</p>
<p>　　　　1.5）第五行</p>
<p>　　　　　　目标地址：占32位，也是IP地址</p>
<p>　　2）可选部分：为了使整个数据包为整数个字节而设置的。　　　</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="五、ICMP协议"><a href="#五、ICMP协议" class="headerlink" title="五、ICMP协议"></a>五、ICMP协议</h1><p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929094156450-305546820.png" alt="img">　</p>
<p>　　ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。它是一个非常重要的协议，它对于<a href="https://baike.baidu.com/item/网络安全" target="_blank" rel="noopener">网络安全</a>具有极其重要的意义。</p>
<p>　　它是<a href="https://baike.baidu.com/item/TCP%2FIP协议" target="_blank" rel="noopener">TCP/IP协议</a>族的一个子协议，属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。</p>
<p>　　当遇到IP数据无法访问目标、IP<a href="https://baike.baidu.com/item/路由器" target="_blank" rel="noopener">路由器</a>无法按当前的传输速率转发<a href="https://baike.baidu.com/item/数据包" target="_blank" rel="noopener">数据包</a>等情况时，会自动发送ICMP消息。ICMP报文在IP帧结构的首部协议类型字段（Protocol 8bit)的值=1。</p>
<p>这个协议比较简单，它有两部分组成：ICMP差错报告报文、ICMP询问报文 。这个挺有用的，比如我们经常用来测试网络连接畅通的ping命令等</p>
<h2 id="5-1、ICMP差错报告报文"><a href="#5-1、ICMP差错报告报文" class="headerlink" title="5.1、ICMP差错报告报文"></a>5.1、ICMP差错报告报文</h2><p>　　检测在传送数据的过程中，发生的错误，如果发生了错误，会通过该协议返回给源主机一个带有错误原因的数据包</p>
<p>　　终点不可达：发送数据后，路由器或主机不能完成交付数据报时，就会往源主机发送终点不可达报文</p>
<p>　　源点抑制：当路由器或主机由于网络拥塞而丢弃数据报时，返回一个源点抑制报文</p>
<p>　　超时：</p>
<p>　　　　参数问题，在ip数据包中的首部有的字段不正确时，丢弃该报，返回参数问题报文</p>
<p>　　　　改变路由(重定向)：路由器把改变路由报文发送给主机，让主机下次直接经过改变后的路由器。</p>
<h2 id="5-2、ICMP询问报文"><a href="#5-2、ICMP询问报文" class="headerlink" title="5.2、ICMP询问报文"></a>5.2、ICMP询问报文</h2><p>　　回送请求和回答：主机向特定目标发出询问，收到此报文必须返回一个ICMP回送回答报文。用于测试目的站是否可达。　　　　　　　　　　　　</p>
<p>　　时间戳请求和回答：请某个路由器或主机回答当前的日期和时间，用于进行时钟的同步和测量时间。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="六、IGMP协议"><a href="#六、IGMP协议" class="headerlink" title="六、IGMP协议"></a>六、IGMP协议</h1><h2 id="6-1、概述"><a href="#6-1、概述" class="headerlink" title="6.1、概述"></a>6.1、概述</h2><p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929094650106-1702985758.png" alt="img"></p>
<h2 id="6-2、多播"><a href="#6-2、多播" class="headerlink" title="6.2、多播　　"></a>6.2、多播　　</h2><p>　　IGMP协议用于多播，解释一下多播是什么把。</p>
<p>　　广播：老师在台上讲课，你们能随时看到老师的电脑屏幕，因为采用的广播，每个人度能接受到老师屏幕上所有的数据包</p>
<p>　　多播：在一个局域网中，有三个多播组，A、B、C，A在放java视频，B在放C++视频，C在放娱乐视频，如果你想看Java视频，那么你就调到A这个多播组中学习java视频，学习累了，</p>
<p>　　　　 你就可以换到C这个多播组中看看娱乐节目，这就是多播的意思，相对广播来说，自己需要什么就调什么，而不是跟广播一样，被动接受，他播到哪，就只能看到哪，多播能自由控制速度。</p>
<p>　　单播：50个人想看视频，就得发送50个数据包。多播的话就发一个，然后通过路由器转发50分给不同的人。</p>
<p>   单播：　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929094914903-280236468.png" alt="img">   多播： <img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929095019294-649093041.png" alt="img"></p>
<h2 id="6-3、IGMP协议工作流程"><a href="#6-3、IGMP协议工作流程" class="headerlink" title="6.3、IGMP协议工作流程"></a>6.3、IGMP协议工作流程</h2><p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929095155887-329195226.png" alt="img"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7609242.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929095230075-1587770275.png" alt="img"></p>
<p>　　注意：每个路由器度有一个路由表，并且主机也有记录ip地址和对应mac地址的功能。并不是每次通信度需要发广播询问。</p>
<h2 id="7-1、分析从主机A找到主机B的过程"><a href="#7-1、分析从主机A找到主机B的过程" class="headerlink" title="7.1、分析从主机A找到主机B的过程"></a>7.1、分析从主机A找到主机B的过程</h2><p>　　1）A先在自己的网络中发送广播，通过ARP协议。问所有的主机，谁知道10.0.0.3这个ip地址的主机是谁，同时把自己的主机ip地址和mac地址一起发送，</p>
<p>　　　　主机B发现自己是10.0.03这个ip地址，就把自己的mac地址发回去</p>
<p>　　2）主机A发现有人回应，就知道在自己本网络中，然后就找到了目标主机，开始通讯</p>
<h2 id="7-2、分析从主机A找到主机E的过程"><a href="#7-2、分析从主机A找到主机E的过程" class="headerlink" title="7.2、分析从主机A找到主机E的过程"></a>7.2、分析从主机A找到主机E的过程</h2><p>　　1）主机A先发广播看自己本网络没有该主机，没有，然后就给ip地址为10.0.0.1这个路由器F1发信号获得路由器的mac地址，然后给他发信号叫该路由器F1帮我们查找ip地址为12.0.0.3的主机。</p>
<p>　　　　这个路由器的ip地址就网关，所以每台计算机上度要有三个东西，ip地址，子网掩码，网关。 </p>
<p>　　2）路由器因为知道所有的网络在哪里，通过子网掩码和ip地址，就能够算出该ip地址在哪一个网段中，路由器就一跳一跳的经过路由器，知道找到对应网段的路由器F2</p>
<p>　　3）找到F2后，F2就以同样的方式通过ip地址找到对应的mac地址，就这样找到了。</p>
<p>　　省略了路由器如何找的这一步，这个可以自己看书，其中有很多中方式，很多种算法，我们就知道我们给ip地址和子网掩码给路由器，路由器就知道下一跳给谁，知道找到对应网段</p>
<h2 id="7-3、分析从主机A到主机E数据的形式"><a href="#7-3、分析从主机A到主机E数据的形式" class="headerlink" title="7.3、分析从主机A到主机E数据的形式"></a>7.3、分析从主机A到主机E数据的形式</h2><p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929095621419-1188385242.png" alt="img"></p>
<p>　　传输层(还没讲)：讲各个数据段划分序号</p>
<p>　　网络层：加上ip地址</p>
<p>　　数据链路层：加上mac地址和CRC检测的FCS</p>
<p>　　物理层：转化为比特流传输</p>
<p>　　集线器：只认识物理层，用来转发比特流</p>
<p>　　交换机：能认识数据链路层，所以交换机有mac地址表，能够记录各种mac地址，下一次就能选择性的转发数据了</p>
<p>　　路由器，能认识网络层，有路由表，所以能够通过ip地址找到对应网段。</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>传输层之细说TCP的三次握手和四次挥手</title>
    <url>/2020/05/10/network7/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>复制自：<a href="https://www.cnblogs.com/zhangyinhua" target="_blank" rel="noopener">https://www.cnblogs.com/zhangyinhua</a></p>
<p><strong>阅读目录(Content)</strong></p>
<ul>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_label0" target="_blank" rel="noopener">一、运输层概述</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_0_0" target="_blank" rel="noopener">1.1、运输层简介</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_0_1" target="_blank" rel="noopener">1.2、端口</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_0_2" target="_blank" rel="noopener">1.3、熟知端口、登记端口、客户端端口</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_label1" target="_blank" rel="noopener">二、UDP协议</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_1_0" target="_blank" rel="noopener">　　2.1、UDP概述</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_1_1" target="_blank" rel="noopener">　　2.2、特点　</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_1_2" target="_blank" rel="noopener">　　2.3、UDP报文格式</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_1_3" target="_blank" rel="noopener">　　2.4、使用UDP协议的例子</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_label2" target="_blank" rel="noopener">三、TCP协议</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_2_0" target="_blank" rel="noopener">3.1、TCP协议概述</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_2_1" target="_blank" rel="noopener">3.2、TCP协议功能　</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_2_2" target="_blank" rel="noopener">3.3、TCP报文结构</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_2_3" target="_blank" rel="noopener">3.4、面向连接（三次握手）</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_2_4" target="_blank" rel="noopener"> 3.5、同时打开连接请求</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_2_5" target="_blank" rel="noopener">3.6、可靠传输</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_2_6" target="_blank" rel="noopener">3.7、流量控制</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_2_7" target="_blank" rel="noopener">3.8、堵塞控制</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_2_8" target="_blank" rel="noopener">3.9、TCP释放连接（四次挥手）</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_lab2_2_9" target="_blank" rel="noopener">3.10、同时关闭连接</a></li>
</ul>
</li>
</ul>
<p><strong>前言</strong></p>
<p>　　这一篇我将介绍的是大家面试经常被会问到的，三次握手四次挥手的过程。以前我听到这个是什么意思呀？听的我一脸蒙逼，但是学习之后就原来就那么回事！</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="一、运输层概述"><a href="#一、运输层概述" class="headerlink" title="一、运输层概述"></a>一、运输层概述</h1><h2 id="1-1、运输层简介"><a href="#1-1、运输层简介" class="headerlink" title="1.1、运输层简介"></a>1.1、运输层简介</h2><p>　　这一层的功能也挺简单的，运输层提供应用层提供端到端通信服务，通俗的讲，两个主机通讯，也就是应用层上的进程之间的通信，也就是转换为进程和进程之间的通信了，我们之前学到网络层，</p>
<p>　　IP协议能将分组准确的发送到目的主机，但是停留在网络层，并不知道要怎么交给我们的主机应用进程，通过前面的学习，我们学习有mac地址，通过mac地址能找到同一个网络下主机，有IP地址，</p>
<p>　　通过ip地址能找到不同网络下的网络，结合mac地址就能找到对应主机，那么怎么找到主机应用进程呢，肯定也有一个东西来标识它，那就是我们常说的端口了。</p>
<h2 id="1-2、端口"><a href="#1-2、端口" class="headerlink" title="1.2、端口"></a>1.2、端口</h2><p>　　端口，占有16位，其大小也就有65536个，是从0~65535.也就是一台计算机有65535个端口，主机之间的通讯，也就是应用进程之间的通讯，都要依靠端口，一个进程对应一个端口，</p>
<p>　　进程A和进程B通信，进程A分到的端口为60000，进程B分到的端口为60001，进程A通过端口60000发送数据给进程B，就知道要交给60001端口，也就到了进程B中 ，这样就达到了通信的目的。</p>
<h2 id="1-3、熟知端口、登记端口、客户端端口"><a href="#1-3、熟知端口、登记端口、客户端端口" class="headerlink" title="1.3、熟知端口、登记端口、客户端端口"></a>1.3、熟知端口、登记端口、客户端端口</h2><p>　　1）熟知端口：0-1023， 也就是一些固定的端口号，比如http使用的80端口，意思就是在访问网址时，我们访问服务器的端口就是80，然后服务器那边传网页的数据给我们。</p>
<p>　　2）登记端口：1024-49151，比如微软开发了一个系统应用，该应用在通讯或使用时，需要使用到xxx端口，那么就要去登记一下这个端口，以免有别人公司的应用使用同一个端口号，</p>
<p>　　　　　　　　例如，windows系统中的3389端口，就是用来实现远程连接的，就固定了这台计算机如果要使用远程连接服务，就打开3389端口，别人就能使用远程连接连你了，默认是不打开的。</p>
<p>　　3）客户端端口：49152-65535，一般我们使用某个软件，比如QQ，等其他服务，随机拿这个范围内的端口，而不是去拿前面哪些固定的，拿到等通讯结束后，就会释放该端口。</p>
<p>知道了端口是什么？运输层具体做了什么事情呢？运输层就是将两个端口连起来通信的介质，不然光知道两个端口有什么用，怎么通信的，还是要靠运输层来做这个事情，其中重要的就是靠两个协议，UDP和TCP协议。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="二、UDP协议"><a href="#二、UDP协议" class="headerlink" title="二、UDP协议"></a>二、UDP协议</h1><h2 id="2-1、UDP概述"><a href="#2-1、UDP概述" class="headerlink" title="　　2.1、UDP概述"></a>　　2.1、UDP概述</h2><p>　　　　UDP:User Datagram Protocol 用户数据报协议</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929104015872-2047532795.png" alt="img"></p>
<h2 id="2-2、特点"><a href="#2-2、特点" class="headerlink" title="　　2.2、特点　"></a>　　2.2、特点　</h2><p>　　　　无连接、不可靠</p>
<p>　　　　无连接：意思就是在通讯之前不需要建立连接，直接传输数据。</p>
<p>　　　　不可靠：是将数据报的分组从一台主机发送到另一台主机，但并不保证数据报能够到达另一端，任何必须的可靠性都由应用程序提供。在 UDP 情况下，虽然可以确保发送消息的大小，</p>
<p>　　　　　　　　却不能保证消息一定会达到目的端。没有超时和重传功能，当 UDP 数据封装到 IP 数据报传输时，如果丢失，会发送一个 ICMP 差错报文给源主机。即使出现网络阻塞情况，</p>
<p>　　　　　　　　UDP 也无法进行流量控制。此外，传输途中即使出现丢包，UDP 也不负责重发，甚至当出现包的到达顺序杂乱也没有纠正的功能。</p>
<h2 id="2-3、UDP报文格式"><a href="#2-3、UDP报文格式" class="headerlink" title="　　2.3、UDP报文格式"></a>　　2.3、UDP报文格式</h2><p>　　　　UDP在IP报文中的位置如图所示：</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929110726372-1065135917.png" alt="img"></p>
<p>　　　　UDP报文格式如图所示：</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929104712294-151752902.png" alt="img"></p>
<p>　　　　1）UDP首部　　</p>
<p>　　　　　　源端口号：占16位，源主机的应用进程所使用的端口号</p>
<p>　　　　　　目标端口号：占16位，目标主机的应用进程所使用的端口号，也就是我们需要通信的目标进程</p>
<p>　　　　　　UDP（包）报长度：UDP用户数据报的长度，数据部分+UDP首部之和为UDP报长度。</p>
<p>　　　　　　检验和：检验和是为了提供可靠的 UDP 首部和数据而设计，这里不要和上面的不可靠传输搞混淆了，这里提供可靠的UDP首部，是因为一个进程可能接受多个进程过来的报文，那么如何区分他们呢，</p>
<p>　　　　　　　　　　就是通过5个东西来进行区分的， “源 IP 地址”、“目的 IP 地址”、“协议号”、“源端口号”、“目标端口号”的，这个检测可靠，是检测接受哪个正确的报文，也就是说是哪个报文要进这个端口。那个不可靠，</p>
<p>　　　　　　　　　　说的是这个报文可能丢失，可能其中数据损坏了我们不关心，但是这些的前提是，你得传输到正确的目的地去，不然乱出乱发数据报，岂不是乱套了。</p>
<p>　　　　2）UDP伪首部</p>
<p>　　　　　　就是拿到IP层的一些数据，因为要进行检验和，就必须要有这些数据。其中检验的算法跟IP层中检验首部的办法是一样的。</p>
<p>　　　　　　分析：</p>
<p>　　　　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929105335903-1914988627.png" alt="img"></p>
<p>　　　　　一个目标进程中，其中的报文，目标端口，目标ip地址肯定都是一样的，但是源IP地址和源端口就可能不一样，这就说明了不同源而同一目的地的报文会定位到同一队列。</p>
<p>　　　　　　这跟接下来我们要讨论的TCP不一样，因为UDP是无连接的，大家都是用这一条通道，所以其队列中就会出现上面所说的这样的情况。</p>
<h2 id="2-4、使用UDP协议的例子"><a href="#2-4、使用UDP协议的例子" class="headerlink" title="　　2.4、使用UDP协议的例子"></a>　　2.4、使用UDP协议的例子</h2><p>　　　　　　在选择使用协议的时候，选择UDP必须要谨慎。在<a href="https://baike.baidu.com/item/网络" target="_blank" rel="noopener">网络</a>质量令人十分不满意的环境下，UDP协议数据包丢失会比较严重。但是由于UDP的特性：它不属于连接型协议，因而具有资源消耗小，</p>
<p>　　　　处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。比如我们聊天用的ICQ和<a href="https://baike.baidu.com/item/QQ" target="_blank" rel="noopener">QQ</a>就是使用的UDP协议。</p>
<p>　　　　1）应用层协议中DNS，也就是根据域名解析ip地址的一个协议，他使用的就是UDP</p>
<p>　　　　2）DHCP,这个是给各电脑分配ip地址的协议，其中用的也是UDP协议</p>
<p>　　　　3）IGMP，我们说的多播，也就是使用的UDP，在多媒体教师，老师拿笔记本讲课，我们在下面通过各自的电脑看到老师的画面，这就是通过UDP传输数据，所以会出现有的同学卡，</p>
<p>　　　　　　有的同学很流畅，就是因为其不可靠传输，但是卡一下，对接下来的观看并没有什么映像。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7610922.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="三、TCP协议"><a href="#三、TCP协议" class="headerlink" title="三、TCP协议"></a>三、TCP协议</h1><h2 id="3-1、TCP协议概述"><a href="#3-1、TCP协议概述" class="headerlink" title="3.1、TCP协议概述"></a>3.1、TCP协议概述</h2><p>　　百度上说：</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929111206278-1051951614.png" alt="img"></p>
<p>　　TCP协议是面向连接的、可靠传输、有流量控制，拥塞控制，面向字节流传输等很多优点的协议。其最终功能和UDP一样，在端和端之间进行通信，但是和UDP的区别还是很大的。</p>
<h2 id="3-2、TCP协议功能"><a href="#3-2、TCP协议功能" class="headerlink" title="3.2、TCP协议功能　"></a>3.2、TCP协议功能　</h2><p>　　1）当应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，TCP则把数据流分割成适当长度的报文段，最大传输段大小（MSS）通常受该计算机连接的网络的数据链路层的最大传送单元（MTU）限制。</p>
<p>　　　　之后TCP把数据包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。<br>　　2）TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；</p>
<p>　　　　如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。<br>　　　　　　在数据正确性与合法性上，TCP用一个校验和函数来检验数据是否有错误，在发送和接收时都要计算校验和；同时可以使用md5认证对数据进行加密。<br>　　　　　　在保证可靠性上，采用超时重传和捎带确认机制。<br>　　　　　　在流量控制上，采用滑动窗口[1] 协议，协议中规定，对于窗口内未经确认的分组需要重传。<br>　　3）在拥塞控制上，采用广受好评的TCP拥塞控制算法（也称AIMD算法）。该算法主要包括三个主要部分：1）加性增、乘性减；2）慢启动；3）对超时事件做出反应。</p>
<h2 id="3-3、TCP报文结构"><a href="#3-3、TCP报文结构" class="headerlink" title="3.3、TCP报文结构"></a>3.3、TCP报文结构</h2><p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929111828700-1117064463.png" alt="img"></p>
<p>　　1）源端口号</p>
<p>　　2）目标端口号</p>
<p>　　3）序列号：因为在TCP是面向字节流的，他会将报文都分成一个个字节，给每个字节进行序号编写，比如一个报文有900个字节组成，那么就会编成1-900个序号，然后分几部分来进行传输，</p>
<p>　　　　　　　　比如第一次传，序列号就是1，传了50个字节， 那么第二次传，序列号就为51，所以序列号就是传输的数据的第一个字节相对所有的字节的位置。</p>
<p>　　4）确认应答：如刚说的例子，第一次传了50个字节给对方，对方也会回应你，其中带有确认应答，就是告诉你下一次要传第51个字节来了，所以这个确认应答就是告诉对方要传第多少个字节了</p>
<p>　　5）首部长度：就是首部的长度，</p>
<p>　　6）保留：给以后有需要在用，这个保留的位置放的东西是跟控制位类似的</p>
<p>　　7）控制位：目前有的控制位为6个</p>
<p>　　　　URG:紧急，当URG为1时，表名紧急指针字段有效，标识该报文是一个紧急报文，传送到目标主机后，不用排队，应该让该报文尽量往下排，让其早点让应用程序给接受。</p>
<p>　　　　ACK:确认，当ACK为1时，确认序号才有效。当ACK为0时，　　　　确认序号没用</p>
<p>　　　　PSH：推送，当为1时，当遇到此报文时，会减少数据向上交付，本来想应用进程交付数据是要等到一定的缓存大小才发送的，但是遇到它，就不用在等足够多的数据才向上交付，</p>
<p>　　　　　　　　而是让应用进程早点拿到此报文，这个要和紧急分清楚，紧急是插队，但是提交缓存大小的数据不变，这个推送就要排队，但是遇到他的时候，会减少交付的缓存数据，提前交付。</p>
<p>　　　　RST:复位，报文遇到很严重的差错时，比如TCP连接出错等，会将RST置为1，然后释放连接，全部重新来过。</p>
<p>　　　　SYN：同步，在进行连接的时候，也就是三次握手时用得到，下面会具体讲到，配合ACK一起使用</p>
<p>　　　　FIN：终止，在释放连接时，也就是四次挥手时用的。</p>
<p>　　8）窗口：指发送报文段一方的接受窗口大小，用来控制对方发送的数据量(从确认号开始，允许对方发送的数据量)。也就是后面需要讲的滑动窗口的窗口大小</p>
<p>　　9）检验和：检验首部和数据这两部分，和UDP一样，需要拿到伪首部中的数据来帮助检测</p>
<p>　　10）选项：长度可变，介绍一种选项，最大报文段长度，MSS。 能够告诉对方TCP，我的缓存能接受报文段的数据字段的最大长度是MSS个字节。如果没有使用选项，那么首部固定是20个字节。</p>
<p>　　11）填充：就是为了让其成为整数个字节</p>
<h2 id="3-4、面向连接（三次握手）"><a href="#3-4、面向连接（三次握手）" class="headerlink" title="3.4、面向连接（三次握手）"></a>3.4、面向连接（三次握手）</h2><p>　　面向连接(三次握手)：在通信之前，会先通过三次握手的机制来确认两端口之间的连接是否可用。而UDP不需要确认是否可用，直接传。</p>
<p>　　三次握手机制：</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929140236606-834864575.png" alt="img">　　　　　<strong><img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929140445825-702107298.png" alt="img"></strong></p>
<p>　　一开始客户端和服务端都是关闭状态，但是在某个时刻，客户端需要和服务端进行通信，此时双方都会各自准备好端口，服务器段的端口会处于监听状态，等待客户端的连接。</p>
<p>　　客户端可会知道自己的端口号，和目的进程的端口号，这样才能发起请求。</p>
<p>　　第一次握手：客户端想与服务器进行连接了，所以状态变为主动打开，同时发送一个连接请求报文给服务器段SYN=1，并且会携带x个字节过去。</p>
<p>　　　　　　　　发送完请求连接报文后，客户端的状态就变为了SYN_SENT，可以说这个状态是等待发送确认(为了发送第三次握手时的确认包)</p>
<p>　　第二次握手：服务端接收到连接请求报文后，从LSTTEN状态变为被动打开状态，然后给客户端返回一个报文。这个报文有两层意思，一是确认报文，而可以达到告诉客户端，我也打开连接了。</p>
<p>　　　　　　　　发完后，变为SYN_RCVD状态(也可以说是等待接受确认状态，接受客户端发过来的确认包)</p>
<p>　　第三次握手：客户端得到服务器端的确认和知道服务器端也已经准备好了连接后，还会发一个确认报文到服务器端，告诉服务器端，我接到了你发送的报文，接下来就让我们两个进行连接了。</p>
<p>　　　　　　　　客户端发送完确认报文后，进入ESTABLISHED，而服务器接到了，也变为ESTABLISHED。</p>
<h2 id="3-5、同时打开连接请求"><a href="#3-5、同时打开连接请求" class="headerlink" title="3.5、同时打开连接请求"></a>3.5、同时打开连接请求</h2><p>　　正常情况下，通信一方请求建立连接，另一方响应该请求，但是如果出现，通信双方同时请求建立连接时，则连接建立过程并不是三次握手过程，而且这种情况的连接也只有一条，并不会建立两条连接。</p>
<p>　　同时打开连接时，两边几乎同时发送 SYN，并进入 SYN_SENT 状态，当每一端收到 SYN 时，状态变为 SYN_RCVD，同时双方都再发 SYN 和 ACK 作为对收到的 SYN 进行确认应答。</p>
<p>　　当双方都收到 SYN 及相应的 ACK 时，状态变为 ESTABLISHED </p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929142218825-490369738.png" alt="img"></p>
<h2 id="3-6、可靠传输"><a href="#3-6、可靠传输" class="headerlink" title="3.6、可靠传输"></a>3.6、可靠传输</h2><p>　通过1）数据编号和积累确认 2）以字节为单位的滑动窗口 3）超时重传时间 4）快速重传 这四个方面来达到可靠传输的目的。</p>
<p>　　1）、数据编号：将每个字节进行编号，有900个字节，就从1到900进行编号</p>
<p>　　　　 积累确认：服务器端不是接收到一个字节就发一个确认，那样效率太低，而是当接收到4，5个时，在发送一个确认，那么在之前的确认之前的数据就算发送成功了的。</p>
<p>　　2）滑动窗口：这个跟在数据链路层讲个滑动窗口一样。每次能发送的数据是在此窗口中的，接到了多少数据，就往后滑多少数据</p>
<p>　　3）超时重传时间：这个也在链路层讲过，如果等待一段时间后，还没接收到确认报文，那么就重新传</p>
<p>　　4）快速重传：在滑动窗口中的应用，比如传了1234 6到服务器端，老办法是在4之后的所有数据度要重新传，而这个快速重传就只需要等待传了5这个序号，就可以继续往下接收数据了。</p>
<h2 id="3-7、流量控制"><a href="#3-7、流量控制" class="headerlink" title="3.7、流量控制"></a>3.7、流量控制</h2><p>　　在传输层中，有接受缓存和发送缓存这两个东西的存在，所以每次发送数据过去另一端时，都会把这些数据给带过去，让对方知道自己的这两个缓存的大小，然后来合理的设置自己的发送窗口的大小，</p>
<p>　　如果对方的缓存快满了，对方在传送数据过来的时候，就会告诉自己，少发一点数据过来，自己就设置滑动窗口小一点，让对方有缓冲的机会，而不会导致缓存溢出，不让自己的报文被丢弃。</p>
<h2 id="3-8、堵塞控制"><a href="#3-8、堵塞控制" class="headerlink" title="3.8、堵塞控制"></a>3.8、堵塞控制</h2><p>　　其实跟流量控制差不多，但是站的角度更大，此时既考虑了对方接收不过来，缓存太多溢出导致，又考虑在线路中，线路上的传输速率就那么大，但是有很多人同时用，发送的数据太多，就会使线路发现拥塞，</p>
<p>　　也就是路由器可能转发不过来，导致大量数据丢失，这两个问题。所以拥塞控制这个解决方案，大概意思就是当检测到有网络拥塞时，就会让自己的滑动窗口变小，但具体是怎么变化的，就是根据算法来算了，</p>
<p>　　　　发送窗口的上限值 = Min[rwnd，cwnd]   </p>
<p>　　　　rwnd：接受窗口，根据接受缓存，而定的接受窗口，接收缓存还有很多，那么接收窗口就大</p>
<p>　　　　cwnd：拥塞窗口，根据线路中的拥塞状况来决定，线路中不拥塞，那么此窗口就大，</p>
<p>　　　　发送窗口是取两个中较小值。这个还是可以理解的。</p>
<p>　　慢启动算法、快速恢复算法、结合来达到对拥塞进行控制的。</p>
<h2 id="3-9、TCP释放连接（四次挥手）"><a href="#3-9、TCP释放连接（四次挥手）" class="headerlink" title="3.9、TCP释放连接（四次挥手）"></a>3.9、TCP释放连接（四次挥手）</h2><p>　　通信完成后，连接就会被释放，通过四次挥手机制来完成这个事情。</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929142848090-1019184299.png" alt="img"></p>
<p>　　</p>
<p>　　第一次挥手：从ESTABLISHED变为主动关闭状态，客户端主动发送释放连接请求给服务器端，FIN=1。发送完之后就变为FIN_WAIT_1状态，这个状态可以说是等待确认状态。</p>
<p>　　第二次挥手：服务器接收到客户端发来的释放连接请求后，状态变为CLOSE_WAIT，然后发送确认报文给客户端，告诉他我接收到了你的请求。为什么变为CLOSE_WAIT，原因是是客户端发送的释放连接请求，</p>
<p>　　　　　　　　可能自己这端还有数据没有发送完呢，所以这个时候整个TCP连接的状态就变为了半关闭状态。服务器端还能发送数据，并且客户端也能接收数据，但是客户端不能在发送数据了，只能够发送确认报文。</p>
<p>　　　　　　　　客户端接到服务器的确认报文后，就进入了FIN_WAIT_2状态。也可以说这是等待服务器释放连接状态。</p>
<p>　　第三次挥手：服务器端所有的数据度发送完了，认为可以关闭连接了，状态变为被动关闭，所以向客户端发送释放连接报文，发完之后自己变为LAST_WAIT状态，也就是等待客户端确认状态</p>
<p>　　第四次挥手：客户端接到释放连接报文后，发送一个确认报文，然后自己变为TIME_WAIT,而不是立马关闭，因为客户端发送的确认报文可能会丢失，丢失的话服务器就会重传一个FIN，也就是释放连接报文，</p>
<p>　　　　　　　　这个时候客户端必须还没关闭。 当服务器接受到确认报文后，服务器就进入CLOSE状态，也就是关闭了。但是由于上面说的这个原因，客户端必须等待一定的时间才能够进入CLOSE状态。</p>
<h2 id="3-10、同时关闭连接"><a href="#3-10、同时关闭连接" class="headerlink" title="3.10、同时关闭连接"></a>3.10、同时关闭连接</h2><p>　　正常情况下，通信一方请求连接关闭，另一方响应连接关闭请求，并且被动关闭连接。但是若出现同时关闭连接请求时，通信双方均从 ESTABLISHED 状态转换为 FIN_WAIT_1 状态。</p>
<p>　　任意一方收到对方发来的 FIN 报文段后，其状态均由 FIN_WAIT_1转变到 CLOSING 状态，并发送最后的 ACK 数据段。当收到最后的 ACK 数据段后，状态转变化 TIME_WAIT，</p>
<p>　　在等待 2MSL 时间后进入到 CLOSED 状态，最终释放整个 TCP 传输连接。其过程入下：</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929143138919-200620568.png" alt="img"></p>
<p>总结：一般需要保证数据可靠时，都会使用tcp协议：http协议进行网站的访问时，使用的就是tcp。</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>python400集10</title>
    <url>/2020/05/03/python400%E9%9B%8610/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>HTTP详解</title>
    <url>/2020/05/10/network9/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>复制自：<a href="https://www.cnblogs.com/zhangyinhua" target="_blank" rel="noopener">https://www.cnblogs.com/zhangyinhua</a></p>
<p><strong>阅读目录(Content)</strong></p>
<ul>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_label0" target="_blank" rel="noopener">一、HTTP协议概述</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_lab2_0_0" target="_blank" rel="noopener">1.1、HTTP协议简介</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_lab2_0_1" target="_blank" rel="noopener">1.2、HTTP协议特点</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_label1" target="_blank" rel="noopener">二、URL和URI</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_lab2_1_0" target="_blank" rel="noopener">2.1、URL</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_lab2_1_1" target="_blank" rel="noopener">2.2、URI和URI的区别</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_label2" target="_blank" rel="noopener">三、工作流程</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_label3" target="_blank" rel="noopener">四、HTTP中请求消息（request）</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_lab2_3_0" target="_blank" rel="noopener">4.1、请求消息格式</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_lab2_3_1" target="_blank" rel="noopener">4.2、用GET请求的请求报文</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_lab2_3_2" target="_blank" rel="noopener">4.3、用POST请求的请求报文</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_label4" target="_blank" rel="noopener">五、HTTP请求详解</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_lab2_4_0" target="_blank" rel="noopener">5.1、HTTP请求方法</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_lab2_4_1" target="_blank" rel="noopener">5.2、GET和POST请求的区别</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_label5" target="_blank" rel="noopener">六、HTTP中响应消息（response）</a></p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_lab2_5_0" target="_blank" rel="noopener">6.1、响应消息格式</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_lab2_5_1" target="_blank" rel="noopener">6.2、响应消息</a></li>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_lab2_5_2" target="_blank" rel="noopener">6.3、响应状态码</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_label6" target="_blank" rel="noopener"> 七、HTTP工作原理</a></p>
</li>
</ul>
<p><strong>前言</strong></p>
<p>　　前面一篇的博文简单的介绍了一下属于应用层的HTTP协议，这一篇我将详细的学习HTTP协议，这也是做Web开发中一定要用到的协议。虽然我是做大数据的，但是多学习一点肯定是</p>
<p>　　没有坏处的。国庆放假7天，很多人都是想着怎么玩，我也很想出去玩，但是没有办法，努力才能有出路，加油！</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="一、HTTP协议概述"><a href="#一、HTTP协议概述" class="headerlink" title="一、HTTP协议概述"></a>一、HTTP协议概述</h1><h2 id="1-1、HTTP协议简介"><a href="#1-1、HTTP协议简介" class="headerlink" title="1.1、HTTP协议简介"></a>1.1、HTTP协议简介</h2><p>　　1）协议：计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。</p>
<p>　　2）HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>
<p>　　3）HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>
<p>　　4）HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。</p>
<p>　　　　目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</p>
<p>　　5）HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170930125740340-1045168955.png" alt="img"></p>
<h2 id="1-2、HTTP协议特点"><a href="#1-2、HTTP协议特点" class="headerlink" title="1.2、HTTP协议特点"></a>1.2、HTTP协议特点</h2><p>　　1）简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>　　2）灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>
<p>　　3）无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>　　4）无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。</p>
<p>　　　　　　　　另一方面，在服务器不需要先前信息时它的应答就较快。<br>　　5）支持B/S及C/S模式。　</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="二、URL和URI"><a href="#二、URL和URI" class="headerlink" title="二、URL和URI"></a>二、URL和URI</h1><h2 id="2-1、URL"><a href="#2-1、URL" class="headerlink" title="2.1、URL"></a>2.1、URL</h2><p>　　其实前面已经简单的知道了什么是URL。</p>
<p>　　HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）描述一个网络上的资源，来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。</p>
<p>　　URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址，它的组成部分是：</p>
<p>　　　　<a href="http://www.zyh.com:8080/woss/index.html?username=10086&amp;password=123456#name" target="_blank" rel="noopener">http://www.zyh.com:8080/woss/index.html?username=10086&amp;password=123456#name</a>　</p>
<p>　　从上面的URL可以看出，一个完整的URL包括以下几部分：<br>　　　　1）协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符</p>
<p>　　　　2）域名部分：该URL的域名部分为“<a href="http://www.zyh.com”。一个URL中，也可以使用IP地址作为域名使用" target="_blank" rel="noopener">www.zyh.com”。一个URL中，也可以使用IP地址作为域名使用</a></p>
<p>　　　　3）端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（80）</p>
<p>　　　　4）虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/woss/”</p>
<p>　　　　5）文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，</p>
<p>　　　　　　　　　　　　都是文件名部分。本例中的文件名是“index.html”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p>
<p>　　　　6）锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p>
<p>　　　　7）参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“username=10086&amp;password=123456”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p>
<h2 id="2-2、URI和URI的区别"><a href="#2-2、URI和URI的区别" class="headerlink" title="2.2、URI和URI的区别"></a>2.2、URI和URI的区别</h2><p>　　1）URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。<br>　　　　Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的<br>　　　　URI一般由三部组成：<br>　　　　　　访问资源的命名机制<br>　　　　　　存放资源的主机名<br>　　　　　　资源自身的名称，由路径表示，着重强调于资源。</p>
<p>　　2）URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。<br>　　　　URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。<br>　　　　采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：<br>　　　　　　协议(或称为服务方式)<br>　　　　　　存有该资源的主机IP地址(有时也包括端口号)<br>　　　　　　主机资源的具体地址。如目录和文件名等</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="三、工作流程"><a href="#三、工作流程" class="headerlink" title="三、工作流程"></a>三、工作流程</h1><p>一次HTTP操作称为一个事务，其工作过程可分为四步：<br>1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。<br>2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。<br>3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。<br>4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。<br>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p>
<p>我们用图来理解一下：　　</p>
<p>　　当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 </p>
<p>　　实际上我们输入URL后，我们的浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 浏览器解析Response中的HTML,这样我们就看到了网页，过程如下图所示：</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170930132020294-1539783244.png" alt="img"></p>
<p>　　我们的Request 有可能是经过了代理服务器，最后才到达Web服务器的。过程如下图所示：</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170930132125137-685597381.png" alt="img">　</p>
<p>　　代理服务器就是网络信息的中转站，它的功能是：</p>
<p>　　　　 提高访问速度， 大多数的代理服务器都有缓存功能。</p>
<p>　　　　 突破限制， 也就是FQ了</p>
<p>　　　　隐藏身份。</p>
<p>注意：</p>
<p>　　HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的“三次握手”。</p>
<p>　　下图所示TCP连接的三次握手。<br>　　在TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。一个重要的概念是面向连接，既HTTP在传输完成之间并不断开TCP连接。在HTTP1.1中(通过Connection头设置)这是默认行为。</p>
<p> 　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170930133829184-1642006770.png" alt="img"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="四、HTTP中请求消息（request）"><a href="#四、HTTP中请求消息（request）" class="headerlink" title="四、HTTP中请求消息（request）"></a>四、HTTP中请求消息（request）</h1><h2 id="4-1、请求消息格式"><a href="#4-1、请求消息格式" class="headerlink" title="4.1、请求消息格式"></a>4.1、请求消息格式</h2><p> 　客户端发送一个HTTP请求到服务器的请求消息是有一定的格式：</p>
<p>　　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170930210336403-1134722875.png" alt="img"></p>
<p>　　从上面可以看出来，请求消息由四部分组成：</p>
<p>　　请求行（request line）、请求头部（header）、空行和请求数据四个部分组成</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170930210549184-1505946240.png" alt="img"></p>
<p>　　第一行中的Method表示请求方法,比如”POST”,”GET”, Path-to-resoure表示请求的资源（url）， Http/version-number 表示HTTP协议的版本号</p>
<p>　　当使用的是”GET” 方法的时候， body是为空的。</p>
<h2 id="4-2、用GET请求的请求报文"><a href="#4-2、用GET请求的请求报文" class="headerlink" title="4.2、用GET请求的请求报文"></a>4.2、用GET请求的请求报文</h2><p>　　当我们访问搜狐的官网的时候，我使用的是Firebug抓取的请求消息</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170930211630450-1434056493.png" alt="img"></p>
<p>　　第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本。</p>
<p>　　　　GET　/<a href="http://www.sohu.com" target="_blank" rel="noopener">http://www.sohu.com</a> HTTP/1.1 请求行，只不过这里被分开了，请求的方式 URL　版本</p>
<p>　　第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。　</p>
<p>　　　　1）Host：主机名 <a href="http://www.solu.com" target="_blank" rel="noopener">www.solu.com</a>　　　　　　</p>
<p>　　　　2）User-Agent：使用什么代理服务器，这里就是FireFox，也就是火狐</p>
<p>　　　　3）Accept：能接收的数据类型有哪些</p>
<p>　　　　4）Accept-Language：表示用户希望优先想得到的版本，一次排列下去，先是中文，再是英文</p>
<p>　　　　5）Accept-Encoding：通知服务端可以发送的数据压缩格式</p>
<p>　　　　6）Cookie：浏览器端的一个技术，在服务器上记录用户信息，但是也会在浏览器中保存一份。</p>
<p>　　　　7）Connection：连接的方式，有两种，非持续连接和持续连接，非持续连接，一次请求/响应就对应一个TCP连接，接到了响应该连接就关闭，然后在发送请求就在建立TCP连接，持续连接就相反，这里使用的是持续连接</p>
<p>　　　　8）Upgrade-Insecure-Requests：该指令用于让浏览器自动升级请求从http到https,用于大量包含http资源的http网页直接升级到https而不会报错.简洁的来讲,就相当于在http和https之间起的一个过渡作用。</p>
<p>　　第三部分：空行，请求头部后面的空行是必须的<br>　　　　即使第四部分的请求数据为空，也必须有空行。　</p>
<p>　　第四部分：请求数据也叫主体，可以添加任意的其他数据。<br>　　　　使用GET方式请求时请求数据为空。</p>
<p>　　由于一般请求报文都不会有请求数据的，所以在9后面就没有内容了，一般如果想要发送数据过去度会通过在域名后面加?然后将数据创送过去</p>
<h2 id="4-3、用POST请求的请求报文"><a href="#4-3、用POST请求的请求报文" class="headerlink" title="4.3、用POST请求的请求报文"></a>4.3、用POST请求的请求报文</h2><p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170930212852669-786954344.png" alt="img"></p>
<p>　　第一部分：请求行，第一行明了是post请求，以及http1.1版本。<br>　　第二部分：请求头部，第二行至第六行。<br>　　第三部分：空行，第七行的空行。<br>　　第四部分：请求数据，第八行。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="五、HTTP请求详解"><a href="#五、HTTP请求详解" class="headerlink" title="五、HTTP请求详解"></a>五、HTTP请求详解</h1><h2 id="5-1、HTTP请求方法"><a href="#5-1、HTTP请求方法" class="headerlink" title="5.1、HTTP请求方法"></a>5.1、HTTP请求方法</h2><p>　　根据HTTP标准，HTTP请求可以使用多种请求方法。<br>　　HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET：请求指定的页面信息，并返回实体主体。</span><br><span class="line">POST： 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</span><br><span class="line">HEAD： 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</span><br></pre></td></tr></table></figure>

<p>　　HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT：从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">DELETE ：请求服务器删除指定的页面。</span><br><span class="line">CONNECT：HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。</span><br><span class="line">OPTIONS： 允许客户端查看服务器的性能。</span><br><span class="line">TRACE：回显服务器收到的请求，主要用于测试或诊断。</span><br></pre></td></tr></table></figure>

<h2 id="5-2、GET和POST请求的区别"><a href="#5-2、GET和POST请求的区别" class="headerlink" title="5.2、GET和POST请求的区别"></a>5.2、GET和POST请求的区别</h2><p>　　Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE.。一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。</p>
<p>　  我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。</p>
<p>　　1）提交数据方式：GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接。</p>
<p>　　　　例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，</p>
<p>　　　　　　  如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p>
<p>　　　　POST提交：把提交的数据放置在是HTTP包的包体中。在前面的例子中提交的数据就是在回车换行的下面。　</p>
<p>　　2）传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。而在实际开发中存在的限制主要有：　　</p>
<p>　　　　GET：特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。</p>
<p>　　　　　　因此对于GET提交时，传输数据就会受到URL长度的 限制。</p>
<p>　　　　POST：由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p>
<p>　　3）安全性：POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，</p>
<p>　　　　除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。</p>
<p>　　4）Http get,post,soap协议都是在http上运行的　</p>
<p>　　　　get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的<br>　　　　　　查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全</p>
<p>　　　　post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。</p>
<p>　　　　　　  post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。</p>
<p>　　　　soap：是http post的一个专用版本，遵循一种特殊的xml消息格式，Content-type设置为: text/xml 任何数据都可以xml化。<br>　　总结上面所说的，GET和POST的区别：　　</p>
<p>　　 GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。POST方法是把提交的数据放在HTTP包的Body中.</p>
<p>　　 GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p>
<p>　　 GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p>
<p>　　 GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p>
<h2 id="5-3、打开一个网页需要浏览器发送多次Request请求"><a href="#5-3、打开一个网页需要浏览器发送多次Request请求" class="headerlink" title="5.3、打开一个网页需要浏览器发送多次Request请求"></a>5.3、打开一个网页需要浏览器发送多次Request请求</h2><p>　　1） 当你在浏览器输入URL <a href="http://www.cnblogs.com" target="_blank" rel="noopener">http://www.cnblogs.com</a> 的时候，浏览器发送一个Request去获取 <a href="http://www.cnblogs.com" target="_blank" rel="noopener">http://www.cnblogs.com</a> 的html. 服务器把Response发送回给浏览器.<br>　　2） 浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件。<br>　　3） 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。<br>　　4） 等所有的文件都下载成功后。 网页就被显示出来了。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="六、HTTP中响应消息（response）"><a href="#六、HTTP中响应消息（response）" class="headerlink" title="六、HTTP中响应消息（response）"></a>六、HTTP中响应消息（response）</h1><h2 id="6-1、响应消息格式"><a href="#6-1、响应消息格式" class="headerlink" title="6.1、响应消息格式"></a>6.1、响应消息格式</h2><p>　　一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。格式如下：</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170930213225653-1491450577.png" alt="img"></p>
<p>　　HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>
<h2 id="6-2、响应消息"><a href="#6-2、响应消息" class="headerlink" title="6.2、响应消息"></a>6.2、响应消息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>　　第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>
<p>　　　　第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</p>
<p>　　第二部分：消息报头，用来说明客户端要使用的一些附加信息</p>
<p>　　　　第二行和第三行为消息报头。Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</p>
<p>　　第三部分：空行，消息报头后面的空行是必须的</p>
<p>　　第四部分：响应正文，服务器返回给客户端的文本信息。</p>
<p>　　　　空行后面的html部分为响应正文。</p>
<h2 id="6-3、响应状态码"><a href="#6-3、响应状态码" class="headerlink" title="6.3、响应状态码"></a>6.3、响应状态码</h2><p>　　状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别：<br>　　　　1xx：指示信息–表示请求已接收，继续处理<br>　　　　2xx：成功–表示请求已被成功接收、理解、接受<br>　　　　3xx：重定向–要完成请求必须进行更进一步的操作<br>　　　　4xx：客户端错误–请求有语法错误或请求无法实现<br>　　　　5xx：服务器端错误–服务器未能实现合法的请求</p>
<p>　　常见的状态码有：　</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200 OK                        &#x2F;&#x2F;客户端请求成功</span><br><span class="line">400 Bad Request               &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line">403 Forbidden                 &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 &#x2F;&#x2F;请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error     &#x2F;&#x2F;服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        &#x2F;&#x2F;服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7614800.html#_labelTop" target="_blank" rel="noopener">回到顶部(go to top)</a></p>
<h1 id="七、HTTP工作原理"><a href="#七、HTTP工作原理" class="headerlink" title="七、HTTP工作原理"></a>七、HTTP工作原理</h1><p>前面把HTTP的内容讲的非常的细致，那我们来总体的看一下它的工作原理吧！</p>
<p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，</p>
<p>请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p> HTTP 请求/响应的步骤：</p>
<p>　　1）客户端连接到Web服务器</p>
<p>　　　　一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn。" target="_blank" rel="noopener">http://www.oakcms.cn。</a></p>
<p>　　2）发送HTTP请求</p>
<p>　　　　通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p>
<p>　　3）服务器接受请求并返回HTTP响应</p>
<p>　　　　Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>
<p>　　4）释放连接TCP连接</p>
<p>　　　　若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>
<p>　　5）客户端浏览器解析HTML内容</p>
<p>　　　　客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。</p>
<p>　　　　客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>
<p>　　例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>
<p>　　　　浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p>
<p>　　　　解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</p>
<p>　　　　浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</p>
<p>　　　　服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p>
<p>　　　　释放 TCP连接;</p>
<p>　　　　浏览器将该 html 文本并显示内容;</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>crawlerblog</title>
    <url>/2020/04/27/crawlerblog/</url>
    <content><![CDATA[<p>原文：[<a href="https://www.zhihu.com/search?type=content&amp;q=%20%E7%88%AC%E8%99%AB%E6%80%8E%E4%B9%88%E5%AD%A6]" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=%20%E7%88%AC%E8%99%AB%E6%80%8E%E4%B9%88%E5%AD%A6]</a>(<a href="https://www.zhihu.com/search?type=content&amp;q=" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=</a> 爬虫怎么学)</p>
<p>博客：<a href="https://cuiqingcai.com/947.html" target="_blank" rel="noopener">https://cuiqingcai.com/947.html</a></p>
<h1 id="python爬虫入门"><a href="#python爬虫入门" class="headerlink" title="python爬虫入门"></a>python爬虫入门</h1><h2 id="1-爬虫基础了解"><a href="#1-爬虫基础了解" class="headerlink" title="1.爬虫基础了解"></a>1.爬虫基础了解</h2><h3 id="1-什么是爬虫"><a href="#1-什么是爬虫" class="headerlink" title="1.什么是爬虫"></a>1.什么是爬虫</h3><p>爬虫，即网络爬虫，大家可以理解为在网络上爬行的一直蜘蛛，互联网就比作一张大网，而爬虫便是在这张网上爬来爬去的蜘蛛咯，如果它遇到资源，那么它就会抓取下来。想抓取什么？这个由你来控制它咯。</p>
<p>比如它在抓取一个网页，在这个网中他发现了一条道路，其实就是指向网页的超链接，那么它就可以爬到另一张网上来获取数据。这样，整个连在一起的大网对这之蜘蛛来说触手可及，分分钟爬下来不是事儿。</p>
<h3 id="2-浏览网页的过程"><a href="#2-浏览网页的过程" class="headerlink" title="2.浏览网页的过程"></a>2.浏览网页的过程</h3><p>在用户浏览网页的过程中，我们可能会看到许多好看的图片，比如 <a href="http://image.baidu.com/" target="_blank" rel="noopener">http://image.baidu.com/</a> ，我们会看到几张的图片以及百度搜索框，这个过程其实就是用户输入网址之后，经过DNS服务器，找到服务器主机，向服务器发出一个请求，服务器经过解析之后，发送给用户的浏览器 HTML、JS、CSS 等文件，浏览器解析出来，用户便可以看到形形色色的图片了。</p>
<p>因此，用户看到的网页实质是由 HTML 代码构成的，爬虫爬来的便是这些内容，通过分析和过滤这些 HTML 代码，实现对图片、文字等资源的获取。</p>
<h3 id="3-URL的含义"><a href="#3-URL的含义" class="headerlink" title="3.URL的含义"></a>3.URL的含义</h3><p>URL，即统一资源定位符，也就是我们说的网址，统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p>
<blockquote>
<p>URL的格式由三部分组成：<br>①第一部分是协议(或称为服务方式)。<br>②第二部分是存有该资源的主机IP地址(有时也包括端口号)。<br>③第三部分是主机资源的具体地址，如目录和文件名等。</p>
</blockquote>
<p>爬虫爬取数据时必须要有一个目标的URL才可以获取数据，因此，它是爬虫获取数据的基本依据，准确理解它的含义对爬虫学习有很大帮助。</p>
<h2 id="2-Urllib库基本使用"><a href="#2-Urllib库基本使用" class="headerlink" title="2. Urllib库基本使用"></a>2. Urllib库基本使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib2</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">response = urllib2.urlopen(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">print(response.read())</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> urlopen(url, data, timeout)</span><br><span class="line"></span><br><span class="line">第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。</span><br><span class="line"></span><br><span class="line">第二三个参数是可以不传送的，data默认为空<span class="literal">None</span>，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT</span><br><span class="line"></span><br><span class="line">第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> print response.read()</span><br><span class="line">response对象有一个read方法，可以返回获取到的网页内容。</span><br><span class="line">如果不加read直接打印会是什么？</span><br><span class="line">&lt;addinfourl at 139728495260376 whose fp &#x3D; &lt;socket._fileobject **object** at 0x7f1513fb3ad0&gt;&gt;</span><br><span class="line">直接打印出了该对象的描述，所以记得一定要加read方法</span><br></pre></td></tr></table></figure>

<h3 id="构造Request"><a href="#构造Request" class="headerlink" title="构造Request"></a>构造Request</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib2</span><br><span class="line"> </span><br><span class="line">request = urllib2.Request(<span class="string">"http://www.baidu.com"</span>)<span class="comment">#推荐这样书写，因为在构建请求时还需要加入好多内容，通过构建一个request，服务器响应请求得到应答，这样显得逻辑上清晰明确。</span></span><br><span class="line">response = urllib2.urlopen(request)</span><br><span class="line">print(response.read())</span><br></pre></td></tr></table></figure>

<h3 id="POST和GET数据传送"><a href="#POST和GET数据传送" class="headerlink" title="POST和GET数据传送"></a>POST和GET数据传送</h3><p>上面的程序演示了最基本的网页抓取，不过，现在大多数网站都是动态网页，需要你动态地传递参数给它，它做出对应的响应。所以，在访问时，我们需要传递数据给它。</p>
<p>GET方式是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。POST则不会在网址上显示所有的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>python400集2</title>
    <url>/2020/04/29/python400%E9%9B%862/</url>
    <content><![CDATA[<h1 id="python基础入门"><a href="#python基础入门" class="headerlink" title="python基础入门"></a>python基础入门</h1><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>python 中常用的序列结构有:</p>
<p>字符串、列表、元组、字典、集合</p>
<h2 id="列表简介"><a href="#列表简介" class="headerlink" title="列表简介"></a><strong>列表简介</strong></h2><p><strong>列表:用于存储任意数目、任意类型的数据集合。</strong></p>
<p>列表是内置可变序列，是包含多个元素的有序连续的内存空间。列表定义的标准语法格式: a = [10,20,30,40]</p>
<p>其中，10,20,30,40 这些称为:列表 a 的元素。 列表中的元素可以各不相同，可以是任意类型。比如:</p>
<p>a = [10,20,’abc’,True] 列表对象的常用方法汇总如下，方便大家学习和查阅。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>要点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>list.append(x)</td>
<td>增加元素</td>
<td>将元素 x 增加到列表 list 尾部</td>
</tr>
<tr>
<td>list.extend(aList)</td>
<td>增加元素</td>
<td>将列表 alist 所有元素加到列表 list 尾部</td>
</tr>
<tr>
<td>list.insert(index,x)</td>
<td>增加元素</td>
<td>在列表 list 指定位置 index 处插入元素 x</td>
</tr>
<tr>
<td>list.remove(x)</td>
<td>删除元素</td>
<td>在列表 list 中删除首次出现的指定元素 x</td>
</tr>
<tr>
<td>list.pop([index])</td>
<td>删除元素</td>
<td>删除并返回列表 list 指定为止 index 处的元素，默认是 最后一个元素</td>
</tr>
<tr>
<td>list.clear()</td>
<td>删除所有元素</td>
<td>删除列表所有元素，并不是删除列表对象</td>
</tr>
<tr>
<td>list.index(x)</td>
<td>访问元素</td>
<td>返回第一个 x 的索引位置，若不存在 x 元素抛出异常</td>
</tr>
<tr>
<td>list.count(x)</td>
<td>计数</td>
<td>返回指定元素 x 在列表 list 中出现的次数</td>
</tr>
<tr>
<td>len(list)</td>
<td>列表长度</td>
<td><code>返回列表中包含元素的个数</code></td>
</tr>
<tr>
<td>list.reverse()</td>
<td>翻转列表</td>
<td>所有元素原地翻转</td>
</tr>
<tr>
<td>list.sort()</td>
<td>排序</td>
<td>所有元素原地排序</td>
</tr>
<tr>
<td>list.copy()</td>
<td>浅拷贝</td>
<td>返回列表对象的浅拷贝</td>
</tr>
</tbody></table>
<p>Python 的列表大小可变，根据需要随时增加或缩小。</p>
<p>字符串和列表都是序列类型，一个字符串是一个字符序列，一个列表是任何元素的序列。我 们前面学习的很多字符串的方法，在列表中也有类似的用法，几乎一模一样。</p>
<p><strong>列表的创建</strong></p>
<h5 id="基本语法-创建"><a href="#基本语法-创建" class="headerlink" title="基本语法[]创建"></a><strong>基本语法[]创建</strong></h5><p><strong>list()创建</strong>: 使用 list()可以将任何可迭代的数据转化成列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; list(&quot;gaoqi,sxt&quot;)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[&#39;g&#39;, &#39;a&#39;, &#39;o&#39;, &#39;q&#39;, &#39;i&#39;, &#39;,&#39;, &#39;s&#39;, &#39;x&#39;, &#39;t&#39;]</span><br></pre></td></tr></table></figure>

<p><strong>range()创建整数列表</strong></p>
<p>range()可以帮助我们非常方便的创建整数列表，这在开发中及其有用。语法格式为: range([start,] end [,step])</p>
<p>start 参数:可选，表示起始数字。默认是 0<br> end 参数:必选，表示结尾数字。<br> step 参数:可选，表示步长，默认为 1<br> python3 中 range()返回的是一个 range 对象，而不是列表。我们需要通过 list()方法将其 转换成列表对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(3,15,2))</span><br><span class="line">[3, 5, 7, 9, 11, 13]</span><br></pre></td></tr></table></figure>

<p><strong>推导式生成列表</strong></p>
<p>使用列表推导式可以非常方便的创建列表，在开发中经常使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> a &#x3D; [x*2 for x in range(100) if x%9&#x3D;&#x3D;0] #通过 if 过滤元素 </span><br><span class="line"> &gt;&gt;&gt; a</span><br><span class="line">[0, 18, 36, 54, 72, 90, 108, 126, 144, 162, 180, 198]</span><br></pre></td></tr></table></figure>

<p><strong>列表元素的增加和删除</strong></p>
<p>当列表增加和删除元素时，列表会自动进行内存管理，大大减少了程序员的负担。但这 个特点涉及列表元素的大量移动，效率较低。除非必要，我们一般只在列表的尾部添加元素 或删除元素，这会大大提高列表的操作效率。</p>
<p><strong>append()方法</strong></p>
<p>原地修改列表对象，是真正的列表尾部添加新的元素，速度最快，推荐使用。 a.append(80)</p>
<p><strong>+运算符操作</strong></p>
<p>并不是真正的尾部添加元素，而是创建新的列表对象;将原列表的元素和新列表的元素依次 复制到新的列表对象中。这样，会涉及大量的复制操作，对于操作大量元素不建议使用。a = a+[50]</p>
<p><strong>extend()方法</strong></p>
<p>将目标列表的所有元素添加到本列表的尾部，属于原地操作，不创建新的列表对象。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [20,40]</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">46016072</span><br><span class="line">&gt;&gt;&gt; a.extend([50,60])</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">46016072</span><br></pre></td></tr></table></figure>

<p><strong>insert()插入元素</strong></p>
<p>使用 insert()方法可以将指定的元素插入到列表对象的任意制定位置。这样会让插入位置后 面所有的元素进行移动，会影响处理速度。涉及大量元素时，尽量避免使用。类似发生这种 移动的函数还有:remove()、pop()、del()，它们在删除非尾部元素时也会发生操作位置后 面元素的移动。</p>
<p>a.insert(2,100)#在index2处加入100</p>
<p><strong>乘法扩展</strong></p>
<p>使用乘法扩展列表，生成一个新列表，新列表元素时原列表元素的多次重复。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b &#x3D; a*3 </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[&#39;sxt&#39;, 100] </span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[&#39;sxt&#39;, 100, &#39;sxt&#39;, 100, &#39;sxt&#39;, 100]</span><br></pre></td></tr></table></figure>

<p><strong>列表元素的删除 del 删除</strong></p>
<p>删除列表指定位置的元素。del a[1]</p>
<p><strong>pop()方法</strong></p>
<p>pop()删除并返回指定位置元素，如果未指定位置则默认操作列表最后一个元素。</p>
<p>a.pop(1)#返回index 1的元素</p>
<p><strong>remove()方法</strong></p>
<p>删除首次出现的指定元素，若不存在该元素抛出异常。a.remove(20)</p>
<h3 id="列表元素访问和计数"><a href="#列表元素访问和计数" class="headerlink" title="列表元素访问和计数"></a>列表元素访问和计数</h3><p>我们可以通过索引直接访问元素。索引的区间在[0, 列表长度-1]这个范围。超过这个范围则 会抛出异常。</p>
<p><strong>index()获得指定元素在列表中首次出现的索引</strong></p>
<p>index()可以获取指定元素首次出现的索引位置。语法是:index(value,[start,[end]])。其中， start 和 end 指定了搜索的范围。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a.index(30,5,7) #从索引位置 5 到 7 这个区间，第一次出现 30 元素的位置</span><br></pre></td></tr></table></figure>

<p><strong>count()获得指定元素在列表中出现的次数</strong></p>
<p>count()可以返回指定元素在列表中出现的次数。 a.count(20)</p>
<p><strong>len()返回列表长度</strong></p>
<p>len()返回列表长度，即列表中包含元素的个数。 len(a)</p>
<p><strong>成员资格判断</strong></p>
<p>判断列表中是否存在指定的元素，我们可以使用 count()方法，返回 0 则表示不存在，返回 大于 0 则表示存在。但是，一般我们会使用更加简洁的 in 关键字来判断，直接返回 True 或 False。100 not in a</p>
<ol>
<li><p><strong>切片操作</strong></p>
<p>我们在前面学习字符串时，学习过字符串的切片操作，对于列表的切片操作和字符串类似。 切片是 Python 序列及其重要的操作，适用于列表、元组、字符串等等。切片的格式如下:</p>
<p>切片 slice 操作可以让我们快速提取子列表或修改。标准格式为: [起始偏移量 start:终止偏移量 end[:步长 step]]</p>
<p>注:当步长省略时顺便可以省略第二个冒号</p>
<table>
<thead>
<tr>
<th>操作和说明</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>[:] 提取整个列表</td>
<td>[10,20,30][:]</td>
<td>[10,20,30]</td>
</tr>
<tr>
<td>[start:]从 start 索引开始到 结尾</td>
<td>[10,20,30][1:]</td>
<td>[20,30]</td>
</tr>
<tr>
<td>[:end]从头开始知道 end-1</td>
<td>[10,20,30][:2]</td>
<td>[10,20]</td>
</tr>
<tr>
<td>[start:end]从 start 到 end-1</td>
<td>[10,20,30,40][1:3]</td>
<td>[20,30]</td>
</tr>
<tr>
<td>[start:end:step] 从 start 提 取到 end-1，步长是 step</td>
<td>[10,20,30,40,50,60,70][1:6: 2]</td>
<td>[20, 40, 60]</td>
</tr>
</tbody></table>
</li>
</ol>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>[10,20,30,40,50,60,70][-3:]</td>
<td>倒数三个</td>
<td>[50,60,70]</td>
</tr>
<tr>
<td>10,20,30,40,50,60,70][-5:-3]</td>
<td>倒数第五个到倒数 第三个(包头不包尾)</td>
<td>[30,40]</td>
</tr>
<tr>
<td>[10,20,30,40,50,60,70][::-1]</td>
<td>步长为负，从右到左 反向提取</td>
<td>[70, 60, 50, 40, 30, 20, 10]</td>
</tr>
</tbody></table>
<p>切片操作时，起始偏移量和终止偏移量不在[0,字符串长度-1]这个范围，也不会报错。起始 偏移量小于 0 则会当做 0，终止偏移量大于“长度-1”会被当成”长度-1”</p>
<p><strong>列表的遍历</strong></p>
<p>for obj in listObj: print(obj)</p>
<h3 id="复制列表所有的元素到新列表对象"><a href="#复制列表所有的元素到新列表对象" class="headerlink" title="复制列表所有的元素到新列表对象"></a>复制列表所有的元素到新列表对象</h3><p>我们可以通过如下简单方式，实现列表元素内容的复制: list1 = [30,40,50]</p>
<p>list2 = [] + list1</p>
<h3 id="列表排序"><a href="#列表排序" class="headerlink" title="*列表排序 *"></a>*<em>列表排序 *</em></h3><p><strong>修改原列表，不建新列表的排序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [20,10,30,40]</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">46017416</span><br><span class="line">&gt;&gt;&gt; a.sort() #默认是升序排列 </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[10, 20, 30, 40]</span><br><span class="line">&gt;&gt;&gt; a &#x3D; [10,20,30,40] </span><br><span class="line">&gt;&gt;&gt; a.sort(reverse&#x3D;True) #降序</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[40, 30, 20, 10]</span><br><span class="line">&gt;&gt;&gt; import random </span><br><span class="line">&gt;&gt;&gt; random.shuffle(a) #打乱排序</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[20, 40, 30, 10]</span><br></pre></td></tr></table></figure>

<h3 id="建新列表排序"><a href="#建新列表排序" class="headerlink" title="建新列表排序"></a>建新列表排序</h3><p>我们也可以通过内置函数 sorted()进行排序，这个方法返回新列表，不对原列表做修改。</p>
<p> a = sorted(a)</p>
<p> c = sorted(a,reverse=True)   #降序</p>
<p><strong>reversed()返回迭代器</strong></p>
<p>内置函数 reversed()也支持进行逆序排列，与列表对象 reverse()方法不同的是，内置函数 reversed()不对原列表做任何修改，只是返回一个逆序排列的迭代器对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">20</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">40</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = reversed(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">&lt;list_reverseiterator object at <span class="number">0x0000000002BCCEB8</span>&gt; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(c)</span><br><span class="line">[<span class="number">40</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(c)</span><br><span class="line">[]</span><br><span class="line">···</span><br><span class="line">我们打印输出 c 发现提示是:list_reverseiterator。也就是一个迭代对象。同时，我们使用 list(c)进行输出，发现只能使用一次。第一次输出了元素，第二次为空。那是因为迭代对象 在第一次时已经遍历结束了，第二次不能再使用。</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p><strong>列表相关的其他内置函数汇总 max 和 min</strong></p>
<p>用于返回列表中最大和最小值。max（a）</p>
<p><strong>sum</strong></p>
<p>对数值型列表的所有元素进行求和操作，对非数值型列表运算则会报错。</p>
<h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 tuple"></a><strong>元组 tuple</strong></h2><p>列表属于可变序列，可以任意修改列表中的元素。元组属于不可变序列，不能修改元组中的 元素。因此，元组没有增加元素、修改元素、删除元素相关的方法。</p>
<p>因此，我们只需要学习元组的创建和删除，元组中元素的访问和计数即可。元组支持如 下操作:</p>
<p>\1. 索引访问<br> \2. 切片操作<br> \3. 连接操作<br> \4. 成员关系操作<br> \5. 比较运算操作<br> \6. 计数:元组长度 len()、最大值 max()、最小值 min()、求和 sum()等。</p>
<h3 id="元组的创建"><a href="#元组的创建" class="headerlink" title="元组的创建"></a><strong>元组的创建</strong></h3><p>\1. 通过()创建元组。小括号可以省略。</p>
<p> 如果元组只有一个元素，则必须后面加逗号。这是因为解释器会把(1)解释为整数 1，(1,) 解释为元组。</p>
<p>a = (10,20,30) 或者 a = 10,20,30</p>
<p>\2. 通过 tuple()创建元组 tuple(可迭代的对象)</p>
<p>tuple()可以接收列表、字符串、其他序列类型、迭代器等生成元组。 list()可以接收元组、字符串、其他序列类型、迭代器等生成列表。</p>
<h3 id="元组的元素访问和计数"><a href="#元组的元素访问和计数" class="headerlink" title="元组的元素访问和计数"></a><strong>元组的元素访问和计数</strong></h3><p>\1. 元组的元素不能修改</p>
<p>\2. 元组的元素访问和列表一样，只不过返回的仍然是元组对象。</p>
<p>\3. 列表关于排序的方法 list.sorted()是修改原列表对象，元组没有该方法。如果要对元组排 序，只能使用内置函数 sorted(tupleObj)，并生成新的列表对象。 sorted(a)</p>
<p><strong>zip</strong></p>
<p>zip(列表 1，列表 2，…)将多个列表对应位置的元素组合成为元组，并返回这个 zip 对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [10,20,30]</span><br><span class="line">&gt;&gt;&gt; b &#x3D; [40,50,60]</span><br><span class="line">&gt;&gt;&gt; c &#x3D; [70,80,90]</span><br><span class="line">&gt;&gt;&gt; d &#x3D; zip(a,b,c)</span><br><span class="line">&gt;&gt;&gt; list(d)</span><br><span class="line">[(10, 40, 70), (20, 50, 80), (30, 60, 90)]</span><br></pre></td></tr></table></figure>

<p><strong>生成器推导式创建元组</strong></p>
<p>从形式上看，生成器推导式与列表推导式类似，只是生成器推导式使用小括号。列表推 导式直接生成列表对象，生成器推导式生成的不是列表也不是元组，而是一个生成器对象。</p>
<p>我们可以通过生成器对象，转化成列表或者元组。也可以使用生成器对象的<strong>next</strong>() 方法进行遍历，或者直接作为迭代器对象来使用。不管什么方式使用，元素访问结束后，如 果需要重新访问其中的元素，必须重新创建该生成器对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; (x*2 for x in range(5))</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x0000000002BDEB48&gt;</span><br><span class="line">&gt;&gt;&gt; tuple(s)</span><br><span class="line">(0, 2, 4, 6, 8)</span><br><span class="line">&gt;&gt;&gt; list(s) #只能访问一次元素。第二次就为空了。需要再生成一次 </span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x0000000002BDEB48&gt;</span><br><span class="line">&gt;&gt;&gt; tuple(s)</span><br><span class="line">()</span><br><span class="line">&gt;&gt;&gt; s &#x3D; (x*2 for x in range(5))</span><br><span class="line">&gt;&gt;&gt; s.__next__()</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; s.__next__()</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; s.__next__()</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><strong>元组总结</strong></p>
<p>\1. 元组的核心特点是:不可变序列。<br> \2. 元组的访问和处理速度比列表快。<br> \3. 与整数和字符串一样，元组可以作为字典的键，列表则永远不能作为字典的键使用。</p>
<h2 id="字典介绍"><a href="#字典介绍" class="headerlink" title="字典介绍"></a><strong>字典介绍</strong></h2><p>字典是“键值对”的无序可变序列，字典中的每个元素都是一个“键值对”，包含:“键 对象”和“值对象”。可以通过“键对象”实现快速获取、删除、更新对应的“值对象”。</p>
<p>列表中我们通过“下标数字”找到对应的对象。字典中通过“键对象”找到对应的“值 对象”。“键”是任意的不可变数据，比如:整数、浮点数、字符串、元组。但是:列表、 字典、集合这些可变对象，不能作为“键”。并且“键”不可重复。</p>
<p>“值”可以是任意的数据，并且可重复。</p>
<p><strong>字典的创建</strong></p>
<p>\1. 我们可以通过{}、dict()来创建字典对象。</p>
<p>\2. 通过 zip()创建字典对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; k &#x3D; [&#39;name&#39;,&#39;age&#39;,&#39;job&#39;]</span><br><span class="line">&gt;&gt;&gt; v &#x3D; [&#39;gaoqi&#39;,18,&#39;techer&#39;]</span><br><span class="line">&gt;&gt;&gt; d &#x3D; dict(zip(k,v))</span><br></pre></td></tr></table></figure>

<p>\3. 通过 fromkeys 创建值为空的字典</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; dict.fromkeys([&#39;name&#39;,&#39;age&#39;,&#39;job&#39;]) </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#39;name&#39;: None, &#39;age&#39;: None, &#39;job&#39;: None&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字典元素的访问</strong></p>
<p>\1. 通过 [键] 获得“值”。若键不存在，则抛出异常。 a[‘name’]</p>
<p>\2. 通过 get()方法获得“值”。推荐使用。优点是:指定键不存在，返回 None;也可以设 定指定键不存在时默认返回的对象。推荐使用 get()获取“值对象”。a.get(‘name’)</p>
<p>\3. 列出所有的键值对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a.items()</span><br><span class="line">dict_items([(&#39;name&#39;, &#39;gaoqi&#39;), (&#39;age&#39;, 18), (&#39;job&#39;, &#39;programmer&#39;)])</span><br></pre></td></tr></table></figure>

<p>\4. 列出所有的键，列出所有的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a.keys()</span><br><span class="line">dict_keys([&#39;name&#39;, &#39;age&#39;, &#39;job&#39;])</span><br><span class="line">&gt;&gt;&gt; a.values()</span><br><span class="line">dict_values([&#39;gaoqi&#39;, 18, &#39;programmer&#39;])</span><br></pre></td></tr></table></figure>

<p>\5. len() 键值对的个数<br> \6. 检测一个“键”是否在字典中 用in</p>
<h3 id="字典元素添加、修改、删除"><a href="#字典元素添加、修改、删除" class="headerlink" title="字典元素添加、修改、删除"></a><strong>字典元素添加、修改、删除</strong></h3><p>\1. 给字典新增“键值对”。如果“键”已经存在，则覆盖旧的键值对;如果“键”不存在， 则新增“键值对”。a[‘age’]=16</p>
<p>\2. 使用 update()将新字典中所有键值对全部添加到旧字典对象上。如果 key 有重复，则直 接覆盖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &#123;&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;job&#39;:&#39;programmer&#39;&#125; </span><br><span class="line">&gt;&gt;&gt; b &#x3D; &#123;&#39;name&#39;:&#39;gaoxixi&#39;,&#39;money&#39;:1000,&#39;sex&#39;:&#39;男的&#39;&#125; </span><br><span class="line">&gt;&gt;&gt; a.update(b)</span><br></pre></td></tr></table></figure>

<p>\3. 字典中元素的删除，可以使用 del()方法;或者 clear()删除所有键值对;pop()删除指定 键值对，并返回对应的“值对象”;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; del(a[&#39;name&#39;])</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#39;age&#39;: 18, &#39;job&#39;: &#39;programmer&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; a.pop(&#39;age&#39;)</span><br></pre></td></tr></table></figure>

<p>\4. popitem() :随机删除和返回该键值对。字典是“无序可变序列”，因此没有第一个元 素、最后一个元素的概念;popitem 弹出随机的项，因为字典并没有”最后的元素”或者其 他有关顺序的概念。若想一个接一个地移除并处理项，这个方法就非常有效(因为不用首先获取键的列表)。</p>
<p> a.popitem()</p>
<p><strong>序列解包</strong></p>
<p>序列解包可以用于元组、列表、字典。序列解包可以让我们方便的对多个变量赋值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x,y,z&#x3D;(20,30,10)</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">30</span><br><span class="line">&gt;&gt;&gt; z</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; (a,b,c)&#x3D;(9,8,10) </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; [a,b,c]&#x3D;[10,20,30] </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<p>序列解包用于字典时，默认是对“键”进行操作; 如果需要对键值对操作，则需要使用 items();如果需要对“值”进行操作，则需要使用 values();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; &#123;&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;job&#39;:&#39;teacher&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; name,age,job&#x3D;s #默认对键进行操作 </span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">&#39;name&#39;</span><br><span class="line">&gt;&gt;&gt; name,age,job&#x3D;s.items() </span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">(&#39;name&#39;, &#39;gaoqi&#39;)</span><br><span class="line">&gt;&gt;&gt; name,age,job&#x3D;s.values() </span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">&#39;gaoqi&#39;</span><br></pre></td></tr></table></figure>

<h3 id="字典核心底层原理-重要"><a href="#字典核心底层原理-重要" class="headerlink" title="字典核心底层原理(重要)"></a><strong>字典核心底层原理(重要)</strong></h3><p>字典对象的核心是散列表。散列表是一个稀疏数组(总是有空白元素的数组)，数组的 每个单元叫做 bucket。每个 bucket 有两部分:一个是键对象的引用，一个是值对象的引 用。<br> 由于，所有 bucket 结构和大小一致，我们可以通过偏移量来读取指定 bucket。</p>
<p><strong>扩容</strong></p>
<p>python 会根据散列表的拥挤程度扩容。“扩容”指的是:创造更大的数组，将原有内容 拷贝到新数组中。</p>
<p>接近 2/3 时，数组就会扩容。</p>
<p>用法总结:<br> \1. 键必须可散列</p>
<p>(1) 数字、字符串、元组，都是可散列的。 </p>
<p>(2) 自定义对象需要支持下面三点:</p>
<ol>
<li>1  支持 hash()函数</li>
<li>2  支持通过<strong>eq</strong>()方法检测相等性。</li>
<li>3  若 a==b 为真，则 hash(a)==hash(b)也为真。</li>
</ol>
<p>\2. 字典在内存中开销巨大，典型的空间换时间。<br> \3. 键查询速度很快<br> \4. 往字典里面添加新建可能导致扩容，导致散列表中键的次序变化。因此，不要在遍历字 典的同时进行字典的修改。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h2><p><strong>集合创建和删除</strong></p>
<p>\1. 使用{}创建集合对象，并使用 add()方法添加元素</p>
<p>\2. 使用 set()，将列表、元组等可迭代对象转成集合。如果原来数据存在重复数据，则只保 留一个。</p>
<p>\3. remove()删除指定元素;clear()清空整个集合</p>
<p><strong>集合相关操作</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &#123;1,3,&#39;sxt&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; &#123;&#39;he&#39;,&#39;it&#39;,&#39;sxt&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a|b #并集</span><br><span class="line">&#123;1, 3, &#39;sxt&#39;, &#39;he&#39;, &#39;it&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a&amp;b #交集 </span><br><span class="line">&#123;&#39;sxt&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a-b #差集 </span><br><span class="line">&#123;1, 3&#125;</span><br><span class="line">&gt;&gt;&gt; a.union(b) #并集 </span><br><span class="line">&#123;1, 3, &#39;sxt&#39;, &#39;he&#39;, &#39;it&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a.intersection(b) #交集 </span><br><span class="line">&#123;&#39;sxt&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a.difference(b) #差集 </span><br><span class="line">&#123;1, 3&#125;</span><br></pre></td></tr></table></figure>

<h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="三元条件运算符"><a href="#三元条件运算符" class="headerlink" title="三元条件运算符"></a><strong>三元条件运算符</strong></h2><p>Python 提供了三元运算符，用来在某些简单双分支赋值情况。三元条件运算符语法格式如 下:</p>
<h3 id="条件为真时的值-if-条件表达式-else-条件为假时的值"><a href="#条件为真时的值-if-条件表达式-else-条件为假时的值" class="headerlink" title="条件为真时的值 if (条件表达式) else 条件为假时的值"></a>条件为真时的值 if (条件表达式) else 条件为假时的值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print( num if int(num)&lt;10 else &quot;数字太大&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>可迭代对象</strong></p>
<p>Python 包含以下几种可迭代对象: </p>
<ol>
<li>​    序列。包含:字符串、列表、元组 </li>
<li><ol start="2">
<li>字典</li>
<li>. 迭代器对象(iterator)<br>  \4. 生成器函数(generator)<br>  \5. 文件对象</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">for x in print(x)</span><br><span class="line">for x in print(x)</span><br><span class="line">d.keys():#遍历字典所有的 key</span><br><span class="line">d.values():#遍历字典所有的 value</span><br><span class="line">for x in d.items():#遍历字典所有的&quot;键值对&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【操作】利用嵌套循环打印九九乘法表</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">		<span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">			print(<span class="string">"&#123;0&#125;*&#123;1&#125;=&#123;2&#125;"</span>.format(m,n,(m*n)),end=<span class="string">"\t"</span>) </span><br><span class="line">		print()</span><br></pre></td></tr></table></figure>

<p><strong>使用 zip()并行迭代</strong></p>
<p>我们可以通过 zip()函数对多个序列进行并行迭代，zip()函数在最短序列“用完”时就会停止。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">names &#x3D; (&quot;高淇&quot;,&quot;高老二&quot;,&quot;高老三&quot;,&quot;高老四&quot;) </span><br><span class="line">ages &#x3D; (18,16,20,25)</span><br><span class="line">jobs &#x3D; (&quot;老师&quot;,&quot;程序员&quot;,&quot;公务员&quot;)</span><br><span class="line">for name,age,job in zip(names,ages,jobs): </span><br><span class="line">	print(&quot;&#123;0&#125;--&#123;1&#125;--&#123;2&#125;&quot;.format(name,age,job))</span><br></pre></td></tr></table></figure>

<p><strong>推导式创建序列</strong></p>
<p>推导式是从一个或者多个迭代器快速创建序列的一种方法。它可以将循环和条件判断结合， 从而避免冗长的代码。推导式是典型的 Python 风格，会使用它代表你已经超过 Python 初 学者的水平。</p>
<p><strong>列表推导式</strong></p>
<p>列表推导式生成列表对象，语法如下:<br> [表达式 for item in 可迭代对象 ]</p>
<p>或者:{表达式 for item in 可迭代对象 if 条件判断}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; [x for x in range(1,5)] </span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; [x*2 for x in range(1,5)]</span><br><span class="line">[2, 4, 6, 8]</span><br><span class="line">&gt;&gt;&gt; [x*2 for x in range(1,20) if x%5&#x3D;&#x3D;0 ] </span><br><span class="line">[10, 20, 30]</span><br><span class="line">&gt;&gt;&gt; [a for a in &quot;abcdefg&quot;]</span><br><span class="line">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span><br><span class="line">&gt;&gt;&gt; cells &#x3D; [(row,col) for row in range(1,10) for col in range(1,10)]</span><br><span class="line">#可以使用两个循环</span><br><span class="line">&gt;&gt;&gt; for cell in cells:</span><br><span class="line">print(cell)</span><br></pre></td></tr></table></figure>

<p><strong>字典推导式</strong></p>
<p>row in range(1,10) for col in range(1,10)]</p>
<p>#可以使用两</p>
<p>字典的推导式生成字典对象，格式如下:<br> {key_expression : value_expression for 表达式 in 可迭代对象}</p>
<p>类似于列表推导式，字典推导也可以增加 if 条件判断、多个 for 循环。</p>
<p>统计文本中字符出现的次数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\&gt;&gt;&gt; my_text &#x3D; &#39; i love you, i love sxt, i love gaoqi&#39;</span><br><span class="line">\&gt;&gt;&gt; char_count &#x3D; &#123;c:my_text.count(c) for c in my_text&#125;</span><br><span class="line">\&gt;&gt;&gt; char_count</span><br><span class="line">&#123;&#39; &#39;: 9, &#39;i&#39;: 4, &#39;l&#39;: 3, &#39;o&#39;: 5, &#39;v&#39;: 3, &#39;e&#39;: 3, &#39;y&#39;: 1, &#39;u&#39;: 1, &#39;,&#39;: 2, &#39;s&#39;: 1, &#39;x&#39;: 1, &#39;t&#39;: 1, &#39;g&#39;: 1, &#39;a&#39;: 1, &#39;q&#39;: 1&#125;</span><br></pre></td></tr></table></figure>

<p><strong>集合推导式</strong></p>
<p>集合推导式生成集合，和列表推导式的语法格式类似:<br> {表达式 for item in 可迭代对象 }</p>
<p>或者:{表达式 for item in 可迭代对象 if 条件判断}</p>
<p>&gt;&gt;&gt; {x for x in range(1,100) if x%9==0} {99, 36, 72, 9, 45, 81, 18, 54, 90, 27, 63}</p>
<h4 id="生成器推导式-生成元组"><a href="#生成器推导式-生成元组" class="headerlink" title="生成器推导式(生成元组)"></a>生成器推导式(生成元组)</h4><p>很多同学可能会问:“都有推导式，元组有没有?”，能不能用小括号呢? </p>
<p> (x for x in range(1,100) if x%9==0)<br> &lt;generator object <genexpr> at 0x0000000002BD3048&gt; </p>
<p>我们发现提示的是“一个生成器对象”。显然，元组是没有推导式的。</p>
<p>一个生成器只能运行一次。第一次迭代可以得到数据，第二次迭代发现数据已经没有了。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; gnt &#x3D; (x for x in range(1,100) if x%9&#x3D;&#x3D;0)</span><br><span class="line"> &gt;&gt;&gt; for x in gnt:</span><br><span class="line"></span><br><span class="line">print(x,end&#x3D;&#39; &#39;)</span><br><span class="line"> 9 18 27 36 45 54 63 72 81 90 99 </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; for x in gnt:</span><br><span class="line"></span><br><span class="line">print(x,end&#x3D;&#39; &#39;)</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Python 中函数分为如下几类: 1. 内置函数</p>
<p>我们前面使用的 str()、list()、len()等这些都是内置函数，我们可以拿来直接使用。</p>
<ol start="2">
<li>标准库函数</li>
</ol>
<p>我们可以通过 import 语句导入库，然后使用其中定义的函数 </p>
<ol start="3">
<li>第三方库函数</li>
</ol>
<p>Python 社区也提供了很多高质量的库。下载安装这些库后，也是通过 import 语句导 入，然后可以使用这些第三方库的函数</p>
<ol start="4">
<li>用户自定义函数</li>
</ol>
<p>用户自己定义的函数，显然也是开发中适应用户自身需求定义的函数。今天我们学习的 就是如何自定义函数。</p>
<h2 id="文档字符串-函数的注释"><a href="#文档字符串-函数的注释" class="headerlink" title="文档字符串(函数的注释)"></a><strong>文档字符串(函数的注释)</strong></h2><p>程序的可读性最重要，一般建议在函数体开始的部分附上函数定义说明，这就是“文档字符 串”，也有人成为“函数的注释”。我们通过三个单引号或者三个双引号来实现，中间可以</p>
<p>北京尚学堂·百战程序员 实战 系统 好教育</p>
<p>加入多行文字进行说明。</p>
<p><strong>函数也是对象，内存底层分析</strong></p>
<p>Python 中，“一切都是对象”。实际上，执行 def 定义函数后，系统就创建了相应的函数 对象。</p>
<h3 id="变量的作用域-全局变量和局部变量"><a href="#变量的作用域-全局变量和局部变量" class="headerlink" title="变量的作用域(全局变量和局部变量)"></a>变量的作用域<strong>(</strong>全局变量和局部变量<strong>)</strong></h3><p>变量起作用的范围称为变量的作用域，不同作用域内同名变量之间互不影响。变量分为:全局变量、局部变量。</p>
<p>全局变量:</p>
<p>\1. 在函数和类定义之外声明的变量。作用域为定义的模块，从定义位置开始直到模块 结束。</p>
<ol>
<li>全局变量降低了函数的通用性和可读性。应尽量避免全局变量的使用。</li>
<li>全局变量一般做常量使用。</li>
<li>函数内要改变全局变量的值，使用 global 声明一下</li>
</ol>
<p>局部变量:<br> \1. 在函数体中(包含形式参数)声明的变量。<br> \2. 局部变量的引用比全局变量快，优先考虑使用。<br> \3. 如果局部变量和全局变量同名，则在函数内隐藏全局变量，只使用同名的局部变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100</span> <span class="comment">#全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> a <span class="comment">#如果要在函数内改变全局变量的值，增加 global 关键字声明</span></span><br><span class="line">	print(a) <span class="comment">#打印全局变量 a 的值, </span></span><br><span class="line">	a = <span class="number">300</span></span><br><span class="line">  print(a)<span class="comment">#局部变量a</span></span><br><span class="line">  print(locals())</span><br><span class="line">  print(globals())</span><br><span class="line">f1() </span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">```结果</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">300</span></span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': '/Users/mengxiaowang/Documents/a.py', 'a': 300, 'f1': &lt;function f1 at 0x7ff5602dc430&gt;&#125;</span><br><span class="line"><span class="number">300</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>另一种输出，因为local变global后没有了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100</span> <span class="comment">#全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">300</span></span><br><span class="line">    print(locals())<span class="comment">#&#123;'a': 300&#125;</span></span><br><span class="line">    print(globals())<span class="comment">#&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'a': &lt;function a at 0x7f9388270830&gt;&#125;</span></span><br><span class="line">f1() </span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">```</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">300</span>&#125;</span><br><span class="line">&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': '/Users/mengxiaowang/Documents/a.py', 'a': 100, 'f1': &lt;function f1 at 0x7fc050745430&gt;&#125;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h3 id="局部变量和全局变量效率测试"><a href="#局部变量和全局变量效率测试" class="headerlink" title="局部变量和全局变量效率测试"></a>局部变量和全局变量效率测试</h3><p>局部变量的查询和访问速度比全局变量快，优先考虑使用，尤其是在循环的时候。 在特别强调效率的地方或者循环次数较多的地方，可以通过将全局变量转为局部变量提高运 行速度。</p>
<h3 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a><strong>参数的传递</strong></h3><p>函数的参数传递本质上就是:从实参到形参的赋值操作。 Python 中“一切皆对象”， 所有的赋值操作都是“引用的赋值”。所以，Python 中参数的传递都是“引用传递”，不 是“值传递”。具体操作时分为两类:</p>
<p>\1. 对“可变对象”进行“写操作”，直接作用于原对象本身。</p>
<p>\2. 对“不可变对象”进行“写操作”，会产生一个新的“对象空间”，并用新的值填 充这块空间。(起到其他语言的“值传递”效果，但不是“值传递”)</p>
<p>可变对象有: 字典、列表、集合、自定义的对象等</p>
<p>不可变对象有: 数字、字符串、元组、function 等</p>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a><strong>浅拷贝和深拷贝</strong></h3><p>为了更深入的了解参数传递的底层原理，我们需要讲解一下“浅拷贝和深拷贝”。我们可以 使用内置函数:copy(浅拷贝)、deepcopy(深拷贝)。</p>
<p>浅拷贝:不拷贝子对象的内容，只是拷贝子对象的引用。 深拷贝:会连子对象的内存也全部拷贝一份，对子对象的修改不会影响源对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testCopy</span><span class="params">()</span>:</span> <span class="string">'''测试浅拷贝'''</span></span><br><span class="line">	a = [<span class="number">10</span>, <span class="number">20</span>, [<span class="number">5</span>, <span class="number">6</span>]] </span><br><span class="line">  b = copy.copy(a)</span><br><span class="line">	print(<span class="string">"a"</span>, a) </span><br><span class="line">  print(<span class="string">"b"</span>, b) </span><br><span class="line">  b.append(<span class="number">30</span>) </span><br><span class="line">  b[<span class="number">2</span>].append(<span class="number">7</span>) </span><br><span class="line">  print(<span class="string">"浅拷贝......"</span>) </span><br><span class="line">  print(<span class="string">"a"</span>, a) </span><br><span class="line">  print(<span class="string">"b"</span>, b)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testDeepCopy</span><span class="params">()</span>:</span> <span class="string">'''测试深拷贝'''</span></span><br><span class="line">	a = [<span class="number">10</span>, <span class="number">20</span>, [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">  b = copy.deepcopy(a)</span><br><span class="line">	print(<span class="string">"a"</span>, a) </span><br><span class="line">  print(<span class="string">"b"</span>, b) </span><br><span class="line">  b.append(<span class="number">30</span>) </span><br><span class="line">  b[<span class="number">2</span>].append(<span class="number">7</span>) </span><br><span class="line">  print(<span class="string">"深拷贝......"</span>) </span><br><span class="line">  print(<span class="string">"a"</span>, a) </span><br><span class="line">  print(<span class="string">"b"</span>, b)</span><br><span class="line">testCopy() </span><br><span class="line">print(<span class="string">"*************"</span>) </span><br><span class="line">testDeepCopy()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结果</span><br><span class="line"></span><br><span class="line">a [10, 20, [5, 6]]</span><br><span class="line">b [10, 20, [5, 6]]</span><br><span class="line">浅拷贝......</span><br><span class="line">a [10, 20, [5, 6, 7]]</span><br><span class="line">b [10, 20, [5, 6, 7], 30]</span><br><span class="line">   *************</span><br><span class="line">a [10, 20, [5, 6]]</span><br><span class="line">b [10, 20, [5, 6]] </span><br><span class="line">深拷贝......</span><br><span class="line">a [10, 20, [5, 6]]</span><br><span class="line">b [10, 20, [5, 6, 7], 30]</span><br></pre></td></tr></table></figure>

<h3 id="传递不可变对象包含的子对象是可变的情况"><a href="#传递不可变对象包含的子对象是可变的情况" class="headerlink" title="传递不可变对象包含的子对象是可变的情况"></a>传递不可变对象包含的子对象是可变的情况</h3><p>#传递不可变对象时。不可变对象里面包含的子对象是可变的。则 方法内修改了这个可变对象，源对象也发生了变化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">10</span>,<span class="number">20</span>,[<span class="number">5</span>,<span class="number">6</span>]) </span><br><span class="line">print(<span class="string">"a:"</span>,id(a))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test01</span><span class="params">(m)</span>:</span> </span><br><span class="line">	print(<span class="string">"m:"</span>,id(m)) </span><br><span class="line">  m[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">888</span> </span><br><span class="line">  print(m) </span><br><span class="line">  print(<span class="string">"m:"</span>,id(m))</span><br><span class="line">test01(a)</span><br><span class="line">print(a)</span><br><span class="line">运行结果:</span><br><span class="line">a: <span class="number">41611632</span></span><br><span class="line">m: <span class="number">41611632</span> </span><br><span class="line">  (<span class="number">10</span>, <span class="number">20</span>, [<span class="number">888</span>, <span class="number">6</span>]) </span><br><span class="line">  m: <span class="number">41611632</span> </span><br><span class="line">    (<span class="number">10</span>, <span class="number">20</span>, [<span class="number">888</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>

<p>id相对于c中地址符&amp;</p>
<h3 id="参数的几种类型"><a href="#参数的几种类型" class="headerlink" title="*参数的几种类型 *"></a>*<em>参数的几种类型 *</em></h3><p><strong>位置参数</strong></p>
<p>函数调用时，实参默认按位置顺序传递，需要个数和形参匹配。按位置传递的参数，称为: “位置参数”。</p>
<p><strong>默认值参数</strong></p>
<p>我们可以为某些参数设置默认值，这样这些参数在传递时就是可选的。称为“默认值参数”。 默认值参数放到位置参数后面。def f1(a,b,c=10,d=20): #默认值参数必须位于普通位置参数后面</p>
<p><strong>命名参数</strong></p>
<p>我们也可以按照形参的名称传递参数，称为“命名参数”，也称“关键字参数”。f1(8,9,19) #位置参数 f1(c=10,a=20,b=30) #命名参数</p>
<p><strong>强制命名参数</strong></p>
<p>在带星号的“可变参数”后面增加新的参数，必须在调用的时候“强制命名参数”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(*a,b,c)</span>:</span> </span><br><span class="line">	print(a,b,c)</span><br><span class="line"><span class="comment">#f1(2,3,4) #会报错。由于 a 是可变参数，将 2,3,4 全部收集。造成 b 和 c 没有赋值。 </span></span><br><span class="line">f1(<span class="number">2</span>,b=<span class="number">3</span>,c=<span class="number">4</span>)</span><br><span class="line">执行结果: (<span class="number">2</span>,) <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="lambda-表达式和匿名函数"><a href="#lambda-表达式和匿名函数" class="headerlink" title="lambda 表达式和匿名函数"></a><strong>lambda 表达式和匿名函数</strong></h2><p>lambda 表达式可以用来声明匿名函数。lambda 函数是一种简单的、在同一行中定义函数 的方法。lambda 函数实际生成了一个函数对象。<br> lambda 表达式只允许包含一个表达式，不能包含复杂语句，该表达式的计算结果就是函数 的返回值。</p>
<p>lambda 表达式的基本语法如下:<br> lambda arg1,arg2,arg3… : &lt;表达式&gt;</p>
<p>arg1/arg2/arg3 为函数的参数。&lt;表达式&gt;相当于函数体。运算结果是:表达式的运算结果。</p>
<p>g = [lambda a:a<em>2,lambda b:b</em>3,lambda c:c*4]</p>
<h3 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a><strong>eval()函数</strong></h3><p>功能:将字符串 str 当成有效的表达式来求值并返回计算结果。</p>
<p>语法: eval(source[, globals[, locals]]) -&gt; value</p>
<p>参数:<br> source:一个 Python 表达式或函数 compile()返回的代码对象 globals:可选。必须是 dictionary locals:可选。任意映射对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = dict(a=<span class="number">100</span>,b=<span class="number">200</span>)</span><br><span class="line">d = eval(<span class="string">"a+b"</span>,dict1) </span><br><span class="line">print(d)<span class="comment">#eval 函数会将字符串当做语句来执行，因此会被注入安全隐患。比如:字符串中含有删除文 件的语句。那就麻烦大了。因此，使用时候，要慎重!!!</span></span><br></pre></td></tr></table></figure>

<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a><strong>递归函数</strong></h2><p>递归函数指的是:自己调用自己的函数，在函数体内部直接或间接的自己调用自己。递归类 似于大家中学数学学习过的“数学归纳法”。 每个递归函数必须包含两个部分:<br> \1. 终止条件</p>
<p>表示递归什么时候结束。一般用于返回值，不再调用自己。 2. 递归步骤</p>
<p>把第 n 步的值和第 n-1 步相关联。</p>
<p>递归函数由于会创建大量的函数对象、过量的消耗内存和运算能力。在处理大量数据时，谨 慎使用。</p>
<p><strong>嵌套函数(内部函数)</strong></p>
<p>嵌套函数: 在函数内部定义的函数!</p>
<p>一般在什么情况下使用嵌套函数? </p>
<ol>
<li>封装 - 数据隐藏外部无法访问“嵌套函数”。</li>
<li>贯彻 DRY(Don’t Repeat Yourself) 原则嵌套函数，可以让我们在函数内部避免重复代码。</li>
<li>闭包</li>
</ol>
<h3 id="nonlocal-关键字"><a href="#nonlocal-关键字" class="headerlink" title="nonlocal 关键字"></a><strong>nonlocal 关键字</strong></h3><p>nonlocal 用来声明外层的局部变量。 global 用来声明全局变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">  b=<span class="number">10</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">  	<span class="keyword">nonlocal</span> b<span class="comment">#声明外部函数的局部变量</span></span><br><span class="line">  	print(<span class="string">"inner b:"</span>,b)</span><br><span class="line"> 		b=<span class="number">20</span></span><br><span class="line">  	<span class="keyword">global</span> a<span class="comment">#声明全局变量</span></span><br><span class="line">  	a=<span class="number">1000</span></span><br><span class="line">	inner()</span><br><span class="line">	print(<span class="string">"outer b:"</span>,b)</span><br><span class="line">outer()</span><br><span class="line">print(<span class="string">"a:"</span>,a)</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">inner b: <span class="number">10</span></span><br><span class="line">outer b: <span class="number">20</span></span><br><span class="line">a: <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<h2 id="LEGB-规则"><a href="#LEGB-规则" class="headerlink" title="LEGB 规则"></a><strong>LEGB 规则</strong></h2><h3 id="Python-在查找“名称”时，是按照-LEGB-规则查找的-Local–-gt-Enclosed–-gt-Global–-gt-Built-in"><a href="#Python-在查找“名称”时，是按照-LEGB-规则查找的-Local–-gt-Enclosed–-gt-Global–-gt-Built-in" class="headerlink" title="Python 在查找“名称”时，是按照 LEGB 规则查找的: Local–&gt;Enclosed–&gt;Global–&gt;Built in"></a>Python 在查找“名称”时，是按照 LEGB 规则查找的: Local–&gt;Enclosed–&gt;Global–&gt;Built in</h3><p>Local 指的就是函数或者类的方法内部<br> Enclosed 指的是嵌套函数(一个函数包裹另一个函数，闭包) Global 指的是模块中的全局变量<br> Built in 指的是 Python 为自己保留的特殊名称。</p>
<p>如果某个 name 映射在局部(local)命名空间中没有找到，接下来就会在闭包作用域 (enclosed)进行搜索，如果闭包作用域也没有找到，Python 就会到全局(global)命名空 间中进行查找，最后会在内建(built-in)命名空间搜索 (如果一个名称在所有命名空间 中都没有找到，就会产生一个 NameError)。</p>
]]></content>
  </entry>
  <entry>
    <title>python400集1</title>
    <url>/2020/04/29/python400%E9%9B%861/</url>
    <content><![CDATA[<h1 id="python基础入门"><a href="#python基础入门" class="headerlink" title="python基础入门"></a>python基础入门</h1><h2 id="python入门"><a href="#python入门" class="headerlink" title="python入门"></a>python入门</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h3><ol>
<li><p>(1)  行注释</p>
<p>每行注释前加#号。当解释器看到#，则忽略这一行#后面的内容</p>
</li>
<li><p>(2)  段注释</p>
<p>使用三个连续单引号(‘’’)。当解释看到’’’，则会扫描到下一个’’’，然后忽略他们</p>
</li>
</ol>
<p>之间的内容。</p>
<h3 id="2-行连接符"><a href="#2-行连接符" class="headerlink" title="2.行连接符"></a>2.行连接符</h3><p><strong>使用\行连接符</strong></p>
<p>一行程序长度是没有限制的，但是为了可读性更强，通常将一行比较长的程序分为多行。这 是，我们可以使用\行连接符，把它放在行结束的地方。Python 解释器仍然将它们解释为同 一行。</p>
<p>&gt;&gt;&gt;  a = [10,20,30,40,\ 50,60,70,\</p>
<p>​        80,90,100]</p>
<h3 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h3><p><strong>Python 中，一切皆对象。</strong>每个对象由:标识(identity)、类型(type)、value(值)</p>
<p>组成。</p>
<ol>
<li><p>标识用于唯一标识对象，通常对应于对象在计算机内存中的地址。使用内置函数 id(obj) 可返回对象 obj 的标识。</p>
</li>
<li><p>类型用于表示对象存储的“数据”的类型。类型可以限制对象的取值范围以及可执行的 操作。可以使用 type(obj)获得对象的所属类型。</p>
</li>
<li><p>值表示对象所存储的数据的信息。使用 print(obj)可以直接打印出值。</p>
</li>
</ol>
<p><strong>对象的本质就是:一个内存块，拥有特定的值，支持特定类型的相关操作。</strong></p>
<p>源码:</p>
<p>&gt;&gt;&gt; a = 3<br> &gt;&gt;&gt; a<br> 3<br> &gt;&gt;&gt; id(3) 1531372336<br> &gt;&gt;&gt; type(3) &lt;class ‘int’&gt;<br> &gt;&gt;&gt; b = “我爱你” &gt;&gt;&gt; id(a) 1531372336</p>
<p>&gt;&gt;&gt; type(a) &lt;class ‘int’&gt; &gt;&gt;&gt; print(a) 3</p>
<p>&gt;&gt;&gt; id(b) 46806816 &gt;&gt;&gt; type(b) &lt;class ‘str’&gt;</p>
<p><strong>引用</strong></p>
<p>在 Python 中，变量也称为:对象的引用。因为，变量存储的就是对象的地址。 变量通过地址引用了“对象”。</p>
<p>变量位于:栈内存(压栈出栈等细节，后续再介绍)。 对象位于:堆内存。</p>
<p><strong>·Python 是动态类型语言</strong></p>
<p>变量不需要显式声明类型。根据变量引用的对象，Python 解释器自动确定数据类型。</p>
<p><strong>·Python 是强类型语言</strong></p>
<p>每个对象都有数据类型，只支持该类型支持的操作。</p>
<h3 id="4-python标识符规则"><a href="#4-python标识符规则" class="headerlink" title="4.python标识符规则"></a>4.python标识符规则</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>模块和包名</td>
<td>全小写字母，尽量简单。若多个单词之间用 下划线</td>
<td>math, os, sys</td>
</tr>
<tr>
<td>函数名</td>
<td>全小写字母，多个单词之间用下划线隔开</td>
<td>phone, my_name</td>
</tr>
<tr>
<td>类名</td>
<td>首字母大写，采用驼峰原则。多个单词时， 每个单词第一个字母大写，其余部分小写</td>
<td>MyPhone 、 MyClass 、 Phone</td>
</tr>
<tr>
<td>常量名</td>
<td>全大写字母，多个单词使用下划线隔开</td>
<td>SPEED、MAX_SPEED</td>
</tr>
</tbody></table>
<h3 id="5-变量声明赋值"><a href="#5-变量声明赋值" class="headerlink" title="5.变量声明赋值"></a>5.变量声明赋值</h3><p>变量的声明和赋值用于将一个变量绑定到一个对象上，格式如下: 变量名 = 表达式</p>
<p>最简单的表达式就是字面量。比如:a = 123 。 运行过程中，解释器先运行右边的表达式， 生成一个代表表达式运算结果的对象;然后，将这个对象地址赋值给左边的变量。</p>
<p><strong>变量在使用前必须先被初始化(先被赋值)</strong>，否则出现NameError</p>
<p>可以通过 del 语句删除不在使用的变量。</p>
<p>如果对象没有变量引用，就会被垃圾回收器回收，清空内存空间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;pyshell#20&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; x</span><br><span class="line">NameError: name <span class="string">'x'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>

<p><strong>链式赋值</strong></p>
<p>链式赋值用于同一个对象赋值给多个变量。 x=y=123 相当于:x=123; y=123</p>
<p><strong>系列解包赋值</strong></p>
<p>系列数据赋值给对应相同个数的变量(个数必须保持一致) &gt;&gt;&gt; a,b,c=4,5,6 相当于:a=4;b=5;c=6</p>
<p>使用系列解包赋值实现变量交换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a,b&#x3D;1,2 </span><br><span class="line">&gt;&gt;&gt; a,b&#x3D;b,a </span><br><span class="line">&gt;&gt;&gt; print(a,b) </span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<p>Python 不支持常量，即没有语法规则限制改变一个常量的值。我们只能约定常量的命名规 则，以及在程序的逻辑上不对常量的值作出修改。（bug，其实可以改，所以说还是java好啊）</p>
<h3 id="6-数据类型"><a href="#6-数据类型" class="headerlink" title="6.数据类型"></a>6.数据类型</h3><p><strong>使用 int()实现类型转换:</strong>：其他类型转int</p>
<p>python有自动转型，小转大，int+float自动转float</p>
<p>最大整数是googol，也就是Google最初的名字，googol = 10**100</p>
<p>类似于 int()，我们也可以使用 float()将其他类型转化成浮点数。</p>
<p>round(value)可以返回四舍五入的值 注:但不会改变原有值，而是产生新的值</p>
<p>运算符+、-、<em>，/、//、*</em>和%和赋值符=结合可以构成“增强型赋值运算符”。</p>
<p>注意:“+=”中间不能加空格!</p>
<p>python 中可以通过 time.time() 获得当前时刻，返回的值是以秒为单位，带微秒 (1/1000 毫秒)精度的浮点值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import time</span><br><span class="line">&gt;&gt;&gt; b &#x3D; int(time.time())</span><br><span class="line">&gt;&gt;&gt; totalMinutes &#x3D; b&#x2F;60</span><br><span class="line">&gt;&gt;&gt; totalMinutes &#x3D; b&#x2F;&#x2F;60</span><br><span class="line">&gt;&gt;&gt; totalHours &#x3D; totalMinutes&#x2F;&#x2F;60</span><br><span class="line">&gt;&gt;&gt; totalDays &#x3D; totalHours&#x2F;&#x2F;24</span><br><span class="line">&gt;&gt;&gt; totalYears &#x3D; totalDays&#x2F;&#x2F;365</span><br></pre></td></tr></table></figure>

<p>Python2 中没有布尔值，直接用数字 0 表示 False,用数字 1 表示 True。（类似c）<br> Python3 中，把 True 和 False 定义成了关键字，但他们的本质还是 1 和 0，甚至可以和数 字相加。</p>
<p>同一运算符用于比较两个对象的存储单元，实际比较的是对象的地址。</p>
<p>is;is 是判断两个标识符是不是引用同一个对象</p>
<p>is not：is not 是判断两个标识符是不是引用不同对象</p>
<p>is 与 == 区别:<br> is 用于判断两个变量引用对象是否为同一个，既比较对象的地址。</p>
<p>== 用于判断引用变量引用对象的值是否相等，默认调用对象的 <strong>eq</strong>()方法。</p>
<h4 id="Python-仅仅对比较小的整数对象进行缓存-范围为-5-256-缓存起来，而并非是所有整数对-象。需要注意的是，这仅仅是在命令行中执行，而在-Pycharm-或者保存为文件执行，结果是不一样-的，这是因为解释器做了一部分优化-范围是-5-任意正整数-。"><a href="#Python-仅仅对比较小的整数对象进行缓存-范围为-5-256-缓存起来，而并非是所有整数对-象。需要注意的是，这仅仅是在命令行中执行，而在-Pycharm-或者保存为文件执行，结果是不一样-的，这是因为解释器做了一部分优化-范围是-5-任意正整数-。" class="headerlink" title="Python 仅仅对比较小的整数对象进行缓存(范围为[-5, 256])缓存起来，而并非是所有整数对 象。需要注意的是，这仅仅是在命令行中执行，而在 Pycharm 或者保存为文件执行，结果是不一样 的，这是因为解释器做了一部分优化(范围是[-5,任意正整数])。"></a>Python 仅仅对比较小的整数对象进行缓存(范围为[-5, 256])缓存起来，而并非是所有整数对 象。需要注意的是，这仅仅是在命令行中执行，而在 Pycharm 或者保存为文件执行，结果是不一样 的，这是因为解释器做了一部分优化(范围是[-5,任意正整数])。</h4><table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
<tr>
<td><strong>·总结</strong></td>
</tr>
<tr>
<td>1、is 比较两个对象的 id 值是否相等，是否指向同一个内存地址;</td>
</tr>
<tr>
<td>2、== 比较的是两个对象的内容是否相等，值是否相等;</td>
</tr>
<tr>
<td>3、小整数对象[-5,256]在全局解释器范围内被放入缓存供重复使用;</td>
</tr>
<tr>
<td>4、is 运算符比 == 效率高，在变量和 None 进行比较时，应该使用 is。</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; 1000</span><br><span class="line">&gt;&gt;&gt; b &#x3D; 1000</span><br><span class="line">&gt;&gt;&gt; a &#x3D;&#x3D; b </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a is b </span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; id(a) 46764560 </span><br><span class="line">&gt;&gt;&gt; id(b) 46765216 </span><br><span class="line">&gt;&gt;&gt; c &#x3D; 10 </span><br><span class="line">&gt;&gt;&gt; d &#x3D; 10 </span><br><span class="line">&gt;&gt;&gt; c is d </span><br><span class="line">True#和整数缓存有关，类似java</span><br><span class="line">&gt;&gt;&gt; id(c) 1388831648 </span><br><span class="line">&gt;&gt;&gt; id(d) 1388831648</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="与-C-和-JAVA-不一样，Python-不支持自增-和自减-–"><a href="#与-C-和-JAVA-不一样，Python-不支持自增-和自减-–" class="headerlink" title="与 C 和 JAVA 不一样，Python 不支持自增(++)和自减(–)"></a>与 C 和 JAVA 不一样，Python 不支持自增(++)和自减(–)</h4><h3 id="7。字符串"><a href="#7。字符串" class="headerlink" title="7。字符串"></a>7。字符串</h3><p>字符串的本质是:字符序列。Python 的字符串是不可变的，我们无法对原字符串做任 何修改。但，可以将字符串的一部分复制到新创建的字符串，达到“看起来修改”的效果。</p>
<p>Python 不支持单字符类型，单字符也是作为一个字符串使用的。</p>
<p>Python3 直接支持 Unicode，可以表示世界上任何书面语言的字符。Python3 的字符 默认就是 16 位 Unicode 编码，ASCII 码是 Unicode 编码的子集。</p>
<p>使用内置函数 ord()可以把字符转换成对应的 Unicode 码; 使用内置函数 chr()可以把十进制数字转换成对应的字符。</p>
<p>连续三个单引号或三个双引号，可以帮助我们创建多行字符串。例如: </p>
<p>resume = ‘’’ name=”gaoqi”<br> company=”sxt” age=18<br> lover=”Tom”‘’’</p>
<p>&gt;&gt;&gt; print(resume) </p>
<p>name=”gaoqi”</p>
<p>company=”sxt” age=18 lover=”Tom”</p>
<p>转义字符： 我们可以使用“\+特殊字符”，实现某些难以用字符表示的效果</p>
<p>我们前面调用 print 时，会自动打印一个换行符。有时，我们不想换行，不想自动添加换行 符。我们可以自己通过参数 end = “任意字符串”。实现末尾添加任何内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;sxt&quot;,end&#x3D;&#39; &#39;) </span><br><span class="line">print(&quot;sxt&quot;,end&#x3D;&#39;##&#39;) </span><br><span class="line">print(&quot;sxt&quot;)</span><br><span class="line">运行结果:</span><br><span class="line">sxt sxt##sxt</span><br></pre></td></tr></table></figure>

<p>我们可以使用 input()从控制台读取键盘输入的内容。</p>
<p>当我们调用 print()函数时，解释器自动调用了 str()将非字符串的对象转成了字符串。</p>
<p>字符串的本质就是字符序列，我们可以通过在字符串后面添加[]，在[]里面指定偏移量， 可以提取该位置的单个字符。</p>
<p>正向搜索:<br> 最左侧第一个字符，偏移量是 0，第二个偏移量是 1，以此类推。直到 len(str)-1</p>
<p>为止。 反向搜索:</p>
<p>最右侧第一个字符，偏移量是-1，倒数第二个偏移量是-2，以此类推，直到-len(str) 为止。</p>
<p>字符串不可改变。但是，我们确实有时候需要替换某些字符。这时，只能通过创建新的字符 串来实现。</p>
<p>使用replace</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;&quot;alfjoashoa&quot;</span><br><span class="line">a&#x3D;a.replace(&quot;a&quot;,&quot;替换字&quot;)</span><br></pre></td></tr></table></figure>

<p>切片 slice 操作可以让我们快速的提取子字符串。标准格式为: [起始偏移量 start:终止偏移量 end:步长 step]</p>
<p>典型操作(三个量为正数的情况)如下:</p>
<table>
<thead>
<tr>
<th>操作和说明</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>[:] 提取整个字符串</td>
<td>“abcdef”[:]</td>
<td>“abcdef”</td>
</tr>
<tr>
<td>[start:]从 start 索引开始到结尾</td>
<td>“abcdef”[2:]</td>
<td>“cdef”</td>
</tr>
<tr>
<td>[:end]从头开始知道 end-1</td>
<td>“abcdef”[:2]</td>
<td>“ab”</td>
</tr>
<tr>
<td>[start:end]从 start 到 end-1</td>
<td>“abcdef”[2:4]</td>
<td>“cd”</td>
</tr>
<tr>
<td>[start​：end:step]从 start 提取到 end-1，步长是 step</td>
<td>“abcdef”[1:5:2]</td>
<td>“bd”</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其他操作(三个量为负数)的情况:</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>“abcdefghijklmnopqrstuv wxyz”[-3:]</td>
<td>倒数三个</td>
<td>“xyz”</td>
</tr>
<tr>
<td>“abcdefghijklmnopqrstuv wxyz”[-8:-3]</td>
<td>倒数第八个到倒数第 三个(包头不包尾)</td>
<td>‘stuvw’</td>
</tr>
<tr>
<td>“abcdefghijklmnopqrstuv wxyz”[::-1]</td>
<td>步长为负，从右到左 反向提取</td>
<td>‘zyxwvutsrqpon mlkjihgfedcba’</td>
</tr>
</tbody></table>
<p><strong>split()分割和 join()合并</strong></p>
<p>split()可以基于指定分隔符将字符串分隔成多个子字符串(存储到列表中)。如果不指定分隔 符，则默认使用空白字符(换行符/空格/制表符)。示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;to be or not to be&quot; </span><br><span class="line">&gt;&gt;&gt; a.split()</span><br><span class="line">[&#39;to&#39;, &#39;be&#39;, &#39;or&#39;, &#39;not&#39;, &#39;to&#39;, &#39;be&#39;] </span><br><span class="line">&gt;&gt;&gt; a.split(&#39;be&#39;)</span><br><span class="line">[&#39;to &#39;, &#39; or not to &#39;, &#39;&#39;]</span><br></pre></td></tr></table></figure>

<p>join()的作用和 split()作用刚好相反，用于将一系列子字符串连接起来。示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [&#39;sxt&#39;,&#39;sxt100&#39;,&#39;sxt200&#39;]</span><br><span class="line">&gt;&gt;&gt; &#39;*&#39;.join(a)</span><br><span class="line">&#39;sxt*sxt100*sxt200&#39;</span><br></pre></td></tr></table></figure>

<p><strong>拼接字符串要点:</strong></p>
<p>使用字符串拼接符+，会生成新的字符串对象，因此不推荐使用+来拼接字符串。推荐 使用 join 函数，因为 join 函数在拼接字符串之前会计算所有字符串的长度，然后逐一拷贝， 仅新建一次对象。</p>
<p><strong>字符串驻留:</strong>仅保存一份相同且不可变字符串的方法，不同的值被存放在字符串驻留池中。 Python 支持字符串驻留机制，对于符合标识符规则的字符串(仅包含下划线(_)、字母 和数字)会启用字符串驻留机制驻留机制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;abd_33&quot;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; &quot;abd_33&quot;</span><br><span class="line">&gt;&gt;&gt; a is b </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; c &#x3D; &quot;dd#&quot;</span><br><span class="line">&gt;&gt;&gt; d &#x3D; &quot;dd#&quot;</span><br><span class="line">&gt;&gt;&gt; c is d </span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; str1 &#x3D; &quot;aa&quot;</span><br><span class="line">&gt;&gt;&gt; str2 &#x3D; &quot;bb&quot;</span><br><span class="line">&gt;&gt;&gt; str1+str2 is &quot;aabb&quot;</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; str1+str2 &#x3D;&#x3D; &quot;aabb&quot; </span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p><strong>字符串比较和同一性</strong></p>
<p>我们可以直接使用==,!=对字符串进行比较，是否含有相同的字符。<br> 我们使用 is / not is，判断两个对象是否同一个对象。比较的是对象的地址，即 id(obj1)是 否和 id(obj2)相等。</p>
<h3 id="字符串常用方法汇总"><a href="#字符串常用方法汇总" class="headerlink" title="字符串常用方法汇总"></a><strong>字符串常用方法汇总</strong></h3><p><strong>常用查找方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;&quot;akhfahglwaejiorhsdlhgkld&quot;</span><br><span class="line">len(a)#返回长度</span><br><span class="line">a.startswith(&#39;a&#39;)#以指定字符串开头</span><br><span class="line">a.endswith(&#39;d&#39;)#以指定字符串结尾</span><br><span class="line">a.find(&#39;k&#39;)#第一次出现指定字符串的位置</span><br><span class="line">a.rfind(&#39;d&#39;)#最后一次出现指定字符串的位置</span><br><span class="line">a.count(&#39;ad&#39;)#指定字符串出现几次</span><br><span class="line">a.isalnum()#所有字符全是字母数字</span><br></pre></td></tr></table></figure>

<p><strong>去除首尾信息</strong></p>
<p>我们可以通过 strip()去除字符串首尾指定信息。通过 lstrip()去除字符串左边指定信息， rstrip()去除字符串右边指定信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;*s*x*t*&quot;.strip(&quot;*&quot;) </span><br><span class="line">&#39;s*x*t&#39;</span><br><span class="line">&gt;&gt;&gt; &quot;*s*x*t*&quot;.lstrip(&quot;*&quot;) </span><br><span class="line">&#39;s*x*t*&#39;</span><br><span class="line">&gt;&gt;&gt; &quot;*s*x*t*&quot;.rstrip(&quot;*&quot;) </span><br><span class="line">&#39;*s*x*t&#39;</span><br><span class="line">&gt;&gt;&gt; &quot; sxt &quot;.strip() </span><br><span class="line">&#39;sxt&#39;</span><br></pre></td></tr></table></figure>

<p><strong>大小写转换</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>a.capitalize()</td>
<td>产生新的字符串,首字母 大写</td>
<td></td>
</tr>
<tr>
<td>a.title()</td>
<td>产生新的字符串,每个单 词都首字母大写</td>
<td></td>
</tr>
<tr>
<td>a.upper()</td>
<td>产生新的字符串,所有字 符全转成大写</td>
<td></td>
</tr>
<tr>
<td>a.lower()</td>
<td>产生新的字符串,所有字 符全转成小写</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>a.swapcase()</th>
<th>产生新的,所有字母大小 写转换</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>格式排版</strong></p>
<p>center()、ljust()、rjust()这三个函数用于对字符串实现排版。示例如下: &gt;&gt;&gt; a=”SXT”<br> &gt;&gt;&gt; a.center(10,”*”)<br> ‘<strong><em>SXT*</em></strong>‘</p>
<p>&gt;&gt;&gt; a.center(10)<br> ‘ SXT ‘<br> &gt;&gt;&gt; a.ljust(10,”*”) ‘SXT<strong>***</strong>‘</p>
<p><strong>其他方法</strong></p>
<p>\1. isalnum() 是否为字母或数字<br> \2. isalpha() 检测字符串是否只由字母组成(含汉字)。 3. isdigit() 检测字符串是否只由数字组成。<br> \4. isspace() 检测是否为空白符<br> \5. isupper() 是否为大写字母<br> \6. islower() 是否为小写字母</p>
<p><strong>字符串的格式化</strong> </p>
<p><strong>format()基本用法</strong></p>
<p>Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的 功能。<br> 基本语法是通过 {} 和 : 来代替以前的 % 。</p>
<p>format 函数可以接受不限个参数，位置可以不按顺序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;名字是:&#123;0&#125;,年龄是:&#123;1&#125;&quot; </span><br><span class="line">&gt;&gt;&gt; a.format(&quot;高淇&quot;,18) </span><br><span class="line">&#39;名字是:高淇,年龄是:18&#39;</span><br><span class="line">&gt;&gt;&gt; a.format(&quot;高希希&quot;,6) </span><br><span class="line">&#39;名字是:高希希,年龄是:6&#39;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; &quot;名字是:&#123;0&#125;，年龄是&#123;1&#125;。&#123;0&#125;是个好小伙&quot; </span><br><span class="line">&gt;&gt;&gt; b.format(&quot;高淇&quot;,18)</span><br><span class="line">&#39;名字是:高淇，年龄是 18。高淇是个好小伙&#39;</span><br><span class="line">&gt;&gt;&gt; c &#x3D; &quot;名字是&#123;name&#125;，年龄是&#123;age&#125;&quot;</span><br><span class="line">&gt;&gt;&gt; c.format(age&#x3D;19,name&#x3D;&#39;高淇&#39;) </span><br><span class="line">&#39;名字是高淇，年龄是 19&#39;#我们可以通过&#123;索引&#125;&#x2F;&#123;参数名&#125;，直接映射参数值，实现对字符串的格式化，非常方便。</span><br></pre></td></tr></table></figure>

<p><strong>填充与对齐</strong></p>
<p>填充常跟对齐一起使用 ^、&lt;、&gt;分别是居中、左对齐、右对齐，后面带宽度</p>
<p>:号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;:*&gt;8&#125;&quot;.format(&quot;245&quot;)</span><br><span class="line">&#39;*****245&#39;</span><br></pre></td></tr></table></figure>



<p>浮点数通过 f，整数通过 d 进行需要的格式化。案例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;我是&#123;0&#125;，我的存款有&#123;1:.2f&#125;&quot;</span><br><span class="line"></span><br><span class="line"> &gt;&gt;&gt; a.format(&quot;高淇&quot;,3888.234342) </span><br><span class="line"> &#39;我是高淇，我的存款有 3888.23&#39;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>数字</th>
<th>格式</th>
<th>输出</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>3.1415926</td>
<td>{:.2f}</td>
<td>3.14</td>
<td>保留小数点后两位</td>
</tr>
<tr>
<td>3.1415926</td>
<td>{:+.2f}</td>
<td>3.14</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>2.71828</td>
<td>{:.0f}</td>
<td>3</td>
<td>不带小数</td>
</tr>
<tr>
<td>5</td>
<td>{:0&gt;2d}</td>
<td>05</td>
<td>数字补零 (填充左边, 宽度为 2)</td>
</tr>
<tr>
<td>5</td>
<td>{:x&lt;4d}</td>
<td>5xxx</td>
<td>数字补 x (填充右边, 宽度为 4)</td>
</tr>
<tr>
<td>10</td>
<td>{:x&lt;4d}</td>
<td>10xx</td>
<td>数字补 x (填充右边, 宽度为 4)</td>
</tr>
<tr>
<td>1000000</td>
<td>{:,}</td>
<td>1,000,000</td>
<td>以逗号分隔的数字格式</td>
</tr>
<tr>
<td>0.25</td>
<td>{:.2%}</td>
<td>25.00%</td>
<td>百分比格式</td>
</tr>
<tr>
<td>1000000000</td>
<td>{:.2e}</td>
<td>1.00E+09</td>
<td>指数记法</td>
</tr>
<tr>
<td>13</td>
<td>{:10d}</td>
<td>13</td>
<td>右对齐 (默认, 宽度为 10)</td>
</tr>
<tr>
<td>13</td>
<td>{:&lt;10d}</td>
<td>13</td>
<td>左对齐 (宽度为 10)</td>
</tr>
<tr>
<td>13</td>
<td>{:^10d}</td>
<td>13</td>
<td>中间对齐 (宽度为 10)</td>
</tr>
</tbody></table>
<p><strong>可变字符串</strong></p>
<p>在 Python 中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，智 能创建新的字符串对象。但是，经常我们确实需要原地修改字符串，可以使用 io.StringIO 对象或 array 模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import io</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &quot;hello, sxt&quot;</span><br><span class="line">&gt;&gt;&gt; sio &#x3D; io.StringIO(s)</span><br><span class="line">&gt;&gt;&gt; sio</span><br><span class="line">&lt;_io.StringIO object at 0x02F462B0&gt; &gt;&gt;&gt; sio.getvalue()</span><br><span class="line">&#39;hello, sxt&#39;</span><br><span class="line">&gt;&gt;&gt; sio.seek(7)</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; sio.write(&quot;g&quot;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; sio.getvalue()</span><br><span class="line">&#39;hello, gxt&#39;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>python400集4</title>
    <url>/2020/04/29/python400%E9%9B%864/</url>
    <content><![CDATA[<h1 id="异常和错误"><a href="#异常和错误" class="headerlink" title="异常和错误"></a>异常和错误</h1><p>软件程序在运行过程中，非常可能遇到刚刚提到的这些问题，我们称之为 异常，英文是:Exception，意思是例外。</p>
<h2 id="异常机制本质"><a href="#异常机制本质" class="headerlink" title="异常机制本质"></a>异常机制本质</h2><p>异常指程序运行过程中出现的非正常现象，例如用户输入错误、除数为零、需 要处理的文件不存在、数组下标越界等。</p>
<p>所谓异常处理，就是指程序在出现问题时依然可以正确的执行剩余的程序，而 不会因为异常而终止程序执行。</p>
<p>python 中，引进了很多用来描述和处理异常的类，称为异常类。异常类定义中 包含了该类异常的信息和对异常进行处理的方法。</p>
<p>python 中内建异常类的继承层次:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BaseException:所以异常的父类</span><br><span class="line">有4子类：KeyBoardInterrupt, Exception, SystemExit,GeneratorExit</span><br><span class="line">Exception内子类：NameError, ValueError, AttributeError等</span><br></pre></td></tr></table></figure>

<p><strong>python 中一切都是对象，异常也采用对象的方式来处理。处理过程:</strong> </p>
<ol>
<li><p><strong>抛出异常:</strong>在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给解释器。</p>
</li>
<li><p><strong>捕获异常:</strong>解释器得到该异常后，寻找相应的代码来处理该异常。</p>
</li>
</ol>
<p>异常解决的关键:定位</p>
<p>当发生异常时，解释器会报相关的错误信息，并会在控制台打印出相关错误信息。我们 只需按照从上到下的顺序即可追溯(Trackback)错误发生的过程，最终定位引起错误的那一 行代码。</p>
<h2 id="try…-一个except-结构"><a href="#try…-一个except-结构" class="headerlink" title="try… 一个except 结构"></a><strong>try…</strong> 一个<strong>except</strong> 结构</h2><p>try…except 是最常见的异常处理结构。结构如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">	被监控的可能引发异常的语句块</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> BaseException [<span class="keyword">as</span> e]:</span><br><span class="line"></span><br><span class="line">	异常处理语句块</span><br></pre></td></tr></table></figure>

<p>try 块包含着可能引发异常的代码，except 块则用来捕捉和处理发生的异常。执行的时 候，如果 try 块中没有引发异常，则跳过 ecept 块继续执行后续代码;执行的时候，如果 try块中发生了异常，则跳过 try 块中的后续代码，跳到相应的 except 块中处理异常;异常处理 完后，继续执行后续代码。</p>
<p>例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  print(<span class="string">"step1"</span>)</span><br><span class="line">  a=<span class="number">3</span>/<span class="number">0</span></span><br><span class="line">  print(<span class="string">"step2"</span>)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">  print(<span class="string">"step3"</span>)</span><br><span class="line">  print(<span class="string">"e"</span>)</span><br><span class="line">print(<span class="string">"step4"</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">step1</span><br><span class="line">step3</span><br><span class="line">division by zero </span><br><span class="line">step4</span><br></pre></td></tr></table></figure>

<p>例子2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">  print(&quot;step1&quot;)</span><br><span class="line">  a&#x3D;3&#x2F;2</span><br><span class="line">  print(&quot;step2&quot;)</span><br><span class="line">except BaseException as e:</span><br><span class="line">  print(&quot;step3&quot;)</span><br><span class="line">  print(&quot;e&quot;)</span><br><span class="line">print(&quot;step4&quot;)</span><br></pre></td></tr></table></figure>

<p>#结果</p>
<p>step1<br>step2<br>step4</p>
<h2 id="try…多个-except-结构"><a href="#try…多个-except-结构" class="headerlink" title="try…多个 except 结构"></a><strong>try…</strong>多个 <strong>except</strong> 结构</h2><p>上面的结构可以捕获所有的异常，工作中也很常见。但是，从经典理论考虑，一般建议 尽量捕获可能出现的多个异常(按照先子类后父类的顺序)，并且针对性的写出异常处理代 码。为了避免遗漏可能出现的异常，可以在最后增加 BaseException。结构如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">	被监控的可能引发异常的语句块</span><br><span class="line">except Exception1:</span><br><span class="line"> 处理 Exception1 的语句块</span><br><span class="line"></span><br><span class="line">except Exception2:</span><br><span class="line"> 处理 Exception2 的语句块</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	a=input(<span class="string">"输入一个被除数："</span>)</span><br><span class="line">	b=input(<span class="string">"输入一个除数："</span>)</span><br><span class="line">  c=float(a)/float(b)</span><br><span class="line">  print(c)</span><br><span class="line"><span class="keyword">except</span> ZeroDicisionError:</span><br><span class="line">  print(<span class="string">"除数不为0"</span>)</span><br><span class="line"><span class="keyword">except</span> TypeError: </span><br><span class="line">  print(<span class="string">"异常:除数和被除数都应该为数值类型"</span>)</span><br><span class="line"><span class="keyword">except</span> NameError: </span><br><span class="line">  print(<span class="string">"异常:变量不存在"</span>)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">    print(type(e)) </span><br><span class="line"> ```</span><br><span class="line">请输入被除数:<span class="number">10</span> </span><br><span class="line">请输入除数:<span class="number">0</span> </span><br><span class="line">异常:除数不能为 <span class="number">0</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="try…except…else-结构"><a href="#try…except…else-结构" class="headerlink" title="try…except…else 结构"></a><strong>try…except…else</strong> 结构</h2><p> try…except…else 结构增加了“else 块”。如果 try 块中没有抛出异常，则执行 else 块。如果</p>
<p>try 块中抛出异常，则执行 except 块，不执行 else 块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发生异常的执行情况(执行 except 块，没有执行 else):</span><br><span class="line"></span><br><span class="line">没有发生异常的执行情况(执行完 try 块后，执行 else):</span><br></pre></td></tr></table></figure>

<h2 id="try…except…finally-结构"><a href="#try…except…finally-结构" class="headerlink" title="try…except…finally 结构"></a><strong>try…except…finally</strong> 结构</h2><p> try…except…finally 结构中，finally 块无论是否发生异常都会被执行;通常用来释放 try 块中申请的资源</p>
<p> finally 中的语句，无论是否发生异常都执行</p>
<p>读取文件，finally 中保证关闭文件资源</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	f = open(<span class="string">"d:/a.txt"</span>,<span class="string">'r'</span>) </span><br><span class="line">  content = f.readline() </span><br><span class="line">  print(content)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	f.close() <span class="comment">#释放资源。此处也可能会发生异常。若发生异常，则程序终止,不会继续往下执行</span></span><br><span class="line">print(<span class="string">"step4"</span>)</span><br><span class="line">```</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">[Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">'d:/a.txt'</span></span><br><span class="line">File <span class="string">"C:/PycharmProjects/mypro_exception/my01.py"</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">f.close() <span class="comment">#释放资源。此处也可能会发生异常。若发生异常，则程序终止,不会继续往下执行</span></span><br><span class="line">NameError: name <span class="string">'f'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined Process finished <span class="keyword">with</span> exit code <span class="number">1</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>需要把f.close也try except</p>
<h2 id="return-语句和异常处理问题"><a href="#return-语句和异常处理问题" class="headerlink" title="return 语句和异常处理问题"></a><strong>return</strong> 语句和异常处理问题</h2><p> 由于 return 有两种作用:结束方法运行、返回值。我们一般不把 return 放到异常处理结构</p>
<p>中，而是放到方法最后。</p>
<h3 id="一般不要将-return-语句放到-try、except、else、finally-块中，会发生一些意想不到的错误。建议放到方法最后。"><a href="#一般不要将-return-语句放到-try、except、else、finally-块中，会发生一些意想不到的错误。建议放到方法最后。" class="headerlink" title="一般不要将 return 语句放到 try、except、else、finally 块中，会发生一些意想不到的错误。建议放到方法最后。"></a>一般不要将 return 语句放到 try、except、else、finally 块中，会发生一些意想不到的错误。建议放到方法最后。</h3><h2 id="常见异常的解决"><a href="#常见异常的解决" class="headerlink" title="常见异常的解决"></a>常见异常的解决</h2><p>Python 中的异常都派生自 BaseException 类</p>
<p>\1. SyntaxError:语法错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D;3 </span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>\2. NameError:尝试访问一个没有申明的变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(a)</span><br><span class="line">NameError: name &#39;a&#39; is not defined</span><br></pre></td></tr></table></figure>

<p>\3. ZeroDivisionError:除数为0错误(零除错误)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 3&#x2F;0</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>

<p>\4. ValueError:数值错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float(&quot;gaoqi&quot;)</span><br><span class="line">ValueError: could not convert string to float: &#39;gaoqi&#39;</span><br></pre></td></tr></table></figure>

<p>\5. TypeError:类型错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123+&quot;abc&quot;</span><br><span class="line">TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;</span><br></pre></td></tr></table></figure>

<p>\6. AttributeError:访问对象的不存在的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.sayhi()</span><br><span class="line">AttributeError: &#39;int&#39; object has no attribute &#39;sayhi&#39;</span><br></pre></td></tr></table></figure>

<p>\7. IndexError:索引越界异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[10]</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure>

<p>\8. KeyError:字典的关键字不存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[&#39;salary&#39;] KeyError: &#39;salary&#39;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>异常名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArithmeticError</code></td>
<td>所有数值计算错误的基类</td>
</tr>
<tr>
<td><code>AssertionError</code></td>
<td>断言语句失败</td>
</tr>
<tr>
<td><code>AttributeError</code></td>
<td>对象没有这个属性</td>
</tr>
<tr>
<td><code>BaseException</code></td>
<td>所有异常的基类</td>
</tr>
<tr>
<td><code>DeprecationWarning</code></td>
<td>关于被弃用的特征的警告</td>
</tr>
<tr>
<td><code>EnvironmentError</code></td>
<td>操作系统错误的基类</td>
</tr>
<tr>
<td>EOFError</td>
<td>没有内建输入,到达 EOF 标记</td>
</tr>
<tr>
<td>Exception</td>
<td>常规错误的基类</td>
</tr>
<tr>
<td><code>FloatingPointError</code></td>
<td>浮点计算错误</td>
</tr>
<tr>
<td><code>FutureWarning</code></td>
<td><code>关于构造将来语义会有改变的警告</code></td>
</tr>
<tr>
<td><code>GeneratorExit</code></td>
<td>生成器(generator)发生异常来通知退出</td>
</tr>
<tr>
<td>ImportError</td>
<td>导入模块/对象失败</td>
</tr>
<tr>
<td><code>IndentationError</code></td>
<td>缩进错误</td>
</tr>
<tr>
<td>IndexError</td>
<td>序列中没有此索引(index)</td>
</tr>
<tr>
<td>IOError</td>
<td>输入/输出操作失败</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>KeyboardInterrupt</code></th>
<th>用户中断执行(通常是输入^C)</th>
</tr>
</thead>
<tbody><tr>
<td>KeyError</td>
<td>映射中没有这个键</td>
</tr>
<tr>
<td>LookupError</td>
<td>无效数据查询的基类</td>
</tr>
<tr>
<td>MemoryError</td>
<td>内存溢出错误(对于 Python 解释器不是致命的)</td>
</tr>
<tr>
<td>NameError</td>
<td>未声明/初始化对象 (没有属性)</td>
</tr>
<tr>
<td><code>NotImplementedError</code></td>
<td>尚未实现的方法</td>
</tr>
<tr>
<td>OSError</td>
<td>操作系统错误</td>
</tr>
<tr>
<td><code>OverflowError</code></td>
<td>数值运算超出最大限制</td>
</tr>
<tr>
<td><code>OverflowWarning</code></td>
<td>旧的关于自动提升为长整型(long)的警告</td>
</tr>
<tr>
<td><code>PendingDeprecationWarning</code></td>
<td><code>关于特性将会被废弃的警告</code></td>
</tr>
<tr>
<td><code>ReferenceError</code></td>
<td>弱引用(Weak reference)试图访问已经垃圾回收了的对象</td>
</tr>
<tr>
<td><code>RuntimeError</code></td>
<td>一般的运行时错误</td>
</tr>
<tr>
<td><code>RuntimeWarning</code></td>
<td>可疑的运行时行为(runtime behavior)的警告</td>
</tr>
<tr>
<td><code>StandardError</code></td>
<td><code>所有的内建标准异常的基类</code></td>
</tr>
<tr>
<td><code>StopIteration</code></td>
<td>迭代器没有更多的值</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>Python 语法错误</td>
</tr>
<tr>
<td><code>SyntaxWarning</code></td>
<td>可疑的语法的警告</td>
</tr>
<tr>
<td>SystemError</td>
<td>一般的解释器系统错误</td>
</tr>
<tr>
<td>SystemExit</td>
<td>解释器请求退出</td>
</tr>
<tr>
<td>TabError</td>
<td>Tab 和空格混用</td>
</tr>
<tr>
<td>TypeError</td>
<td>对类型无效的操作</td>
</tr>
<tr>
<td><code>UnboundLocalError</code></td>
<td>访问未初始化的本地变量</td>
</tr>
<tr>
<td><code>UnicodeDecodeError</code></td>
<td>Unicode 解码时的错误</td>
</tr>
<tr>
<td><code>UnicodeEncodeError</code></td>
<td>Unicode 编码时错误</td>
</tr>
<tr>
<td><code>UnicodeError</code></td>
<td>Unicode 相关的错误</td>
</tr>
<tr>
<td><code>UnicodeTranslateError</code></td>
<td>Unicode 转换时错误</td>
</tr>
<tr>
<td>UserWarning</td>
<td>用户代码生成的警告</td>
</tr>
<tr>
<td>ValueError</td>
<td>传入无效的参数</td>
</tr>
<tr>
<td>Warning</td>
<td>警告的基类</td>
</tr>
<tr>
<td><code>WindowsError</code></td>
<td>系统调用失败</td>
</tr>
<tr>
<td><code>ZeroDivisionError</code></td>
<td>除(或取模)零 (所有数据类型)</td>
</tr>
</tbody></table>
<h2 id="with-上下文管理"><a href="#with-上下文管理" class="headerlink" title="with 上下文管理"></a><strong>with</strong> 上下文管理</h2><p> finally 块由于是否发生异常都会执行，通常我们放释放资源的代码。其实，我们可以通过 with 上下文管理，更方便的实现释放资源的操作。 with 上下文管理的语法结构如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> context_expr [ <span class="keyword">as</span> var]: </span><br><span class="line">	语句块</span><br></pre></td></tr></table></figure>

<p>with 上下文管理可以自动管理资源，在 with 代码块执行完毕后自动还原进入该代码之前的 现场或上下文。不论何种原因跳出 with 块，不论是否有异常，总能保证资源正常释放。极 大的简化了工作，在文件操作、网络通信相关的场合非常常用。</p>
<h3 id="With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发"><a href="#With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发" class="headerlink" title="With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发"></a>With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"d:/bb.txt"</span>) <span class="keyword">as</span> f: </span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">		print(line)</span><br></pre></td></tr></table></figure>

<h2 id="trackback-模块"><a href="#trackback-模块" class="headerlink" title="trackback 模块"></a><strong>trackback</strong> 模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">  print(<span class="string">"step1"</span>)</span><br><span class="line">	num = <span class="number">1</span>/<span class="number">0</span> </span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	traceback.print_exc()</span><br><span class="line">  ```</span><br><span class="line">  step1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/mengxiaowang/Documents/a.py"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    num = <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">  ```</span><br></pre></td></tr></table></figure>

<p>使用 traceback 将异常信息写入日志文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">  print(<span class="string">"step1"</span>)</span><br><span class="line">	num = <span class="number">1</span>/<span class="number">0</span> </span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="keyword">with</span> open(<span class="string">"d:/a.log"</span>,<span class="string">"a"</span>) <span class="keyword">as</span> f: </span><br><span class="line">    traceback.print_exc(file=f)</span><br></pre></td></tr></table></figure>

<h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>程序开发中，有时候我们也需要自己定义异常类。自定义异常类一般都是运行时异常，通常继承 Exception 或其子类即可。命名一般以 Error、Exception 为后缀。</p>
<p> 自定义异常由 raise 语句主动抛出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classAgeError(Exception): <span class="comment">#继承Exception </span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,errorInfo)</span>:</span></span><br><span class="line">		Exception.__init__(self)</span><br><span class="line">		self.errorInfo = errorInfo </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> str(self.errorInfo)+<span class="string">",年龄错误!应该在 1-150 之间"</span></span><br><span class="line"><span class="comment">############测试代码################</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: <span class="comment">#如果为 True，则模块是作为独立文件运行， 可以执行测试代码</span></span><br><span class="line">	age = int(input(<span class="string">"输入一个年龄:"</span>)) </span><br><span class="line">  	<span class="keyword">if</span> age&lt;<span class="number">1</span> <span class="keyword">or</span> age&gt;<span class="number">150</span>:</span><br><span class="line">    	<span class="keyword">raise</span> AgeError(age)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">			print(<span class="string">"正常的年龄:"</span>,age)</span><br><span class="line">```</span><br><span class="line">输入一个年龄：<span class="number">160</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"C:/Users/Administrator/PycharmProjects/mypro_exception/my10.py"</span>, line <span class="number">16</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"><span class="keyword">raise</span> AgeError(age)</span><br><span class="line">__main__.AgeError: <span class="number">200</span>,年龄错误!应该在 <span class="number">1</span><span class="number">-150</span> 之间</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="if-name-‘main‘-的作用"><a href="#if-name-‘main‘-的作用" class="headerlink" title="if name == ‘main‘:的作用"></a>if <strong>name</strong> == ‘<strong>main</strong>‘:的作用</h2><p>简单说：</p>
<h4 id="在当前执行的程序下（例如当前程序为test-py），如果导入其他模块（other-test-py），则运行程序时other-test-py的if-name-‘main‘-语句判断失败，将不会运行下面的方法。"><a href="#在当前执行的程序下（例如当前程序为test-py），如果导入其他模块（other-test-py），则运行程序时other-test-py的if-name-‘main‘-语句判断失败，将不会运行下面的方法。" class="headerlink" title="在当前执行的程序下（例如当前程序为test.py），如果导入其他模块（other_test.py），则运行程序时other_test.py的if name == ‘main‘ 语句判断失败，将不会运行下面的方法。"></a>在当前执行的程序下（例如当前程序为test.py），如果导入其他模块（other_test.py），则运行程序时other_test.py的if <strong>name</strong> == ‘<strong>main</strong>‘ 语句判断失败，将不会运行下面的方法。</h4><p>也就是说导入的模块的if <strong>name</strong> == ‘<strong>main</strong>‘ 语句下的方法是不会执行的。只会执行当前的if <strong>name</strong> == ‘<strong>main</strong>‘ 下的方法。<br>一个python文件通常有两种使用方法，第一是作为脚本直接执行，第二是 import 到其他的 python 脚本中被调用（模块重用）执行。因此 if <strong>name</strong> == ‘main’: 的作用就是控制这两种情况执行代码的过程，在 if <strong>name</strong> == ‘main’: 下的代码只有在第一种情况下（即文件作为脚本直接执行）才会被执行，而 import 到其他脚本中是不会被执行的。举例说明如下：</p>
<ul>
<li>直接执行</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190510141202522.png" alt="img"></p>
<p><strong>直接执行 test.py，</strong>结果如下图，可以成功 print 两行字符串。即<strong>，if <strong>name</strong>==”<strong>main</strong>“: 语句之前和之后的代码都被执行。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190510141303114.png" alt="img"></p>
<ul>
<li>import 执行</li>
</ul>
<p>然后在同一文件夹新建名称为 import_test.py 的脚本，输入如下代码：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510141602268.png" alt="img"></p>
<p>执行 <strong>import_test.py 脚本</strong>，输出结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510141624918.png" alt="img"></p>
<p>只输出了第一行字符串。即，<strong>if <strong>name</strong>==”<strong>main</strong>“: 之前的语句被执行，之后的没有被执行。</strong></p>
<h3 id="if-name-‘main‘-的运行原理"><a href="#if-name-‘main‘-的运行原理" class="headerlink" title="if name == ‘main‘:的运行原理"></a>if <strong>name</strong> == ‘<strong>main</strong>‘:的运行原理</h3><p><strong>每个python模块</strong>（python文件，也就是此处的 test.py 和 import_test.py）都包含<strong>内置的变量 <strong>name</strong></strong>，当该模块被<strong>直接执行</strong>的时候，<strong><strong>name</strong> 等于文件名（包含后缀 .py ）</strong>；如果该模块 <strong>import</strong> 到其他模块中，<strong>则该模块的 <strong>name</strong> 等于模块名称（不包含后缀.py）。</strong></p>
<p>而 <strong>“<strong>main</strong>” 始终指当前执行模块的名称（包含后缀.py）</strong>。进而当模块被<strong>直接执行</strong>时<strong>，<strong>name</strong> == ‘main’ 结果为真。</strong></p>
<p>为了进一步说明，我们在 test.py 脚本的 if <strong>name</strong>==”<strong>main</strong>“: 之前<strong>加入 print(<strong>name</strong>)，</strong>即将 <strong>name</strong> 打印出来。文件内容和结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510142230219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlcWlhbmc1MjU=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190510142253482.png" alt="img"></p>
<p>可以看出，此时变量<strong><strong>name</strong>的值为”<strong>main</strong>“。</strong></p>
<p>再执行 import_test.py，执行结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510142441889.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190510142452571.png" alt="img"></p>
<p>此时，<strong>test.py中的<strong>name</strong>变量值为 test，</strong>不满足 <strong>name</strong>==”<strong>main</strong>“ 的条件，因此，无法执行其后的代码。</p>
]]></content>
  </entry>
  <entry>
    <title>python400集7</title>
    <url>/2020/05/03/python400%E9%9B%867/</url>
    <content><![CDATA[<h1 id="GUI-图形用户界面编程"><a href="#GUI-图形用户界面编程" class="headerlink" title="GUI 图形用户界面编程"></a>GUI 图形用户界面编程</h1><p>常用的 GUI 库</p>
<p>\1. Tkinter<br> tkinter(Tk interface)是 Python 的标准 GUI 库，支持跨</p>
<p>平台的 GUI 程序开发。tkinter 适合小型的 GUI 程序编写， 也特别适合初学者学习 GUI 编程。本书以 tkinter 为核心进 行讲解。<br> \2. wxPython</p>
<p>wxPython 是比较流行的 GUI 库，适合大型应用程序开发， 功能强于 tkinter，整体设计框架类似于 MFC(Microsoft Foundation Classes 微软基础类库)。</p>
<p>\3. PyQT<br> Qt 是一种开源的 GUI 库，适合大型 GUI 程序开发，PyQT</p>
<p>是 Qt 工具包标准的 Python 实现。我们也可以使用 Qt Desginer 界面设计器快速开发 GUI 应用程序。</p>
]]></content>
  </entry>
  <entry>
    <title>python400集5</title>
    <url>/2020/05/03/python400%E9%9B%865/</url>
    <content><![CDATA[<h1 id="文件操作（IO技术）"><a href="#文件操作（IO技术）" class="headerlink" title="文件操作（IO技术）"></a>文件操作（IO技术）</h1><p>一个完整的程序一般都包括数据的存储和读取;我们在前面写的程序数据都没有进行实 际的存储，因此 python 解释器执行完数据就消失了。实际开发中，我们经常需要从外部存 储介质(硬盘、光盘、U 盘等)读取数据，或者将程序产生的数据存储到文件中，实现“持 久化”保存。</p>
<p>很多软件系统是将数据存储的数据库中;数据库实际也是基于文件 形式存储的</p>
<p><strong>文本文件和二进制文件</strong></p>
<p>按文件中数据组织形式，我们把文件分为文本文件和二进制文件两大类。</p>
<ol>
<li>文本文件</li>
</ol>
<p>文本文件存储的是普通“字符”文本，python 默认为 unicode 字符集(两个字节表示 一个字符，最多可以表示:65536 个)，可以使用记事本程序打开。但是，像 word 软件 编辑的文档不是文本文件。</p>
<ol start="2">
<li>二进制文件</li>
</ol>
<p>二进制文件把数据内容用“字节”进行存储，无法用记事本打开。必须使用专用的软件 解码。常见的有:MP4 视频文件、MP3 音频文件、JPG 图片、doc 文档等等。</p>
<h2 id="文件操作相关模块概述"><a href="#文件操作相关模块概述" class="headerlink" title="文件操作相关模块概述"></a><strong>文件操作相关模块概述</strong></h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>io 模块</td>
<td>文件流的输入和输出操作 input output</td>
</tr>
<tr>
<td>os 模块</td>
<td>基本操作系统功能，包括文件操作</td>
</tr>
<tr>
<td>glob 模块</td>
<td><code>查找符合特定规则的文件路径名</code></td>
</tr>
<tr>
<td>fnmatch 模块</td>
<td><code>使用模式来匹配文件路径名</code></td>
</tr>
<tr>
<td>fileinput 模块</td>
<td>处理多个输入文件</td>
</tr>
<tr>
<td>filecmp 模块</td>
<td>用于文件的比较</td>
</tr>
<tr>
<td>cvs 模块</td>
<td>用于 csv 文件处理</td>
</tr>
<tr>
<td>pickle 和 cPickle</td>
<td>用于序列化和反序列化</td>
</tr>
<tr>
<td>xml 包</td>
<td>用于 XML 数据处理</td>
</tr>
<tr>
<td>bz2、gzip、zipfile、zlib、tarfile</td>
<td><code>用于处理压缩和解压缩文件(分别对应不同的算法)</code></td>
</tr>
</tbody></table>
<h2 id="创建文件对象-open"><a href="#创建文件对象-open" class="headerlink" title="创建文件对象 open()"></a><strong>创建文件对象 open()</strong></h2><p>open()函数用于创建文件对象，基本语法格式如下: open(文件名[,打开方式])</p>
<p>如果只是文件名，代表在当前目录下的文件。文件名可以录入全路径，比如:D:\a\b.txt。</p>
<h3 id="为了减少“-”的输入，可以使用原始字符串-r-“d-b-txt”。"><a href="#为了减少“-”的输入，可以使用原始字符串-r-“d-b-txt”。" class="headerlink" title="为了减少“\”的输入，可以使用原始字符串:r “d:\b.txt”。"></a>为了减少“\”的输入，可以使用原始字符串:r “d:\b.txt”。</h3><h3 id="示例如下"><a href="#示例如下" class="headerlink" title="示例如下:"></a>示例如下:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f &#x3D; open(r&quot;d:\b.txt&quot;,&quot;w&quot;)</span><br></pre></td></tr></table></figure>

<p>打开方式有如下几种:</p>
<p>模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> r 读 read 模式</span><br><span class="line"></span><br><span class="line">w 写 write 模式。如果文件不存在则创建;如果文件存在，则重写新内容;</span><br><span class="line"></span><br><span class="line">a 追加 append 模式。如果文件不存在则创建;如果文件存在，则在文件末尾追加内容</span><br><span class="line"></span><br><span class="line">b 二进制 binary 模式(可与其他模式组合使用)</span><br><span class="line"></span><br><span class="line">+ 读、写模式(可与其他模式组合使用)</span><br></pre></td></tr></table></figure>

<p>文本文件对象和二进制文件对象的创建: 如果我们没有增加模式“b”，则默认创建的是文本文件对象，处理的基本单元是“字符”。如果是二进制模式“b”，则创建的是二进制文件对象，处理的基本单元是“字节”。</p>
<h2 id="文本文件的写入"><a href="#文本文件的写入" class="headerlink" title="文本文件的写入"></a><strong>文本文件的写入</strong></h2><p><strong>基本的文件写入操作</strong></p>
<p>文本文件的写入一般就是三个步骤: </p>
<ol>
<li>创建文件对象</li>
<li>写入数据</li>
<li>关闭文件对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">r"a.txt"</span>,<span class="string">"a"</span>) </span><br><span class="line">s = <span class="string">"itbaizhan\nsxt\n"</span> </span><br><span class="line">f.write(s)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h2 id="常用编码介绍"><a href="#常用编码介绍" class="headerlink" title="常用编码介绍"></a><strong>常用编码介绍</strong></h2><p>在操作文本文件时，经常会操作中文，这时候就经常会碰到乱码问题。</p>
<h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a><strong>ASCII</strong></h3><p>全称为 American Standard Code for Information Interchange，美国信 息交换标准代码，这是世界上最早最通用的单字节编码系统，主要用来显示现代 英语及其他西欧语言。</p>
<p>ASCII 码用 7 位表示，只能表示 128 个字符。只定义了 27=128 个字符，用 7bit 即可完全编码，而一字节 8bit 的容量是 256，所以一字节 ASCII 的编码最 高位总是 0。</p>
<p>0<del>31 表示控制字符如回车、退格、删除等;32</del>126 表示打印字符即可以 通过键盘输入并且能显示出来的字符;其中 48<del>57 为 0 到 9 十个阿拉伯数字， 65</del>90 为 26 个大写英文字母，97~122 号为 26 个小写英文字母，其余为一 些标点符号、运算符号等，具体可以参考 ASCII 标准表(大家自行百度，不在此 赘述)。</p>
<h3 id="ISO8859-1"><a href="#ISO8859-1" class="headerlink" title="ISO8859-1"></a><strong>ISO8859-1</strong></h3><p>ISO-8859-1 又称 Latin-1，是一个 8 位单字节字符集，它把 ASCII 的最高 位也利用起来，并兼容了 ASCII，新增的空间是 128，但它并没有完全用完。</p>
<p>在 ASCII 编码之上又增加了西欧语言、希腊语、泰语、阿拉伯语、希伯来语 对应的文字符号，它是向下兼容 ASCII 编码</p>
<h3 id="GB2312-GBK-GB18030"><a href="#GB2312-GBK-GB18030" class="headerlink" title="GB2312,GBK,GB18030"></a><strong>GB2312,GBK,GB18030</strong></h3><h4 id="·GB2312"><a href="#·GB2312" class="headerlink" title="·GB2312"></a><strong>·GB2312</strong></h4><p>GB2312 全称为信息交换用汉字编码字符集，是中国于 1980 年发布，主要 用于计算机系统中的汉字处理。GB2312 主要收录了 6763 个汉字、682 个符号。</p>
<p>GB2312 覆盖了汉字的大部分使用率，但不能处理像古汉语等特殊的罕用字， 所以后来出现了像 GBK、GB18030 这种编码。</p>
<p><strong>GB2312 完全兼容 ISO8859-1。</strong></p>
<h4 id="·GBK"><a href="#·GBK" class="headerlink" title="·GBK"></a><strong>·GBK</strong></h4><p>全称为 Chinese Internal Code Specification，即汉字内码扩展规范，于 1995 年制定。 它主要是扩展了 GB2312，在它的基础上又加了更多的汉字，它一共收录了 21003 个汉字</p>
<h4 id="·GB18030"><a href="#·GB18030" class="headerlink" title="·GB18030"></a><strong>·GB18030</strong></h4><p>现在最新的内码字集于 2000 年发布，并于 2001 年强制执行，包含了中国大部分少数 民族的语言字符，收录汉字数超过 70000 余个。</p>
<p>它主要采用单字节、双字节、四字节对字符编码，它是向下兼容 GB2312 和 GBK 的， 虽然是我国的强制使用标准，但在实际生产中很少用到，用得最多的反而是 GBK 和 GB2312</p>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a><strong>Unicode</strong></h3><p>Unicode 编码设计成了固定两个字节，所有的字符都用 16 位(2^16=65536) 表示，包括之前只占 8 位的英文字符等，所以会造成空间的浪费，UNICODE 在 很长的一段时间内都没有得到推广应用。</p>
<p>6</p>
<p>北京尚学堂·百战程序员 高淇的 python400 集:从零打好内功，直达手写神经网络 Unicode 完全重新设计，不兼容 iso8859-1，也不兼容任何其他编码。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a><strong>UTF-8</strong></h3><p>对于英文字母，unicode 也需要两个字节来表示。所以 unicode 不便 于传输和存储。因此而产生了 UTF 编码，UTF-8 全称是(8-bit Unicode Transformation Format)。</p>
<p>UTF 编码兼容 iso8859-1 编码，同时也可以用来表示所有语言的字符， 不过，UTF 编码是不定长编码，每一个字符的长度从 1-4 个字节不等。其中， 英文字母都是用一个字节表示，而汉字使用三个字节。</p>
<p>【老鸟建议】一般项目都会使用 UTF-8。unicode 中虽然汉字是两个字节， UTF-8 中汉字是 3 个字节。但是互联网中一个网页也包含了大量的英文字母， 这些英文字母只占用 1 个字节，整体占用空间，UTF-8 仍然由于 Unicode。</p>
<h2 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a><strong>中文乱码问题</strong></h2><p>windows 操作系统默认的编码是 GBK，Linux 操作系统默认的编码是 UTF-8。当我们 用 open()时，调用的是操作系统打开的文件，默认的编码是 GBK。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们在文件编辑区单击右键，选择 FileEncoding，选择 GBK 即可:</span><br></pre></td></tr></table></figure>

<h2 id="write-writelines-写入数据"><a href="#write-writelines-写入数据" class="headerlink" title="write()/writelines()写入数据"></a><strong>write()/writelines()写入数据</strong></h2><p>write(a):把字符串 a 写入到文件中 </p>
<p>writelines(b):把字符串列表写入文件中，不添加换行符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">r"d:\bb.txt"</span>,<span class="string">"w"</span>,encoding=<span class="string">"utf-8"</span>) </span><br><span class="line">s = [<span class="string">"高淇\n"</span>,<span class="string">"高老三\n"</span>,<span class="string">"高老四\n"</span>] </span><br><span class="line">f.writelines(s)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h2 id="close-关闭文件流"><a href="#close-关闭文件流" class="headerlink" title="close()关闭文件流"></a><strong>close()关闭文件流</strong></h2><p>由于文件底层是由操作系统控制，所以我们打开的文件对象必须显式调用 close()方法 关闭文件对象。当调用 close()方法时，首先会把缓冲区数据写入文件(也可以直接调用 flush() 方法)，再关闭文件，释放文件对象。</p>
<p>为了确保打开的文件对象正常关闭，一般结合异常机制的 finally 或者 with 关键字实现 无论何种情况都能关闭打开的文件对象。</p>
<p>结合异常机制 finally 确保关闭文件对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	f = open(<span class="string">r"my01.txt"</span>,<span class="string">"a"</span>) </span><br><span class="line">  str = <span class="string">"gaoqi"</span></span><br><span class="line">	f.write(str)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e: </span><br><span class="line">  print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  f.close()</span><br></pre></td></tr></table></figure>

<h2 id="with-语句-上下文管理器"><a href="#with-语句-上下文管理器" class="headerlink" title="with 语句(上下文管理器)"></a><strong>with 语句(上下文管理器)</strong></h2><p>with 关键字(上下文管理器)可以自动管理上下文资源，不论什么原因跳出 with 块，都能 确保文件正确的关闭，并且可以在代码块执行完毕后自动还原进入该代码块时的现场。</p>
<p>使用 with 管理文件写入操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = [<span class="string">"高淇\n"</span>,<span class="string">"高老三\n"</span>,<span class="string">"高老五\n"</span>]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"d:\bb.txt"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">	f.writelines(s)</span><br></pre></td></tr></table></figure>

<h2 id="文本文件的读取"><a href="#文本文件的读取" class="headerlink" title="文本文件的读取"></a><strong>文本文件的读取</strong></h2><p>文件的读取一般使用如下三个方法: 1. read([size])</p>
<p>从文件中读取 size 个字符，并作为结果返回。如果没有 size 参数，则读取整个文件。</p>
<p>读取到文件末尾，会返回空字符串。 2. readline()</p>
<p>读取一行内容作为结果返回。读取到文件末尾，会返回空字符串。 3. readlines()</p>
<p>文本文件中，每一行作为一个字符串存入列表中，返回该列表</p>
<p>读取一个文件前 4 个字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(r&quot;bb&quot;,&quot;r&quot;,encoding&#x3D;&quot;utf-8&quot;) as f: </span><br><span class="line">	print(f.read(4))</span><br></pre></td></tr></table></figure>

<p>文件较小，一次将文件内容读入到程序中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(r&quot;d:\bb.txt&quot;,&quot;r&quot;) as f: </span><br><span class="line">	print(f.read())</span><br></pre></td></tr></table></figure>

<p>按行读取一个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(r&quot;bb.txt&quot;,&quot;r&quot;) as f: </span><br><span class="line">	while True:</span><br><span class="line">		fragment &#x3D; f.readline() </span><br><span class="line">		if not fragment:</span><br><span class="line">			break </span><br><span class="line">		else:</span><br><span class="line">			print(fragment,end&#x3D;&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p>使用迭代器(每次返回一行)读取文本文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(r&quot;d:\bb.txt&quot;,&quot;r&quot;) as f: </span><br><span class="line">	for a in f:</span><br><span class="line">		print(a,end&#x3D;&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p>为文本文件每一行的末尾增加行号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"e.txt"</span>,<span class="string">"r"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f: </span><br><span class="line">  lines = f.readlines()</span><br><span class="line">  lines = [ line.rstrip()+<span class="string">" #"</span>+str(index+<span class="number">1</span>)+<span class="string">"\n"</span> <span class="keyword">for</span> index,line <span class="keyword">in</span> enumerate(lines)] <span class="comment">#推导式生成列表</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"e.txt"</span>,<span class="string">"w"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f: </span><br><span class="line">  f.writelines(lines)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行前文件内容:</span><br><span class="line">我 love u! </span><br><span class="line">尚学堂 </span><br><span class="line">百战程序员</span><br><span class="line">执行程序后文件内容:</span><br><span class="line">我 love u! #1 </span><br><span class="line">尚学堂 #2 </span><br><span class="line">百战程序员 #3</span><br></pre></td></tr></table></figure>

<p><strong>二进制文件的读取和写入</strong></p>
<p>二进制文件的处理流程和文本文件流程一致。首先还是要创建文件对象，不过，我们需要指 定二进制模式，从而创建出二进制文件对象。例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f &#x3D; open(r&quot;d:\a.txt&quot;, &#39;wb&#39;) #可写的、重写模式的二进制文件对象</span><br><span class="line">f &#x3D; open(r&quot;d:\a.txt&quot;, &#39;ab&#39;)  #可写的、追加模式的二进制文件对象</span><br><span class="line">f &#x3D; open(r&quot;d:\a.txt&quot;, &#39;rb&#39;) #可读的二进制文件对象</span><br></pre></td></tr></table></figure>

<p>创建好二进制文件对象后，仍然可以使用 write()、read()实现文件的读写操作。</p>
<p>读取图片文件，实现文件的拷贝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;aa.gif&#39;, &#39;rb&#39;) as f:</span><br><span class="line">	with open(&#39;aa_copy.gif&#39;, &#39;wb&#39;) as w:</span><br><span class="line">		for line in f.readlines():</span><br><span class="line">    w.write(line)</span><br><span class="line">print(&#39;图片拷贝完成!&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="文件对象的常用属性和方法"><a href="#文件对象的常用属性和方法" class="headerlink" title="文件对象的常用属性和方法"></a>文件对象的常用属性和方法</h2><p>文件对象封装了文件相关的操作。在前面我们学习了通过文件对象对文件进行读写操作。本 节我们详细列出文件对象的常用属性和方法，并进行说明。</p>
<p>文件对象的属性<br> 属性                                                说明</p>
<table>
<thead>
<tr>
<th>name</th>
<th>返回文件的名字</th>
</tr>
</thead>
<tbody><tr>
<td>mode</td>
<td>返回文件的打开模式</td>
</tr>
<tr>
<td>closed</td>
<td>若文件被关闭则返回 True</td>
</tr>
</tbody></table>
<p>文件对象的打开模式</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读模式</td>
</tr>
<tr>
<td>w</td>
<td>写模式</td>
</tr>
<tr>
<td>a</td>
<td>追加模式</td>
</tr>
<tr>
<td>b</td>
<td><code>二进制模式(可与其他模式组合)</code></td>
</tr>
<tr>
<td>+</td>
<td><code>读写模式(可以其他模式组合)</code></td>
</tr>
</tbody></table>
<p>文件对象的常用方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>read([size])</td>
<td>从文件中读取 size 个字节或字符的内容返回。若省略[size]，则读 取到文件末尾，即一次读取文件所有内容</td>
</tr>
<tr>
<td>readline()</td>
<td>从文本文件中读取一行内容</td>
</tr>
<tr>
<td>readlines()</td>
<td>把文本文件中每一行都作为独立的字符串对象，并将这些对象放入 列表返回</td>
</tr>
<tr>
<td>write(str)</td>
<td>将字符串 str 内容写入文件</td>
</tr>
<tr>
<td>writelines(s)</td>
<td>将字符串列表 s 写入文件文件，不添加换行符</td>
</tr>
<tr>
<td>seek(offset ,whence])</td>
<td>把文件指针移动到新的位置，offset 表示相对于 whence 的多少个 字节的偏移量; offset:                                 off 为正往结束方向移动，为负往开始方向移动 whence 不同的值代表不同含义:  0: 从文件头开始计算(默认值) 1:从当前位置开始计算  2:从文件尾开始计算</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>tell()</td>
<td>返回文件指针的当前位置</td>
</tr>
<tr>
<td>truncate([size])</td>
<td>不论指针在什么位置，只留下指针前 size 个字节的内容，其余全 部删除;  如果没有传入 size，则当指针当前位置到文件末尾内容全部删除</td>
</tr>
<tr>
<td>flush()</td>
<td>把缓冲区的内容写入文件，但不关闭文件</td>
</tr>
<tr>
<td>close()</td>
<td>把缓冲区内容写入文件，同时关闭文件，释放文件对象相关资源</td>
</tr>
</tbody></table>
<h2 id="文件任意位置操作"><a href="#文件任意位置操作" class="headerlink" title="文件任意位置操作"></a><strong>文件任意位置操作</strong></h2><p>seek()移动文件指针示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&quot;e.txt&quot;,&quot;r&quot;,encoding&#x3D;&quot;utf-8&quot;) as f: </span><br><span class="line">	print(&quot;文件名是:&#123;0&#125;&quot;.format(f.name)) </span><br><span class="line">	print(f.tell())</span><br><span class="line">	print(&quot;读取的内容:&#123;0&#125;&quot;.format(str(f.readline()))) </span><br><span class="line">	print(f.tell())</span><br><span class="line">	f.seek(0,0) </span><br><span class="line">	print(&quot;读取的内容:&#123;0&#125;&quot;.format(str(f.readline())))</span><br></pre></td></tr></table></figure>

<h2 id="使用-pickle-序列化"><a href="#使用-pickle-序列化" class="headerlink" title="使用 pickle 序列化"></a><strong>使用 pickle 序列化</strong></h2><p>Python 中，一切皆对象，对象本质上就是一个“存储数据的内存块”。有时候，我们 需要将“内存块的数据”保存到硬盘上，或者通过网络传输到其他的计算机上。这时候，就 需要“对象的序列化和反序列化”。 对象的序列化机制广泛的应用在分布式、并行系统上。</p>
<p>序列化指的是:将对象转化成“串行化”数据形式，存储到硬盘或通过网络传输到其他 地方。反序列化是指相反的过程，将读取到的“串行化数据”转化成对象。</p>
<p>我们可以使用 pickle 模块中的函数，实现序列化和反序列操作。</p>
<p>序列化我们使用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> pickle.dump(obj, file) obj 就是要被序列化的对象，file 指的是存储的文件</span><br><span class="line">pickle.load(file) 从 file 读取数据，反序列化成对象</span><br></pre></td></tr></table></figure>

<p>1.序列化是指把对象转换为字节序列的过程，而反序列化是指把字节序列恢复为对象的过程</p>
<p>2.对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。</p>
<p>3.序列化机制的核心作用就是对象状态的保存与重建。</p>
<p>4.反序列化就是客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p>
<p>5.序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态。</p>
<p>6.序列化算法一般会按步骤做如下事情：</p>
<p>（1）将对象实例相关的类元数据输出。<br>（2）递归地输出类的超类描述直到不再有超类。<br>（3）类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。<br>（4）从上至下递归输出实例的数据</p>
<p>7.序列化的好处：</p>
<p>一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），</p>
<p>二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。</p>
<h4 id="对象序列化到文件中-反序列化"><a href="#对象序列化到文件中-反序列化" class="headerlink" title="对象序列化到文件中,反序列化"></a>对象序列化到文件中,反序列化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"d:\data.dat"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> f:<span class="comment">#序列化</span></span><br><span class="line">  a1=<span class="string">"nihao"</span></span><br><span class="line">  a2=<span class="string">"223"</span></span><br><span class="line">  pickle.dump(a1,f)</span><br><span class="line">  pickle.dump(a2,f)</span><br><span class="line"> <span class="comment">#反序列化</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"d:\data.dat"</span>,<span class="string">"rb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">  a1 = pickle.load(f)</span><br><span class="line">  a2 = pickle.load(f)</span><br><span class="line">  print(a1);print(a2)</span><br><span class="line">  <span class="comment">#打印出：nihao</span></span><br><span class="line">          <span class="number">223</span></span><br></pre></td></tr></table></figure>

<h2 id="CSV-文件的操作"><a href="#CSV-文件的操作" class="headerlink" title="CSV 文件的操作"></a><strong>CSV 文件的操作</strong></h2><p>csv(Comma Separated Values)是逗号分隔符文本格式，常用于数据交换、Excel 文件和数据库数据的导入和导出。与 Excel 文件不同，CSV 文件中:</p>
<p>值没有类型，所有值都是字符串 不能指定字体颜色等样式 不能指定单元格的宽高，不能合并单元格，没有多个工作表</p>
<p>不能嵌入图像图表</p>
<h3 id="csv-reader-对象和-csv-文件读取"><a href="#csv-reader-对象和-csv-文件读取" class="headerlink" title="csv.reader 对象和 csv 文件读取"></a><strong>csv.reader 对象和 csv 文件读取</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"d:\a.csv"</span>) <span class="keyword">as</span> a:</span><br><span class="line">	a_csv = csv.reader(a) <span class="comment">#创建 csv 对象,它是一个包含所有数据的列表，每一行为一个元素</span></span><br><span class="line">  headers = next(a_csv) <span class="comment">#获得列表对象，包含标题行的信息</span></span><br><span class="line">  print(headers)</span><br><span class="line">	<span class="keyword">for</span> row <span class="keyword">in</span> a_csv:<span class="comment">#循环打印各行内容</span></span><br><span class="line">		print(row)</span><br><span class="line">    <span class="comment">#['高老三', '19', '测试工程师', '20000'] </span></span><br><span class="line">    [<span class="string">'高老五'</span>, <span class="string">'20'</span>, <span class="string">'人工智能开发'</span>, <span class="string">'50000'</span>]</span><br></pre></td></tr></table></figure>

<h3 id="csv-writer-对象和-csv-文件写入"><a href="#csv-writer-对象和-csv-文件写入" class="headerlink" title="csv.writer 对象和 csv 文件写入"></a><strong>csv.writer 对象和 csv 文件写入</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">headers = [<span class="string">"工号"</span>,<span class="string">"姓名"</span>,<span class="string">"年龄"</span>,<span class="string">"地址"</span>,<span class="string">"月薪"</span>]</span><br><span class="line">rows = [(<span class="string">"1001"</span>,<span class="string">"高淇"</span>,<span class="number">18</span>,<span class="string">"西三旗 1 号院"</span>,<span class="string">"50000"</span>),(<span class="string">"1002"</span>,<span class="string">"高八"</span>,<span class="number">19</span>,<span class="string">"西三旗 1 号院"</span>,<span class="string">"30000"</span>)] </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"d:\b.csv"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> b:</span><br><span class="line">	b_csv = csv.writer(b) <span class="comment">#创建 csv 对象</span></span><br><span class="line">	b_csv.writerow(headers) <span class="comment">#写入一行(标题)</span></span><br><span class="line">	b_csv.writerows(rows)  <span class="comment">#写入多行(数据)</span></span><br><span class="line">```</span><br><span class="line">执行结果:</span><br><span class="line">工号,姓名,年龄,地址,月薪 </span><br><span class="line"><span class="number">1001</span>,高淇,<span class="number">18</span>,西三旗 <span class="number">1</span> 号院,<span class="number">50000</span> </span><br><span class="line"><span class="number">1002</span>,高八,<span class="number">19</span>,西三旗 <span class="number">1</span> 号院,<span class="number">30000</span></span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="os-和-os-path-模块"><a href="#os-和-os-path-模块" class="headerlink" title="os 和 os.path 模块"></a><strong>os 和 os.path 模块</strong></h2><p>os 模块可以帮助我们直接对操作系统进行操作。我们可以直接调用操作系统的可执行 文件、命令，直接操作文件、目录等等。在系统运维的核心基础。</p>
<p>**os 模块-调用操作系统命令</p>
<h3 id="·os-system-可以帮助我们直接调用系统的命令"><a href="#·os-system-可以帮助我们直接调用系统的命令" class="headerlink" title="** ·os.system 可以帮助我们直接调用系统的命令"></a>** <strong>·os.system 可以帮助我们直接调用系统的命令</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os </span><br><span class="line">os.system(&quot;notepad.exe&quot;)#os.system 调用 windows 系统的记事本程序</span><br><span class="line">import os</span><br><span class="line">os.system(&quot;ping www.baidu.com&quot;)#os.system 调用 windows 系统中 ping 命令</span><br><span class="line">import os</span><br><span class="line">os.startfile(r&quot;C:\Program Files (x86)\Tencent\WeChat\WeChat.exe&quot;)#运行安装好的微信</span><br></pre></td></tr></table></figure>

<p><strong>【注】</strong>Linux 是命令行操作更容易，我们可以通过 os.system 可以更加容易的调用相关的命 令;</p>
<p>【注】控制台输出中文可能会有乱码问题，可以在 file–&gt;setting 中设置</p>
<p><strong>os.startfile:直接调用可执行文件</strong></p>
<p><strong>os 模块-文件和目录操作</strong></p>
<p>我们可以通过前面讲的文件对象实现对于文件内容的读写操作。如果，还需要对文件和 目录做其他操作，可以使用 os 和 os.path 模块。</p>
<p>os 模块下常用操作文件的方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>remove(path)</td>
<td>删除指定的文件</td>
</tr>
<tr>
<td>rename(src,dest)</td>
<td>重命名文件或目录</td>
</tr>
<tr>
<td>stat(path)</td>
<td>返回文件的所有属性</td>
</tr>
<tr>
<td>listdir(path)</td>
<td>返回 path 目录下的文件和目录列表</td>
</tr>
</tbody></table>
<p>os 模块下关于目录操作的相关方法，汇总如下:</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>mkdir(path)</td>
<td>创建目录</td>
</tr>
<tr>
<td>makedirs(path1/path2/path3/… )</td>
<td>创建多级目录</td>
</tr>
<tr>
<td>rmdir(path)</td>
<td>删除目录</td>
</tr>
<tr>
<td>removedirs(path1/path2…)</td>
<td>删除多级目录</td>
</tr>
<tr>
<td>getcwd()</td>
<td>返回当前工作目录:current work dir</td>
</tr>
<tr>
<td>chdir(path)</td>
<td>把 path 设为当前工作目录</td>
</tr>
<tr>
<td>walk()</td>
<td>遍历目录树</td>
</tr>
<tr>
<td>sep</td>
<td><code>当前操作系统所使用的路径分隔符</code></td>
</tr>
</tbody></table>
<p>os 模块:创建、删除目录、获取文件信息等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;utf-8</span><br><span class="line">#测试 os 模块中，关于文件和目录的操作 import os</span><br><span class="line">#############获取文件和文件夹相关的信息################ print(os.name) #windows-&gt;nt linux 和 unix-&gt;posix print(os.sep) #windows-&gt;\ linux 和 unix-&gt;&#x2F; print(repr(os.linesep)) #windows-&gt;\r\n linux--&gt;\n\</span><br><span class="line">print(os.stat(&quot;my02.py&quot;))</span><br><span class="line">##############关于工作目录的操作############### #print(os.getcwd())</span><br><span class="line">#os.chdir(&quot;d:&quot;) #改变当前的工作目录为:d:盘根目录 #os.mkdir(&quot;书籍&quot;) ################创建目录、创建多级目录、删除############# #os.mkdir(&quot;书籍&quot;)</span><br><span class="line">#os.rmdir(&quot;书籍&quot;) #相对路径都是相对于当前的工作目录</span><br><span class="line"></span><br><span class="line">#os.rename(&quot;电影&quot;,&quot;movie&quot;)</span><br><span class="line">dirs &#x3D; os.listdir(&quot;movie&quot;)</span><br><span class="line">print(dirs)</span><br></pre></td></tr></table></figure>

<p><strong>os.path 模块</strong></p>
<p>os.path 模块提供了目录相关(路径判断、路径切分、路径连接、文件夹遍历)的操作</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>isabs(path)</td>
<td>判断 path 是否绝对路径</td>
</tr>
<tr>
<td>isdir(path)</td>
<td>判断 path 是否为目录</td>
</tr>
<tr>
<td>isfile(path)</td>
<td>判断 path 是否为文件</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>exists(path)</th>
<th><code>判断指定路径的文件是否存在</code></th>
</tr>
</thead>
<tbody><tr>
<td>getsize(filename)</td>
<td>返回文件的大小</td>
</tr>
<tr>
<td>abspath(path)</td>
<td>返回绝对路径</td>
</tr>
<tr>
<td>dirname(p)</td>
<td>返回目录的路径</td>
</tr>
<tr>
<td>getatime(filename)</td>
<td>返回文件的最后访问时间</td>
</tr>
<tr>
<td>getmtime(filename)</td>
<td>返回文件的最后修改时间</td>
</tr>
<tr>
<td>walk(top,func,arg)</td>
<td>递归方式遍历目录</td>
</tr>
<tr>
<td>join(path,*paths)</td>
<td>连接多个 path</td>
</tr>
<tr>
<td>split(path)</td>
<td>对路径进行分割，以列表形式返回</td>
</tr>
<tr>
<td>splitext(path)</td>
<td><code>从路径中分割文件的扩展名</code></td>
</tr>
</tbody></table>
<p><strong>walk()递归遍历所有文件和目录</strong></p>
<p>os.walk()方法:</p>
<p>返回一个 3 个元素的元组，(dirpath, dirnames, filenames), </p>
<p>dirpath:要列出指定目录的路径 dirnames:目录下的所有文件夹 filenames:目录下的所有文件</p>
<p><strong>shutil 模块(拷贝和压缩)</strong></p>
<p>shutil 模块是 python 标准库中提供的，主要用来做文件和文件夹的拷贝、移动、删除等;还可以做 文件和文件夹的压缩、解压缩操作。</p>
<p>os 模块提供了对目录或文件的一般操作。shutil 模块作为补充，提供了移动、复制、压缩、解压等操 作，这些 os 模块都没有提供。</p>
]]></content>
  </entry>
  <entry>
    <title>python400集3</title>
    <url>/2020/04/29/python400%E9%9B%863/</url>
    <content><![CDATA[<h1 id="python面向对象"><a href="#python面向对象" class="headerlink" title="python面向对象"></a>python面向对象</h1><p>类定义数据类型的属性(数据)和方法(行为),也就是说，“类将行为和状态打 包在一起”。</p>
<p>对象是类的具体实体，一般称为“类的实例”。“方法代码是共享的，属性数据不共享”。</p>
<p>定义类的语法格式如下: class 类名:</p>
<p>类体</p>
<p>要点如下:</p>
<ol>
<li><p>类名必须符合“标识符”的规则;一般规定，首字母大写，多个单词使用“驼峰原则”。</p>
<ol start="2">
<li>类体中我们可以定义属性和方法。</li>
<li>. 属性用来描述数据，方法(即函数)用来描述这些数据相关的操作。</li>
</ol>
</li>
</ol>
<h2 id="init构造方法和new方法"><a href="#init构造方法和new方法" class="headerlink" title="init构造方法和new方法"></a><strong><strong>init</strong>构造方法和<strong>new</strong>方法</strong></h2><p>类是抽象的，也称之为“对象的模板”。我们需要通过类这个模板，创建类的实例对象，然 后才能使用类定义的功能。</p>
<p>我们前面说过一个 Python 对象包含三个部分:id(identity 识别码)、type(对象类型)、 value(对象的值)。</p>
<p>现在，我们可以更进一步的说，一个 Python 对象包含如下部分: 1. id(identity 识别码)</p>
<ol start="2">
<li>type(对象类型) 3. value(对象的值)：(1) 属性(attribute) (2) 方法(method)</li>
</ol>
<h4 id="创建对象，我们需要定义构造函数init-方法。构造方法用于执行“实例对象的初始化工-作”，即对象创建后，初始化当前对象的相关属性，无返回值。"><a href="#创建对象，我们需要定义构造函数init-方法。构造方法用于执行“实例对象的初始化工-作”，即对象创建后，初始化当前对象的相关属性，无返回值。" class="headerlink" title="创建对象，我们需要定义构造函数init()方法。构造方法用于执行“实例对象的初始化工 作”，即对象创建后，初始化当前对象的相关属性，无返回值。"></a>创建对象，我们需要定义构造函数<strong>init</strong>()方法。构造方法用于执行“实例对象的初始化工 作”，即对象创建后，初始化当前对象的相关属性，无返回值。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_init_()</span><br></pre></td></tr></table></figure>

<p>的要点如下:<br> \1. 名称固定，必须为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__init__()</span><br></pre></td></tr></table></figure>

<p> \2. 第一个参数固定，必须为:self。 self 指的就是刚刚创建好的实例对象。<br> \3. 构造函数通常用来初始化实例对象的实例属性，如下代码就是初始化实例属性:name 和 score。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,score)</span>:</span></span><br><span class="line">	self.name = name <span class="comment">#实例属性 </span></span><br><span class="line">	self.score = score</span><br></pre></td></tr></table></figure>

<p>\4. 通过“类名(参数列表)”来调用构造函数。调用后，将创建好的对象返回给相应的变量。 比如:s1 = Student(‘张三’, 80)</p>
<p>\5. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__init__()方法:初始化创建好的对象，初始化指的是:“给实例属性赋值”</span><br></pre></td></tr></table></figure>


<p> \6. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__new__()方法: 用于创建对象，但我们一般无需重定义该方法。</span><br></pre></td></tr></table></figure>


<p> \7.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果我们不定义__init__方法，系统会提供一个默认的__init__方法。如果我们定义了带参 的__init__方法，系统不创建默认的__init__方法。</span><br></pre></td></tr></table></figure>

<p>注:<br> \1. Python中的self相当于C++中的self指针，JAVA和C#中的this关键字。Python中， self 必须为构造函数的第一个参数，名字可以任意修改。但一般遵守惯例，都叫做 self。</p>
<h2 id="实例属性和实例方法"><a href="#实例属性和实例方法" class="headerlink" title="实例属性和实例方法"></a>实例属性和实例方法</h2><h3 id="实例属性instance（其实跟java差不多）"><a href="#实例属性instance（其实跟java差不多）" class="headerlink" title="实例属性instance（其实跟java差不多）"></a>实例属性instance（其实跟java差不多）</h3><p>实例属性是从属于实例对象的属性，也称为“实例变量”。他的使用有如下几个要点: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\1. 实例属性一般在__init__()方法中通过如下代码定义:</span><br><span class="line"></span><br><span class="line">self.实例属性名 &#x3D; 初始值</span><br><span class="line"> \2. 在本类的其他实例方法中，也是通过 self 进行访问:</span><br><span class="line"></span><br><span class="line">self.实例属性名</span><br><span class="line"> \3. 创建实例对象后，通过实例对象访问:</span><br><span class="line"></span><br><span class="line">obj01 &#x3D; 类名() #创建对象，调用__init__()初始化属性 </span><br><span class="line">obj01.实例属性名 &#x3D; 值 #可以给已有属性赋值，也可以新加属性</span><br></pre></td></tr></table></figure>



<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a><strong>实例方法</strong></h3><p>实例方法是从属于实例对象的方法。实例方法的定义格式如下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def 方法名(self [, 形参列表]):</span><br><span class="line">	函数体</span><br><span class="line">方法的调用格式如下:</span><br><span class="line">	对象.方法名([实参列表])</span><br></pre></td></tr></table></figure>



<p>要点:<br> \1. 定义实例方法时，第一个参数必须为 self。和前面一样，self 指当前的实例对象。 2. 调用实例方法时，不需要也不能给 self 传参。self 由解释器自动传参。</p>
<h3 id="·-函数和方法的区别"><a href="#·-函数和方法的区别" class="headerlink" title="· 函数和方法的区别"></a><strong>· 函数和方法的区别</strong></h3><ol>
<li><p>都是用来完成一个功能的语句块，本质一样。</p>
</li>
<li><p>方法调用时，通过对象来调用。方法从属于特定实例对象，普通函数没有这个特点。 </p>
</li>
<li><p>直观上看，方法定义时需要传递 self，函数不需要。</p>
</li>
</ol>
<p><strong>· 实例对象的方法调用本质:</strong></p>
<p><strong>a = Student()</strong></p>
<p><strong>a.say_score()</strong></p>
<p>解释器翻译:</p>
<p><strong>Student.say_score(a)</strong></p>
<p><strong>· 其他操作:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> dir(obj)可以获得对象的所有属性、方法</span><br><span class="line"><span class="number">2.</span>obj.__dict__ 对象的属性字典</span><br><span class="line"><span class="number">3.</span><span class="keyword">pass</span> 空语句</span><br><span class="line"><span class="number">4.</span>isinstance(对象,类型) 判断“对象”是不是“指定类型”</span><br></pre></td></tr></table></figure>

<h2 id="类对象、类属性、类方法、静态方法"><a href="#类对象、类属性、类方法、静态方法" class="headerlink" title="类对象、类属性、类方法、静态方法"></a><strong>类对象、类属性、类方法、静态方法</strong></h2><p><strong>类对象</strong></p>
<p>我们在前面讲的类定义格式中，“class 类名:”。实际上，当解释器执行 class 语句时， 就会创建一个类对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	<span class="keyword">pass</span> <span class="comment">#空语句</span></span><br><span class="line">print(type(Student)) </span><br><span class="line">print(id(Student))</span><br><span class="line">Stu2 = Student </span><br><span class="line">s1 = Stu2() </span><br><span class="line">print(s1)</span><br></pre></td></tr></table></figure>

<p>执行结果如下:<br> &lt;class ‘type’&gt;</p>
<p>51686328<br> &lt;<strong>main</strong>.Student object at 0x0000000002B5FDD8&gt;</p>
<p>我们可以看到实际上生成了一个变量名就是类名“Student”的对象。我们通过赋值给新变 量 Stu2，也能实现相关的调用。说明，确实创建了“类对象”。</p>
<p>【注】pass 为空语句。就是表示什么都不做，只是作为一个占位符存在。当你写代码时， 遇到暂时不知道往方法或者类中加入什么时，可以先用 pass 占位，后期再补上。</p>
<h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a><strong>类属性</strong></h3><p>类属性是从属于“类对象”的属性，也称为“类变量”。由于，类属性从属于类对象，可以 被所有实例对象共享。</p>
<p>类属性的定义方式:<br> class 类名:</p>
<p>类变量名= 初始值 在类中或者类的外面，我们可以通过:“类名.类变量名”来读写。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	company = <span class="string">"SXT"</span> <span class="comment">#类属性 </span></span><br><span class="line">	count = <span class="number">0</span> <span class="comment">#类属性</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,score)</span>:</span> </span><br><span class="line">		self.name = name 	</span><br><span class="line">		self.score = score <span class="comment">#实例属性</span></span><br><span class="line">		Student.count = Student.count+<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_score</span><span class="params">(self)</span>:</span> <span class="comment">#实例方法 </span></span><br><span class="line">  print(<span class="string">"我的公司是:"</span>,Student.company) </span><br><span class="line">  print(self.name,<span class="string">'的分数是:'</span>,self.score)</span><br><span class="line">s1 = Student(<span class="string">'张三'</span>,<span class="number">80</span>) <span class="comment">#s1 是实例对象，自动调用__init__()方法 </span></span><br><span class="line">s1.say_score()</span><br><span class="line">print(<span class="string">'一共创建&#123;0&#125;个 Student 对象'</span>.format(Student.count))</span><br><span class="line">```</span><br><span class="line">执行结果:</span><br><span class="line">我的公司是: SXT</span><br><span class="line">张三 的分数是: <span class="number">80</span> </span><br><span class="line">一共创建 <span class="number">1</span> 个 Student 对象</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a><strong>类方法</strong></h3><p>类方法是从属于“类对象”的方法。类方法通过装饰器@classmethod 来定义，格式如下: @classmethod</p>
<p>def 类方法名(cls [，形参列表]) : 函数体</p>
<p>要点如下:<br> \1. @classmethod 必须位于方法上面一行<br> \2. 第一个 cls 必须有;cls 指的就是“类对象”本身;<br> \3. 调用类方法格式:“类名.类方法名(参数列表)”。 参数列表中，不需要也不能给 cls 传 值。<br> \4. 类方法中访问实例属性和实例方法会导致错误<br> \5. 子类继承父类方法时，传入 cls 是子类对象，而非父类对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	company = <span class="string">"SXT"</span> <span class="comment">#类属性 </span></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printCompany</span><span class="params">(cls)</span>:</span> </span><br><span class="line">    print(cls.company)</span><br><span class="line">Student.printCompany()</span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a><strong>静态方法</strong></h3><p>Python 中允许定义与“类对象”无关的方法，称为“静态方法”。</p>
<p>“静态方法”和在模块中定义普通函数没有区别，只不过“静态方法”放到了“类的名字空 间里面”，需要通过“类调用”。</p>
<p>静态方法通过装饰器@staticmethod 来定义，格式如下: @staticmethod</p>
<p>def 静态方法名([形参列表]) : 函数体</p>
<p>要点如下:</p>
<ol>
<li><p>@staticmethod 必须位于方法上面一行</p>
</li>
<li><p>调用静态方法格式:“类名.静态方法名(参数列表)”。 </p>
</li>
<li><p>静态方法中访问实例属性和实例方法会导致错误</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	company = <span class="string">"SXT"</span> <span class="comment"># 类属性</span></span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span> <span class="comment"># 静态方法</span></span><br><span class="line"> 		print(<span class="string">"&#123;0&#125;+&#123;1&#125;=&#123;2&#125;"</span>.format(a,b,(a+b)))</span><br><span class="line"> 		<span class="keyword">return</span> a+b</span><br><span class="line"> Student.add(<span class="number">20</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h2 id="del方法-析构函数-和垃圾回收机制"><a href="#del方法-析构函数-和垃圾回收机制" class="headerlink" title="del方法(析构函数)和垃圾回收机制"></a><strong><strong>del</strong>方法(析构函数)和垃圾回收机制</strong></h2><p><strong>del</strong>方法称为“析构方法”，用于实现对象被销毁时所需的操作。比如:释放对象 占用的资源，例如:打开的文件资源、网络连接等。</p>
<p>Python 实现自动的垃圾回收，当对象没有被引用时(引用计数为 0)，由垃圾回收器 调用<strong>del</strong>方法。</p>
<p>我们也可以通过 del 语句删除对象，从而保证调用<strong>del</strong>方法。 系统会自动提供<strong>del</strong>方法，一般不需要自定义析构方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#析构函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span> </span><br><span class="line">  print(<span class="string">"销毁对象:&#123;0&#125;"</span>.format(self))</span><br><span class="line">p1 = Person() </span><br><span class="line">p2 = Person()</span><br><span class="line"><span class="keyword">del</span> p2</span><br><span class="line">print(<span class="string">"end"</span>)</span><br><span class="line">```</span><br><span class="line">运算结果:</span><br><span class="line">销毁对象:&lt;__main__.Person object at <span class="number">0x02175610</span>&gt; 程序结束</span><br><span class="line">销毁对象:&lt;__main__.Person object at <span class="number">0x021755D0</span>&gt;</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="call方法和可调用对象"><a href="#call方法和可调用对象" class="headerlink" title="call方法和可调用对象"></a><strong><strong>call</strong>方法和可调用对象</strong></h2><p>定义了<strong>call</strong>方法的对象，称为“可调用对象”，即该对象可以像函数一样被调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalaryAccount</span>:</span> <span class="string">'''工资计算类'''</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, salary)</span>:</span> </span><br><span class="line">    yearSalary = salary*<span class="number">12</span> </span><br><span class="line">    daySalary = salary//<span class="number">30</span></span><br><span class="line">		hourSalary = daySalary//<span class="number">8</span> </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">dict(monthSalary=salary,yearSalary=yearSalary,daySalary=daySalary ,hourSalary=hourSalary)</span><br><span class="line">s = SalaryAccount()</span><br><span class="line">print(s(<span class="number">5000</span>)) <span class="comment">#可以像调用函数一样调用对象的__call__方法</span></span><br><span class="line"><span class="comment">#&#123;'monthSalary': 5000, 'yearSalary': 60000, 'daySalary': 166, 'hourSalary': 20&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="方法没有重载"><a href="#方法没有重载" class="headerlink" title="方法没有重载"></a><strong>方法没有重载</strong></h2><p>在其他语言中，可以定义多个重名的方法，只要保证方法签名唯一即可。方法签名包含 3 个部分:方法名、参数数量、参数类型。</p>
<p>Python 中，方法的的参数没有声明类型(调用时确定参数的类型)，参数的数量也可以由 可变参数控制。因此，Python 中是没有方法的重载的。定义一个方法即可有多种调用方式， 相当于实现了其他语言中的方法的重载。</p>
<h3 id="如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。-建议-不要使用重名的方法-Python-中方法没有重载。"><a href="#如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。-建议-不要使用重名的方法-Python-中方法没有重载。" class="headerlink" title="如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。 建议:不要使用重名的方法!Python 中方法没有重载。"></a>如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。 建议:不要使用重名的方法!Python 中方法没有重载。</h3><h2 id="方法的动态性"><a href="#方法的动态性" class="headerlink" title="方法的动态性"></a><strong>方法的动态性</strong></h2><p>Python 是动态语言，我们可以动态的为类添加新的方法，或者动态的修改类的已有的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"努力上班!"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_game</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;0&#125;玩游戏"</span>.format(self))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work2</span><span class="params">(s)</span>:</span></span><br><span class="line">    print(<span class="string">"好好工作，努力上班!"</span>)</span><br><span class="line">Person.play = play_game</span><br><span class="line">Person.work = work2 </span><br><span class="line">p = Person()</span><br><span class="line">p.play()</span><br><span class="line">p.work()</span><br><span class="line">```</span><br><span class="line">&lt;__main__.Person object at <span class="number">0x7fb0405fdee0</span>&gt;玩游戏</span><br><span class="line">好好工作，努力上班!</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>我们可以看到，Person 动态的新增了 play_game 方法，以及用 work2 替换了 work 方法。</p>
<h2 id="私有属性和私有方法-实现封装"><a href="#私有属性和私有方法-实现封装" class="headerlink" title="私有属性和私有方法(实现封装)"></a><strong>私有属性和私有方法(实现封装)</strong></h2><p>Python 对于类的成员没有严格的访问控制限制，这与其他面向对象语言有区别。关于私有 属性和私有方法，有如下要点:</p>
<ol>
<li><p>通常我们约定，两个下划线开头的属性是私有的(private)。其他为公共的(public)。 </p>
</li>
<li><p>类内部可以访问私有属性(方法)</p>
</li>
<li><p>类外部不能直接访问私有属性(方法)</p>
</li>
<li><p>类外部可以通过“_类名__私有属性(方法)名”访问私有属性(方法)</p>
</li>
</ol>
<p>【注】方法本质上也是属性!只不过是可以通过()执行而已。所以，此处讲的私有属性和公有属性，也同时讲解了私有方法和公有方法的用法。如下测试中，同时也包含了私有方法和 公有方法的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试私有属性、私有方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">	__company = <span class="string">"google"</span> <span class="comment">#私有类属性. 通过 dir 可以查到_Employee__company</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.__age = age <span class="comment">#私有实例属性</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">say_company</span><span class="params">(self)</span>:</span> </span><br><span class="line">    print(<span class="string">"我的公司是:"</span>,Employee.__company) <span class="comment">#类内部可以直接访问私有属性</span></span><br><span class="line">		print(self.name,<span class="string">"的年龄是:"</span>,self.__age) </span><br><span class="line">    self.__work()</span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">__work</span><span class="params">(self)</span>:</span> <span class="comment">#私有实例方法 通过 dir 可以查到 _Employee__work</span></span><br><span class="line">		print(<span class="string">"工作!好好工作，好好赚钱，娶个媳妇!"</span>)</span><br><span class="line">p1 = Employee(<span class="string">"高淇"</span>,<span class="number">32</span>)</span><br><span class="line">print(p1.name)</span><br><span class="line">print(dir(p1)) <span class="comment"># </span></span><br><span class="line">p1.say_company()</span><br><span class="line">print(p1._Employee__age) <span class="comment">#通过这种方式可以直接访问到私有属性 。通过 dir 可以查到属性:_Employee__age </span></span><br><span class="line"><span class="comment">#print(p1.__age) #直接访问私有属性，报错</span></span><br><span class="line"> <span class="comment">#p1.__sleep() #直接访问私有方法，报错</span></span><br><span class="line">  ```</span><br><span class="line">  执行结果:</span><br><span class="line">高淇</span><br><span class="line">[<span class="string">'_Person__age'</span>, <span class="string">'_Person__leg_num'</span>, <span class="string">'_Person__sleep'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'name'</span>, <span class="string">'say_age'</span>]</span><br><span class="line">腿的数目: <span class="number">2</span></span><br><span class="line">高淇 的年龄是: <span class="number">18</span></span><br><span class="line">睡觉</span><br><span class="line"><span class="number">18</span></span><br><span class="line">从打印的 Person 对象所有属性我们可以看出。私有属性“__age”在实际存储时是按照 “_Person__age”这个属性来存储的。这也就是为什么我们不能直接使用“__age”而可以 使用“_Person__age”的根本原因。</span><br><span class="line">  ```</span><br></pre></td></tr></table></figure>

<h2 id="property-装饰器"><a href="#property-装饰器" class="headerlink" title="@property 装饰器"></a><strong>@property 装饰器</strong></h2><p>@property 可以将一个方法的调用方式变成“属性调用”</p>
<p>@property 主要用于帮助我们处理属性的读操作、写操作。对于某一个属性，我们可以直 接通过:</p>
<p>emp1.salary = 30000 如上的操作读操作、写操作。但是，这种做法不安全。比如，我需要限制薪水必须为 1-10000 的数字。这时候，我们就需要通过 getter、setter 方法来处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,salary)</span>:</span> </span><br><span class="line">    self.name = name</span><br><span class="line"> 		self.__salary = salary</span><br><span class="line"><span class="meta">	@property #相当于 salary 属性的 getter 方法</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">salary</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"月薪为&#123;0&#125;,年薪为 &#123;1&#125;"</span>.format(self.__salary,(<span class="number">12</span>*self.__salary)))</span><br><span class="line"> 		<span class="keyword">return</span> self.__salary;</span><br><span class="line"><span class="meta"> 	@salary.setter</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">salary</span><span class="params">(self,salary)</span>:</span> <span class="comment">#相当于 salary 属性的 setter 方法</span></span><br><span class="line"> 		<span class="keyword">if</span>(<span class="number">0</span>&lt;salary&lt;<span class="number">1000000</span>): </span><br><span class="line">      self.__salary = salary</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line"> 			print(<span class="string">"薪水录入错误!只能在 0-1000000 之间"</span>)</span><br><span class="line">emp1 = Employee(<span class="string">"高淇"</span>,<span class="number">100</span>) </span><br><span class="line">print(emp1.salary)</span><br><span class="line">emp1.salary = <span class="number">-200</span></span><br></pre></td></tr></table></figure>

<p>运行结果:<br> 月薪为 100,年薪为 1200</p>
<p>100<br> 月薪为 100,年薪为 1200<br> 100<br> 薪水录入错误!只能在 0-1000000 之间</p>
<h2 id="属性和方法命名总结"><a href="#属性和方法命名总结" class="headerlink" title="属性和方法命名总结"></a><strong>属性和方法命名总结</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">· _xxx:保护成员，不能用“from module import * ”导入，只有类对象和子类对象能访 问这些成员。(类似java 的proetected)</span><br><span class="line"> · __xxx__:系统定义的特殊成员</span><br><span class="line"> · __xxx: 类中的私有成员，只有类对象自己能访问，子类对象也不能访问。(但，在类外 部可以通过“对象名. _类名__xxx”这种特殊方式访问。Python 不存在严格意义的私有成员)（类似java的private）</span><br></pre></td></tr></table></figure>

<p>注:再次强调，方法和属性都遵循上面的规则。</p>
<p>私有属性是无法被继承的。由此可知，在 Python 中私有属性为假私有属性。那为什么不从语法上保证 private 字段的私密性呢？用最简单的一句话来说：We are all consenting adults here。正如Python 程序员的观点：开放要比封闭好。</p>
<p>综上所述：</p>
<p>Python 编译器无法严格保证 private 字段的私密性。</p>
<p>只有当子类不受自己控制的时候，才可以考虑使用 private 属性来避免名称冲突。所以python还是不如java啊。</p>
<h2 id="类编码风格"><a href="#类编码风格" class="headerlink" title="类编码风格"></a><strong>类编码风格</strong></h2><p>\1. 类名首字母大写，多个单词之间采用驼峰原则。<br> \2. 实例名、模块名采用小写，多个单词之间采用下划线隔开。<br> \3. 每个类，应紧跟“文档字符串”，说明这个类的作用。<br> \4. 可以用空行组织代码，但不能滥用。在类中，使用一个空行隔开方法;模块中，使用两 个空行隔开多个类。</p>
<h1 id="面向对象进阶"><a href="#面向对象进阶" class="headerlink" title="面向对象进阶"></a>面向对象进阶</h1><p><strong>面向对象三大特征介绍</strong></p>
<p>Python 是面向对象的语言，也支持面向对象编程的三大特性:继承、封装(隐藏)、多态。</p>
<p><strong>·封装(隐藏)</strong></p>
<p>隐藏对象的属性和实现细节，只对外提供必要的方法。相当于将“细节封装起来”，只 对外暴露“相关调用方法”。</p>
<p>通过前面学习的“私有属性、私有方法”的方式，实现“封装”。Python 追求简洁的 语法，没有严格的语法级别的“访问控制符”，更多的是依靠程序员自觉实现。</p>
<p><strong>·继承</strong></p>
<p>继承可以让子类具有父类的特性，提高了代码的重用性。</p>
<p>从设计上是一种增量进化，原有父类设计不变的情况下，可以增加新的功能，或者改进 已有的算法。</p>
<p><strong>·多态</strong></p>
<p>多态是指同一个方法调用由于对象不同会产生不同的行为。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h2><p>继承是面向对象程序设计的重要特征，也是实现“代码复用”的重要手段。</p>
<p>如果一个新类继承自一个设计好的类，就直接具备了已有类的特征，就大大降低了工作 难度。已有的类，我们称为“父类或者基类”，新的类，我们称为“子类或者派生类”。</p>
<h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a><strong>语法格式</strong></h3><p>Python 支持多重继承，一个子类可以继承多个父类。继承的语法格式如下: </p>
<p>class 子类类名(父类 1[，父类 2，…]):</p>
<p>​    类体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果在类定义中没有指定父类，则默认父类是 object 类。也就是说，object 是所有类的父 类，里面定义了一些所有类共有的默认实现，比如:__new__()。</span><br><span class="line"></span><br><span class="line">定义子类时，必须在其构造函数中调用父类的构造函数。调用格式如下: 父类名.__init__(self, 参数列表)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,score)</span>:</span></span><br><span class="line"> 		self.score = score</span><br><span class="line">		Person.__init__(self,name,age) <span class="comment">#构造函数中包含调用父类构造函数。根据需要，不是必须。 子类并不会自动调用父类的__init__()，我们必须显式的调用它</span></span><br></pre></td></tr></table></figure>

<h3 id="类成员的继承和重写"><a href="#类成员的继承和重写" class="headerlink" title="类成员的继承和重写"></a><strong>类成员的继承和重写</strong></h3><p>\1. 成员继承:子类继承了父类除构造方法之外的所有成员。<br> \2. 方法重写:子类可以重新定义父类中的方法，这样就会覆盖父类的方法，也称为“重写”</p>
<h3 id="查看类的继承层次结构"><a href="#查看类的继承层次结构" class="headerlink" title="查看类的继承层次结构"></a><strong>查看类的继承层次结构</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过类的方法 mro()或者类的属性__mro__可以输出这个类的继承层次结构。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">pass</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span><span class="keyword">pass</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B)</span>:</span><span class="keyword">pass</span></span><br><span class="line">print(C.mro())</span><br><span class="line"><span class="comment">#[&lt;class '__main__.C'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]</span></span><br><span class="line"><span class="comment">#c继承B，继承A，继承object</span></span><br></pre></td></tr></table></figure>

<h3 id="object-根类"><a href="#object-根类" class="headerlink" title="object 根类"></a><strong>object 根类</strong></h3><p>object 类是所有类的父类，因此所有的类都有 object 类的属性和方法。我们显然有必要深 入研究一下 object 类的结构。对于我们继续深入学习 Python 很有好处。</p>
<p><strong>dir()查看对象属性</strong></p>
<p>为了深入学习对象，我们先学习内置函数 dir()，他可以让我们方便的看到指定对象所有的 属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span> </span><br><span class="line">    self.name = name</span><br><span class="line"> 		self.age = age</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say_age</span><span class="params">(self)</span>:</span> </span><br><span class="line">    print(self.name,<span class="string">"的年龄是:"</span>,self.age)</span><br><span class="line">obj = object() </span><br><span class="line">print(dir(obj))</span><br><span class="line">s2 = Person(<span class="string">"高淇"</span>,<span class="number">18</span>)</span><br><span class="line">print(dir(s2))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;]</span><br><span class="line">[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;age&#39;, &#39;name&#39;, &#39;say_age&#39;]</span><br></pre></td></tr></table></figure>

<p>从上面我们可以发现这样几个要点: </p>
<ol>
<li>Person 对象增加了六个属性:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__dict__ __module__ __weakref__ age name say_age</span><br></pre></td></tr></table></figure>

<p>\2. object 的所有属性，Person 类作为 object 的子类，显然包含了所有的属性。<br> \3. 我们打印 age、name、say_age，发现 say_age 虽然是方法，实际上也是属性。只不过， 这个属性的类型是“method”而已。</p>
<p>age &lt;class ‘int’&gt;<br> name &lt;class ‘str’&gt;</p>
<p>say_age &lt;class ‘method’&gt;</p>
<h2 id="重写str-方法"><a href="#重写str-方法" class="headerlink" title="重写str()方法"></a><strong>重写<strong>str</strong>()方法</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">object 有一个__str__()方法，用于返回一个对于“对象的描述”，对应于内置函数 str() 经常用于 print()方法，帮助我们查看对象的信息。__str__()可以重写。</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"> <span class="string">'''将对象转化成一个字符串，一般用于 print 方法'''</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"名字是:&#123;0&#125;,年龄是&#123;1&#125;"</span>.format(self.name,self.__age)</span><br></pre></td></tr></table></figure>

<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a><strong>多重继承</strong></h2><p>Python 支持多重继承，一个子类可以有多个“直接父类”。这样，就具备了“多个父 类”的特点。但是由于，这样会被“类的整体层次”搞的异常复杂，尽量避免使用。<strong>class</strong> C(B,A):</p>
<h2 id="MRO"><a href="#MRO" class="headerlink" title="MRO()"></a><strong>MRO()</strong></h2><p>Python 支持多继承，如果父类中有相同名字的方法，在子类没有指定父类名时，解释器将 “从左向右”按顺序搜索。<br> MRO(Method Resolution Order):方法解析顺序。 我们可以通过 mro()方法获得 “类的层次结构”，方法解析顺序也是按照这个“类的层次结构”寻找的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">aa</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"aa"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span> </span><br><span class="line">    print(<span class="string">"say AAA!"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">bb</span><span class="params">(self)</span>:</span></span><br><span class="line">			print(<span class="string">"bb"</span>)</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span> </span><br><span class="line">      print(<span class="string">"say BBB!"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B,A)</span>:</span> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cc</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"cc"</span>)</span><br><span class="line">c = C()</span><br><span class="line">print(C.mro()) <span class="comment">#打印类的层次结构</span></span><br><span class="line">c.say() <span class="comment">#解释器寻找方法是“从左到右”的方式寻找，此时会执行 B 类中的 say()</span></span><br></pre></td></tr></table></figure>

<p>[&lt;class ‘<strong>main</strong>.C’&gt;, &lt;class ‘<strong>main</strong>.B’&gt;, &lt;class ‘<strong>main</strong>.A’&gt;, &lt;class ‘object’&gt;]<br>say BBB!</p>
<h2 id="super-获得父类定义"><a href="#super-获得父类定义" class="headerlink" title="super()获得父类定义"></a><strong>super()获得父类定义</strong></h2><p>在子类中，如果想要获得父类的方法时，我们可以通过 super()来做。super()代表父类的定义，不是父类对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def say(self):</span><br><span class="line"> #A.say(self) 调用父类的 say 方法 </span><br><span class="line"> super().say() #通过 super()调用父类的方法</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h2><p>多态(polymorphism)是指同一个方法调用由于对象不同可能会产生不同的行为。在现实 生活中，我们有很多例子。比如:同样是调用人的休息方法，张三的休息是睡觉，李四的休 息是玩游戏，高淇老师是敲代码。同样是吃饭的方法，中国人用筷子吃饭，英国人用刀叉吃 饭，印度人用手吃饭。</p>
<p>关于多态要注意以下 2 点:<br> \1. 多态是方法的多态，属性没有多态。<br> \2. 多态的存在有 2 个必要条件:继承、方法重写。</p>
<h2 id="特殊方法和运算符重载"><a href="#特殊方法和运算符重载" class="headerlink" title="特殊方法和运算符重载"></a><strong>特殊方法和运算符重载</strong></h2><p>Python 的运算符实际上是通过调用对象的特殊方法实现的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">20</span> </span><br><span class="line">b = <span class="number">30</span></span><br><span class="line">c = a+b</span><br><span class="line">d = a.__add__(b) </span><br><span class="line">print(<span class="string">"c="</span>,c)</span><br><span class="line">print(<span class="string">"d="</span>,d)</span><br><span class="line"><span class="comment">#运算结果: c= 50</span></span><br><span class="line">d= <span class="number">50</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常见的特殊方法统计如下:</span><br><span class="line"></span><br><span class="line">__init__  构造方法      对象创建:p &#x3D; Person()</span><br><span class="line">__del__  析构方法 对象回收</span><br><span class="line">__repr__,__str__  打印，转换     rint(a)</span><br><span class="line">__call__ 函数调用 a()</span><br><span class="line">__getattr__ 点号运算 a.xxx</span><br><span class="line">__setattr__ 属性赋值 a.xxx &#x3D; value</span><br><span class="line">__getitem__ 索引运算 a[key]</span><br><span class="line">__setitem__ 索引赋值 a[key]&#x3D;value</span><br><span class="line">__len__ 长度 len(a)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运算符+ __add__ 加法</span><br><span class="line">运算符- __sub__ 减法</span><br><span class="line">&lt;,&lt;&#x3D;,&#x3D;&#x3D;  __lt__,__le__，__eq__ 比较运算符</span><br><span class="line">&gt;,&gt;&#x3D;,!&#x3D; __gt__,__ge__,__ne__ 比较运算符</span><br><span class="line">|,^,&amp; __or__,__xor__,__and__  或、异或、与</span><br><span class="line">&lt;&lt;,&gt;&gt; __lshift__,__rshift__ 左移、右移</span><br><span class="line">*,&#x2F;,%,&#x2F;&#x2F; __mul__,__truediv__,__mod__,_ _floordiv__ 乘、浮点除、模运算 (取余)、整数除</span><br><span class="line">** __pow__ 指数运算</span><br></pre></td></tr></table></figure>

<p>我们可以重写上面的特殊方法，即实现了“运算符的重载”。</p>
<h2 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a><strong>特殊属性</strong></h2><p>Python 对象中包含了很多双下划线开始和结束的属性，这些是特殊属性，有特殊用法。这 里我们列出常见的特殊属性:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj.__dict__对象的属性字典</span><br><span class="line">obj.__class__对象所属的类</span><br><span class="line">class.__bases__类的基类元组(多继承)</span><br><span class="line">class.__base__类的基类</span><br><span class="line">class.__mro__类层次结构</span><br><span class="line">class.__subclasses__()子类列表</span><br><span class="line">print(dir(c)) </span><br><span class="line">print(c.__dict__) </span><br><span class="line">print(c.__class__) </span><br><span class="line">print(C.__bases__) </span><br><span class="line">print(C.mro()) </span><br><span class="line">print(A.__subclasses__())</span><br></pre></td></tr></table></figure>

<p><strong>对象的浅拷贝和深拷贝</strong></p>
<p><strong>·变量的赋值操作</strong></p>
<p>只是形成两个变量，实际还是指向同一个对象。</p>
<p><strong>·浅拷贝</strong></p>
<p>Python 拷贝一般都是浅拷贝。拷贝时，对象包含的子对象内容不拷贝。因此，源对象 和拷贝对象会引用同一个子对象。<br> <strong>·深拷贝</strong></p>
<p>使用 copy 模块的 deepcopy 函数，递归拷贝对象中包含的子对象。源对象和拷贝对象 所有的子对象也不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line">m2 &#x3D; copy.copy(m) #m2 是新拷贝的另一个手机对象</span><br><span class="line">m3 &#x3D; copy.deepcopy(m)</span><br></pre></td></tr></table></figure>

<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a><strong>组合</strong></h2><p>“is-a”关系，我们可以使用“继承”。从而实现子类拥有的父类的方法和属性。“is-a” 关系指的是类似这样的关系:狗是动物，dog is animal。狗类就应该继承动物类。</p>
<p>“has-a”关系，我们可以使用“组合”，也能实现一个类拥有另一个类的方法和属性。” has-a”关系指的是这样的关系:手机拥有 CPU。 MobilePhone has a CPU。self.cpu=cpu</p>
<h2 id="设计模式-工厂模式实现"><a href="#设计模式-工厂模式实现" class="headerlink" title="设计模式_工厂模式实现"></a><strong>设计模式_工厂模式实现</strong></h2><p>设计模式是面向对象语言特有的内容，是我们在面临某一类问题时候固定的做法，设计 模式有很多种，比较流行的是:GOF(Goup Of Four)23 种设计模式。当然，我们没有 必要全部学习，学习几个常用的即可。</p>
<p>对于初学者，我们学习两个最常用的模式:工厂模式和单例模式。</p>
<p>工厂模式实现了创建者和调用者的分离，使用专门的工厂类将选择实现类、创建对象进 行统一的管理和控制。</p>
<h2 id="设计模式-单例模式实现"><a href="#设计模式-单例模式实现" class="headerlink" title="设计模式_单例模式实现"></a><strong>设计模式_单例模式实现</strong></h2><p>单例模式(Singleton Pattern)的核心作用是确保一个类只有一个实例，并且提供一 个访问该实例的全局访问点。</p>
<p>单例模式只生成一个实例对象，减少了对系统资源的开销。当一个对象的产生需要比较 多的资源，如读取配置文件、产生其他依赖对象时，可以产生一个“单例对象”，然后永久 驻留内存中，从而极大的降低开销。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单例模式有多种实现的方式，我们这里推荐重写__new__()的方法。</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>python400集8</title>
    <url>/2020/05/03/python400%E9%9B%868/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>python400集9</title>
    <url>/2020/05/03/python400%E9%9B%869/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>ssh，scp详解</title>
    <url>/2020/04/29/ssh%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用"><a href="#教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用" class="headerlink" title="教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用"></a>教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用</h1><p>如何获取本地ip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig | grep inet</span><br><span class="line">#如果没有ifconfig命令</span><br><span class="line">linux中</span><br><span class="line">sudo apt install net-tools</span><br></pre></td></tr></table></figure>



<h2 id="教你玩转ssh"><a href="#教你玩转ssh" class="headerlink" title="教你玩转ssh"></a>教你玩转ssh</h2><p>ssh， secure shell，远程登录服务器，机器的一种命令。</p>
<p>此教程仅适合mac，unix，linux系统，windows系统请使用PuTTy 等软件进行操作。</p>
<h3 id="1-先在本机生成rsa密钥对"><a href="#1-先在本机生成rsa密钥对" class="headerlink" title="1.先在本机生成rsa密钥对"></a>1.先在本机生成rsa密钥对</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<h3 id="2-然后一路enter，不要设置密码"><a href="#2-然后一路enter，不要设置密码" class="headerlink" title="2.然后一路enter，不要设置密码"></a>2.然后一路enter，不要设置密码</h3><p>本机 .ssh 隐藏目录中会多几个文件，</p>
<p>authorized-keys    config        id_rsa        id_rsa.pub    known_hosts</p>
<p>其中id_rsa.pub是你的公钥，id_rsa是私钥。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi config</span><br><span class="line">#点i进入insert模式,按照各人信息填入，school是你想要的快捷名，以后无需输入ip和用户名了，ip是远程服务器ip</span><br><span class="line">Host school</span><br><span class="line">	HostName ip address</span><br><span class="line">	User username</span><br><span class="line">	Port portnumber</span><br></pre></td></tr></table></figure>

<h3 id="3-然后开始免密操作，很简单，mac需要homebrew"><a href="#3-然后开始免密操作，很简单，mac需要homebrew" class="headerlink" title="3.然后开始免密操作，很简单，mac需要homebrew"></a>3.然后开始免密操作，很简单，mac需要homebrew</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install ssh-copy-id</span><br></pre></td></tr></table></figure>

<p>然后，主要此处school是你的快捷名字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id school</span><br></pre></td></tr></table></figure>

<p>这是最简单的操作，或者手动把你的公钥复制到远程服务器~/.ssh/authorized_keys中。</p>
<h2 id="教你玩会scp"><a href="#教你玩会scp" class="headerlink" title="教你玩会scp"></a>教你玩会scp</h2><p>ssh就这么简单，既然如此简单，我们顺便提一下scp。</p>
<p>scp就是安全传输文件的命令，</p>
<p>scp没有那么多小技巧，唯一就是要注意路径怎么写，要用绝对路径，最好不要相对路径。</p>
<p>还有就是目录需要加-r</p>
<p>. 表示当前目录</p>
<p>~表示家目录</p>
<p>/表示根目录</p>
<p>了解以上3个即可帮你灵活使用scp了，记住，unix类的操作系统都是树形管理文件的，而不是windows分区形（其实我也不了解）</p>
<p>下面我们开始了解scp命令</p>
<h3 id="1、从本地复制到远程"><a href="#1、从本地复制到远程" class="headerlink" title="1、从本地复制到远程"></a>1、从本地复制到远程</h3><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_username@remote_ip:remote_file </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_ip:remote_file</span><br></pre></td></tr></table></figure>



<ul>
<li>第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名； </li>
<li>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；</li>
</ul>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3 </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3</span><br></pre></td></tr></table></figure>

<p>复制目录命令格式： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp -r local_folder remote_ip:remote_folder</span><br></pre></td></tr></table></figure>

<ul>
<li>第1个指定了用户名，命令执行后需要再输入密码；</li>
<li>第2个没有指定用户名，命令执行后需要输入用户名和密码；</li>
</ul>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; </span><br><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;</span><br></pre></td></tr></table></figure>

<p>上面命令将本地 music 目录复制到远程 others 目录下。</p>
<h3 id="2、从远程复制到本地"><a href="#2、从远程复制到本地" class="headerlink" title="2、从远程复制到本地"></a>2、从远程复制到本地</h3><p>从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例 </p>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 </span><br><span class="line">scp -r www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; &#x2F;home&#x2F;space&#x2F;music&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>1.如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#scp 命令使用端口号 4588</span><br><span class="line">scp -P 4588 remote@www.runoob.com:&#x2F;usr&#x2F;local&#x2F;sin.sh &#x2F;home&#x2F;administrator</span><br></pre></td></tr></table></figure>

<p>2.使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。</p>
]]></content>
  </entry>
  <entry>
    <title>recommandtool</title>
    <url>/2020/04/18/recommandtool/</url>
    <content><![CDATA[<p>I want to recommand you some wonderful tools for Mac.</p>
<ol>
<li><p>VS code, it is an excellent editor for all programming, you are see, it has command line and easy to debug. I will have a future article takes about vs code more, and shortcut of it.</p>
</li>
<li><p>Keka is an uncompress or compress application, so amazing.</p>
</li>
<li><p>IINA is a multiple support player，you can play avi, mp4, etc. Almost everything, it has poweful function, like 16 times speed.</p>
</li>
<li><p>Intellij IDEA, a java idle, very powerful, i will have a eesay about shortcut and introduction for this in the future.</p>
</li>
<li><p>Dash, the best tools, it has almost all the api files of all programming language, so good to use it.</p>
</li>
<li><p>VM fusion, the virtual machine, it is so stable, although it have some bug in it, like offnetwork sometime, but when you face this, restart your laptop, it works for most time.</p>
<h2 id="Keep-update-in-the-future"><a href="#Keep-update-in-the-future" class="headerlink" title="Keep update in the future."></a>Keep update in the future.</h2></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>python400集6</title>
    <url>/2020/05/03/python400%E9%9B%866/</url>
    <content><![CDATA[<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>module：一个 .py 文件就是个 module</p>
<p>lib：抽象概念，和另外两个不zhidao是一类，只要你喜欢，什么都是 lib，就算只有个 hello world</p>
<p>package：就是个带 <strong>init</strong>.py 的文件夹，并不在乎里内面有什么，不过一般来讲会包含一些 packages/modules</p>
<p>scrapy、flask、Django、numpy、scipy、NLTK、jieba一般都被认为是 lib，因为关注点并不是代码是怎么组织容的。</p>
<ol>
<li>Python 程序由模块组成。一个模块对应 python 源文件，一般后缀名是:.py。</li>
<li>模块由语句组成。运行 Python 程序时，按照模块中语句的顺序依次执行。</li>
<li>语句是 Python 程序的构造单元，用于创建对象、变量赋值、调用函数、控制语句等。</li>
</ol>
<h2 id="1-python模块是："><a href="#1-python模块是：" class="headerlink" title="1.python模块是："></a>1.python模块是：</h2><p>python模块：包含并且有组织的代码片段为模块。</p>
<p>表现形式为：写的代码保存为文件。这个文件就是一个模块。sample.py 其中文件名smaple为模块名字。</p>
<p>关系图：</p>
<p><a href="https://iknow-pic.cdn.bcebos.com/1ad5ad6eddc451dad2c24565bffd5266d0163203" target="_blank" rel="noopener"><img src="https://iknow-pic.cdn.bcebos.com/1ad5ad6eddc451dad2c24565bffd5266d0163203?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" alt="img"></a></p>
<h2 id="2-python包是："><a href="#2-python包是：" class="headerlink" title="2.python包是："></a>2.python包是：</h2><p>包是一个有层次的文件目录结构，它定义了由n个模块或n个子包组成的python应用程序执行环境。通俗一点：包是一个包含<strong>init</strong>.py 文件的目录，该目录下一定得有这个<strong>init</strong>.py文件和其它e68a84e79fa5e9819331333365656638模块或子包。</p>
<p>常见问题：</p>
<p>引入某一特定路径下的模块</p>
<p>使用sys.path.append(yourmodulepath)</p>
<p>将一个路径加入到python系统路径下，避免每次通过代码指定路径</p>
<p>利用系统环境变量 export PYTHONPATH=$PYTHONPATH:yourmodulepath，</p>
<p>直接将这个路径链接到类似/Library/Python/2.7/site-packages目录下</p>
<p>好的建议：</p>
<p>经常使用if <strong>name</strong> == ‘<strong>main</strong>‘，保证写包既可以import又可以独立运行，用于test。</p>
<p>多次import不会多次执行模块，只会执行一次。可以使用reload来强制运行模块，但不提倡。</p>
<p>常见的包结构如下：</p>
<p>package_a├── <strong>init</strong>.py├── module_a1.py└── module_a2.pypackage_b├── <strong>init</strong>.py├── module_b1.py└── module_b2.py</p>
<p>main.py</p>
<p>如果main.py想要引用packagea中的模块modulea1，可以使用:</p>
<p>from package_a import module_a1</p>
<p>import package_a.module_a1</p>
<p>如果packagea中的modulea1需要引用packageb，那么默认情况下，python是找不到packageb。我们可以使用sys.path.append(‘../‘),可以在packagea中的<strong>init</strong>.py添加这句话，然后该包下得所有module都添加* import __init_即可。</p>
<p>关系图：</p>
<p><a href="https://iknow-pic.cdn.bcebos.com/1c950a7b02087bf4949b1e67fbd3572c10dfcfcd" target="_blank" rel="noopener"><img src="https://iknow-pic.cdn.bcebos.com/1c950a7b02087bf4949b1e67fbd3572c10dfcfcd?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" alt="img"></a></p>
<h2 id="3-库（library）"><a href="#3-库（library）" class="headerlink" title="3.库（library）"></a>3.库（library）</h2><p>库的概念是具有相关功能模块的集合。这也是Python的一大特色之一，即具有强大的标准库、第三方库以及自定义模块。</p>
<h2 id="1-2-标准库模块-standard-library"><a href="#1-2-标准库模块-standard-library" class="headerlink" title="1.2 标准库模块(standard library)"></a><strong>1.2 标准库模块(standard library)</strong></h2><p>与函数类似，模块也分为标准库模块和用户自定义模块。<br> Python 标准库提供了操作系统功能、网络通信、文本处理、文件处理、数学运算等基 本的功能。比如:random(随机数)、math(数学运算)、time(时间处理)、file(文件处理)、 os(和操作系统交互)、sys(和解释器交互)等。</p>
<p>另外，Python 还提供了海量的第三方模块，使用方式和标准库类似。功能覆盖了我们 能想象到的所有领域，比如:科学计算、WEB 开发、大数据、人工智能、图形系统等。</p>
<p>模块化编程有如下几个重要优势:<br> \1. 便于将一个任务分解成多个模块，实现团队协同开发，完成大规模程序 2. 实现代码复用。一个模块实现后，可以被反复调用。<br> \3. 可维护性增强。</p>
<p><strong>1.4 模块化编程的流程</strong></p>
<p>模块化编程的一般流程:<br> \1. 设计 API，进行功能描述</p>
<p>\2. 编码实现 API 中描述的功能。<br> \3. 在模块中编写测试代码，并消除全局代码。<br> \4. 使用私有函数实现不被外部客户端调用的模块函数。</p>
<p>API(Application Programming Interface 应用程序编程接口)是用于描述模 块中提供的函数和类的功能描述和使用方式描述。</p>
<p>模块化编程中，首先设计的就是模块的 API(即要实现的功能描述)，然后开始编 码实现 API 中描述的功能。最后，在其他模块中导入本模块进行调用。</p>
<p>我们可以通过help(模块名)查看模块的API。一般使用时先导入模块 然后通过help函数查看</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">help(math)</span><br></pre></td></tr></table></figure>

<p>设计计算薪水模块的 API</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">本模块用于计算公司员工的薪资</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">company &#x3D; &quot;北京尚学堂&quot;</span><br><span class="line"></span><br><span class="line">def yearSalary(monthSalary):</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;根据传入的月薪，计算出年薪&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">  pass</span><br><span class="line"></span><br><span class="line">def daySalary(monthSalary): </span><br><span class="line">&quot;&quot;&quot;根据传入的月薪，计算出每天的薪资&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>

<p>如上模块只有功能描述和规范，需要编码人员按照要求实现编码。 我们可以通过<strong>doc</strong>可以获得模块的文档字符串的内容。</p>
<p>test.py 的源代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import salary</span><br><span class="line"></span><br><span class="line">print(salary.__doc__)</span><br><span class="line"></span><br><span class="line">print(salary.yearSalary.__doc__)</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p>本模块用于计算公司员工的薪资 </p>
<p>根据传入的月薪，计算出年薪</p>
<p><strong>模块的创建和测试代码</strong></p>
<p>每个模块都有一个名称，通过特殊变量<strong>name</strong>可以获取模块的名称。在正常情况下，模块名字对应源文件名。 仅有一个例外，就是当一个模块被作为程序入口时(主 程序、交互式提示符下)，它的<strong>name</strong>的值为“<strong>main</strong>”。我们可以根据这个特 点，将模块源代码文件中的测试代码进行独立的处理。例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> import math</span><br><span class="line"></span><br><span class="line">math.__name__ #输出&#39;math&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">company = <span class="string">"北京尚学堂"</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">yearSalary</span><span class="params">(monthSalary)</span>:</span> </span><br><span class="line"> <span class="string">"""根据传入的月薪，计算出年薪"""</span></span><br><span class="line">		<span class="keyword">return</span> monthSalary*<span class="number">12</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">daySalary</span><span class="params">(monthSalary)</span>:</span></span><br><span class="line"><span class="string">"""根据传入的月薪，计算出每天的薪资"""</span></span><br><span class="line">	<span class="keyword">return</span> monthSalary/<span class="number">22.5</span> <span class="comment">#国家规定每个月的平均工作日是 22.5</span></span><br><span class="line"> <span class="keyword">if</span> __name__ ==<span class="string">"__main__"</span>: <span class="comment">#测试代码</span></span><br><span class="line">		print(yearSalary(<span class="number">3000</span>))</span><br><span class="line">		print(daySalary(<span class="number">3000</span>))</span><br></pre></td></tr></table></figure>

<p><strong>1.7 模块文档字符串和 API 设计</strong></p>
<p>我们可以在模块的第一行增加一个文档字符串，用于描述模块的相关功能。然后，通过 <strong>doc</strong>可以获得文档字符串的内容。</p>
<h2 id="2-模块的导入"><a href="#2-模块的导入" class="headerlink" title="2. 模块的导入"></a><strong>2. 模块的导入</strong></h2><p>模块化设计的好处之一就是“代码复用性高”。写好的模块可以被反复调用，重复使用。 模块的导入就是“在本模块中使用其他模块”。</p>
<p><strong>2.1 import 语句导入</strong></p>
<p>import 语句的基本语法格式如下: import 模块名</p>
<p>import 模块 1，模块 2… import 模块名 as 模块别名</p>
<p>#导入一个模块 #导入多个模块</p>
<p>#导入模块并使用新名字</p>
<p>import 加载的模块分为四个通用类别:<br> a.使用 python 编写的代码(.py 文件); b.已被编译为共享库或 DLL 的 C 或 C++扩展; c.包好一组模块的包<br> d.使用 C 编写并链接到 python 解释器的内置模块;</p>
<p>我们一般通过 import 语句实现模块的导入和使用，import 本质上是使用了内置函数 <strong>import</strong>()。</p>
<p>当我们通过 import 导入一个模块时，python 解释器进行执行，最终会生成一个对象， 这个对象就代表了被加载的模块。</p>
<p>我们可以看到 math 模块被加载后，实际会生成一个 module 类的对象，该对象被 math 变量引用。我们可以通过 math 变量引用模块中所有的内容。</p>
<p>我们通过 import 导入多个模块，本质上也是生成多个 module 类的对象而已。</p>
<p>有时候，我们也需要给模块起个别名，本质上，这个别名仅仅是新创建一个变量引用加 载的模块对象而已。</p>
<p><strong>2.2 from…import 导入</strong></p>
<p>Python 中可以使用 from…import 导入模块中的成员。基本语法格式如下: from 模块名 import 成员 1，成员 2，…</p>
<p>如果希望导入一个模块中的所有成员，则可以采用如下方式: from 模块名 import *</p>
<p>【注】尽量避免“from 模块名 import <em>”这种写法。</em> 它表示导入模块中所有的不 是以下划线(_)开头的名字都导入到当前位置。 但你不知道你导入什么名字，很有可能 会覆盖掉你之前已经定义的名字。而且可读性极其的差。一般生产环境中尽量避免使用， 学习时没有关系。</p>
<h2 id="2-3-import-语句和-from…import-语句的区别"><a href="#2-3-import-语句和-from…import-语句的区别" class="headerlink" title="2.3 import 语句和 from…import 语句的区别"></a><strong>2.3 import 语句和 from…import 语句的区别</strong></h2><p>import 导入的是模块。from…import 导入的是模块中的一个函数/一个类。</p>
<p>如果进行类比的话，import 导入的是“文件”，我们要使用该“文件”下的内容，必 须前面加“文件名称”。from…import 导入的是文件下的“内容”，我们直接使用这 些“内容”即可，前面再也不需要加“文件名称”了。</p>
<p><strong>2.4 <strong>import</strong>()动态导入</strong></p>
<p>import 语句本质上就是调用内置函数<strong>import</strong>()，我们可以通过它实现动态导入。给 <strong>import</strong>()动态传递不同的的参数值，就能导入不同的模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;math&quot;</span><br><span class="line">m &#x3D; __import__(s) #导入后生成的模块对象的引用给变量 m</span><br><span class="line">print(m.pi)</span><br></pre></td></tr></table></figure>

<p>注意:一般不建议我们自行使用<strong>import</strong>()导入，其行为在 python2 和 python3 中 有差异，会导致意外错误。如果需要动态导入可以使用 importlib 模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import importlib</span><br><span class="line">a &#x3D; importlib.import_module(&quot;math&quot;)</span><br><span class="line">print(a.pi)</span><br></pre></td></tr></table></figure>

<p><strong>2.5 模块的加载问题</strong></p>
<p>当导入一个模块时， 模块中的代码都会被执行。不过，如果再次导入这个模块， 则不会再次执行。</p>
<p>Python 的设计者为什么这么设计?因为，导入模块更多的时候需要的是定义模块 中的变量、函数、对象等。这些并不需要反复定义和执行。“只导入一次 import-only-once”就成了一种优化。</p>
<p>一个模块无论导入多少次，这个模块在整个解释器进程内有且仅有一个实例对象。</p>
<p><strong>重新加载 有时候我们确实需要重新加载一个模块，这时候可以使用:**</strong>importlib.reload()**</p>
<p><strong>方法:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import test02</span><br><span class="line">import test02</span><br><span class="line">print(&quot;####&quot;)</span><br><span class="line">import importlib </span><br><span class="line">importlib.reload(test02)</span><br></pre></td></tr></table></figure>

<h2 id="3-包-package-的使用"><a href="#3-包-package-的使用" class="headerlink" title="3. 包 package 的使用"></a><strong>3. 包 package 的使用</strong></h2><p><strong>3.1 包(package)的概念和结构</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当一个项目中有很多个模块时，需要再进行组织。我们将功能类似的模块放到一起， 形成了“包”。本质上，“包”就是一个必须有__init__.py 的文件夹。典型结构如下:</span><br></pre></td></tr></table></figure>

<p>包下面可以包含“模块(module)”，也可以再包含“子包(subpackage)”。就像文件 夹下面可以有文件，也可以有子文件夹一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">，a 是上层的包，下面有一个子包:aa。可以看到每个包里面都有__init__.py 文件。</span><br></pre></td></tr></table></figure>

<p><strong>3.2 pycharm 中创建包</strong></p>
<p>在 pycharm 开发环境中创建包，非常简单。在要创建包的地方单击右键:New–&gt;Python package 即可。pycharm 会自动帮助我们生成带有<strong>init</strong>.py 文件的包。</p>
<p><strong>3.3 导入包操作和本质</strong></p>
<p>上一节中的包结构，我们需要导入 module_AA.py。方式如下:</p>
<ol>
<li><p>import a.aa.module_AA</p>
<p>在使用时，必须加完整名称来引用，比如:a.aa.module_AA.fun_AA()</p>
</li>
<li><p>from a.aa import module_AA</p>
<p>在使用时，直接可以使用模块名。 比如:module_AA.fun_AA()</p>
</li>
<li><p>from a.aa.module_AA import fun_AA 直接导入函数</p>
<p>在使用时，直接可以使用函数名。 比如:fun_AA()</p>
<p>【注】<br> \1. from package import item 这种语法中，item 可以是包、模块，也可以是函数、</p>
<p>类、变量。<br> \2. import item1.item2 这种语法中，item 必须是包或模块，不能是其他。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">导入包的本质其实是“导入了包的__init__.py”文件。也就是说，”import pack1”意味 着执行了包 pack1 下面的__init__.py 文件。 这样，可以在__init__.py 中批量导入我们需要 的模块，而不再需要一个个导入。</span><br><span class="line"></span><br><span class="line">__init__.py 的三个核心作用:</span><br><span class="line">1. 作为包的标识，不能删除。</span><br><span class="line">2. 用来实现模糊导入</span><br><span class="line">3. 导入包实质是执行__init__.py 文件，可以在__init__.py 文件中做这个包的初始化、以及 需要统一执行代码、批量导入。</span><br></pre></td></tr></table></figure>

<h4 id="可以说“包的本质还是模块”。"><a href="#可以说“包的本质还是模块”。" class="headerlink" title="可以说“包的本质还是模块”。"></a>可以说“包的本质还是模块”。</h4><p><strong>3.4 用*导入包</strong></p>
<p>import * 这样的语句理论上是希望文件系统找出包中所有的子模块，然后导入它们。 这可能会花长时间等。Python 解决方案是提供一个明确的包索引。</p>
<p>这个索引由 <strong>init</strong>.py 定义 <strong>all</strong> 变量，该变量为一列表，如上例 a 包下的 <strong>init</strong>.py 中，可定义 <strong>all</strong> = [“module_A”,”module_A2”]</p>
<p>这意味着， from sound.effects import * 会从对应的包中导入以上两个子模块;</p>
<p>【注】尽管提供 import * 的方法，仍不建议在生产代码中使用这种写法。</p>
<p><strong>3.5 包内引用</strong></p>
<p>如果是子包内的引用，可以按相对位置引入子模块 以 aa 包下的 module_AA 中导入 a 包下内容为例:</p>
<p>from .. import module_A #..表示上级目录 .表示同级目录 </p>
<p>from . import module_A2 #.表示同级目录</p>
<p><strong>3.6 sys.path 和模块搜索路径</strong></p>
<p>当我们导入某个模块文件时， Python 解释器去哪里找这个文件呢?只有找到这个文 件才能读取、装载运行该模块文件。它一般按照如下路径寻找模块文件(按照顺序寻找，找 到即停不继续往下寻找):</p>
<p>\1. 内置模块<br> \2. 当前目录<br> \3. 程序的主目录<br> \4. pythonpath 目录(如果已经设置了 pythonpath 环境变量) 5. 标准链接库目录<br> \6. 第三方库目录(site-packages 目录)<br> \7. .pth 文件的内容(如果存在的话)<br> \8. sys.path.append()临时添加的目录</p>
<p>当任何一个 python 程序启动时，就将上面这些搜索路径(除内置模块以外的路径)进行收集， 放到 sys 模块的 path 属性中(sys.path)。</p>
<p><strong>使用 sys.path 查看和临时修改搜索路径</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys </span><br><span class="line">sys.path.append(&quot;d:&#x2F;&quot;) </span><br><span class="line">print(sys.path)</span><br></pre></td></tr></table></figure>

<h2 id="4-模块发布和安装"><a href="#4-模块发布和安装" class="headerlink" title="4. 模块发布和安装"></a><strong>4. 模块发布和安装</strong></h2><p>4.1 模块的本地发布**</p>
<p>当我们完成了某个模块开发后，可以将他对外发布，其他开发者也可以以“第三方扩展 库”的方式使用我们的模块。我们按照如下步骤即可实现模块的发布:</p>
<p>1.为模块文件创建如下结构的文件夹(一般，文件夹的名字和模块的名字一样):</p>
<p>2.在文件夹中创建一个名为『setup.py』的文件</p>
<p>\3. 构建一个发布文件。通过终端，cd 到模块文件夹 c 下面，再键入命令:</p>
<p>python setup.py sdist</p>
<p><strong>4.3 上传模块到 PyPI</strong></p>
<p>将自己开发好的模块上传到 PyPI 网站上，将成为公开的资源，可以让全球用户自由使 用。按照如下步骤做，很容易就实现上传模块操作。</p>
<p><strong>·管理你的模块</strong></p>
<p><strong>4.4 让别人使用你的模块</strong></p>
<p>模块发布完成后，其他人只需要使用 pip 就可以安装你的模块文件。比如:</p>
<p>pip <strong>install package</strong>-<strong>name</strong></p>
<h2 id="5-库-Library"><a href="#5-库-Library" class="headerlink" title="5. 库(Library)"></a><strong>5. 库(Library)</strong></h2><p>Python 中库是借用其他编程语言的概念，没有特别具体的定义。模块和包侧重于代码 组织，有明确的定义。</p>
<p>一般情况，库强调的是功能性，而不是代码组织。我们通常将某个功能的“模块的集合”， 称为库。</p>
<p><strong>5.1 标准库(Standard Library)</strong></p>
<p>Python 拥有一个强大的标准库。Python 语言的核心只包含数字、字符串、列表、字典、 文件等常见类型和函数，而由 Python 标准库提供了系统管理、网络通信、文本处理、数据 库接口、图形系统、XML 处理等额外的功能。</p>
<p>Python 标准库的主要功能有:<br> \1. 文本处理，包含文本格式化、正则表达式匹配、文本差异计算与合并、Unicode 支 持，二进制数据处理等功能<br> \2. 文件处理，包含文件操作、创建临时文件、文件压缩与归档、操作配置文件等功能</p>
<p>\3. 操作系统功能，包含线程与进程支持、IO 复用、日期与时间处理、调用系统函数、 日志(logging)等功能<br> \4. 网络通信，包含网络套接字，SSL 加密通信、异步网络通信等功能<br> \5. 网络协议，支持 HTTP，FTP，SMTP，POP，IMAP，NNTP，XMLRPC 等多种网 络协议，并提供了编写网络服务器的框架</p>
<p>\6. W3C 格式支持，包含 HTML，SGML，XML 的处理<br> \7. 其它功能，包括国际化支持、数学运算、HASH、Tkinter 等</p>
<p>目前学过的有:random、math、time、file、os、sys 等模块。可以通过 random 模 块实现随机数处理、math 模块实现数学相关的运算、time 模块实现时间的处理、file 模块 实现对文件的操作、OS 模块实现和操作系统的交互、sys 模块实现和解释器的交互。</p>
<p><strong>5.2 第三方扩展库的介绍</strong></p>
<p>强大的标准库奠定了 python 发展的基石，丰富和不断扩展的第三方库是 python 壮大 的保证。我们可以进入 PyPI 官网:</p>
<p><strong>常用第三方库大汇总</strong></p>
<table>
<thead>
<tr>
<th>分类</th>
<th>库名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>环境管理</td>
<td>P</td>
<td>非常简单的交互式 python 版本管理工具</td>
</tr>
<tr>
<td>Pyenv</td>
<td>简单的 Python 版本管理工具</td>
<td></td>
</tr>
<tr>
<td>Vex</td>
<td><code>可以在虚拟环境中执行命令</code></td>
<td></td>
</tr>
<tr>
<td>Virtualenv virtualenvwrapp</td>
<td>创建独立 Python 环境的工具</td>
<td></td>
</tr>
</tbody></table>
<p>尚学堂·百战程序员 <a href="http://www.itbaizhan.cn" target="_blank" rel="noopener">www.itbaizhan.cn</a></p>
<table>
<thead>
<tr>
<th></th>
<th>er</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>包管理</td>
<td>pip</td>
<td>Python 包和依赖关系管理工具</td>
</tr>
<tr>
<td>pip-tools</td>
<td>保证 Python 包依赖关系更新的一组工具</td>
<td></td>
</tr>
<tr>
<td>Pipenv</td>
<td>Python 官方推荐的新一代包管理工具</td>
<td></td>
</tr>
<tr>
<td>Poetry</td>
<td>可完全取代 setup.py 的包管理工具</td>
<td></td>
</tr>
<tr>
<td>包仓库</td>
<td>warehouse</td>
<td>下一代 PyPI</td>
</tr>
<tr>
<td>Devpi</td>
<td>PyPI 服务和打包/测试/分发工具</td>
<td></td>
</tr>
<tr>
<td>分发 (打包为可执行文件 以便分发)</td>
<td>PyInstaller</td>
<td>将 Python 程序转成独立的执行文件(跨平台)</td>
</tr>
<tr>
<td>Nuitka</td>
<td>将脚本、模块、包编译成可执行文件或扩展模块</td>
<td></td>
</tr>
<tr>
<td>py2app</td>
<td>将 Python 脚本变为独立软件包(Mac OS X)</td>
<td></td>
</tr>
<tr>
<td>py2exe</td>
<td>将 Python 脚本变为独立软件包(Windows)</td>
<td></td>
</tr>
<tr>
<td>pynsist</td>
<td>一个用来创建 Windows 安装程序的工具，可 以在安装程序中打包 Python 本身</td>
<td></td>
</tr>
<tr>
<td>构建工具 (将源码编译成软件)</td>
<td>Buildout</td>
<td>构建系统，从多个组件来创建，组装和部署应用</td>
</tr>
<tr>
<td>BitBake</td>
<td>针对嵌入式 Linux 的类似 make 的构建工具</td>
<td></td>
</tr>
<tr>
<td>Fabricate</td>
<td><code>对任何语言自动找到依赖关系的构建工具</code></td>
<td></td>
</tr>
<tr>
<td>交互式 Python 解 析器</td>
<td>IPython</td>
<td>功能丰富的工具，非常有效的使用交互式 Python</td>
</tr>
<tr>
<td>bpython</td>
<td>界面丰富的 Python 解析器</td>
<td></td>
</tr>
<tr>
<td>Ptpython</td>
<td>高级交互式 Python 解析器，构建 于 python-prompt-toolkit 之上</td>
<td></td>
</tr>
<tr>
<td>文件管理</td>
<td>Aiofiles</td>
<td>基于 asyncio，提供文件异步操作</td>
</tr>
<tr>
<td>Imghdr</td>
<td>(Python 标准库)检测图片类型</td>
<td></td>
</tr>
<tr>
<td>Mimetypes</td>
<td>(Python 标准库)将文件名映射为 MIME 类型</td>
<td></td>
</tr>
<tr>
<td>path.py</td>
<td>对 os.path 进行封装的模块</td>
<td></td>
</tr>
<tr>
<td>Pathlib</td>
<td>(Python3.4+ 标准库)跨平台的、面向对象的 路径操作库</td>
<td></td>
</tr>
<tr>
<td>Unipath</td>
<td><code>用面向对象的方式操作文件和目录</code></td>
<td></td>
</tr>
<tr>
<td>Watchdog</td>
<td>管理文件系统事件的 API 和 shell 工具</td>
<td></td>
</tr>
<tr>
<td>日期和时间</td>
<td>Arrow</td>
<td>更好的 Python 日期时间操作类库</td>
</tr>
<tr>
<td>Chronyk</td>
<td><code>解析手写格式的时间和日期</code></td>
<td></td>
</tr>
<tr>
<td>Dateutil</td>
<td>Python datetime 模块的扩展</td>
<td></td>
</tr>
<tr>
<td>PyTime</td>
<td>一个简单易用的 Python 模块，用于通过字符 串来操作日期/时间</td>
<td></td>
</tr>
<tr>
<td>when.py</td>
<td>提供用户友好的函数来帮助用户进行常用的日 期和时间操作</td>
<td></td>
</tr>
<tr>
<td>文本处理</td>
<td>chardet</td>
<td>字符编码检测器，兼容 Python2 和 Python3</td>
</tr>
</tbody></table>
<p>尚学堂·百战程序员 <a href="http://www.itbaizhan.cn" target="_blank" rel="noopener">www.itbaizhan.cn</a></p>
<table>
<thead>
<tr>
<th></th>
<th>Difflib</th>
<th>(Python 标准库)帮助我们进行差异化比较</th>
</tr>
</thead>
<tbody><tr>
<td>Fuzzywuzzy</td>
<td>模糊字符串匹配</td>
<td></td>
</tr>
<tr>
<td>Levenshtein</td>
<td><code>快速计算编辑距离以及字符串的相似度</code></td>
<td></td>
</tr>
<tr>
<td>Pypinyin</td>
<td>汉字拼音转换工具 Python 版</td>
<td></td>
</tr>
<tr>
<td>Shortuuid</td>
<td>一个生成器库，用以生成简洁的，明白的，URL 安全的 UUID</td>
<td></td>
</tr>
<tr>
<td>simplejson</td>
<td>Python 的 JSON 编码、解码器</td>
<td></td>
</tr>
<tr>
<td>Unidecode</td>
<td>Unicode 文本的 ASCII 转换形式</td>
<td></td>
</tr>
<tr>
<td>Xpinyin</td>
<td>一个用于把汉字转换为拼音的库</td>
<td></td>
</tr>
<tr>
<td>Pygment</td>
<td>通用语法高亮工具</td>
<td></td>
</tr>
<tr>
<td>Phonenumbers</td>
<td>解析，格式化，储存，验证电话号码</td>
<td></td>
</tr>
<tr>
<td>Sqlparse</td>
<td>一个无验证的 SQL 解析器</td>
<td></td>
</tr>
<tr>
<td>特殊文本格式处理</td>
<td>Tablib</td>
<td>一个用来处理中表格数据的模块</td>
</tr>
<tr>
<td>Pyexcel</td>
<td>用来读写，操作 Excel 文件的库</td>
<td></td>
</tr>
<tr>
<td>python-docx</td>
<td>读取，查询以及修改 word 文件</td>
<td></td>
</tr>
<tr>
<td>PDFMiner</td>
<td>一个用于从 PDF 文档中抽取信息的工具</td>
<td></td>
</tr>
<tr>
<td>Python-Markdo wn2</td>
<td>纯 Python 实现的 Markdown 解析器</td>
<td></td>
</tr>
<tr>
<td>Csvkit</td>
<td>用于转换和操作 CSV 的工具</td>
<td></td>
</tr>
<tr>
<td>自然语言处理</td>
<td>NLTK</td>
<td>一个先进的平台，用以构建处理人类语言数据的 Python 程序</td>
</tr>
<tr>
<td>Jieba</td>
<td>中文分词工具</td>
<td></td>
</tr>
<tr>
<td>langid.py</td>
<td>独立的语言识别系统</td>
<td></td>
</tr>
<tr>
<td>SnowNLP</td>
<td>一个用来处理中文文本的库</td>
<td></td>
</tr>
<tr>
<td>Thulac</td>
<td>清华大学自然语言处理与社会人文计算实验室 研制推出的一套中文词法分析工具包</td>
<td></td>
</tr>
<tr>
<td>下载器</td>
<td>you-get</td>
<td>一个 YouTube/Youku/Niconico 视频下载器</td>
</tr>
<tr>
<td>图像处理</td>
<td>pillow</td>
<td>最常用的图像处理库</td>
</tr>
<tr>
<td>imgSeek</td>
<td>一个使用视觉相似性搜索一组图片集合的项目</td>
<td></td>
</tr>
<tr>
<td>face_recognition</td>
<td>简单易用的 python 人脸识别</td>
<td></td>
</tr>
<tr>
<td>python-qrcode</td>
<td>一个纯 Python 实现的二维码生成器</td>
<td></td>
</tr>
<tr>
<td>OCR</td>
<td>Pyocr</td>
<td>Tesseract 和 Cuneiform 的 一 个 封 装 (wrapper)</td>
</tr>
<tr>
<td>pytesseract</td>
<td>Google Tesseract OCR 的 另 一 个 封 装</td>
<td></td>
</tr>
</tbody></table>
<p>尚学堂·百战程序员 <a href="http://www.itbaizhan.cn" target="_blank" rel="noopener">www.itbaizhan.cn</a></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>(wrapper)</th>
</tr>
</thead>
<tbody><tr>
<td>音频处理</td>
<td>Audiolazy</td>
<td>Python 的数字信号处理包</td>
</tr>
<tr>
<td>Dejavu</td>
<td>音频指纹提取和识别</td>
<td></td>
</tr>
<tr>
<td>id3reader</td>
<td>一个用来读取 MP3 元数据的 Python 模块</td>
<td></td>
</tr>
<tr>
<td>TimeSide</td>
<td>开源 web 音频处理框架</td>
<td></td>
</tr>
<tr>
<td>Tinytag</td>
<td>一个用来读取 MP3, OGG, FLAC 以及 Wave 文件音乐元数据的库</td>
<td></td>
</tr>
<tr>
<td>Mingus</td>
<td>一个高级音乐理论和曲谱包，支持 MIDI 文件 和回放功能</td>
<td></td>
</tr>
<tr>
<td>视频和 GIF 处理</td>
<td>Moviepy</td>
<td>一个用来进行基于脚本的视频编辑模块，适用于 多种格式，包括动图 GIFs</td>
</tr>
<tr>
<td>scikit-video</td>
<td>SciPy 视频处理常用程序</td>
<td></td>
</tr>
<tr>
<td>地理位置</td>
<td>GeoDjango</td>
<td>世界级地理图形 web 框架</td>
</tr>
<tr>
<td>GeoIP</td>
<td>MaxMind GeoIP Legacy 数 据 库 的 Python API</td>
<td></td>
</tr>
<tr>
<td>Geopy</td>
<td>Python 地址编码工具箱</td>
<td></td>
</tr>
<tr>
<td>HTTP</td>
<td>requests</td>
<td>人性化的 HTTP 请求库</td>
</tr>
<tr>
<td>httplib2</td>
<td>全面的 HTTP 客户端库</td>
<td></td>
</tr>
<tr>
<td>urllib3</td>
<td>一个具有线程安全连接池，支持文件 post，清 晰友好的 HTTP 库</td>
<td></td>
</tr>
<tr>
<td>Python 实现的 数据库</td>
<td>pickleDB</td>
<td>一个简单，轻量级键值储存数据库</td>
</tr>
<tr>
<td>PipelineDB</td>
<td>流式 SQL 数据库</td>
<td></td>
</tr>
<tr>
<td>TinyDB</td>
<td>一个微型的，面向文档型数据库</td>
<td></td>
</tr>
<tr>
<td>web 框架</td>
<td>Django</td>
<td>Python 界最流行的 web 框架</td>
</tr>
<tr>
<td>Flask</td>
<td>一个 Python 微型框架</td>
<td></td>
</tr>
<tr>
<td>Tornado</td>
<td>一个 web 框架和异步网络库</td>
<td></td>
</tr>
<tr>
<td>CMS 内容管理系统</td>
<td>odoo-cms</td>
<td>一个开源的，企业级 CMS，基于 odoo</td>
</tr>
<tr>
<td>djedi-cms</td>
<td>一个轻量级但却非常强大的 Django CMS ，考 虑到了插件，内联编辑以及性能</td>
<td></td>
</tr>
<tr>
<td>Opps</td>
<td>一个为杂志，报纸网站以及大流量门户网站设计 的 CMS 平台，基于 Django</td>
<td></td>
</tr>
<tr>
<td>电子商务和支付系 统</td>
<td>django-oscar</td>
<td>一个用于 Django 的开源的电子商务框架</td>
</tr>
<tr>
<td>django-shop</td>
<td>一个基于 Django 的店铺系统</td>
<td></td>
</tr>
<tr>
<td>Shoop</td>
<td>一个基于 Django 的开源电子商务平台</td>
<td></td>
</tr>
<tr>
<td>Alipay</td>
<td>Python 支付宝 API</td>
<td></td>
</tr>
<tr>
<td>Merchant</td>
<td>一个可以接收来自多种支付平台支付的</td>
<td></td>
</tr>
</tbody></table>
<p>尚学堂·百战程序员 <a href="http://www.itbaizhan.cn" target="_blank" rel="noopener">www.itbaizhan.cn</a></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>Django 应用</th>
</tr>
</thead>
<tbody><tr>
<td>游戏开发</td>
<td>Cocos2d</td>
<td>用来开发 2D 游戏</td>
</tr>
<tr>
<td>Panda3D</td>
<td>由迪士尼开发的 3D 游戏引擎，并由卡内基梅 陇娱乐技术中心负责维护。使用 C++ 编写, 针 对 Python 进行了完全的封装</td>
<td></td>
</tr>
<tr>
<td>Pygame</td>
<td>Pygame 是一组 Python 模块，用来编写游戏</td>
<td></td>
</tr>
<tr>
<td>RenPy</td>
<td>一个视觉小说(visual novel)引擎</td>
<td></td>
</tr>
<tr>
<td>计算机视觉库</td>
<td>OpenCV</td>
<td>开源计算机视觉库</td>
</tr>
<tr>
<td>Pyocr</td>
<td>Tesseract 和 Cuneiform 的包装库</td>
<td></td>
</tr>
<tr>
<td>SimpleCV</td>
<td>一个用来创建计算机视觉应用的开源框架</td>
<td></td>
</tr>
<tr>
<td>机器学习 人工智能</td>
<td>TensorFlow</td>
<td><code>谷歌开源的最受欢迎的深度学习框架</code></td>
</tr>
<tr>
<td>keras</td>
<td>以 tensorflow/theano/CNTK 为 后 端 的 深 度 学习封装库，快速上手神经网络</td>
<td></td>
</tr>
<tr>
<td>Hebel</td>
<td>GPU 加速的深度学习库</td>
<td></td>
</tr>
<tr>
<td>Pytorch</td>
<td>一个具有张量和动态神经网络，并有强大 GPU 加速能力的深度学习框架</td>
<td></td>
</tr>
<tr>
<td>scikit-learn</td>
<td>基于 SciPy 构建的机器学习 Python 模块</td>
<td></td>
</tr>
<tr>
<td>NuPIC</td>
<td>智能计算 Numenta 平台</td>
<td></td>
</tr>
<tr>
<td>科学计算和数据分 析</td>
<td>NumPy</td>
<td>使用 Python 进行科学计算的基础包</td>
</tr>
<tr>
<td>Pandas</td>
<td>提供高性能，易用的数据结构和数据分析工具</td>
<td></td>
</tr>
<tr>
<td>SciPy</td>
<td>用于数学，科学和工程的开源软件构成的生态系 统</td>
<td></td>
</tr>
<tr>
<td>PyMC</td>
<td><code>马尔科夫链蒙特卡洛采样工具</code></td>
<td></td>
</tr>
<tr>
<td>代码分析和调试</td>
<td>code2flow</td>
<td>把你的 Python 和 JavaScript 代码转换为流 程图</td>
</tr>
<tr>
<td>Pycallgraph</td>
<td>这个库可以把你的 Python 应用的流程(调用 图)进行可视化</td>
<td></td>
</tr>
<tr>
<td>Pylint</td>
<td>一个完全可定制的源码分析器</td>
<td></td>
</tr>
<tr>
<td>autopep8</td>
<td>自动格式化 Python 代码，以使其符合 PEP8 规范</td>
<td></td>
</tr>
<tr>
<td>Wdb</td>
<td>一个奇异的 web 调试器，通过 WebSockets 工作</td>
<td></td>
</tr>
<tr>
<td>Lineprofiler</td>
<td>逐行性能分析</td>
<td></td>
</tr>
<tr>
<td>Memory Profiler</td>
<td>监控 Python 代码的内存使用</td>
<td></td>
</tr>
<tr>
<td>图形用户界面</td>
<td>Pyglet</td>
<td>一个 Python 的跨平台窗口及多媒体库</td>
</tr>
</tbody></table>
<p>尚学堂·百战程序员 <a href="http://www.itbaizhan.cn" target="_blank" rel="noopener">www.itbaizhan.cn</a></p>
<table>
<thead>
<tr>
<th></th>
<th>PyQt</th>
<th>跨平台用户界面框架 Qt 的 Python 绑定 ，支 持 Qtv4 和 Qtv5</th>
</tr>
</thead>
<tbody><tr>
<td>Tkinter</td>
<td>Tkinter 是 Python GUI 的一个事实标准库</td>
<td></td>
</tr>
<tr>
<td>wxPython</td>
<td>wxPython 是 wxWidgets C++ 类 库 和 Python 语言混合的产物</td>
<td></td>
</tr>
<tr>
<td>网络爬虫和 HTML 分析</td>
<td>Scrapy</td>
<td>一个快速高级的屏幕爬取及网页采集框架</td>
</tr>
<tr>
<td>Cola</td>
<td>一个分布式爬虫框架</td>
<td></td>
</tr>
<tr>
<td>Grab</td>
<td>站点爬取框架</td>
<td></td>
</tr>
<tr>
<td>Pyspider</td>
<td>一个强大的爬虫系统</td>
<td></td>
</tr>
<tr>
<td>html2text</td>
<td>将 HTML 转换为 Markdown 格式文本</td>
<td></td>
</tr>
<tr>
<td>python-goose</td>
<td>HTML 内容/文章提取器</td>
<td></td>
</tr>
<tr>
<td>硬件编程</td>
<td>Ino</td>
<td>操作 Arduino 的命令行工具</td>
</tr>
<tr>
<td>Pyro</td>
<td>Python 机器人编程库</td>
<td></td>
</tr>
<tr>
<td>PyUserInput</td>
<td>跨平台的，控制鼠标和键盘的模块</td>
<td></td>
</tr>
<tr>
<td>Pingo</td>
<td>Pingo 为类似 RaspberryPi，pcDuino，Intel Galileo 等设备提供统一的 API</td>
<td></td>
</tr>
</tbody></table>
<p><strong>5.4 安装第三方扩展库的 2 种方式</strong></p>
<p>第三方库有数十万种之多，以 pillow 库为例讲解第三方扩展库的安装。pillow 是 Python 平台事实上的图像处理标准库，本节以安装 pillow 为例，给大家介绍第三方库的两 种常用的安装方法。</p>
<p>尚学堂·百战程序员 <a href="http://www.itbaizhan.cn" target="_blank" rel="noopener">www.itbaizhan.cn</a></p>
<p><strong>第一种方式:命令行下远程安装</strong></p>
<p>以安装第三方 pillow 图像库为例，在命令行提示符下输入:pip 安装完成后，我们就可以开始使用。</p>
<p><strong>第二种方式:Pycharm 中直接安装到项目中</strong></p>
<p>在 Pycharm 中，依次点击:file–&gt;setting–&gt;Project 本项目名–&gt;Project Interpreter</p>
]]></content>
  </entry>
  <entry>
    <title>Python day1-20</title>
    <url>/2020/04/18/pythond01-20/</url>
    <content><![CDATA[<h2 id="Python-notes-day-1"><a href="#Python-notes-day-1" class="headerlink" title="Python notes day 1"></a>Python notes day 1</h2><p>1.Run python:  python name.py</p>
<p>2.Comment: </p>
<p>“””</p>
<p>multiple line</p>
<p>“””</p>
<ol start="3">
<li><p>Sublime Text or PyCharm for python ide.</p>
</li>
<li><p>import this#put this in terminal, the zen of python</p>
<p>The Zen of Python, by Tim Peters</p>
</li>
</ol>
<p>   Beautiful is better than ugly.</p>
<p>   Explicit is better than implicit.</p>
<p>   Simple is better than complex.</p>
<p>   Complex is better than complicated.</p>
<p>   Flat is better than nested.</p>
<p>   Sparse is better than dense.</p>
<p>   Readability counts.</p>
<p>   Special cases aren’t special enough to break the rules.</p>
<p>   Although practicality beats purity.</p>
<p>   Errors should never pass silently.</p>
<p>   Unless explicitly silenced.</p>
<p>   In the face of ambiguity, refuse the temptation to guess.</p>
<p>   There should be one– and preferably only one –obvious way to do it.</p>
<p>   Although that way may not be obvious at first unless you’re Dutch.</p>
<p>   Now is better than never.</p>
<p>   Although never is often better than <em>right</em> now.</p>
<p>   If the implementation is hard to explain, it’s a bad idea.</p>
<p>   If the implementation is easy to explain, it may be a good idea.</p>
<p>   Namespaces are one honking great idea – let’s do more of those!</p>
<h2 id="Python-notes-day-2"><a href="#Python-notes-day-2" class="headerlink" title="Python notes day 2"></a>Python notes day 2</h2><ol>
<li><p>True, False, None</p>
</li>
<li><p>Variable name: number, letter, _, and cannot use number as front.</p>
</li>
<li><p>field instance, protected use <em>, private use _</em></p>
</li>
<li><p>type() : return &lt;class ‘type’&gt;</p>
</li>
<li><p>chr(): int to unicode’s char</p>
</li>
<li><p>ord(): unicode char to an int</p>
</li>
<li><p>input(): for user input</p>
</li>
<li><p>print(): for output</p>
</li>
<li><p><code>%d</code>是整数的占位符，<code>%f</code>是小数的占位符，<code>%%</code>表示百分号（因为百分号代表了占位符，所以带占位符的字符串中要表示百分号必须写成<code>%%</code>），字符串之后的<code>%</code>后面跟的变量值会替换掉占位符然后输出到终端中</p>
</li>
<li><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>[]</code> <code>[:]</code></td>
<td>下标，切片</td>
</tr>
<tr>
<td><code>**</code></td>
<td>指数</td>
</tr>
<tr>
<td><code>~</code> <code>+</code> <code>-</code></td>
<td>按位取反, 正负号</td>
</tr>
<tr>
<td><code>*</code> <code>/</code> <code>%</code> <code>//</code></td>
<td>乘，除，模，整除</td>
</tr>
<tr>
<td><code>+</code> <code>-</code></td>
<td>加，减</td>
</tr>
<tr>
<td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td>
<td>右移，左移</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>按位与</td>
</tr>
<tr>
<td><code>^</code> `</td>
<td>`</td>
</tr>
<tr>
<td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td>
<td>小于等于，小于，大于，大于等于</td>
</tr>
<tr>
<td><code>==</code> <code>!=</code></td>
<td>等于，不等于</td>
</tr>
<tr>
<td><code>is</code> <code>is not</code></td>
<td>身份运算符</td>
</tr>
<tr>
<td><code>in</code> <code>not in</code></td>
<td>成员运算符</td>
</tr>
<tr>
<td><code>not</code> <code>or</code> <code>and</code></td>
<td>逻辑运算符</td>
</tr>
</tbody></table>
<p>and, or , not</p>
</li>
<li><p>在使用<code>print</code>函数输出时，也可以对字符串内容进行格式化处理，上面<code>print</code>函数中的字符串<code>%1.f</code>是一个占位符，稍后会由一个<code>float</code>类型的变量值替换掉它。同理，如果字符串中有<code>%d</code>，后面可以用一个<code>int</code>类型的变量值替换掉它，而<code>%s</code>会被字符串的值替换掉。除了这种格式化字符串的方式外，还可以用下面的方式来格式化字符串，其中<code>{f:.1f}</code>和<code>{c:.1f}</code>可以先看成是<code>{f}</code>和<code>{c}</code>，表示输出时会用变量<code>f</code>和变量<code>c</code>的值替换掉这两个占位符，后面的<code>:.1f</code>表示这是一个浮点数，小数点后保留1位有效数字。</p>
</li>
<li><pre><code class="python">print(<span class="string">f'<span class="subst">{f:<span class="number">.1</span>f}</span>华氏度 = <span class="subst">{c:<span class="number">.1</span>f}</span>摄氏度'</span>)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">13. &#96;&#96;&#96;python</span><br><span class="line">    print(&#39;面积: %.2f&#39; % area)</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>python print格式化输出。</p>
<ol>
<li>打印字符串</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print (&quot;His name is %s&quot;%(&quot;Aviad&quot;))</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://images0.cnblogs.com/i/294206/201405/281715112591828.png" alt="img"></p>
<p>2.打印整数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print (&quot;He is %d years old&quot;%(25))</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://images0.cnblogs.com/i/294206/201405/281715549007593.png" alt="img"></p>
<p>3.打印浮点数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print (&quot;His height is %f m&quot;%(1.83))</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://images0.cnblogs.com/i/294206/201405/281717280885525.png" alt="img"></p>
<p>4.打印浮点数（指定保留小数点位数）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print (&quot;His height is %.2f m&quot;%(1.83))</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://images0.cnblogs.com/i/294206/201405/281719495723934.png" alt="img"></p>
<p>5.指定占位符宽度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print (&quot;Name:%10s Age:%8d Height:%8.2f&quot;%(&quot;Aviad&quot;,25,1.83))</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://images0.cnblogs.com/i/294206/201405/281723589006262.png" alt="img"></p>
<p>6.指定占位符宽度（左对齐）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print (&quot;Name:%-10s Age:%-8d Height:%-8.2f&quot;%(&quot;Aviad&quot;,25,1.83))</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://images0.cnblogs.com/i/294206/201405/281725436348200.png" alt="img"></p>
<p>7.指定占位符（只能用0当占位符？）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print (&quot;Name:%-10s Age:%08d Height:%08.2f&quot;%(&quot;Aviad&quot;,25,1.83))</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://images0.cnblogs.com/i/294206/201405/281727152591175.png" alt="img"></p>
<p>8.科学计数法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">format(0.0015,&#39;.2e&#39;)</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://images0.cnblogs.com/i/294206/201407/241348457447790.png" alt="img"></p>
<ul>
<li></li>
</ul>
</li>
</ol>
<h2 id="Python-notes-day-3"><a href="#Python-notes-day-3" class="headerlink" title="Python notes day 3"></a>Python notes day 3</h2><p>1.if, elif, else</p>
<h2 id="Python-notes-day-4"><a href="#Python-notes-day-4" class="headerlink" title="Python notes day 4"></a>Python notes day 4</h2><ol>
<li>for in 循环： for x in range(a, b, c):# a是初始值，b是最终，到b-1, c是iterate的长度。</li>
<li>while循环，配上break，continue</li>
</ol>
<h2 id="Python-notes-day-5"><a href="#Python-notes-day-5" class="headerlink" title="Python notes day 5"></a>Python notes day 5</h2><p>CRAPS game:</p>
<p>非常好玩的游戏， 在桌面新建.py结尾的文件或用idle直接打开即可</p>
<p><em>注意</em>： python2可能不支持中文</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">money = <span class="number">1000</span></span><br><span class="line"><span class="keyword">while</span> money &gt; <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'你的总资产为:'</span>, money)</span><br><span class="line">    needs_go_on = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        debt = int(input(<span class="string">'请下注: '</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt; debt &lt;= money:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    first = randint(<span class="number">1</span>, <span class="number">6</span>) + randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    print(<span class="string">'玩家摇出了%d点'</span> % first)</span><br><span class="line">    <span class="keyword">if</span> first == <span class="number">7</span> <span class="keyword">or</span> first == <span class="number">11</span>:</span><br><span class="line">        print(<span class="string">'玩家胜!'</span>)</span><br><span class="line">        money += debt</span><br><span class="line">    <span class="keyword">elif</span> first == <span class="number">2</span> <span class="keyword">or</span> first == <span class="number">3</span> <span class="keyword">or</span> first == <span class="number">12</span>:</span><br><span class="line">        print(<span class="string">'庄家胜!'</span>)</span><br><span class="line">        money -= debt</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        needs_go_on = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> needs_go_on:</span><br><span class="line">        needs_go_on = <span class="literal">False</span></span><br><span class="line">        current = randint(<span class="number">1</span>, <span class="number">6</span>) + randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">        print(<span class="string">'玩家摇出了%d点'</span> % current)</span><br><span class="line">        <span class="keyword">if</span> current == <span class="number">7</span>:</span><br><span class="line">            print(<span class="string">'庄家胜'</span>)</span><br><span class="line">            money -= debt</span><br><span class="line">        <span class="keyword">elif</span> current == first:</span><br><span class="line">            print(<span class="string">'玩家胜'</span>)</span><br><span class="line">            money += debt</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            needs_go_on = <span class="literal">True</span></span><br><span class="line">print(<span class="string">'你破产了, 游戏结束!'</span>)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>人工智能10</title>
    <url>/2020/05/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD10/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>人工智能1</title>
    <url>/2020/05/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>vim</title>
    <url>/2020/05/09/vim/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="vim操作大全"><a href="#vim操作大全" class="headerlink" title="vim操作大全"></a><a href="https://www.cnblogs.com/chichung/p/9497784.html" target="_blank" rel="noopener">vim操作大全</a></h1><p># 转自 <a href="https://blog.csdn.net/weixin_37657720/article/details/80645991" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37657720/article/details/80645991</a></p>
<p>曾经使用了两年多的Vim，手册也翻过一遍。虽然现在不怎么用vim了，曾经的笔记还是贴出来，与喜欢vim的朋友分享。</p>
<h1 id="1-关于Vim"><a href="#1-关于Vim" class="headerlink" title="1. 关于Vim"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id59" target="_blank" rel="noopener">1. 关于Vim</a></h1><p>vim是我最喜欢的编辑器，也是<a href="http://lib.csdn.net/base/linux" target="_blank" rel="noopener">Linux</a>下第二强大的编辑器。 虽然emacs是公认的世界第一，我认为使用emacs并没有使用vi进行编辑来得高效。 如果是初学vi，运行一下vimtutor是个聪明的决定。 （如果你的系统环境不是中文，而你想使用中文的vimtutor，就运行vimtutor zh）</p>
<h2 id="1-1-Vim的几种模式"><a href="#1-1-Vim的几种模式" class="headerlink" title="1.1 Vim的几种模式"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id60" target="_blank" rel="noopener">1.1 Vim的几种模式</a></h2><ul>
<li>正常模式：可以使用快捷键命令，或按:输入命令行。</li>
<li>插入模式：可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。</li>
<li>可视模式：正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式。</li>
<li>替换模式：正常模式下，按R进入。</li>
</ul>
<h1 id="2-启动Vim"><a href="#2-启动Vim" class="headerlink" title="2. 启动Vim"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id61" target="_blank" rel="noopener">2. 启动Vim</a></h1><ul>
<li>vim -c cmd file: 在打开文件前，先执行指定的命令；</li>
<li>vim -r file: 恢复上次异常退出的文件；</li>
<li>vim -R file: 以只读的方式打开文件，但可以强制保存；</li>
<li>vim -M file: 以只读的方式打开文件，不可以强制保存；</li>
<li>vim -y num file: 将编辑窗口的大小设为num行；</li>
<li>vim + file: 从文件的末尾开始；</li>
<li>vim +num file: 从第num行开始；</li>
<li>vim +/string file: 打开file，并将光标停留在第一个找到的string上。</li>
<li>vim –remote file: 用已有的vim进程打开指定的文件。 如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim –remote file在已有的gvim中打开文件。</li>
</ul>
<h1 id="3-文档操作"><a href="#3-文档操作" class="headerlink" title="3. 文档操作"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id62" target="_blank" rel="noopener">3. 文档操作</a></h1><ul>
<li>:e file –关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi会警告。</li>
<li>:e! file –放弃对当前文件的修改，编辑新的文件。</li>
<li>:e+file – 开始新的文件，并从文件尾开始编辑。</li>
<li>:e+n file – 开始新的文件，并从第n行开始编辑。</li>
<li>:enew –编译一个未命名的新文档。(CTRL-W n)</li>
<li>:e – 重新加载当前文档。</li>
<li>:e! – 重新加载当前文档，并丢弃已做的改动。</li>
<li>:e#或ctrl+^ – 回到刚才编辑的文件，很实用。</li>
<li>:f或ctrl+g – 显示文档名，是否修改，和光标位置。</li>
<li>:f filename – 改变编辑的文件名，这时再保存相当于另存为。</li>
<li>gf – 打开以光标所在字符串为文件名的文件。</li>
<li>:w – 保存修改。</li>
<li>:n1,n2w filename – 选择性保存从某n1行到另n2行的内容。</li>
<li>:wq – 保存并退出。</li>
<li>ZZ – 保存并退出。</li>
<li>:x – 保存并退出。</li>
<li>:q[uit] ——退出当前窗口。(CTRL-W q或CTRL-W CTRL-Q)</li>
<li>:saveas newfilename – 另存为</li>
<li>:browse e – 会打开一个文件浏览器让你选择要编辑的文件。 如果是终端中，则会打开netrw的文件浏览窗口； 如果是gvim，则会打开一个图形界面的浏览窗口。 实际上:browse后可以跟任何编辑文档的命令，如sp等。 用browse打开的起始目录可以由browsedir来设置：<ul>
<li>:set browsedir=last – 用上次访问过的目录（默认）；</li>
<li>:set browsedir=buffer – 用当前文件所在目录；</li>
<li>:set browsedir=current – 用当前工作目录；</li>
</ul>
</li>
<li>:Sex – 水平分割一个窗口，浏览文件系统；</li>
<li>:Vex – 垂直分割一个窗口，浏览文件系统；</li>
</ul>
<h1 id="4-光标的移动"><a href="#4-光标的移动" class="headerlink" title="4. 光标的移动"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id63" target="_blank" rel="noopener">4. 光标的移动</a></h1><h2 id="4-1-基本移动"><a href="#4-1-基本移动" class="headerlink" title="4.1 基本移动"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id64" target="_blank" rel="noopener">4.1 基本移动</a></h2><p>以下移动都是在normal模式下。</p>
<ul>
<li>h或退格: 左移一个字符；</li>
<li>l或空格: 右移一个字符；</li>
<li>j: 下移一行；</li>
<li>k: 上移一行；</li>
<li>gj: 移动到一段内的下一行；</li>
<li>gk: 移动到一段内的上一行；</li>
<li>+或Enter: 把光标移至下一行第一个非空白字符。</li>
<li>-: 把光标移至上一行第一个非空白字符。</li>
<li>w: 前移一个单词，光标停在下一个单词开头；</li>
<li>W: 移动下一个单词开头，但忽略一些标点；</li>
<li>e: 前移一个单词，光标停在下一个单词末尾；</li>
<li>E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点；</li>
<li>b: 后移一个单词，光标停在上一个单词开头；</li>
<li>B: 移动到上一个单词开头，忽略一些标点；</li>
<li>ge: 后移一个单词，光标停在上一个单词末尾；</li>
<li>gE: 同 ge ，不过‘单词’包含单词相邻的标点。</li>
<li>(: 前移1句。</li>
<li>): 后移1句。</li>
<li>{: 前移1段。</li>
<li>}: 后移1段。</li>
<li>fc: 把光标移到同一行的下一个c字符处</li>
<li>Fc: 把光标移到同一行的上一个c字符处</li>
<li>tc: 把光标移到同一行的下一个c字符前</li>
<li>Tc: 把光标移到同一行的上一个c字符后</li>
<li>;: 配合f &amp; t使用，重复一次</li>
<li>,: 配合f &amp; t使用，反向重复一次</li>
</ul>
<p>上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。</p>
<ul>
<li>0: 移动到行首。</li>
<li>g0: 移到光标所在屏幕行行首。</li>
<li>^: 移动到本行第一个非空白字符。</li>
<li>g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。</li>
<li>: 移动光标所在屏幕行行尾。</li>
<li>n|: 把光标移到递n列上。</li>
<li>nG: 到文件第n行。</li>
<li>:n<cr> 移动到第n行。</li>
<li>:$<cr> 移动到最后一行。</li>
<li>H: 把光标移到屏幕最顶端一行。</li>
<li>M: 把光标移到屏幕中间一行。</li>
<li>L: 把光标移到屏幕最底端一行。</li>
<li>gg: 到文件头部。</li>
<li>G: 到文件尾部。</li>
</ul>
<h2 id="4-2-翻屏"><a href="#4-2-翻屏" class="headerlink" title="4.2 翻屏"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id65" target="_blank" rel="noopener">4.2 翻屏</a></h2><ul>
<li>ctrl+f: 下翻一屏。</li>
<li>ctrl+b: 上翻一屏。</li>
<li>ctrl+d: 下翻半屏。</li>
<li>ctrl+u: 上翻半屏。</li>
<li>ctrl+e: 向下滚动一行。</li>
<li>ctrl+y: 向上滚动一行。</li>
<li>n%: 到文件n%的位置。</li>
<li>zz: 将当前行移动到屏幕中央。</li>
<li>zt: 将当前行移动到屏幕顶端。</li>
<li>zb: 将当前行移动到屏幕底端。</li>
</ul>
<h2 id="4-3-标记"><a href="#4-3-标记" class="headerlink" title="4.3 标记"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id66" target="_blank" rel="noopener">4.3 标记</a></h2><p>使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置。 Ctrl+o和Ctrl+i 很像浏览器上的 后退 和 前进 。</p>
<ul>
<li>m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。</li>
<li>m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。</li>
<li>`{a-z}: 移动到标记位置。</li>
<li>‘{a-z}: 移动到标记行的行首。</li>
<li>`{0-9}：回到上[2-10]次关闭vim时最后离开的位置。</li>
<li>“: 移动到上次编辑的位置。”也可以，不过“精确到列，而”精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。</li>
<li>`”: 移动到上次离开的地方。</li>
<li>`.: 移动到最后改动的地方。</li>
<li>:marks 显示所有标记。</li>
<li>:delmarks a b – 删除标记a和b。</li>
<li>:delmarks a-c – 删除标记a、b和c。</li>
<li>:delmarks a c-f – 删除标记a、c、d、e、f。</li>
<li>:delmarks! – 删除当前缓冲区的所有标记。</li>
<li>:help mark-motions 查看更多关于mark的知识。</li>
</ul>
<h1 id="5-插入文本"><a href="#5-插入文本" class="headerlink" title="5. 插入文本"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id67" target="_blank" rel="noopener">5. 插入文本</a></h1><h2 id="5-1-基本插入"><a href="#5-1-基本插入" class="headerlink" title="5.1 基本插入"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id68" target="_blank" rel="noopener">5.1 基本插入</a></h2><ul>
<li>i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入=， 按esc进入命令模式，就会出现8个=。 这在插入分割线时非常有用，如30i+<esc>就插入了36个+组成的分割线。</li>
<li>I: 在当前行第一个非空字符前插入；</li>
<li>gI: 在当前行第一列插入；</li>
<li>a: 在光标后插入；</li>
<li>A: 在当前行最后插入；</li>
<li>o: 在下面新建一行插入；</li>
<li>O: 在上面新建一行插入；</li>
<li>:r filename在当前位置插入另一个文件的内容。</li>
<li>:[n]r filename在第n行插入另一个文件的内容。</li>
<li>:r !date 在光标处插入当前日期与时间。同理，:r !command可以将其它shell命令的输出插入当前文档。</li>
</ul>
<h2 id="5-2-改写插入"><a href="#5-2-改写插入" class="headerlink" title="5.2 改写插入"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id69" target="_blank" rel="noopener">5.2 改写插入</a></h2><ul>
<li>c[n]w: 改写光标后1(n)个词。</li>
<li>c[n]l: 改写光标后n个字母。</li>
<li>c[n]h: 改写光标前n个字母。</li>
<li>[n]cc: 修改当前[n]行。</li>
<li>[n]s: 以输入的文本替代光标之后1(n)个字符，相当于c[n]l。</li>
<li>[n]S: 删除指定数目的行，并以所输入文本代替之。</li>
</ul>
<p>注意，类似cnw,dnw,ynw的形式同样可以写为ncw,ndw,nyw。</p>
<h1 id="6-剪切复制和寄存器"><a href="#6-剪切复制和寄存器" class="headerlink" title="6. 剪切复制和寄存器"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id70" target="_blank" rel="noopener">6. 剪切复制和寄存器</a></h1><h2 id="6-1-剪切和复制、粘贴"><a href="#6-1-剪切和复制、粘贴" class="headerlink" title="6.1 剪切和复制、粘贴"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id71" target="_blank" rel="noopener">6.1 剪切和复制、粘贴</a></h2><ul>
<li>[n]x: 剪切光标右边n个字符，相当于d[n]l。</li>
<li>[n]X: 剪切光标左边n个字符，相当于d[n]h。</li>
<li>y: 复制在可视模式下选中的文本。</li>
<li>yy or Y: 复制整行文本。</li>
<li>y[n]w: 复制一(n)个词。</li>
<li>y[n]l: 复制光标右边1(n)个字符。</li>
<li>y[n]h: 复制光标左边1(n)个字符。</li>
<li>yor D: 删除（剪切）当前位置到行尾的内容。</li>
<li>d[n]w: 删除（剪切）1(n)个单词</li>
<li>d[n]l: 删除（剪切）光标右边1(n)个字符。</li>
<li>d[n]h: 删除（剪切）光标左边1(n)个字符。</li>
<li>d0: 删除（剪切）当前位置到行首的内容</li>
<li>[n] dd: 删除（剪切）1(n)行。</li>
<li>:m,nd<cr> 剪切m行到n行的内容。</li>
<li>d1G或dgg: 剪切光标以上的所有行。</li>
<li>dG: 剪切光标以下的所有行。</li>
<li>daw和das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</li>
<li>d/f<cr>：这是一个比较高级的组合命令，它将删除当前位置 到下一个f之间的内容。</li>
<li>p: 在光标之后粘贴。</li>
<li>P: 在光标之前粘贴。</li>
</ul>
<h2 id="6-2-文本对象"><a href="#6-2-文本对象" class="headerlink" title="6.2 文本对象"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id72" target="_blank" rel="noopener">6.2 文本对象</a></h2><ul>
<li>aw：一个词</li>
<li>as：一句。</li>
<li>ap：一段。</li>
<li>ab：一块（包含在圆括号中的）。</li>
</ul>
<p>y, d, c, v都可以跟文本对象。</p>
<h2 id="6-3-寄存器"><a href="#6-3-寄存器" class="headerlink" title="6.3 寄存器"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id73" target="_blank" rel="noopener">6.3 寄存器</a></h2><ul>
<li>a-z：都可以用作寄存器名。”ayy把当前行的内容放入a寄存器。</li>
<li>A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。 如”Ayy把当前行的内容追加到a寄存器中。</li>
<li>:reg 显示所有寄存器的内容。</li>
<li>“”：不加寄存器索引时，默认使用的寄存器。</li>
<li>“<em>：当前选择缓冲区，”</em>yy把当前行的内容放入当前选择缓冲区。</li>
<li>“+：系统剪贴板。”+yy把当前行的内容放入系统剪贴板。</li>
</ul>
<h1 id="7-查找与替换"><a href="#7-查找与替换" class="headerlink" title="7. 查找与替换"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id74" target="_blank" rel="noopener">7. 查找与替换</a></h1><h2 id="7-1-查找"><a href="#7-1-查找" class="headerlink" title="7.1 查找"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id75" target="_blank" rel="noopener">7.1 查找</a></h2><ul>
<li>/something: 在后面的文本中查找something。</li>
<li>?something: 在前面的文本中查找something。</li>
<li>/pattern/+number: 将光标停在包含pattern的行后面第number行上。</li>
<li>/pattern/-number: 将光标停在包含pattern的行前面第number行上。</li>
<li>n: 向后查找下一个。</li>
<li>N: 向前查找下一个。</li>
</ul>
<p>可以用grep或vimgrep查找一个模式都在哪些地方出现过，</p>
<p>其中:grep是调用外部的grep程序，而:vimgrep是vim自己的查找算法。</p>
<p>用法为： :vim[grep]/pattern/[g] [j] files</p>
<p>g的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。</p>
<p>j的含义是grep结束后，结果停在第j项，默认是停在第一项。</p>
<p>vimgrep前面可以加数字限定搜索结果的上限，如</p>
<p>:1vim/pattern/ % 只查找那个模式在本文件中的第一个出现。</p>
<p>其实vimgrep在读纯文本电子书时特别有用，可以生成导航的目录。</p>
<p>比如电子书中每一节的标题形式为：n. xxxx。你就可以这样：</p>
<p>:vim/^d{1,}./ %</p>
<p>然后用:cw或:copen查看结果，可以用C-w H把quickfix窗口移到左侧，</p>
<p>就更像个目录了。</p>
<h2 id="7-2-替换"><a href="#7-2-替换" class="headerlink" title="7.2 替换"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id76" target="_blank" rel="noopener">7.2 替换</a></h2><ul>
<li>:s/old/new - 用new替换当前行第一个old。</li>
<li>:s/old/new/g - 用new替换当前行所有的old。</li>
<li>:n1,n2s/old/new/g - 用new替换文件n1行到n2行所有的old。</li>
<li>:%s/old/new/g - 用new替换文件中所有的old。</li>
<li>:%s/^/xxx/g - 在每一行的行首插入xxx，^表示行首。</li>
<li>:%s/表示行尾。</li>
<li>所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。</li>
</ul>
<p>还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，</p>
<p>语法为 :[range]g/pattern/command</p>
<p>例如 :%g/^ xyz/normal dd。</p>
<p>表示对于以一个空格和xyz开头的行执行normal模式下的dd命令。</p>
<p>关于range的规定为：</p>
<ul>
<li>如果不指定range，则表示当前行。</li>
<li>m,n: 从m行到n行。</li>
<li>0: 最开始一行（可能是这样）。</li>
<li>$: 最后一行</li>
<li>.: 当前行</li>
<li>%: 所有行</li>
</ul>
<h2 id="7-3-正则表达式"><a href="#7-3-正则表达式" class="headerlink" title="7.3 正则表达式"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id77" target="_blank" rel="noopener">7.3 正则表达式</a></h2><p>高级的查找替换就要用到正则表达式。</p>
<ul>
<li>\d: 表示十进制数（我猜的）</li>
<li>\s: 表示空格</li>
<li>\S: 非空字符</li>
<li>\a: 英文字母</li>
<li>|: 表示 或</li>
<li>.: 表示.</li>
<li>{m,n}: 表示m到n个字符。这要和 \s与\a等连用，如 \a{m,n} 表示m 到n个英文字母。</li>
<li>{m,}: 表示m到无限多个字符。</li>
<li>**: 当前目录下的所有子目录。</li>
</ul>
<p>:help pattern得到更多帮助。</p>
<hr>
<h1 id="8-排版"><a href="#8-排版" class="headerlink" title="8. 排版"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id78" target="_blank" rel="noopener">8. 排版</a></h1><h2 id="8-1-基本排版"><a href="#8-1-基本排版" class="headerlink" title="8.1 基本排版"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id79" target="_blank" rel="noopener">8.1 基本排版</a></h2><ul>
<li>&lt;&lt; 向左缩进一个shiftwidth</li>
<li>&gt;&gt; 向右缩进一个shiftwidth</li>
<li>:ce(nter) 本行文字居中</li>
<li>:le(ft) 本行文字靠左</li>
<li>:ri(ght) 本行文字靠右</li>
<li>gq 对选中的文字重排，即对过长的文字进行断行</li>
<li>gqq 重排当前行</li>
<li>gqnq 重排n行</li>
<li>gqap 重排当前段</li>
<li>gqnap 重排n段</li>
<li>gqnj 重排当前行和下面n行</li>
<li>gqQ 重排当前段对文章末尾</li>
<li>J 拼接当前行和下一行</li>
<li>gJ 同 J ，不过合并后不留空格。</li>
</ul>
<h2 id="8-2-拼写检查"><a href="#8-2-拼写检查" class="headerlink" title="8.2 拼写检查"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id80" target="_blank" rel="noopener">8.2 拼写检查</a></h2><ul>
<li>:set spell－开启拼写检查功能</li>
<li>:set nospell－关闭拼写检查功能</li>
<li>]s－移到下一个拼写错误的单词</li>
<li>[s－作用与上一命令类似，但它是从相反方向进行搜索</li>
<li>z=－显示一个有关拼写错误单词的列表，可从中选择</li>
<li>zg－告诉拼写检查器该单词是拼写正确的</li>
<li>zw－与上一命令相反，告诉拼写检查器该单词是拼写错误的</li>
</ul>
<h2 id="8-3-统计字数"><a href="#8-3-统计字数" class="headerlink" title="8.3 统计字数"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id81" target="_blank" rel="noopener">8.3 统计字数</a></h2><p>g ^g可以统计文档字符数，行数。 将光标放在最后一个字符上，用字符数减去行数可以粗略统计中文文档的字数。 以上对 Mac 或 Unix 的文件格式适用。 如果是 Windows 文件格式（即换行符有两个字节），字数的统计方法为： 字符数 - 行数 * 2。</p>
<hr>
<h1 id="9-编辑多个文件"><a href="#9-编辑多个文件" class="headerlink" title="9. 编辑多个文件"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id82" target="_blank" rel="noopener">9. 编辑多个文件</a></h1><h2 id="9-1-一次编辑多个文件"><a href="#9-1-一次编辑多个文件" class="headerlink" title="9.1 一次编辑多个文件"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id83" target="_blank" rel="noopener">9.1 一次编辑多个文件</a></h2><p>我们可以一次打开多个文件，如</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi a.txt b.txt c.txt</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>使用:next(:n)编辑下一个文件。</li>
<li>:2n 编辑下2个文件。</li>
<li>使用:previous或:N编辑上一个文件。</li>
<li>使用:wnext，保存当前文件，并编辑下一个文件。</li>
<li>使用:wprevious，保存当前文件，并编辑上一个文件。</li>
<li>使用:args 显示文件列表。</li>
<li>:n filenames或:args filenames 指定新的文件列表。</li>
<li>vi -o filenames 在水平分割的多个窗口中编辑多个文件。</li>
<li>vi -O filenames 在垂直分割的多个窗口中编辑多个文件。</li>
</ul>
<h2 id="9-2-多标签编辑"><a href="#9-2-多标签编辑" class="headerlink" title="9.2 多标签编辑"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id84" target="_blank" rel="noopener">9.2 多标签编辑</a></h2><ul>
<li>vim -p files: 打开多个文件，每个文件占用一个标签页。</li>
<li>:tabe, tabnew – 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。</li>
<li>^w gf – 在新的标签页里打开光标下路径指定的文件。</li>
<li>:tabn – 切换到下一个标签。Control + PageDown，也可以。</li>
<li>:tabp – 切换到上一个标签。Control + PageUp，也可以。</li>
<li>[n] gt – 切换到下一个标签。如果前面加了 n ， 就切换到第n个标签。第一个标签的序号就是1。</li>
<li>:tab split – 将当前缓冲区的内容在新页签中打开。</li>
<li>:tabc[lose] – 关闭当前的标签页。</li>
<li>:tabo[nly] – 关闭其它的标签页。</li>
<li>:tabs – 列出所有的标签页和它们包含的窗口。</li>
<li>:tabm[ove] [N] – 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。</li>
</ul>
<h2 id="9-3-缓冲区"><a href="#9-3-缓冲区" class="headerlink" title="9.3 缓冲区"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id85" target="_blank" rel="noopener">9.3 缓冲区</a></h2><ul>
<li>:buffers或:ls或:files 显示缓冲区列表。</li>
<li>ctrl+^：在最近两个缓冲区间切换。</li>
<li>:bn – 下一个缓冲区。</li>
<li>:bp – 上一个缓冲区。</li>
<li>:bl – 最后一个缓冲区。</li>
<li>:b[n]或:[n]b – 切换到第n个缓冲区。</li>
<li>:nbw(ipeout) – 彻底删除第n个缓冲区。</li>
<li>:nbd(elete) – 删除第n个缓冲区，并未真正删除，还在unlisted列表中。</li>
<li>:ba[ll] – 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。</li>
</ul>
<h1 id="10-分屏编辑"><a href="#10-分屏编辑" class="headerlink" title="10. 分屏编辑"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id86" target="_blank" rel="noopener">10. 分屏编辑</a></h1><ul>
<li>vim -o file1 file2:水平分割窗口，同时打开file1和file2</li>
<li>vim -O file1 file2:垂直分割窗口，同时打开file1和file2</li>
</ul>
<h2 id="10-1-水平分割"><a href="#10-1-水平分割" class="headerlink" title="10.1 水平分割"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id87" target="_blank" rel="noopener">10.1 水平分割</a></h2><ul>
<li>:split(:sp) – 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S) 注意如果在终端下，CTRL-S可能会冻结终端，请按CTRL-Q继续。</li>
<li>:split filename – 水平分割窗口，并在新窗口中显示另一个文件。</li>
<li>:nsplit(:nsp) – 水平分割出一个n行高的窗口。</li>
<li>:[N]new – 水平分割出一个N行高的窗口，并编辑一个新文件。 (CTRL-W n或 CTRL-W CTRL-N)</li>
<li>ctrl+w f –水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。</li>
<li>C-w C-^ – 水平分割一个窗口，打开刚才编辑的文件。</li>
</ul>
<h2 id="10-2-垂直分割"><a href="#10-2-垂直分割" class="headerlink" title="10.2 垂直分割"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id88" target="_blank" rel="noopener">10.2 垂直分割</a></h2><ul>
<li>:vsplit(:vsp) – 把当前窗口分割成水平分布的两个窗口。 (CTRL-W v或CTRL CTRL-V)</li>
<li>:[N]vne[w] – 垂直分割出一个新窗口。</li>
<li>:vertical 水平分割的命令： 相应的垂直分割。</li>
</ul>
<h2 id="10-3-关闭子窗口"><a href="#10-3-关闭子窗口" class="headerlink" title="10.3 关闭子窗口"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id89" target="_blank" rel="noopener">10.3 关闭子窗口</a></h2><ul>
<li>:qall – 关闭所有窗口，退出vim。</li>
<li>:wall – 保存所有修改过的窗口。</li>
<li>:only – 只保留当前窗口，关闭其它窗口。(CTRL-W o)</li>
<li>:close – 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x同样工作 )</li>
</ul>
<h2 id="10-4-调整窗口大小"><a href="#10-4-调整窗口大小" class="headerlink" title="10.4 调整窗口大小"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id90" target="_blank" rel="noopener">10.4 调整窗口大小</a></h2><ul>
<li>ctrl+w + –当前窗口增高一行。也可以用n增高n行。</li>
<li>ctrl+w - –当前窗口减小一行。也可以用n减小n行。</li>
<li>ctrl+w _ –当前窗口扩展到尽可能的大。也可以用n设定行数。</li>
<li>:resize n – 当前窗口n行高。</li>
<li>ctrl+w = – 所有窗口同样高度。</li>
<li>n ctrl+w _ – 当前窗口的高度设定为n行。</li>
<li>ctrl+w &lt; –当前窗口减少一列。也可以用n减少n列。</li>
<li>ctrl+w &gt; –当前窗口增宽一列。也可以用n增宽n列。</li>
<li>ctrl+w | –当前窗口尽可能的宽。也可以用n设定列数。</li>
</ul>
<h2 id="10-5-切换和移动窗口"><a href="#10-5-切换和移动窗口" class="headerlink" title="10.5 切换和移动窗口"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id91" target="_blank" rel="noopener">10.5 切换和移动窗口</a></h2><p>如果支持鼠标，切换和调整子窗口的大小就简单了。</p>
<ul>
<li>ctrl+w ctrl+w: 切换到下一个窗口。或者是ctrl+w w。</li>
<li>ctrl+w p: 切换到前一个窗口。</li>
<li>ctrl+w h(l,j,k):切换到左（右，下，上）的窗口。</li>
<li>ctrl+w t(b):切换到最上（下）面的窗口。<BR></li>
<li>ctrl+w H(L,K,J): 将当前窗口移动到最左（右、上、下）面。</li>
<li>ctrl+w r：旋转窗口的位置。</li>
<li>ctrl+w T: 将当前的窗口移动到新的标签页上。</li>
</ul>
<h1 id="11-快速编辑"><a href="#11-快速编辑" class="headerlink" title="11. 快速编辑"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id92" target="_blank" rel="noopener">11. 快速编辑</a></h1><h2 id="11-1-改变大小写"><a href="#11-1-改变大小写" class="headerlink" title="11.1 改变大小写"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id93" target="_blank" rel="noopener">11.1 改变大小写</a></h2><ul>
<li>~: 反转光标所在字符的大小写。</li>
<li>可视模式下的U或u：把选中的文本变为大写或小写。</li>
<li>gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如gu5j，把当前行和下面四行全部变成小写。</li>
</ul>
<h2 id="11-2-替换（normal模式）"><a href="#11-2-替换（normal模式）" class="headerlink" title="11.2 替换（normal模式）"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id94" target="_blank" rel="noopener">11.2 替换（normal模式）</a></h2><ul>
<li>r: 替换光标处的字符，同样支持汉字。</li>
<li>R: 进入替换模式，按esc回到正常模式。</li>
</ul>
<h2 id="11-3-撤消与重做（normal模式）"><a href="#11-3-撤消与重做（normal模式）" class="headerlink" title="11.3 撤消与重做（normal模式）"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id95" target="_blank" rel="noopener">11.3 撤消与重做（normal模式）</a></h2><ul>
<li>[n] u: 取消一(n)个改动。</li>
<li>:undo 5 – 撤销5个改变。</li>
<li>:undolist – 你的撤销历史。</li>
<li>ctrl + r: 重做最后的改动。</li>
<li>U: 取消当前行中所有的改动。</li>
<li>:earlier 4m – 回到4分钟前</li>
<li>:later 55s – 前进55秒</li>
</ul>
<h2 id="11-4-宏"><a href="#11-4-宏" class="headerlink" title="11.4 宏"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id96" target="_blank" rel="noopener">11.4 宏</a></h2><ul>
<li>. –重复上一个编辑动作</li>
<li>qa：开始录制宏a（键盘操作记录）</li>
<li>q：停止录制</li>
<li>@a：播放宏a</li>
</ul>
<h1 id="12-编辑特殊文件"><a href="#12-编辑特殊文件" class="headerlink" title="12. 编辑特殊文件"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id97" target="_blank" rel="noopener">12. 编辑特殊文件</a></h1><h2 id="12-1-文件加解密"><a href="#12-1-文件加解密" class="headerlink" title="12.1 文件加解密"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id98" target="_blank" rel="noopener">12.1 文件加解密</a></h2><ul>
<li>vim -x file: 开始编辑一个加密的文件。</li>
<li>:X – 为当前文件设置密码。</li>
<li>:set key= – 去除文件的密码。</li>
</ul>
<p><a href="http://www.cnblogs.com/jiqingwu/admin/vim-quick-edit.html" target="_blank" rel="noopener">这里是</a> 滇狐总结的比较高级的vi技巧。</p>
<h2 id="12-2-文件的编码"><a href="#12-2-文件的编码" class="headerlink" title="12.2 文件的编码"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id99" target="_blank" rel="noopener">12.2 文件的编码</a></h2><ul>
<li>:e ++enc=utf8 filename, 让vim用utf-8的编码打开这个文件。</li>
<li>:w ++enc=gbk，不管当前文件什么编码，把它转存成gbk编码。</li>
<li>:set fenc或:set fileencoding，查看当前文件的编码。</li>
<li>在vimrc中添加set fileencoding=ucs-bom,utf-8,cp936，vim会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936对应于gbk编码。 ucs-bom对应于windows下的文件格式。</li>
</ul>
<p>让vim 正确处理文件格式和文件编码，有赖于 <a href="http://www.cnblogs.com/jiqingwu/admin/vimrc.html" target="_blank" rel="noopener">~/.vimrc的正确配置</a></p>
<h2 id="12-3-文件格式"><a href="#12-3-文件格式" class="headerlink" title="12.3 文件格式"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id100" target="_blank" rel="noopener">12.3 文件格式</a></h2><p>大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。</p>
<ul>
<li>:e ++ff=dos filename, 让vim用dos格式打开这个文件。</li>
<li>:w ++ff=mac filename, 以mac格式存储这个文件。</li>
<li>:set ff，显示当前文件的格式。</li>
<li>在vimrc中添加set fileformats=unix,dos,mac，让vim自动识别文件格式。</li>
</ul>
<h1 id="13-编程辅助"><a href="#13-编程辅助" class="headerlink" title="13. 编程辅助"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id101" target="_blank" rel="noopener">13. 编程辅助</a></h1><h2 id="13-1-一些按键"><a href="#13-1-一些按键" class="headerlink" title="13.1 一些按键"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id102" target="_blank" rel="noopener">13.1 一些按键</a></h2><ul>
<li>gd: 跳转到局部变量的定义处；</li>
<li>gD: 跳转到全局变量的定义处，从当前文件开头开始搜索；</li>
<li>g;: 上一个修改过的地方；</li>
<li>g,: 下一个修改过的地方；</li>
<li>[[: 跳转到上一个函数块开始，需要有单独一行的{。</li>
<li>]]: 跳转到下一个函数块开始，需要有单独一行的{。</li>
<li>[]: 跳转到上一个函数块结束，需要有单独一行的}。</li>
<li>][: 跳转到下一个函数块结束，需要有单独一行的}。</li>
<li>[{: 跳转到当前块开始处；</li>
<li>]}: 跳转到当前块结束处；</li>
<li>[/: 跳转到当前注释块开始处；</li>
<li>]/: 跳转到当前注释块结束处；</li>
<li>%: 不仅能移动到匹配的(),{}或[]上，而且能在#if，#else， #endif之间跳跃。</li>
</ul>
<p>下面的括号匹配对编程很实用的。</p>
<ul>
<li>ci’, di’, yi’：修改、剪切或复制’之间的内容。</li>
<li>ca’, da’, ya’：修改、剪切或复制’之间的内容，包含’。</li>
<li>ci”, di”, yi”：修改、剪切或复制”之间的内容。</li>
<li>ca”, da”, ya”：修改、剪切或复制”之间的内容，包含”。</li>
<li>ci(, di(, yi(：修改、剪切或复制()之间的内容。</li>
<li>ca(, da(, ya(：修改、剪切或复制()之间的内容，包含()。</li>
<li>ci[, di[, yi[：修改、剪切或复制[]之间的内容。</li>
<li>ca[, da[, ya[：修改、剪切或复制[]之间的内容，包含[]。</li>
<li>ci{, di{, yi{：修改、剪切或复制{}之间的内容。</li>
<li>ca{, da{, ya{：修改、剪切或复制{}之间的内容，包含{}。</li>
<li>ci&lt;, di&lt;, yi&lt;：修改、剪切或复制&lt;&gt;之间的内容。</li>
<li>ca&lt;, da&lt;, ya&lt;：修改、剪切或复制&lt;&gt;之间的内容，包含&lt;&gt;。</li>
</ul>
<h2 id="13-2-ctags"><a href="#13-2-ctags" class="headerlink" title="13.2 ctags"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id103" target="_blank" rel="noopener">13.2 ctags</a></h2><ul>
<li>ctags -R: 生成tag文件，-R表示也为子目录中的文件生成tags</li>
<li>:set tags=path/tags – 告诉ctags使用哪个tag文件</li>
<li>:tag xyz – 跳到xyz的定义处，或者将光标放在xyz上按C-]，返回用C-t</li>
<li>:stag xyz – 用分割的窗口显示xyz的定义，或者C-w ]， 如果用C-w n ]，就会打开一个n行高的窗口</li>
<li>:ptag xyz – 在预览窗口中打开xyz的定义，热键是C-w }。</li>
<li>:pclose – 关闭预览窗口。热键是C-w z。</li>
<li>:pedit abc.h – 在预览窗口中编辑abc.h</li>
<li>:psearch abc – 搜索当前文件和当前文件include的文件，显示包含abc的行。</li>
</ul>
<p>有时一个tag可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。</p>
<ul>
<li>:[n]tnext – 下一[n]个匹配。</li>
<li>:[n]tprev – 上一[n]个匹配。</li>
<li>:tfirst – 第一个匹配</li>
<li>:tlast – 最后一个匹配</li>
<li>:tselect tagname – 打开选择列表</li>
</ul>
<p>tab键补齐</p>
<ul>
<li>:tag xyz<tab> – 补齐以xyz开头的tag名，继续按tab键，会显示其他的。</li>
<li>:tag /xyz<tab> – 会用名字中含有xyz的tag名补全。</li>
</ul>
<h2 id="13-3-cscope"><a href="#13-3-cscope" class="headerlink" title="13.3 cscope"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id104" target="_blank" rel="noopener">13.3 cscope</a></h2><ul>
<li>cscope -Rbq: 生成cscope.out文件</li>
<li>:cs add /path/to/cscope.out /your/work/dir</li>
<li>:cs find c func – 查找func在哪些地方被调用</li>
<li>:cw – 打开quickfix窗口查看结果</li>
</ul>
<h2 id="13-4-gtags"><a href="#13-4-gtags" class="headerlink" title="13.4 gtags"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id105" target="_blank" rel="noopener">13.4 gtags</a></h2><p>Gtags综合了ctags和cscope的功能。 使用Gtags之前，你需要安装GNU Gtags。 然后在工程目录运行 gtags 。</p>
<ul>
<li>:Gtags funcname 定位到 funcname 的定义处。</li>
<li>:Gtags -r funcname 查询 funcname被引用的地方。</li>
<li>:Gtags -s symbol 定位 symbol 出现的地方。</li>
<li>:Gtags -g string Goto string 出现的地方。 :Gtags -gi string 忽略大小写。</li>
<li>:Gtags -f filename 显示 filename 中的函数列表。 你可以用 :Gtags -f % 显示当前文件。</li>
<li>:Gtags -P pattern 显示路径中包含特定模式的文件。 如 :Gtags -P .h$ 显示所有头文件， :Gtags -P /vm/ 显示vm目录下的文件。</li>
</ul>
<h2 id="13-5-编译"><a href="#13-5-编译" class="headerlink" title="13.5 编译"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id106" target="_blank" rel="noopener">13.5 编译</a></h2><p>vim提供了:make来编译程序，默认调用的是make， 如果你当前目录下有makefile，简单地:make即可。</p>
<p>如果你没有make程序，你可以通过配置makeprg选项来更改make调用的程序。 如果你只有一个abc.<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java</a>文件，你可以这样设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set makeprg&#x3D;javac\ abc.java</span><br></pre></td></tr></table></figure>

<p>然后:make即可。如果程序有错，可以通过quickfix窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让vim识别错误信息。 如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:setl efm&#x3D;%A%f:%l:\ %m,%-Z%p^,%-C%.%#</span><br></pre></td></tr></table></figure>

<p>%f表示文件名，%l表示行号， %m表示错误信息，其它的还不能理解。 请参考 :help errorformat。</p>
<h2 id="13-6-快速修改窗口"><a href="#13-6-快速修改窗口" class="headerlink" title="13.6 快速修改窗口"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id107" target="_blank" rel="noopener">13.6 快速修改窗口</a></h2><p>其实是quickfix插件提供的功能， 对编译调试程序非常有用 :)</p>
<ul>
<li>:copen – 打开快速修改窗口。</li>
<li>:cclose – 关闭快速修改窗口。</li>
</ul>
<p>快速修改窗口在make程序时非常有用，当make之后：</p>
<ul>
<li>:cl – 在快速修改窗口中列出错误。</li>
<li>:cn – 定位到下一个错误。</li>
<li>:cp – 定位到上一个错误。</li>
<li>:cr – 定位到第一个错误。</li>
</ul>
<h2 id="13-7-自动补全"><a href="#13-7-自动补全" class="headerlink" title="13.7 自动补全"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id108" target="_blank" rel="noopener">13.7 自动补全</a></h2><ul>
<li>C-x C-s – 拼写建议。</li>
<li>C-x C-v – 补全vim选项和命令。</li>
<li>C-x C-l – 整行补全。</li>
<li>C-x C-f – 自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按 C-n和C-p。</li>
<li>C-x C-p 和C-x C-n – 用文档中出现过的单词补全当前的词。 直接按C-p和C-n也可以。</li>
<li>C-x C-o – 编程时可以补全关键字和函数名啊。</li>
<li>C-x C-i – 根据头文件内关键字补全。</li>
<li>C-x C-d – 补全宏定义。</li>
<li>C-x C-n – 按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。</li>
</ul>
<p>当弹出补全菜单后：</p>
<ul>
<li>C-p 向前切换成员；</li>
<li>C-n 向后切换成员；</li>
<li>C-e 退出下拉菜单，并退回到原来录入的文字；</li>
<li>C-y 退出下拉菜单，并接受当前选项。</li>
</ul>
<h2 id="13-8-多行缩进缩出"><a href="#13-8-多行缩进缩出" class="headerlink" title="13.8 多行缩进缩出"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id109" target="_blank" rel="noopener">13.8 多行缩进缩出</a></h2><ul>
<li>正常模式下，按两下&gt;;光标所在行会缩进。</li>
<li>如果先按了n，再按两下&gt;;，光标以下的n行会缩进。</li>
<li>对应的，按两下&lt;;，光标所在行会缩出。</li>
<li>如果在编辑代码文件，可以用=进行调整。</li>
<li>在可视模式下，选择要调整的代码块，按=，代码会按书写规则缩排好。</li>
<li>或者n =，调整n行代码的缩排。</li>
</ul>
<h2 id="13-9-折叠"><a href="#13-9-折叠" class="headerlink" title="13.9 折叠"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id110" target="_blank" rel="noopener">13.9 折叠</a></h2><ul>
<li>zf – 创建折叠的命令，可以在一个可视区域上使用该命令；</li>
<li>zd – 删除当前行的折叠；</li>
<li>zD – 删除当前行的折叠；</li>
<li>zfap – 折叠光标所在的段；</li>
<li>zo – 打开折叠的文本；</li>
<li>zc – 收起折叠；</li>
<li>za – 打开/关闭当前折叠；</li>
<li>zr – 打开嵌套的折行；</li>
<li>zm – 收起嵌套的折行；</li>
<li>zR (zO) – 打开所有折行；</li>
<li>zM (zC) – 收起所有折行；</li>
<li>zj – 跳到下一个折叠处；</li>
<li>zk – 跳到上一个折叠处；</li>
<li>zi – enable/disable fold;</li>
</ul>
<h1 id="14-命令行"><a href="#14-命令行" class="headerlink" title="14. 命令行"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id111" target="_blank" rel="noopener">14. 命令行</a></h1><p>normal模式下按:进入命令行模式</p>
<h2 id="14-1-命令行模式下的快捷键："><a href="#14-1-命令行模式下的快捷键：" class="headerlink" title="14.1 命令行模式下的快捷键："></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id112" target="_blank" rel="noopener">14.1 命令行模式下的快捷键：</a></h2><ul>
<li>上下方向键：上一条或者下一条命令。如果已经输入了部分命令，则找上一 条或者下一条匹配的命令。</li>
<li>左右方向键：左/右移一个字符。</li>
<li>C-w： 向前删除一个单词。</li>
<li>C-h： 向前删除一个字符，等同于Backspace。</li>
<li>C-u： 从当前位置移动到命令行开头。</li>
<li>C-b： 移动到命令行开头。</li>
<li>C-e： 移动到命令行末尾。</li>
<li>Shift-Left： 左移一个单词。</li>
<li>Shift-Right： 右移一个单词。</li>
<li>@： 重复上一次的冒号命令。</li>
<li>q： 正常模式下，q然后按’:’，打开命令行历史缓冲区， 可以像编辑文件一样编辑命令。</li>
<li>q/和q? 可以打开查找历史记录。</li>
</ul>
<h2 id="14-2-执行外部命令"><a href="#14-2-执行外部命令" class="headerlink" title="14.2 执行外部命令"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id113" target="_blank" rel="noopener">14.2 执行外部命令</a></h2><ul>
<li>:! cmd 执行外部命令。</li>
<li>:!! 执行上一次的外部命令。</li>
<li>:sh 调用shell，用exit返回vim。</li>
<li>:r !cmd 将命令的返回结果插入文件当前位置。</li>
<li>:m,nw !cmd 将文件的m行到n行之间的内容做为命令输入执行命令。</li>
</ul>
<h1 id="15-其它"><a href="#15-其它" class="headerlink" title="15. 其它"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id114" target="_blank" rel="noopener">15. 其它</a></h1><h2 id="15-1-工作目录"><a href="#15-1-工作目录" class="headerlink" title="15.1 工作目录"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id115" target="_blank" rel="noopener">15.1 工作目录</a></h2><ul>
<li>:pwd 显示vim的工作目录。</li>
<li>:cd path 改变vim的工作目录。</li>
<li>:set autochdir 可以让vim 根据编辑的文件自动切换工作目录。</li>
</ul>
<h2 id="15-2-一些快捷键（收集中）"><a href="#15-2-一些快捷键（收集中）" class="headerlink" title="15.2 一些快捷键（收集中）"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id116" target="_blank" rel="noopener">15.2 一些快捷键（收集中）</a></h2><ul>
<li>K: 打开光标所在词的manpage。</li>
<li>*: 向下搜索光标所在词。</li>
<li>g*: 同上，但部分符合即可。</li>
<li>#: 向上搜索光标所在词。</li>
<li>g#: 同上，但部分符合即可。</li>
<li>g C-g: 统计全文或统计部分的字数。</li>
</ul>
<h2 id="15-3-在线帮助"><a href="#15-3-在线帮助" class="headerlink" title="15.3 在线帮助"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id117" target="_blank" rel="noopener">15.3 在线帮助</a></h2><ul>
<li>:h(elp)或F1 打开总的帮助。</li>
<li>:help user-manual 打开用户手册。</li>
<li>命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。</li>
<li>:helptags somepath 为somepath中的文档生成索引。</li>
<li>:helpgrep 可以搜索整个帮助文档，匹配的列表显示在quickfix窗口中。</li>
<li>Ctrl+] 跳转到tag主题，Ctrl+t 跳回。</li>
<li>:ver 显示版本信息。</li>
</ul>
<h2 id="15-4-一些小功能"><a href="#15-4-一些小功能" class="headerlink" title="15.4 一些小功能"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id118" target="_blank" rel="noopener">15.4 一些小功能</a></h2><ul>
<li>简单计算器: 在插入模式下，输入C-r =，然后输入表达式，就能在 光标处得到计算结果。</li>
</ul>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>有用网站大全</title>
    <url>/2020/05/10/website1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>搞学习</p>
<p>猿学：<a href="http://yuanxue365.com/" target="_blank" rel="noopener">http://yuanxue365.com/</a><br>简书：<a href="https://www.jianshu.com/" target="_blank" rel="noopener">https://www.jianshu.com/</a><br>doyoudo：<a href="http://www.doyoudo.com/" target="_blank" rel="noopener">http://www.doyoudo.com/</a><br>好知网：<a href="http://www.howzhi.com/" target="_blank" rel="noopener">http://www.howzhi.com/</a><br>找书籍</p>
<p>ePuBw（优质电子书下载网站）：<a href="https://epubw.com/" target="_blank" rel="noopener">https://epubw.com/</a><br>鸠摩搜书：<a href="https://www.jiumodiary.com/" target="_blank" rel="noopener">https://www.jiumodiary.com/</a><br>书伴：<a href="https://bookfere.com/" target="_blank" rel="noopener">https://bookfere.com/</a><br>ePUBee电子书库：<a href="http://cn.epubee.com/books/" target="_blank" rel="noopener">http://cn.epubee.com/books/</a><br>超星读书：<a href="http://book.chaoxing.com/" target="_blank" rel="noopener">http://book.chaoxing.com/</a><br>Owllook：<a href="https://www.owllook.net/" target="_blank" rel="noopener">https://www.owllook.net/</a><br>书格：<a href="https://new.shuge.org/" target="_blank" rel="noopener">https://new.shuge.org/</a><br>相识电子书：<a href="http://m.xiangshi123.com/" target="_blank" rel="noopener">http://m.xiangshi123.com/</a><br>冷知识 / 黑科技</p>
<p>全球网络攻击实时地图：<a href="https://cybermap.kaspersky.com/" target="_blank" rel="noopener">https://cybermap.kaspersky.com/</a><br>毒鸡汤：<a href="http://www.nows.fun/" target="_blank" rel="noopener">http://www.nows.fun/</a><br>微景天下：<a href="http://www.vizen.cn/" target="_blank" rel="noopener">http://www.vizen.cn/</a><br>果汁排行榜（生活中各种各样的排行榜）：<a href="http://guozhivip.com/rank/" target="_blank" rel="noopener">http://guozhivip.com/rank/</a><br>小鸡词典（查网络流行语）：<a href="https://jikipedia.com/" target="_blank" rel="noopener">https://jikipedia.com/</a><br>中国妖怪百集：<a href="http://www.cbaigui.com/" target="_blank" rel="noopener">http://www.cbaigui.com/</a><br>全球电视直播：<a href="http://tvvtvv.com/" target="_blank" rel="noopener">http://tvvtvv.com/</a><br>百度企业信用：<a href="https://xin.baidu.com/" target="_blank" rel="noopener">https://xin.baidu.com/</a><br>爱航天网：<a href="http://www.aihangtian.com/" target="_blank" rel="noopener">http://www.aihangtian.com/</a><br>写代码</p>
<p>源码之家_站长下载：<a href="http://down.chinaz.com/" target="_blank" rel="noopener">http://down.chinaz.com/</a><br>找图片</p>
<p>高清壁纸网站：<a href="https://wall.alphacoders.com/?lang=Chinese" target="_blank" rel="noopener">https://wall.alphacoders.com/?lang=Chinese</a><br>资源搜索</p>
<p>大力盘搜索：<a href="https://dalipan.com/" target="_blank" rel="noopener">https://dalipan.com/</a><br>写代码</p>
<p>程序员在线工具：<a href="https://tool.lu/" target="_blank" rel="noopener">https://tool.lu/</a><br>菜鸟工具：<a href="https://c.runoob.com/" target="_blank" rel="noopener">https://c.runoob.com/</a><br>toolfk：<a href="https://www.toolfk.com/" target="_blank" rel="noopener">https://www.toolfk.com/</a><br>小工具</p>
<p>Softonic（软件下载）：<a href="https://en.softonic.com/" target="_blank" rel="noopener">https://en.softonic.com/</a><br>PC下载网（软件下载）<a href="https://www.pcsoft.com.cn/" target="_blank" rel="noopener">https://www.pcsoft.com.cn/</a><br>GitMind（在线思维导图）：<a href="https://gitmind.cn/" target="_blank" rel="noopener">https://gitmind.cn/</a><br>MindLine思维导图：<a href="https://www.mindline.cn/" target="_blank" rel="noopener">https://www.mindline.cn/</a><br>draw.io（在线流程图制作）：<a href="https://app.diagrams.net/" target="_blank" rel="noopener">https://app.diagrams.net/</a><br>站长素材：<a href="http://sc.chinaz.com/" target="_blank" rel="noopener">http://sc.chinaz.com/</a><br>第一PPT：<a href="http://www.1ppt.com/" target="_blank" rel="noopener">http://www.1ppt.com/</a><br>waifu2x（图片拉伸提升画质）：<a href="http://waifu2x.udp.jp" target="_blank" rel="noopener">http://waifu2x.udp.jp</a><br>文字云：<a href="https://wordart.com/" target="_blank" rel="noopener">https://wordart.com/</a><br>Akuziti （汉字转换艺术字体效果）：<a href="http://www.akuziti.com/" target="_blank" rel="noopener">http://www.akuziti.com/</a><br>Ezgif（GIF动画编辑工具，视频转GIF）：<a href="https://ezgif.com/" target="_blank" rel="noopener">https://ezgif.com/</a><br>ProcessOn（在线作图工具）：<a href="https://www.processon.com/mindmap" target="_blank" rel="noopener">https://www.processon.com/mindmap</a><br>导航页（工具集）</p>
<p>炫猿：<a href="https://xydh.fun/" target="_blank" rel="noopener">https://xydh.fun/</a><br>国内外网站的导航站：<a href="https://www.egouz.com/" target="_blank" rel="noopener">https://www.egouz.com/</a><br>AnywhereAnything：<a href="http://lackar.com/aa/" target="_blank" rel="noopener">http://lackar.com/aa/</a><br>兔二工具：<a href="https://www.tool2.cn/" target="_blank" rel="noopener">https://www.tool2.cn/</a><br>现实君工具箱：<a href="http://tool.uixsj.cn/" target="_blank" rel="noopener">http://tool.uixsj.cn/</a><br>工具123：<a href="http://www.gjw123.com/" target="_blank" rel="noopener">http://www.gjw123.com/</a><br>nicetool：<a href="http://www.nicetool.net/" target="_blank" rel="noopener">http://www.nicetool.net/</a><br>一个工具箱：<a href="http://www.atoolbox.net/" target="_blank" rel="noopener">http://www.atoolbox.net/</a><br>孟坤工具箱：<a href="http://tool.mkblog.cn/" target="_blank" rel="noopener">http://tool.mkblog.cn/</a><br>网站直通车：<a href="http://www.wangzhanztc.com/" target="_blank" rel="noopener">http://www.wangzhanztc.com/</a><br>实用工具大全：<a href="https://tool.520101.com/" target="_blank" rel="noopener">https://tool.520101.com/</a><br>听音乐</p>
<p>墨灵音乐：<a href="https://music.qugeek.com/" target="_blank" rel="noopener">https://music.qugeek.com/</a><br>音乐搜索器：<a href="http://www.xieqian.vip/music/" target="_blank" rel="noopener">http://www.xieqian.vip/music/</a><br>51APE无损乐下载：<a href="http://www.51ape.com/" target="_blank" rel="noopener">http://www.51ape.com/</a><br>超高无损音乐下载：<a href="https://www.sq688.com/" target="_blank" rel="noopener">https://www.sq688.com/</a><br>看视频</p>
<p>美剧星球：<a href="http://www.meijuxingqiu.com/" target="_blank" rel="noopener">http://www.meijuxingqiu.com/</a><br>zzzfun动漫网<br>麻辣黑科技影视：<a href="http://dy.27234.cn/" target="_blank" rel="noopener">http://dy.27234.cn/</a><br>美剧17：<a href="http://meiju17.com/index.php/vod/show/by/time/" target="_blank" rel="noopener">http://meiju17.com/index.php/vod/show/by/time/</a><br>二次元宅男腐女（F站）：<a href="http://fuliqu.com/" target="_blank" rel="noopener">http://fuliqu.com/</a><br>原博客再更新，可能就没了，之后将持续更新本篇博客<br>————————————————<br>版权声明：本文为CSDN博主「爪白白」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_43901693/java/article/details/104750730" target="_blank" rel="noopener">https://blog.csdn.net/qq_43901693/java/article/details/104750730</a></p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>人工智能2</title>
    <url>/2020/05/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>人工智能5</title>
    <url>/2020/05/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>人工智能3</title>
    <url>/2020/05/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>人工智能6</title>
    <url>/2020/05/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>人工智能4</title>
    <url>/2020/05/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD4/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>人工智能8</title>
    <url>/2020/05/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>人工智能9</title>
    <url>/2020/05/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD9/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>人工智能7</title>
    <url>/2020/05/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD7/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>动态规划之智能存储</title>
    <url>/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%99%BA%E8%83%BD%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304. 二维区域和检索 - 矩阵不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">304. 二维区域和检索 - 矩阵不可变</a></h2><p>难度中等79收藏分享切换为英文关注反馈</p>
<p>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (<em>row</em>1, <em>col</em>1) ，右下角为 (<em>row</em>2, <em>col</em>2)。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/images/304.png" alt="Range Sum Query 2D"><br>上图子矩阵左上角 (row1, col1) = <strong>(2, 1)</strong> ，右下角(row2, col2) = <strong>(4, 3)，</strong>该子矩形内元素的总和为 8。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D; [</span><br><span class="line">  [3, 0, 1, 4, 2],</span><br><span class="line">  [5, 6, 3, 2, 1],</span><br><span class="line">  [1, 2, 0, 1, 5],</span><br><span class="line">  [4, 1, 0, 1, 7],</span><br><span class="line">  [1, 0, 3, 0, 5]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sumRegion(2, 1, 4, 3) -&gt; 8</span><br><span class="line">sumRegion(1, 1, 2, 2) -&gt; 11</span><br><span class="line">sumRegion(1, 2, 2, 4) -&gt; 12</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li><p>你可以假设矩阵不可变。</p>
</li>
<li><p>会多次调用 <em>sumRegion</em> 方法<em>。</em></p>
</li>
<li><p>你可以假设 <em>row</em>1 ≤ <em>row</em>2 且 <em>col</em>1 ≤ <em>col</em>2。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> r=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> c=matrix[<span class="number">0</span>].length;</span><br><span class="line">        dp=<span class="keyword">new</span> <span class="keyword">int</span>[r+<span class="number">1</span>][c+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j+<span class="number">1</span>]+dp[i+<span class="number">1</span>][j]+matrix[i][j]-dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[row2+<span class="number">1</span>][col2+<span class="number">1</span>]-dp[row1][col2+<span class="number">1</span>]-dp[row2+<span class="number">1</span>][col1]+dp[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>动态规划之最长上升子序列问题</title>
    <url>/2020/04/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">139. 单词拆分</a></h2><p>难度中等388收藏分享切换为英文关注反馈</p>
<p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict*，判定 *s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p><strong>说明：</strong></p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.dp solution so slow</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set &lt;String&gt; w=<span class="keyword">new</span> HashSet(wordDict);</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp= <span class="keyword">new</span> <span class="keyword">boolean</span>[len+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; w.contains(s.substring(j,i)))&#123;</span><br><span class="line">                    dp[i]=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.bfs真香</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; wordDictSet=<span class="keyword">new</span> HashSet(wordDict);</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        queue.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = queue.remove();</span><br><span class="line">            <span class="keyword">if</span> (visited[start] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (wordDictSet.contains(s.substring(start, end))) &#123;</span><br><span class="line">                        queue.add(end);</span><br><span class="line">                        <span class="keyword">if</span> (end == s.length()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[start] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></h2><p>难度中等639收藏分享切换为英文关注反馈</p>
<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>
<li>你算法的时间复杂度应该为 O(<em>n2</em>) 。</li>
</ul>
<p><strong>进阶:</strong> 你能将算法的时间复杂度降低到 O(<em>n</em> log <em>n</em>) 吗?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dp真慢</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">int</span> maxans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxval=<span class="number">0</span>; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])</span><br><span class="line">                    maxval=Math.max(maxval,dp[j]);</span><br><span class="line">            dp[i]=maxval+<span class="number">1</span>;</span><br><span class="line">            maxans=Math.max(maxans,dp[i]);        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//binary search加dp真香</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = Arrays.binarySearch(dp, <span class="number">0</span>, len, num);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                i = -(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = num;</span><br><span class="line">            <span class="keyword">if</span> (i == len) &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>动态规划之背包问题</title>
    <url>/2020/04/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h2><p>难度中等547收藏分享切换为英文关注反馈</p>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>。 贪心+dfs非常快</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        coinChange(coins.length-<span class="number">1</span>, coins, <span class="number">0</span>, amount);</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] coins, <span class="keyword">int</span> count, <span class="keyword">int</span> needAmount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needAmount == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = Math.min(count, ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = needAmount / coins[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=i; k&gt;=<span class="number">0</span> &amp;&amp; count+k&lt;ans; k--) &#123;</span><br><span class="line">            coinChange(index-<span class="number">1</span>, coins, count+k, needAmount-k*coins[index]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>.动态规划第二快</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, max);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">          dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>.递归升级版很慢</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> coinChange(coins, amount, <span class="keyword">new</span> <span class="keyword">int</span>[amount]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> rem, <span class="keyword">int</span>[] count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rem &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rem == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (count[rem - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">      <span class="keyword">int</span> res = coinChange(coins, rem - coin, count);</span><br><span class="line">      <span class="keyword">if</span> (res &gt;= <span class="number">0</span> &amp;&amp; res &lt; min)</span><br><span class="line">        min = <span class="number">1</span> + res;</span><br><span class="line">    &#125;</span><br><span class="line">    count[rem - <span class="number">1</span>] = (min == Integer.MAX_VALUE) ? -<span class="number">1</span> : min;</span><br><span class="line">    <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>自底向上dp自己写的</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=amount+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        Arrays.fill(dp, max);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;max;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> coin: coins)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=coin)&#123;</span><br><span class="line">                    dp[i]=Math.min(dp[i],dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dp[amount]&gt;amount)? -<span class="number">1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a></h2><p>难度中等246收藏分享切换为英文关注反馈</p>
<p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>注意:</strong></p>
<ol>
<li>每个数组中的元素不会超过 100</li>
<li>数组的大小不会超过 200</li>
</ol>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure>



<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. dfs+剪枝</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//涉及到剪枝的问题，先排个序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//算出SUM(S)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">            sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//奇数肯定不行</span></span><br><span class="line">        <span class="keyword">if</span> ((sum % <span class="number">2</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//搜索</span></span><br><span class="line">        <span class="keyword">return</span> canPartition(nums, nums.length-<span class="number">1</span>, sum, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DFS idx为当前元素，had为待接受上限，pass为待丢弃上限</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx, <span class="keyword">int</span> had, <span class="keyword">int</span> pass)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到可行解</span></span><br><span class="line">        <span class="keyword">if</span> (had == <span class="number">0</span> || pass == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (had &lt; <span class="number">0</span> || pass &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续搜索</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> canPartition(nums, idx-<span class="number">1</span>, had-nums[idx], pass) || canPartition(nums, idx-<span class="number">1</span>, had, pass-nums[idx]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为“0-1 背包问题”，它的特点是：“每个数只能用一次”。思路是：物品一个一个选，容量也一点一点放大考虑（这一点是“动态规划”的思想，特别重要）。</p>
<p>如果在实际生活中，其实我们也是这样做的，一个一个尝试把候选物品放入“背包”，看什么时候能容纳的价值最大。</p>
<p>具体做法是：画一个 len 行，target + 1 列的表格。这里 len 是物品的个数，target 是背包的容量。len 行表示一个一个物品考虑，target + 1多出来的那 1 列，表示背包容量从 0 开始，很多时候，我们需要考虑这个容量为 0 的数值。</p>
<p>状态定义：dp[i][j]表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和恰好等于 j。<br>状态转移方程：很多时候，状态转移方程思考的角度是“分类讨论”，对于“0-1 背包问题”而言就是“当前考虑到的数字选与不选”。<br>1、不选择 nums[i]，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；</p>
<p>2、选择 nums[i]，如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。</p>
<p>状态转移方程是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] or dp[i - <span class="number">1</span>][j - nums[i]]</span><br></pre></td></tr></table></figure>



<p>一般写出状态转移方程以后，就需要考虑边界条件（一般而言也是初始化条件）。</p>
<p>1、j - nums[i] 作为数组的下标，一定得保证大于等于 0 ，因此 nums[i] &lt;= j；<br>2、注意到一种非常特殊的情况：j 恰好等于 nums[i]，即单独 nums[j] 这个数恰好等于此时“背包的容积” j，这也是符合题意的。</p>
<p>作者：liweiwei1419<br>链接：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. dp解法 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)</span><br><span class="line">            sum+=num;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[len][target+<span class="number">1</span>];<span class="comment">//row: 0 to len-1 ,col:0 to target</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&lt;=target)</span><br><span class="line">            dp[<span class="number">0</span>][nums[<span class="number">0</span>]]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;target+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j];<span class="comment">//copy the previous answer</span></span><br><span class="line">                <span class="keyword">if</span>(j==nums[i])&#123;</span><br><span class="line">                    dp[i][j]=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&lt;j)&#123;</span><br><span class="line">                    dp[i][j]= dp[i-<span class="number">1</span>][j] || dp[i-<span class="number">1</span>][j-nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.dp优化，还是dfs香</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)</span><br><span class="line">            sum+=num;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[target+<span class="number">1</span>];<span class="comment">//row: 0 to len-1 ,col:0 to target</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&lt;=target)</span><br><span class="line">            dp[nums[<span class="number">0</span>]]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=target;nums[i]&lt;j;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[target])&#123;</span><br><span class="line">                    dp[j]=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j]= dp[j] || dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>动态规划之最长公共子序列问题</title>
    <url>/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></h2><p>难度中等101收藏分享切换为英文关注反馈</p>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长公共子序列。</p>
<p>一个字符串的 <em>子序列</em> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0。</span><br></pre></td></tr></table></figure>



<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= text1.length &lt;= 1000</code></li>
<li><code>1 &lt;= text2.length &lt;= 1000</code></li>
<li>输入的字符串只含有小写英文字符。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c1=text1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] c2=text2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[c1.length+<span class="number">1</span>][c2.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=c1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=c2.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c1[i-<span class="number">1</span>]==c2[j-<span class="number">1</span>])</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=Math.max(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[c1.length][c2.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>动态规划之寻路问题</title>
    <url>/2020/04/18/%E5%AF%BB%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h2><p>难度中等499收藏分享切换为英文关注反馈</p>
<p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p>示例 1:</p>
<p>输入: m = 3, n = 2<br>输出: 3<br>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下</li>
<li>向右 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向右<br>示例 2:</li>
</ol>
<p>输入: m = 7, n = 3<br>输出: 28</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] nums =<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] b: nums )&#123;</span><br><span class="line">            Arrays.fill(b, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                nums[i][j]=nums[i-<span class="number">1</span>][j]+nums[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></h2><p>难度中等267收藏分享切换为英文关注反馈</p>
<p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:</p>
<p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li>
</ol>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> col=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            obstacleGrid[i][<span class="number">0</span>]=(obstacleGrid[i][<span class="number">0</span>]==<span class="number">0</span> &amp;&amp; obstacleGrid[i-<span class="number">1</span>][<span class="number">0</span>]==<span class="number">1</span>)? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][j]=(obstacleGrid[<span class="number">0</span>][j]==<span class="number">0</span> &amp;&amp; obstacleGrid[<span class="number">0</span>][j-<span class="number">1</span>]==<span class="number">1</span>)? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    obstacleGrid[i][j]=obstacleGrid[i-<span class="number">1</span>][j]+obstacleGrid[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    obstacleGrid[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></h2><p>难度中等445收藏分享切换为英文关注反馈</p>
<p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//2d array</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=grid.length;</span><br><span class="line">        <span class="keyword">int</span> col=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> [][] dp=<span class="keyword">new</span> <span class="keyword">int</span> [row][col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=col-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=row-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==row-<span class="number">1</span> &amp;&amp; j !=col-<span class="number">1</span>)</span><br><span class="line">                    dp[i][j]=dp[i][j+<span class="number">1</span>]+grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==col-<span class="number">1</span> &amp;&amp; i !=row-<span class="number">1</span>)</span><br><span class="line">                    dp[i][j]=grid[i][j]+dp[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i!=row-<span class="number">1</span> &amp;&amp; j !=col-<span class="number">1</span>)</span><br><span class="line">                    dp[i][j]=grid[i][j]+Math.min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Runtime: <span class="number">3</span> ms, faster than <span class="number">24.12</span>% of Java online submissions <span class="keyword">for</span> Minimum Path Sum.</span><br><span class="line">Memory Usage: <span class="number">42.6</span> MB, less than <span class="number">72.97</span>% of Java online submissions <span class="keyword">for</span> Minimum Path Sum.</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//1d array</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = grid.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = grid[<span class="number">0</span>].length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == grid.length - <span class="number">1</span> &amp;&amp; j != grid[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">                    dp[j] = grid[i][j] +  dp[j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">                    dp[j] = grid[i][j] + dp[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j != grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">                    dp[j] = grid[i][j] + Math.min(dp[j], dp[j + <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j] = grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> Runtime: <span class="number">2</span> ms, faster than <span class="number">85.12</span>% of Java online submissions <span class="keyword">for</span> Minimum Path Sum.</span><br><span class="line">Memory Usage: <span class="number">42.1</span> MB, less than <span class="number">85.13</span>% of Java online submissions <span class="keyword">for</span> Minimum Path Sum.</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//2d array without extra space</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = grid.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = grid[<span class="number">0</span>].length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == grid.length - <span class="number">1</span> &amp;&amp; j != grid[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">                    grid[i][j] = grid[i][j] +  grid[i][j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">                    grid[i][j] = grid[i][j] + grid[i + <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j != grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">                    grid[i][j] = grid[i][j] + Math.min(grid[i + <span class="number">1</span>][j],grid[i][j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Runtime: <span class="number">3</span> ms, faster than <span class="number">24.12</span>% of Java online submissions <span class="keyword">for</span> Minimum Path Sum.</span><br><span class="line">Memory Usage: <span class="number">42.2</span> MB, less than <span class="number">83.78</span>% of Java online submissions <span class="keyword">for</span> Minimum Path Sum.</span><br></pre></td></tr></table></figure>





<h2 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></h2><p>难度中等365收藏分享切换为英文关注反馈</p>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11）。</p>
<p><strong>说明：</strong></p>
<p>如果你可以只使用 <em>O</em>(<em>n</em>) 的额外空间（<em>n</em> 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] n= <span class="keyword">new</span> <span class="keyword">int</span> [triangle.size()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=triangle.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; triangle.get(i).size();j++)&#123;</span><br><span class="line">                n[j]=Math.min(n[j],n[j+<span class="number">1</span>])+triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="931-下降路径最小和"><a href="#931-下降路径最小和" class="headerlink" title="931. 下降路径最小和"></a><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/" target="_blank" rel="noopener">931. 下降路径最小和</a></h2><p>难度中等43收藏分享切换为英文关注反馈</p>
<p>给定一个<strong>方形</strong>整数数组 <code>A</code>，我们想要得到通过 <code>A</code> 的<em>下降路径</em>的<strong>最小</strong>和。</p>
<p>下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：12</span><br><span class="line">解释：</span><br><span class="line">可能的下降路径有：</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]</code></li>
<li><code>[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]</code></li>
<li><code>[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]</code></li>
</ul>
<p>和最小的下降路径是 <code>[1,4,7]</code>，所以答案是 <code>12</code>。</p>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length == A[0].length &lt;= 100</code></li>
<li><code>-100 &lt;= A[i][j] &lt;= 100</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> best=A[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">                    best=Math.min(A[i+<span class="number">1</span>][j-<span class="number">1</span>],best);</span><br><span class="line">                <span class="keyword">if</span>(j&lt;m-<span class="number">1</span>)</span><br><span class="line">                    best=Math.min(A[i+<span class="number">1</span>][j+<span class="number">1</span>],best);</span><br><span class="line">                A[i][j]+=best;         </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:A[<span class="number">0</span>])&#123;</span><br><span class="line">            n=Math.min(i,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1289-下降路径最小和-II"><a href="#1289-下降路径最小和-II" class="headerlink" title="1289. 下降路径最小和  II"></a><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum-ii/" target="_blank" rel="noopener">1289. 下降路径最小和  II</a></h2><p>难度困难13收藏分享切换为英文关注反馈</p>
<p>给你一个整数方阵 <code>arr</code> ，定义「非零偏移下降路径」为：从 <code>arr</code> 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。</p>
<p>请你返回非零偏移下降路径数字和的最小值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：13</span><br><span class="line">解释：</span><br><span class="line">所有非零偏移下降路径包括：</span><br><span class="line">[1,5,9], [1,5,7], [1,6,7], [1,6,8],</span><br><span class="line">[2,4,8], [2,4,9], [2,6,7], [2,6,8],</span><br><span class="line">[3,4,8], [3,4,9], [3,5,7], [3,5,9]</span><br><span class="line">下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= arr.length == arr[i].length &lt;= 200</code></p>
</li>
<li><p><code>-99 &lt;= arr[i][j] &lt;= 99</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="keyword">int</span>[][] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> best=Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;m;a++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a==j)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        best=Math.min(arr[i+<span class="number">1</span>][a],best);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[i][j]+=best;         </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:arr[<span class="number">0</span>])&#123;</span><br><span class="line">            n=Math.min(i,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>二叉树之遍历</title>
    <url>/2020/04/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h2><p>难度中等477收藏分享切换为英文关注反馈</p>
<p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//recursion</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt;  res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.left, res);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.right !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.right,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//iterative</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        Stack&lt;TreeNode&gt; s= <span class="keyword">new</span> Stack();</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur=cur.left;    </span><br><span class="line">            &#125;</span><br><span class="line">            cur=s.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></h2><p>难度中等454收藏分享切换为英文关注反馈</p>
<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//recursion</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; levels= <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(level==levels.size())</span><br><span class="line">                levels.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">            levels.get(level).add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">                helper(root.left, level+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">                helper(root.right, level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> levels;</span><br><span class="line">            helper(root, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> levels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;&#x2F;&#x2F;iterative</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; levels&#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        if(root&#x3D;&#x3D;null) return levels;</span><br><span class="line">        Queue&lt;TreeNode&gt; q&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        int level&#x3D;0;</span><br><span class="line">        while(!q.isEmpty())&#123;</span><br><span class="line">            levels.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">            int level_l&#x3D; q.size();</span><br><span class="line">            for(int i&#x3D;0; i&lt;level_l;i++)&#123;</span><br><span class="line">                TreeNode n&#x3D;q.remove();</span><br><span class="line">                levels.get(level).add(n.val);</span><br><span class="line">                if(n.left !&#x3D;null) q.add(n.left);</span><br><span class="line">                if(n.right !&#x3D;null) q.add(n.right);</span><br><span class="line">            &#125;  </span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        return levels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103. 二叉树的锯齿形层次遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. 二叉树的锯齿形层次遍历</a></h2><p>难度中等183收藏分享切换为英文关注反馈</p>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回锯齿形层次遍历如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>小甲鱼之c++</title>
    <url>/2020/04/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E4%B9%8Bc/</url>
    <content><![CDATA[<h2 id="P1-C-和OO思想"><a href="#P1-C-和OO思想" class="headerlink" title="P1:C++和OO思想"></a>P1:C++和OO思想</h2><p>经典面向对象java 一样封装继承多态</p>
<h2 id="P2-P4-从小程序说起"><a href="#P2-P4-从小程序说起" class="headerlink" title="P2-P4:从小程序说起"></a>P2-P4:从小程序说起</h2><p>1.类，异常，对象都是c++特有的</p>
<ol start="2">
<li><p>整形数组求和：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">addArray</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n)</span></span>;<span class="comment">//在main用前需要声明</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> data[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">size</span>=<span class="keyword">sizeof</span>(data)/<span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"data size: %ld\n"</span>,<span class="keyword">sizeof</span>(data));<span class="comment">//不要用%d，c99报错</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"answer :%d\n"</span>,addArray(data,<span class="built_in">size</span>));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">addArray</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"data size: %ld\n"</span>,<span class="keyword">sizeof</span>(<span class="built_in">array</span>));</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">       sum+=<span class="built_in">array</span>[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/*data size: 40</span></span><br><span class="line"><span class="comment">   data size: 8</span></span><br><span class="line"><span class="comment">   answer :45</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c++版本</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>带你学c带你飞（day1）小甲鱼视频</title>
    <url>/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9E/</url>
    <content><![CDATA[<h2 id="P1"><a href="#P1" class="headerlink" title="P1"></a>P1</h2><p>打广告</p>
<h2 id="P2"><a href="#P2" class="headerlink" title="P2"></a>P2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.所有的 C 语言程序都需要包含 main() 函数。 代码从 main() 函数开始执行。</span><br><span class="line"></span><br><span class="line">2.&#x2F;* ... *&#x2F; 用于注释说明。</span><br><span class="line"></span><br><span class="line">3.printf() 用于格式化输出到屏幕。printf() 函数在 &quot;stdio.h&quot; 头文件中声明。</span><br><span class="line"></span><br><span class="line">4.stdio.h 是一个头文件 (标准输入输出头文件) , #include 是一个预处理命令，用来引入头文件。 当编译器遇到 printf() 函数时，如果没有找到 stdio.h 头文件，会发生编译错误。</span><br><span class="line"></span><br><span class="line">5.return 0; 语句用于表示退出程序。</span><br></pre></td></tr></table></figure>

<h2 id="P3"><a href="#P3" class="headerlink" title="P3"></a>P3</h2><p>打印 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">print</span>\</span><br><span class="line">f(<span class="string">"hi"</span>&#125;)<span class="comment">//反斜杠表示读下一行开头，可以运行，换行符\n;</span></span><br></pre></td></tr></table></figure>

<h2 id="p4"><a href="#p4" class="headerlink" title="p4"></a>p4</h2><p>变量名：英文字母数字，下划线组成，开头必须是字母下划线。</p>
<p>c有32个关键字</p>
<p>第一类：数 据类型关键 字</p>
<p>A基本数据类 型（5个）：</p>
<p>void： 声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果。</p>
<p>char： 字符型类型数据，属于整型数据的一种。</p>
<p>int： 整型数据，通常为编译器指定的机器字长。</p>
<p>float： 单精度浮点型数据，属于浮点数据的一种，小数点后保存6位。</p>
<p>double： 双精度浮点型数据，属于浮点数据的一种，比float保存的精度高，小数点后保存15/16位。</p>
<p>B类型修饰关 键字（4个）：</p>
<p>short ：修饰int，短整型数据，可省略被修饰的int。 </p>
<p>long ：修饰int，长整形数据，可省略被修饰的int。 </p>
<p>signed ：修饰整型数据，有符号数据类型。 </p>
<p>unsigned： 修饰整型数据，无符号数据类型。</p>
<p>C复杂类型关 键字（5个）：</p>
<p>struct ：结构体声明。 </p>
<p>union ：共用体声明。 </p>
<p>enum ：枚举声明。 </p>
<p>typedef ：声明类型别名。 </p>
<p>sizeof ：得到特定类型或特定类型变量的大小。</p>
<p>D存储级别关 键字（6个）：</p>
<p>auto ：指定为自动变量，由编译器自动分配及释放。通常在栈上分配。 </p>
<p>static ：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部。 </p>
<p>register ：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通 过寄存器而不是堆栈传递参数。 </p>
<p>extern ：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的。 </p>
<p>const ：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改 </p>
<p>volatile ：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存 中取得该变量的值。</p>
<p>第二类：流 程控制关键 字</p>
<p>A跳转结构（4 个）：</p>
<p>return ：用在函数体中，返回特定值（或者是void值，即不返回值）。 </p>
<p>continue： 结束当前循环，开始下一轮循环。 </p>
<p>break ：跳出当前循环或switch结构。 </p>
<p>goto ：无条件跳转语句。</p>
<p>B分支结构（5 个）：</p>
<p>if ：条件语句。 </p>
<p>else： 条件语句否定分支（与if连用）。 </p>
<p>switch： 开关语句（多重分支语句）。 </p>
<p>case ：开关语句中的分支标记。 </p>
<p>default： 开关语句中的“其他”分治，可选。</p>
<p>C循环结构（3 个）：</p>
<p>for ：for循环结构，for(1;2;3)4;的执行顺序为1-&gt;2-&gt;4-&gt;3-&gt;2…循环，其中2为循环条件。 </p>
<p>do：do循环结构，do 1 while(2);的执行顺序是1-&gt;2-&gt;1…循环，2为循环条件。 </p>
<p>while： while循环结构，while(1) 2;的执行顺序是1-&gt;2-&gt;1…循环，1为循环条件， 以上循环语句，当循环条件 表达式为真则继续循环，为假则跳出循环。</p>
<p>c99新增5个关键字</p>
<p>1、<strong>inline</strong>关键字用来定义一个类的内联函数，引入它的主要原因是用它替代C中表达式形式的宏定义</p>
<p>引入原因：C语言是一个效率很高的语言，这种宏定义在形式及使用上像一个函数，但它使用预处理器实现，没有了<strong>参数压栈，代码生成</strong>等一系列的操作</p>
<p>2、<strong>restrict</strong>关键字只用于限定指针；该关键字用于告知编译器，所有修改该指针所指向内容的操作全部都是基于(base on)该指针的，即不存在其它进行修改操作的途径；这样的后果是帮助编译器进行更好的代码优化，生成更有效率的汇编代码。</p>
<p>3、<strong>_Bool</strong>关键字是用于表示布尔值。包含标准头文件 stdbool.h 后，我们可以用 bool 代替 _Bool ，true 代替 1 ，false 代替 0 。</p>
<p>4、<strong>_Complex</strong>and<strong>_Imaginary</strong>关键字</p>
<p>C99标准中定义的复数类型如下：float_Complex; float_Imaginary; double_Complex; double_Imaginary; long double_Complex; long double_Imaginary.</p>
<p>头文件中定义了complex和imaginary宏,并将它们扩展为_Complex和_Imaginary,因此在编写新的应用程序时,应该使用头文件中的complex和imaginary宏。</p>
<p><strong>C语言32个关键字（C99新增5个、C11新增7个）</strong></p>
<p>按年份起始：</p>
<p><strong>auto break case char const continue default do</strong> <strong>double else enum extern float for goto if</strong> <strong>int long register return short signed sizeof static</strong> <strong>struct switch typedef union unsigned void volatile while</strong>1999年12月16日，ISO推出了C99标准，该标准新增了5个C语言关键字：</p>
<p>inline restrict _Bool _Complex _Imaginary2011年12月8日，ISO发布C语言的新标准C11，该标准新增了7个C语言关键字：</p>
<p>_Alignas _Alignof _Atomic _Static_assert _Noreturn _Thread_local _Generic</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%d<span class="comment">//int</span></span><br><span class="line">%c<span class="comment">//char</span></span><br><span class="line">%<span class="number">11.9</span><span class="comment">//11位，小数点后9位</span></span><br><span class="line">gcc test.c -o test &amp;&amp; ./test <span class="comment">//这个-o可以改a.out为你想要的名字， 用&amp;&amp;可以合并编译运行两个阶段，而/ 的意思：目录级别分隔符</span></span><br><span class="line">. 的意思：当前目录</span><br><span class="line">./a 的意思就是：当前目录下文件名为“a”的文件。</span><br><span class="line">Linux中还有 .. 代表上抄级目录</span><br></pre></td></tr></table></figure>

<h2 id="P5"><a href="#P5" class="headerlink" title="P5"></a>P5</h2><p>字符常量单引号，字符串常量双引号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//宏定义, 标识符全大写，宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 标识符 常量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.1415926535</span></span><br></pre></td></tr></table></figure>

<p>C++ 语言可以用const 来定义常量，也可以用#define 来定义常量。但是前者比后者有更多的优点：<br>（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。<br>（2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。规则5-2-1：在C++ 程序中只使用const 常量而不使用宏常量，即const 常量完全取代宏常量。</p>
<p>2.实现机制</p>
<p>宏是预处理命令，即在预编译阶段进行字节替换。const常量是变量，在执行时const定义的只读变量在程序运行过程中只有一份拷贝（因为它是全局的只读变量，存放在静态存储区的只读数据区。根据c/c++语法，当你声明该量为常量，即告诉程序和编译器，你不希望此量被修改。 程序的实现，为了保护常量，特将常量都放在受保护的静态存储区内。凡是试图修改这个区域内的值，都将被视为非法，并报错。 这不能理解为凡是字符串都是放在静态存储区域的。这个跟数据类型没有关系，而是这个量是变量还是常量的问题。例如，一个字符串变量就是可以被修改的。 这种静态存储区域的保护机制是由编译器实现的，而非存储该值的内存的电器属性。换言之，实质上内存永远都可以被用户随意修改，只是编译器给用户的代码注入了一些自己的保护代码，通过软件手段将这段内存软保护起来。这种保护在汇编级别可以轻松突破，其保护也就无效了。）。</p>
<p>3.用法区别</p>
<p>define宏定义和const常变量区别：<br>1.define是宏定义，程序在预处理阶段将用define定义的内容进行了替换。因此程序运行时，常量表中并没有用define定义的常量，系统不为它分配内存。const定义的常量，在程序运行时在常量表中，系统为它分配内存。<br>2.define定义的常量，预处理时只是直接进行了替换。所以编译时不能进行数据类型检验。const定义的常量，在编译时进行严格的类型检验，可以避免出错。3.define定义表达式时要注意“边缘效应”，例如如下定义：<br>#define N 2+3 //我们预想的N值是5，我们这样使用N，int a = N/2; //我们预想的a的值是2.5，可实际上a的值是3.5原因在于在预处理阶段，编译器将 a = N/2处理成了 a = 2+3/2；这就是宏定义的字符串替换的“边缘效应”因此要如下定义：#define N (2+3)。const定义表达式没有上述问题。const定义的常量叫做常变量原因有二：const定义常量像变量一样检查类型；const可以在任何地方定义常量，编译器对它的处理过程与变量相似，只是分配内存的地方不同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">字符串常量， <span class="string">'\0'</span>遇到这个会知道字符串结束了</span><br></pre></td></tr></table></figure>



<h2 id="P6"><a href="#P6" class="headerlink" title="P6"></a>P6</h2><p>C语言数据类型的分类方式如下：</p>
<ul>
<li>基本类型<ul>
<li>标准整数类型，以及扩充的整数类型</li>
<li>实数浮点类型，以及复数浮点类型</li>
</ul>
</li>
<li>枚举类型</li>
<li>void类型</li>
<li>派生类型<ul>
<li>指针类型</li>
<li>数组类型</li>
<li>结构类型</li>
</ul>
</li>
<li>联合类型</li>
<li>函数类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(a);<span class="comment">//return size of a</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span>);<span class="comment">//return 4单位是字节</span></span><br></pre></td></tr></table></figure>

<p>objective-c 中的BOOL 实际上是一种对带符号的字符类型（signed char）的类型定义（typedef），它使用8位的存储空间。通过#define指令把YES定义为1，NO定义为0。</p>
<p>C99标准定义了一个新的关键字_Bool，提供了布尔类内型。以前，C程序员总是使用自己的方法定义布尔类型。0表示false，非0表示true。</p>
<p>可能使用char类型表示一个布尔类型，也可能使用int类型表示一个布尔类型。</p>
<p>1、类型不同百 :  BOOL为int型 , bool为布尔型  </p>
<p>2、长度不同 : bool只有一个字节 , BOOL长度视实际环境来定，一般可认为是4个字节 </p>
<p>3、取值不同 :bool取值false和true，是0和1的区别； false可以代表0，但true有很多种，并非度只有1。  </p>
<p>4、bool表示布尔型变量，也就是逻辑型变量的定义符，以英国数学家、布尔代数的奠基人乔治·布尔（George Boole）命名。</p>
<p>总结bool是true，false，而_Bool is 0,1 但是都是1字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sign <span class="keyword">unsigned</span><span class="comment">//带符号不带符号，如果不用会引发栈溢出栈泄露</span></span><br></pre></td></tr></table></figure>

<h2 id="P7"><a href="#P7" class="headerlink" title="P7"></a>P7</h2><p>printf是输出一个字符串，putchar输出一个char。</p>
<p>printf格式字符：</p>
<table>
<thead>
<tr>
<th>打印格式</th>
<th>对应数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>int</td>
<td>接受整数值并将它表示为有符号的十进制整数</td>
</tr>
<tr>
<td>%hd</td>
<td>short int</td>
<td>短整数</td>
</tr>
<tr>
<td>%hu</td>
<td>unsigned short</td>
<td>无符号短整数</td>
</tr>
<tr>
<td>%o</td>
<td>unsigned int</td>
<td>无符号8进制整数</td>
</tr>
<tr>
<td>%u</td>
<td>unsigned int</td>
<td>无符号10进制整数</td>
</tr>
<tr>
<td>%x,%X</td>
<td>unsigned int</td>
<td>无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF</td>
</tr>
<tr>
<td>%f</td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td>%lf</td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td>%e,%E</td>
<td>double</td>
<td>科学计数法表示的数，此处”e”的大小写代表在输出时用的”e”的大小写</td>
</tr>
<tr>
<td>%c</td>
<td>char</td>
<td>字符型。可以把输入的数字按照ASCII码相应转换’对应的字符</td>
</tr>
<tr>
<td>%s</td>
<td>char *</td>
<td>字符串。输出字符串中的字符直至字符串中的空字符（字符串以’\0‘结尾，这个’\0’即空字符）</td>
</tr>
<tr>
<td>%p</td>
<td>void *</td>
<td>以16进制形式输出指针</td>
</tr>
<tr>
<td>%%</td>
<td>%</td>
<td>输出一个百分号</td>
</tr>
</tbody></table>
<p> %d  整形 int</p>
<p> %f  浮点型 float</p>
<p> %c  字符型  char </p>
<p> %hd 短整型  short</p>
<p> %ld  长整形  long</p>
<p> %lld  长长整形  long long </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1b</span>it=<span class="number">8</span> bytes</span><br><span class="line"><span class="built_in">pow</span>(a,b)<span class="comment">//#include &lt;math.h&gt;,一般打印需要&lt;stdio.h&gt;, a的b次方</span></span><br><span class="line">gcc -lm test.c &amp;&amp; ./a.out<span class="comment">// warning:overflow in implicit constant conversion</span></span><br><span class="line">  unsign <span class="keyword">int</span> 用%u，sign <span class="keyword">int</span>用%d</span><br></pre></td></tr></table></figure>

<p>使用math.h中声明的库函数还有一点特殊之处，gcc命令行必须加-lm选项，因为数学函数位于libm.so库文件中（这些库文件通常位于/lib目录下），-lm选项告诉编译器，我们程序中用到的数学函数要到这个库文件里找。本书用到的大部分库函数（例如printf）位于libc.so库文件中，使用libc.so中的库函数在编译时不需要加-lc选项，当然加了也不算错，因为这个选项是gcc的默认选项。</p>
<p>  C标准主要由两部分组成，一部分描述C的语法，另一部分描述C标准库。C标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型 声明和宏定义。要在一个平台上支持C语言，不仅要实现C编译器，还要实现C标准库，这样的实现才算符合C标准。不符合C标准的实现也是存在的，例如很多单 片机的C语言开发工具中只有C编译器而没有完整的C标准库。</p>
<p>在Linux平台上最广泛使用的C函数库是glibc，其中包括C标准库的实现。几乎所有C程序都要调用glibc的库函数，所以glibc是Linux平台C程序运行的基础。glibc提供一组头文件和一组库文件，最基本、最常用的C标准库函数和系统函数在libc.so库文件中，几乎所有C程序的运行都依赖于libc.so，有些做数学计算的C程序依赖于libm.so，以后我们还会看到多线程的C程序依赖于libpthread.so。以后我说libc时专指libc.so这个库文件，而说glibc时指的是glibc提供的所有库文件。</p>
<h3 id="1-原码"><a href="#1-原码" class="headerlink" title="1. 原码"></a>1. 原码</h3><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p>
<blockquote>
<p>[+1]原 = 0000 0001</p>
<p>[-1]原 = 1000 0001</p>
</blockquote>
<p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p>
<blockquote>
<p>[1111 1111 , 0111 1111]</p>
</blockquote>
<p>即</p>
<blockquote>
<p>[-127 , 127]</p>
</blockquote>
<p>原码是人脑最容易理解和计算的表示方式.</p>
<h3 id="2-反码"><a href="#2-反码" class="headerlink" title="2. 反码"></a>2. 反码</h3><p>反码的表示方法是:</p>
<p>正数的反码是其本身</p>
<p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反</p>
<p>[-1] = [10000001]原 = [11111110]反</p>
</blockquote>
<p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p>
<h3 id="3-补码"><a href="#3-补码" class="headerlink" title="3. 补码"></a>3. 补码</h3><p>补码的表示方法是:</p>
<p>正数的补码就是其本身</p>
<p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p>
<h2 id="P8"><a href="#P8" class="headerlink" title="P8"></a>P8</h2><p>字符用ASCII字符表写的，常用的ascii: 空格的ASCII码值为32；数字0到9的ASCII码值分别为48到57；大写字母“A”到“Z”的ASCII码值分别为65到90；小写字母“a”到“z”的ASCII码值分别为97到到122。</p>
<p>字符类型是特殊的整型，ascii有0-255个字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="number">170</span>；<span class="comment">//这是正数，若不用unsigned，则是负数</span></span><br></pre></td></tr></table></figure>

<p>字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[length];<span class="comment">//0 to length-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//经典问题</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">2</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hi\n"</span>);<span class="comment">//会出现错误，因为字符数组a没有\0,改法： char a[3]=&#123;'a','b'，'\0'&#125;;</span></span><br><span class="line"><span class="keyword">char</span> a[]=<span class="string">"hi"</span>;<span class="comment">//字符串常量</span></span><br></pre></td></tr></table></figure>

<h2 id="P9"><a href="#P9" class="headerlink" title="P9"></a>P9</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>/<span class="number">3</span>=<span class="number">1</span></span><br><span class="line"><span class="number">5</span>%<span class="number">3</span>=<span class="number">2</span></span><br><span class="line"><span class="number">5.0</span>%<span class="number">3.0</span><span class="comment">//出错</span></span><br><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line"> <span class="number">1</span>+<span class="number">2.0</span>;<span class="comment">//-&gt;1.0+2.0</span></span><br><span class="line"> <span class="number">1</span>+(<span class="keyword">int</span>)<span class="number">2.0</span>;<span class="comment">//-&gt;3 </span></span><br><span class="line"><span class="number">1</span>+(<span class="keyword">int</span>)<span class="number">1.8</span>;<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h2 id="P10"><a href="#P10" class="headerlink" title="P10"></a>P10</h2><p>关系表达式返回0，1</p>
<p>c语言中没有true，false，只有1，0</p>
<p>c和java一样采用短路与和短路或</p>
]]></content>
  </entry>
  <entry>
    <title>带你学c带你飞day02</title>
    <url>/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday02/</url>
    <content><![CDATA[<h2 id="P11"><a href="#P11" class="headerlink" title="P11"></a>P11</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);<span class="comment">//地址</span></span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"true"</span>);<span class="comment">//这样缩进可以</span></span><br><span class="line"><span class="keyword">if</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P12"><a href="#P12" class="headerlink" title="P12"></a>P12</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量表达式<span class="number">1</span>：语句或代码块；</span><br><span class="line">	<span class="keyword">case</span> ...</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">	<span class="keyword">default</span>: 语句或代码块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line">  <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span>: <span class="built_in">printf</span>(<span class="string">"hi"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'B'</span>: <span class="built_in">printf</span>(<span class="string">"hey"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">"hello"</span>); </span><br><span class="line">    <span class="keyword">break</span>;<span class="comment">//不加break会导致所有case都输出了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(has = <span class="string">"a"</span>)&#123;&#125;<span class="comment">//永远对，所以应该 ==</span></span><br></pre></td></tr></table></figure>

<h2 id="P13"><a href="#P13" class="headerlink" title="P13"></a>P13</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">()</span></span>;<span class="comment">//读取下一个字符</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>()&#123;&#125;<span class="comment">//判断后循环</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>()；<span class="comment">//先循环在判断，while后面有语句</span></span><br></pre></td></tr></table></figure>

<h2 id="P14"><a href="#P14" class="headerlink" title="P14"></a>P14</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环初始;循环结束;循环条件)&#123;&#125;</span><br><span class="line"><span class="built_in">_Bool</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, <span class="keyword">int</span> j=<span class="number">0</span>;i&lt;j;i++,j++)&#123;&#125;<span class="comment">//也可以</span></span><br><span class="line">若想 <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">10</span>;<span class="comment">//则需 gcc -std=c99 test.c &amp;&amp; ./a.out</span></span><br></pre></td></tr></table></figure>

<h2 id="P15"><a href="#P15" class="headerlink" title="P15"></a>P15</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> 在<span class="built_in">printf</span>中是%lld</span><br><span class="line">  <span class="keyword">break</span>跳出当前循环，<span class="keyword">continue</span>直接进入下一次循环</span><br></pre></td></tr></table></figure>

<h2 id="P16"><a href="#P16" class="headerlink" title="P16"></a>P16</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">5</span>, j;</span><br><span class="line">j=++i;<span class="comment">//i=6=j</span></span><br><span class="line">i=<span class="number">5</span>;</span><br><span class="line">j=i++;<span class="comment">//i=6,j=5</span></span><br><span class="line"><span class="comment">//i++先把值给j，再加加</span></span><br><span class="line"><span class="comment">//多语句，逗号表达式</span></span><br><span class="line"><span class="comment">/* 语法：表达式1，...表达式n</span></span><br><span class="line"><span class="comment">表达式从左到右计算</span></span><br><span class="line"><span class="comment">	逗号表达式作为一个整体，值为最后一个表达式也就是n的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">a=(b=<span class="number">3</span>, (c=b+<span class="number">4</span>) +<span class="number">5</span>)<span class="comment">//a=12</span></span><br><span class="line">exp1 ? exp2:exp3  <span class="comment">//if exp1==true , exp2, else: exp3</span></span><br><span class="line"><span class="comment">//goto 跳到标签</span></span><br><span class="line">  <span class="keyword">goto</span> A;<span class="comment">//谨慎用goto</span></span><br><span class="line">  A: <span class="built_in">printf</span>(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="P17"><a href="#P17" class="headerlink" title="P17"></a>P17</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组 类型 数组名[元素个数]</span></span><br><span class="line"><span class="comment">/*数组不能动态定义</span></span><br><span class="line"><span class="comment">int 自动初始化为0，最好手动初始化，要不然栈内空间会错误赋值，可能。</span></span><br><span class="line"><span class="comment">int a[5]=&#123;[2]=2,[3]=3&#125;;//这样可以</span></span><br><span class="line"><span class="comment">sizeof(a);//计算数组内存大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="P18"><a href="#P18" class="headerlink" title="P18"></a>P18</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态数组</span></span><br><span class="line">c99, c支持可变长数组，数组长度在运行时才被决定</span><br><span class="line">  新编译， 在数组越界不会出现错误，好像</span><br></pre></td></tr></table></figure>

<h2 id="P19"><a href="#P19" class="headerlink" title="P19"></a>P19</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">字符串数组定义：</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[]=&#123;<span class="string">"ab"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[]=<span class="string">"ab"</span>;</span><br><span class="line">字符串处理函数：&lt;<span class="built_in">string</span>.h&gt;内</span><br><span class="line">  <span class="built_in">strcat</span>：连接字符串</span><br><span class="line">  <span class="built_in">strcmp</span>:比较字符串</span><br><span class="line">  <span class="built_in">strcpy</span>:拷贝字符串</span><br><span class="line">  <span class="built_in">strlen</span>:获取长度</span><br><span class="line">  <span class="built_in">strncat</span>(str1,str2,<span class="number">5</span>):（以下<span class="number">3</span>个受限，功能一样）<span class="comment">//str2拷贝5个字符到str1</span></span><br><span class="line">  <span class="built_in">strcmp</span>:</span><br><span class="line">  <span class="built_in">strncpy</span>:</span><br><span class="line"><span class="keyword">sizeof</span>(str);<span class="comment">//n</span></span><br><span class="line"><span class="built_in">strlen</span>(str);<span class="comment">//n-1, 因为strlen不包括那个\n，sizeof包括</span></span><br></pre></td></tr></table></figure>

<h3 id="1-字符串基础"><a href="#1-字符串基础" class="headerlink" title="1 字符串基础"></a>1 字符串基础</h3><p>字符串是一种重要的数据类型，有零个或多个字符组成的有限串行。</p>
<p>定义子串: 串中任意个连续的字符组成的子序列，并规定空串是任意串的子串，任意串也是其自身的子串，如字符串”adereegfb”中它本身、空串、诸如”ader”连续的字符串都是它的子串。子序列则不要求字符连续，但顺序要与主串保持一致，若有”abcd”与”ad”则两者的最长公共子序列为”ad”。在动态规划中计算最长公共子序列和最长公共子串中一定要能区分这两个概念!</p>
<p>在C语言中并没有显示的字符串类型，它有如下两种风格的字符串：</p>
<ul>
<li>字符串常量: 以双引号扩起来的字符序列，规定所有的字符串常量都由编译器自动在末尾添加一个空字符</li>
<li>字符数组: 末尾添加了’\0’的字符数组，一般需要显示在末尾添加空字符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c1[]&#x3D;&#123;&#39;c&#39;,&#39;+&#39;,&#39;+&#39;&#125;; &#x2F;&#x2F;末尾没有空字符</span><br><span class="line">char c2[]&#x3D;&#123;&#39;c&#39;,&#39;+&#39;,&#39;+&#39;，&#39;\0&#39;&#125;; &#x2F;&#x2F;末尾显示添加空字符</span><br><span class="line">char c3&#x3D;&quot;c++&quot;; &#x2F;&#x2F;末尾自动添加空字符</span><br></pre></td></tr></table></figure>

<p>注意到通过字符数组初始化和字符串常量初始化并不完全相同的。因为字符串常量包含一个额外的空字符用于结束字符串，用它来初始化创建数组时，末尾会自动添加空字符。所以c1的长度是3，后两者的长度是4，并且字符数组c2和c3都被称为C风格字符串，而字符数组c1不是C风格字符串。</p>
<p>规定C风格的字符串都是以NULL空字符(‘\0’)作为终结符结尾。由于它是字符串的终止符，但它本身并不是字符串的一部分，所以字符串的长度并不包括NULL字节，如strlen函数。而且C标准库中提供的各种字符串处理函数都要求提供的字符串或字符数组必须以空字符结束，否则会出现不可预料的结果。如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c[]&#x3D;&#123;&#39;c&#39;,&#39;+&#39;,&#39;+&#39;&#125;;</span><br><span class="line">printf(&quot;%d\n&quot;,strlen(c)); &#x2F;&#x2F;结果输出为6，这是不正确的</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-标准库中的字符串处理函数"><a href="#2-标准库中的字符串处理函数" class="headerlink" title="2 标准库中的字符串处理函数"></a>2 标准库中的字符串处理函数</h3><p>C标准库中头文件<code>定义了两组字符串函数(C++中用</code>表示)。</p>
<ul>
<li>第一组函数的名字以str开头，它主要处理以’\0’结尾的字符串，所以字符串内部不能包含任何’\0’字符。</li>
<li>第二组函数的名字以mem开头，主要考虑非字符串内部含有零值的情形，它能够处理任意的字节序列，操作与字符串函数类似</li>
<li>除了memmove函数外，其他函数都没定义重叠对象间的行为</li>
</ul>
<p>为了提高程序在不同机器上的移植性，利用typedef定义新类型名，即<code>typedef unsigned int size_t</code>。 程序员必须要保证目标字符数组的空间能够足以存放结果字符串(有可能存在字符数组溢出的危险)</p>
<ul>
<li>字符串处理类</li>
</ul>
<p>如下表为字符串处理函数说明，变量s,t的类型是<code>char *</code>, cs和ct的类型是<code>const char *</code>;n的类型为<code>size_t</code>,c的类型为<code>int</code>。</p>
<p><img src="https://images0.cnblogs.com/blog2015/678327/201507/311507392043956.png" alt="img"></p>
<ul>
<li>内存操作类</li>
</ul>
<p>按照字节数组的方式操作对象，提供一个高效的函数接口(提供字节流的访问)。其中s,t类型是<code>void *</code> ， cs，ct的类型是<code>const void *</code>; n类型为<code>size_t</code>，c类型为<code>int</code>。</p>
<p><img src="https://images0.cnblogs.com/blog2015/678327/201507/311507530171602.png" alt="img"></p>
<p>总结起来，头文件&lt; string.h&gt;实现了如下函数：</p>
<ul>
<li>长度计算、长度不受限和受限的复制、连接和比较版本的函数</li>
<li>基础字符串查找(查找一个字符、一组字符和匹配一个子串)、高级字符串查找（查找子串前缀位置、返回token标记）</li>
<li>处理任意字节序列的内存操作如复制、比较、查找和初始化等函数</li>
</ul>
<h2 id="P20"><a href="#P20" class="headerlink" title="P20"></a>P20</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二维数组矩阵</span></span><br><span class="line">和一维数组一样</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>带你学c带你飞day04</title>
    <url>/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday04/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>带你学c带你飞day03</title>
    <url>/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday03/</url>
    <content><![CDATA[<h2 id="P21"><a href="#P21" class="headerlink" title="P21"></a>P21</h2><p>内存地址存数据</p>
<p>在C语言中，指针的使用非常广泛，因为使用指针往往可以生成更高效、更紧凑的代码。总的来说，使用指针有如下好处：</p>
<p>1）指针的使用使得不同区域的代码可以轻易的共享内存数据，这样可以使程序更为快速高效；</p>
<p>2）C语言中一些复杂的数据结构往往需要使用指针来构建，如链表、二叉树等；</p>
<p>3）C语言是传值调用，而有些操作传值调用是无法完成的，如通过被调函数修改调用函数的对象，但是这种操作可以由指针来完成，而且并不违背传值调用。</p>
<p><strong>3.1 声明并初始化一个指针</strong></p>
<p>　　指针其实就是一个变量，指针的声明方式与一般的变量声明方式没太大区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p;        &#x2F;&#x2F; 声明一个 int 类型的指针 p</span><br><span class="line">char *p        &#x2F;&#x2F; 声明一个 char 类型的指针 p</span><br><span class="line">int *arr[10]   &#x2F;&#x2F; 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向 int 类型对象的指针</span><br><span class="line">int (*arr)[10] &#x2F;&#x2F; 声明一个数组指针，该指针指向一个 int 类型的一维数组</span><br><span class="line">int **p;       &#x2F;&#x2F; 声明一个指针 p ，该指针指向一个 int 类型的指针</span><br></pre></td></tr></table></figure>

<p>　　指针的声明比普通变量的声明多了一个一元运算符 “<em>”。运算符 “</em>” 是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。在上述的声明中： p 是一个指针，保存着一个地址，该地址指向内存中的一个变量； *p 则会访问这个地址所指向的变量。</p>
<p>　　声明一个指针变量并不会自动分配任何内存。在对指针进行间接访问之前，指针必须进行初始化：或是使他指向现有的内存，或者给他动态分配内存，否则我们并不知道指针指向哪儿，这将是一个很严重的问题，稍后会讨论这个问题。初始化操作如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 方法1：使指针指向现有的内存 *&#x2F;</span><br><span class="line">int x &#x3D; 1;</span><br><span class="line">int *p &#x3D; &amp;x;　　&#x2F;&#x2F; 指针 p 被初始化，指向变量 x ，其中取地址符 &amp; 用于产生操作数内存地址</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法2：动态分配内存给指针 *&#x2F;</span><br><span class="line">int *p;</span><br><span class="line">p &#x3D; (int *)malloc(sizeof(int) * 10);　　　　&#x2F;&#x2F; malloc 函数用于动态分配内存</span><br><span class="line">free(p);　　　　&#x2F;&#x2F; free 函数用于释放一块已经分配的内存，常与 malloc 函数一起使用，要使用这两个函数需要头文件 stdlib.h</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　指针的初始化实际上就是给指针一个合法的地址，让程序能够清楚地知道指针指向哪儿。</p>
<p><strong>3.2 未初始化和非法的指针</strong> </p>
<p>　　 如果一个指针没有被初始化，那么程序就不知道它指向哪里。它可能指向一个非法地址，这时，程序会报错，在 Linux 上，错误类型是 Segmentation fault（core dumped），提醒我们段违例或内存错误。它也可能指向一个合法地址，实际上，这种情况更严重，你的程序或许能正常运行，但是这个没有被初始化的指针所指向的那个位置的值将会被修改，而你并无意去修改它。用一个例子简单的演示一下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int *p;</span><br><span class="line">    *p &#x3D; 1;</span><br><span class="line">    printf(&quot;%d\n&quot;,*p);</span><br><span class="line"></span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　这个程序可以编译通过，但是运行的话会报错，报错信息如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180917175256031-967973584.png" alt="img"></p>
<p>　　要想使这个程序运行起来，需要先对指针 p 进行初始化：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int x &#x3D; 1;  </span><br><span class="line">    int *p &#x3D; &amp;x;</span><br><span class="line">    printf(&quot;%d\n&quot;,*p);</span><br><span class="line">　  *p &#x3D; 2;</span><br><span class="line">    printf(&quot;%d\n&quot;,*p);</span><br><span class="line"></span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　这段代码的输出结果如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180917212250007-280056505.png" alt="img"> </p>
<p>　　可以看到，对指针进行初始化后，便可以正常对指针进行赋值了。 </p>
<p><strong>3.3 NULL指针</strong></p>
<p>　　<strong>NULL 指针是一个特殊的指针变量，表示不指向任何东西</strong>。可以通过给一个指针赋一个零值来生成一个 NULL 指针。 </p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int *p &#x3D; NULL;</span><br><span class="line">    printf(&quot;p的地址为%d\n&quot;,p);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;***************</span><br><span class="line"> * 程序输出：</span><br><span class="line"> * p的地址为0</span><br><span class="line">***************&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　可以看到指针指向内存地址0。在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是为操作系统保留的。但是，内存地址 0 有一个特别重要的意义，它表明改指针不指向一个可访问的内存位置。</p>
<p><strong>四、指针的运算</strong></p>
<p>　　C 指针的算术运算只限于两种形式：</p>
<p>1） 指针 +/- 整数 ：</p>
<p>　　 可以对指针变量 p 进行 p++、p–、p + i 等操作，所得结果也是一个指针，只是指针所指向的内存地址相比于 p 所指的内存地址前进或者后退了 i 个操作数。用一张图来说明一下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180921154218407-1813012241.png" alt="img"></p>
<p>　　在上图中，10000000等是内存地址的十六进制表示（数值是假定的），p 是一个 int 类型的指针，指向内存地址 0x10000008 处。则 p++ 将指向与 p 相邻的下一个内存地址，由于 int 型数据占 4 个字节，因此 p++ 所指的内存地址为 1000000b。其余类推。不过要注意的是，这种运算并不会改变指针变量 p 自身的地址，只是改变了它所指向的地址。举个例子：</p>
<p>2）指针 - 指针</p>
<p>　　只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。两个指针相减的结果的类型是 ptrdiff_t，它是一种有符号整数类型。减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位），因为减法运算的结果将除以数组元素类型的长度。举个例子：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[10] &#x3D; &#123;1,2,3,4,5,6,7,8,9,0&#125;;</span><br><span class="line">    int sub;</span><br><span class="line">    int *p1 &#x3D; &amp;a[2];</span><br><span class="line">    int *p2 &#x3D; &amp;a[8];</span><br><span class="line"></span><br><span class="line">    sub &#x3D; p2-p1;                                                                            </span><br><span class="line">    printf(&quot;%d\n&quot;,sub);　　　　&#x2F;&#x2F; 输出结果为 6</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>五、指针与数组</strong></p>
<p>　　在C语言中，指针与数组之间的关系十分密切。实际上，许多可以用数组完成的工作都可以使用指针来完成。一般来说，用指针编写的程序比用数组编写的程序执行速度快，但另一方面，用指针实现的程序理解起来稍微困难一些。</p>
<p><strong>5.1 指针与数组的关系</strong></p>
<p>　　我们先声明一个数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[10];        &#x2F;&#x2F; 声明一个int类型的数组，这个数组有10个元素</span><br></pre></td></tr></table></figure>

<p>　　我们可以用 a[0]、a[1]、…、a[9] 来表示这个数组中的10个元素，这10个元素是存储在一段连续相邻的内存区域中的。</p>
<p>　　接下来，我们再声明一个指针：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p;           &#x2F;&#x2F; 声明一个int类型的指针变量</span><br></pre></td></tr></table></figure>

<p>　　 p 是一个指针变量，指向内存中的一个区域。如果我们对指针 p 做如下的初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#x3D; &amp;a[0];        &#x2F;&#x2F; 对指针进行初始化，p将指向数组 a 的第 1 个元素 a[0]</span><br></pre></td></tr></table></figure>

<p>　　我们知道，对指针进行自增操作会让指针指向与当前元素相邻的下一个元素，即 <em>(p + 1) 将指向 a[1] ；同样的， <em>(p + i) 将指向 a[i] 。因此，我们可以使用该指针来遍历数组 a[10] 的所有元素。可以看到，数组下标与指针运算之间的关系是一一对应的。而根据定义，</em></em>数组类型的变量或表达式的值是该数组第 1 个元素的地址**，且数组名所代表的的就是该数组第 1 个元素的地址，故，上述赋值语句可以直接写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#x3D; a;        &#x2F;&#x2F; a 为数组名，代表该数组最开始的一个元素的地址</span><br></pre></td></tr></table></figure>

<p>　　很显然，<strong>一个通过数组和下标实现的表达式可以等价地通过指针及其偏移量来实现</strong>，这就是数组和指针的互通之处。但有一点要明确的是，数组和指针并不是完全等价，<em>指针是一个变量，而数组名不是变量，它数组中第 1 个元素的地址</em>，数组可以看做是一个用于保存变量的容器。更直接的方法，我们可以直接看二者的地址，并不一样：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;                                                                          </span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    int x[10] &#x3D; &#123;1,2,3,4,5,6,7,8,9,0&#125;;</span><br><span class="line">    int *p &#x3D; x;</span><br><span class="line">    printf(&quot;x的地址为：%p\n&quot;,x);</span><br><span class="line">    printf(&quot;x[0]的地址为：%p\n&quot;,&amp;x[0]);</span><br><span class="line">    printf(&quot;p的地址为：%p\n&quot;,&amp;p);　　　　　　&#x2F;&#x2F; 打印指针 p 的地址，并不是指针所指向的地方的地址</span><br><span class="line"></span><br><span class="line">    p +&#x3D; 2;</span><br><span class="line">    printf(&quot;*(p+2)的值为：%d\n&quot;,*p);　　　　&#x2F;&#x2F; 输出结果为 3，*(p+2)指向了 x[2]</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　结果如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180918160417548-189120951.png" alt="img"></p>
<p>　　可以看到， x 的值与 x[0] 的地址是一样的，也就是说数组名即为数组中第 1 个元素的地址。实际上，打印 &amp;x 后发现，x 的地址也是这个值。而 x 的地址与指针变量 p 的地址是不一样的。故而数组和指针并不能完全等价。</p>
<p>（笔者注：上述输出结果是在 centos7 64bit 的环境下使用 gcc 编译器得到的，可以看到地址是一个12位的十六进制数，转换成二进制是48位，也就是说寻址空间有 256TB，但是笔者的电脑只有 8GB 内存，猜测是不是由于 linux 系统开启了内存分页机制，这里寻址的是虚拟地址？另外，在Windows下使用 vs2015 编译运行的话，则输出结果是一个 8位的十六进制数，也就是32位二进制，寻址空间为 4GB） </p>
<p><strong>5.2 指针数组</strong></p>
<p>　　指针是一个变量，而数组是用于存储变量的容器，因此，指针也可以像其他变量一样存储在数组中，也就是指针数组。 <strong>指针数组是一个数组，数组中的每一个元素都是指针</strong>。声明一个指针数组的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p[10];    &#x2F;&#x2F; 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向int类型的指针</span><br></pre></td></tr></table></figure>

<p>　　在上述声明中，由于 [] 的优先级比 * 高，故 p 先与 [] 结合，成为一个数组 p[]；再由 int * 指明这是一个 int 类型的指针数组，数组中的元素都是 int 类型的指针。数组的第 i 个元素是 <em>p[i]，而 *</em>p[i] 是一个指针**。由于指针数组中存放着多个指针，操作灵活，在一些需要操作大量数据的程序中使用，可以使程序更灵活快速。</p>
<p><strong>5.3 数组指针</strong></p>
<p>　　<strong>数组指针是一个指针，它指向一个数组</strong>。声明一个数组指针的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int (*p)[10];        &#x2F;&#x2F; 声明一个数组指针 p ，该指针指向一个数组</span><br></pre></td></tr></table></figure>

<p>　　由于 () 的优先级最高，所以 p 是一个指针，指向一个 int 类型的一维数组，这个一维数组的长度是 10，这也是指针 p 的步长。也就是说，执行 p+1 时，p 要跨过 n 个 int 型数据的长度。数组指针与二维数组联系密切，可以用数组指针来指向一个二维数组，如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int arr[2][3] &#x3D; &#123;1,2,3,4,5,6&#125;;               &#x2F;&#x2F; 定义一个二维数组并初始化</span><br><span class="line">    int (*p)[3];                                 &#x2F;&#x2F; 定义一个数组指针，指针指向一个含有3个元素的一维数组</span><br><span class="line"></span><br><span class="line">    p &#x3D; arr;                                     &#x2F;&#x2F; 将二维数组的首地址赋给 p，此时 p 指向 arr[0] 或 &amp;arr[0][0]</span><br><span class="line">    printf(&quot;%d\n&quot;,(*p)[0]);　　　　　　　　　　　　  &#x2F;&#x2F; 输出结果为 1</span><br><span class="line">    p++;　　　　　　　　　　　　　　　　　　　　　　　　 &#x2F;&#x2F; 对 p 进行算术运算，此时 p 将指向二维数组的下一行的首地址，即 &amp;arr[1][0]</span><br><span class="line">    printf(&quot;%d\n&quot;,(*p)[1]);                      &#x2F;&#x2F; 输出结果为5</span><br><span class="line"></span><br><span class="line">    return 0;                                                                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>六、指针与结构</strong></p>
<p><strong>6.1 简单介绍一下结构</strong></p>
<p>　　结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。由于结构将一组相关的变量看做一个单元而不是各自独立的实体，因此结构有助于组织复杂的数据，特别是在大型的程序中。声明一个结构的方式如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct message&#123;　　　　　　      &#x2F;&#x2F; 声明一个结构 message</span><br><span class="line">    char name[10];             &#x2F;&#x2F; 成员</span><br><span class="line">    int age;</span><br><span class="line">    int score;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct message s_message;　　　　 &#x2F;&#x2F; 类型定义符 typedef</span><br><span class="line"></span><br><span class="line">s_message mess &#x3D; &#123;&quot;tongye&quot;,23,83&#125;;　　　　&#x2F;&#x2F; 声明一个 struct message 类型的变量 mess,并对其进行初始化　</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line">&#x2F;* 另一种更简便的声明方法 *&#x2F;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">　　char name[10];</span><br><span class="line">　　int age;</span><br><span class="line">　　int score;</span><br><span class="line">&#125;message;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　可以使用 <strong>结构名.成员</strong> 的方式来访问结构中的成员，如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">　　printf(&quot;%s\n&quot;,mess.name);　　　　&#x2F;&#x2F; 输出结果：tongye</span><br><span class="line">　　printf(&quot;%d\n&quot;,mess.age);　　　　 &#x2F;&#x2F; 输出结果：23</span><br><span class="line"></span><br><span class="line">　　return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>6.2 结构指针</strong>　</p>
<p>　　结构指针是指向结构的指针，以上面的结构为例，可以这样定义一个结构指针：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s_message *p;        &#x2F;&#x2F; 声明一个结构指针 p ，该指针指向一个 s_message 类型的结构</span><br><span class="line">*p &#x3D; &amp;mess;　　　　　　&#x2F;&#x2F; 对结构指针的初始化与普通指针一样，也是使用取地址符 &amp;</span><br></pre></td></tr></table></figure>

<p>　　C语言中使用 -&gt; 操作符来访问结构指针的成员，举个例子：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char name[10];</span><br><span class="line">    int age;</span><br><span class="line">    int score;  </span><br><span class="line">&#125;message;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    message mess &#x3D; &#123;&quot;tongye&quot;,23,83&#125;;</span><br><span class="line">    message *p &#x3D; &amp;mess;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%s\n&quot;,p-&gt;name);　　　　　　&#x2F;&#x2F; 输出结果为：tongye</span><br><span class="line">    printf(&quot;%d\n&quot;,p-&gt;score);         &#x2F;&#x2F; 输出结果为：83</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>七、指针与函数</strong></p>
<p>　　<strong>C语言的所有参数均是以“传值调用”的方式进行传递的</strong>，这意味着函数将获得参数值的一份拷贝。这样，函数可以放心修改这个拷贝值，而不必担心会修改调用程序实际传递给它的参数。 </p>
<p><strong>7.1 指针作为函数的参数</strong></p>
<p>　　传值调用的好处是是被调函数不会改变调用函数传过来的值，可以放心修改。但是有时候需要被调函数回传一个值给调用函数，这样的话，传值调用就无法做到。为了解决这个问题，可以使用传指针调用。<strong>指针参数使得被调函数能够访问和修改主调函数中对象的值。</strong>用一个例子来说明：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">void swap1(int a,int b)　　　　　　  &#x2F;&#x2F; 参数为普通的 int 变量</span><br><span class="line">&#123;</span><br><span class="line">　　int temp;</span><br><span class="line">　　temp &#x3D; a;</span><br><span class="line">　　a &#x3D; b;</span><br><span class="line">　　b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap2(int *a,int *b)　　　　　　&#x2F;&#x2F; 参数为指针，接受调用函数传递过来的变量地址作为参数，对所指地址处的内容进行操作</span><br><span class="line">&#123;</span><br><span class="line">　　int temp;　　　　                &#x2F;&#x2F; 最终结果是，地址本身并没有改变，但是这一地址所对应的内存段中的内容发生了变化，即x,y的值发生了变化</span><br><span class="line">　　temp &#x3D; *a;</span><br><span class="line">　　*a &#x3D; *b;</span><br><span class="line">　　*b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">　　int x &#x3D; 1,y &#x3D; 2;</span><br><span class="line">　　swap1(x,y);                     &#x2F;&#x2F; 将 x,y 的值本身作为参数传递给了被调函数</span><br><span class="line">　　printf(&quot;%d %5d\n&quot;,x,y);         &#x2F;&#x2F; 输出结果为：1     2</span><br><span class="line"></span><br><span class="line">　　swap(&amp;x,&amp;y);                    &#x2F;&#x2F; 将 x,y 的地址作为参数传递给了被调函数，传递过去的也是一个值，与传值调用不冲突</span><br><span class="line">　　printf(&quot;%d %5d\n&quot;,x,y);         &#x2F;&#x2F; 输出结果为：2     1</span><br><span class="line">　　return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>7.2 指向函数的指针</strong></p>
<p>　　在C语言中，函数本身不是变量，但是可以定义指向函数的指针，也称作函数指针，函数指针指向函数的入口地址。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。 声明一个函数指针的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回值类型 （* 指针变量名）（[形参列表]）;</span><br><span class="line"></span><br><span class="line">int (*pointer)(int *,int *);        &#x2F;&#x2F; 声明一个函数指针</span><br></pre></td></tr></table></figure>

<p>　　上述代码声明了一个函数指针 pointer ，该指针指向一个函数，函数具有两个 int * 类型的参数，且返回值类型为 int。下面的代码演示了函数指针的用法：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line"></span><br><span class="line">int str_comp(const char *m,const char *n);                             &#x2F;&#x2F; 声明一个函数 str_comp，该函数有两个 const char 类型的指针，函数的返回值为 int 类型</span><br><span class="line">void comp(char *a,char *b,int (*prr)(const char *,const char*));       &#x2F;&#x2F; 声明一个函数 comp ,注意该函数的第三个参数，是一个函数指针</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char str1[20];      &#x2F;&#x2F; 声明一个字符数组</span><br><span class="line">    char str2[20];</span><br><span class="line">    int (*p)(const char *,const char *) &#x3D; str_comp;　　　　　　　　　　　 &#x2F;&#x2F; 声明并初始化一个函数指针，该指针所指向的函数有两个 const char 类型的指针，且返回值为 int 类型</span><br><span class="line">    gets(str1);         &#x2F;&#x2F; 使用 gets() 函数从 I&#x2F;O 读取一行字符串</span><br><span class="line">    gets(str2);</span><br><span class="line">    comp(str1,str2,p);  &#x2F;&#x2F; 函数指针 p 作为参数传给 comp 函数</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int str_comp(const char *m,const char *n)</span><br><span class="line">&#123;</span><br><span class="line">　　 &#x2F;&#x2F; 库函数 strcmp 用于比较两个字符串，其原型是： int strcmp(const char *s1,const char *s2);</span><br><span class="line">    if(strcmp(m,n) &#x3D;&#x3D; 0) </span><br><span class="line">        return 0;</span><br><span class="line">    else</span><br><span class="line">        return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 函数 comp 接受一个函数指针作为它的第三个参数 *&#x2F;</span><br><span class="line">void comp(char *a,char *b,int (*prr)(const char *,const char*))</span><br><span class="line">&#123;</span><br><span class="line">    if((*prr)(a,b) &#x3D;&#x3D; 0)</span><br><span class="line">        printf(&quot;str1 &#x3D; str2\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;str1 !&#x3D; str2\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　这段代码的功能是从键盘读取两行字符串（长度不超过20），判断二者是否相等。</p>
<p>　　注意，声明一个函数指针时，() 不能漏掉，否则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p(void *,void*);</span><br></pre></td></tr></table></figure>

<p>　　这表明 p 是一个函数，该函数返回一个指向 int 类型的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a=<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> *pa=&amp;a;</span><br></pre></td></tr></table></figure>

<p>指针长度：以前是16位地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就占8个字节。</p>
<p>避免访问未初始化指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *a; *a=<span class="number">123</span>;<span class="comment">//野指针</span></span><br></pre></td></tr></table></figure>

<h2 id="P22"><a href="#P22" class="headerlink" title="P22"></a>P22</h2><p>&amp;取值操作符</p>
<p>数组名就是地址信息，也是第一个元素的地址。</p>
<p>当指针指向数组元素是，可以对指针变量进行加减运算。指针加一指向下一个元素。</p>
]]></content>
  </entry>
  <entry>
    <title>带你学c带你飞day05</title>
    <url>/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday05/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>rsa加密算法详解</title>
    <url>/2020/05/01/rsa%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<p>我们日常传输数据想防止hacker的攻击，需要加密算法，常见的：对称加密，非对称加密，对称加密相对于交易双方有相同钥匙，但是任意一方被黑，两方都有危险，而非对称加密，最经典的rsa解决了这个问题。</p>
<p>rsa算法原理：</p>
<p>首先找出两个质数 p和q</p>
<p>计算   n = p * q</p>
<p>φ(n) = (p-1)  * (q-1)      这个函数又叫欧拉函数</p>
<p>公钥e    1 &lt; e &lt; φ(n)   在这个范围取出一个整数，并且 e 和 φ(n) 互质</p>
<p>私钥d    (e * d ) / φ(n)  = x  ······ 1       (x是几无所谓，余数必须是1，比如 φ(n)是20 e是3 那么d就是7)</p>
<p> 加密  m^e / n =x  ······  c     (这几个x都代表任意数的商，在这里面没有直接意义，可以忽略不看，这三个x也都不相等)</p>
<p> 解密  c^d  / n =x   ······ m   (可以从数学上证明，经过这一系列的计算，得到结果的余数一定是m)<br>————————————————<br>版权声明：本文为CSDN博主「狱蝶阿一」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_42510528/java/article/details/80765361" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42510528/java/article/details/80765361</a></p>
<p><strong>一、RSA加密简介</strong>（ssh典型用此算法）</p>
<p>　　RSA加密是一种非对称加密。可以在不直接传递密钥的情况下，完成解密。这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。是由一对密钥来进行加解密的过程，分别称为公钥和私钥。两者之间有数学相关，该加密算法的原理就是对一极大整数做因数分解的困难性来保证安全性。通常个人保存私钥，公钥是公开的（可能同时多人持有）。</p>
<p>　　</p>
<p><strong>二、RSA加密、签名区别</strong></p>
<p>　　加密和签名都是为了安全性考虑，但略有不同。常有人问加密和签名是用私钥还是公钥？其实都是对加密和签名的作用有所混淆。简单的说，加密是为了防止信息被泄露，而签名是为了防止信息被篡改。这里举2个例子说明。</p>
<p><strong>第一个场景</strong>：战场上，B要给A传递一条消息，内容为某一指令。</p>
<p>RSA的加密过程如下：</p>
<p>（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。</p>
<p>（2）A传递自己的公钥给B，B用A的公钥对消息进行加密。</p>
<p>（3）A接收到B加密的消息，利用A自己的私钥对消息进行解密。</p>
<p>　　在这个过程中，只有2次传递过程，第一次是A传递公钥给B，第二次是B传递加密消息给A，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行解密，防止了消息内容的泄露。</p>
<p>所以.ssh文件中私钥千万别动，那是你唯一救命稻草。但是公钥随便给别人。 </p>
<p><strong>第二个场景：</strong>A收到B发的消息后，需要进行回复“收到”。</p>
<p>RSA签名的过程如下：</p>
<p>（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。</p>
<p>（2）A用自己的私钥对消息加签，形成签名，并将加签的消息和消息本身一起传递给B。</p>
<p>（3）B收到消息后，在获取A的公钥进行验签，如果验签出来的内容与消息本身一致，证明消息是A回复的。</p>
<p>　　在这个过程中，只有2次传递过程，第一次是A传递加签的消息和消息本身给B，第二次是B获取A的公钥，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行签名，即使知道了消息内容，也无法伪造带签名的回复给B，防止了消息内容的篡改。</p>
<p>　　但是，综合两个场景你会发现，第一个场景虽然被截获的消息没有泄露，但是可以利用截获的公钥，将假指令进行加密，然后传递给A。第二个场景虽然截获的消息不能被篡改，但是消息的内容可以利用公钥验签来获得，并不能防止泄露。所以在实际应用中，要根据情况使用，也可以同时使用加密和签名，比如A和B都有一套自己的公钥和私钥，当A要给B发送消息时，先用B的公钥对消息加密，再对加密的消息使用A的私钥加签名，达到既不泄露也不被篡改，更能保证消息的安全性。</p>
<p>　　<strong>总结：公钥加密、私钥解密、私钥签名、公钥验签。</strong></p>
<p><strong>三、RSA加密、签名的方法，代码例子如下：</strong></p>
<p>java实现此算法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1 import java.io.ByteArrayOutputStream;&#x2F;&#x2F;都是javase6以后的包</span><br><span class="line">  2 import java.security.KeyFactory;</span><br><span class="line">  3 import java.security.KeyPair;</span><br><span class="line">  4 import java.security.KeyPairGenerator;</span><br><span class="line">  5 import java.security.PrivateKey;</span><br><span class="line">  6 import java.security.PublicKey;</span><br><span class="line">  7 import java.security.Signature;</span><br><span class="line">  8 import java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line">  9 import java.security.spec.X509EncodedKeySpec;</span><br><span class="line"> 10 import javax.crypto.Cipher;</span><br><span class="line"> 11 import org.apache.commons.codec.binary.Base64;</span><br><span class="line"> 12 </span><br><span class="line"> 13 public class TestRSA &#123;</span><br><span class="line"> 14 </span><br><span class="line"> 15     &#x2F;**</span><br><span class="line"> 16      * RSA最大加密明文大小</span><br><span class="line"> 17      *&#x2F;</span><br><span class="line"> 18     private static final int MAX_ENCRYPT_BLOCK &#x3D; 117;</span><br><span class="line"> 19 </span><br><span class="line"> 20     &#x2F;**</span><br><span class="line"> 21      * RSA最大解密密文大小</span><br><span class="line"> 22      *&#x2F;</span><br><span class="line"> 23     private static final int MAX_DECRYPT_BLOCK &#x3D; 128;</span><br><span class="line"> 24 </span><br><span class="line"> 25     &#x2F;**</span><br><span class="line"> 26      * 获取密钥对</span><br><span class="line"> 27      * </span><br><span class="line"> 28      * @return 密钥对</span><br><span class="line"> 29      *&#x2F;</span><br><span class="line"> 30     public static KeyPair getKeyPair() throws Exception &#123;</span><br><span class="line"> 31         KeyPairGenerator generator &#x3D; KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line"> 32         generator.initialize(1024);</span><br><span class="line"> 33         return generator.generateKeyPair();</span><br><span class="line"> 34     &#125;</span><br><span class="line"> 35 </span><br><span class="line"> 36     &#x2F;**</span><br><span class="line"> 37      * 获取私钥</span><br><span class="line"> 38      * </span><br><span class="line"> 39      * @param privateKey 私钥字符串</span><br><span class="line"> 40      * @return</span><br><span class="line"> 41      *&#x2F;</span><br><span class="line"> 42     public static PrivateKey getPrivateKey(String privateKey) throws Exception &#123;</span><br><span class="line"> 43         KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line"> 44         byte[] decodedKey &#x3D; Base64.decodeBase64(privateKey.getBytes());</span><br><span class="line"> 45         PKCS8EncodedKeySpec keySpec &#x3D; new PKCS8EncodedKeySpec(decodedKey);</span><br><span class="line"> 46         return keyFactory.generatePrivate(keySpec);</span><br><span class="line"> 47     &#125;</span><br><span class="line"> 48 </span><br><span class="line"> 49     &#x2F;**</span><br><span class="line"> 50      * 获取公钥</span><br><span class="line"> 51      * </span><br><span class="line"> 52      * @param publicKey 公钥字符串</span><br><span class="line"> 53      * @return</span><br><span class="line"> 54      *&#x2F;</span><br><span class="line"> 55     public static PublicKey getPublicKey(String publicKey) throws Exception &#123;</span><br><span class="line"> 56         KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line"> 57         byte[] decodedKey &#x3D; Base64.decodeBase64(publicKey.getBytes());</span><br><span class="line"> 58         X509EncodedKeySpec keySpec &#x3D; new X509EncodedKeySpec(decodedKey);</span><br><span class="line"> 59         return keyFactory.generatePublic(keySpec);</span><br><span class="line"> 60     &#125;</span><br><span class="line"> 61     </span><br><span class="line"> 62     &#x2F;**</span><br><span class="line"> 63      * RSA加密</span><br><span class="line"> 64      * </span><br><span class="line"> 65      * @param data 待加密数据</span><br><span class="line"> 66      * @param publicKey 公钥</span><br><span class="line"> 67      * @return</span><br><span class="line"> 68      *&#x2F;</span><br><span class="line"> 69     public static String encrypt(String data, PublicKey publicKey) throws Exception &#123;</span><br><span class="line"> 70         Cipher cipher &#x3D; Cipher.getInstance(&quot;RSA&quot;);</span><br><span class="line"> 71         cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line"> 72         int inputLen &#x3D; data.getBytes().length;</span><br><span class="line"> 73         ByteArrayOutputStream out &#x3D; new ByteArrayOutputStream();</span><br><span class="line"> 74         int offset &#x3D; 0;</span><br><span class="line"> 75         byte[] cache;</span><br><span class="line"> 76         int i &#x3D; 0;</span><br><span class="line"> 77         &#x2F;&#x2F; 对数据分段加密</span><br><span class="line"> 78         while (inputLen - offset &gt; 0) &#123;</span><br><span class="line"> 79             if (inputLen - offset &gt; MAX_ENCRYPT_BLOCK) &#123;</span><br><span class="line"> 80                 cache &#x3D; cipher.doFinal(data.getBytes(), offset, MAX_ENCRYPT_BLOCK);</span><br><span class="line"> 81             &#125; else &#123;</span><br><span class="line"> 82                 cache &#x3D; cipher.doFinal(data.getBytes(), offset, inputLen - offset);</span><br><span class="line"> 83             &#125;</span><br><span class="line"> 84             out.write(cache, 0, cache.length);</span><br><span class="line"> 85             i++;</span><br><span class="line"> 86             offset &#x3D; i * MAX_ENCRYPT_BLOCK;</span><br><span class="line"> 87         &#125;</span><br><span class="line"> 88         byte[] encryptedData &#x3D; out.toByteArray();</span><br><span class="line"> 89         out.close();</span><br><span class="line"> 90         &#x2F;&#x2F; 获取加密内容使用base64进行编码,并以UTF-8为标准转化成字符串</span><br><span class="line"> 91         &#x2F;&#x2F; 加密后的字符串</span><br><span class="line"> 92         return new String(Base64.encodeBase64String(encryptedData));</span><br><span class="line"> 93     &#125;</span><br><span class="line"> 94 </span><br><span class="line"> 95     &#x2F;**</span><br><span class="line"> 96      * RSA解密</span><br><span class="line"> 97      * </span><br><span class="line"> 98      * @param data 待解密数据</span><br><span class="line"> 99      * @param privateKey 私钥</span><br><span class="line">100      * @return</span><br><span class="line">101      *&#x2F;</span><br><span class="line">102     public static String decrypt(String data, PrivateKey privateKey) throws Exception &#123;</span><br><span class="line">103         Cipher cipher &#x3D; Cipher.getInstance(&quot;RSA&quot;);</span><br><span class="line">104         cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">105         byte[] dataBytes &#x3D; Base64.decodeBase64(data);</span><br><span class="line">106         int inputLen &#x3D; dataBytes.length;</span><br><span class="line">107         ByteArrayOutputStream out &#x3D; new ByteArrayOutputStream();</span><br><span class="line">108         int offset &#x3D; 0;</span><br><span class="line">109         byte[] cache;</span><br><span class="line">110         int i &#x3D; 0;</span><br><span class="line">111         &#x2F;&#x2F; 对数据分段解密</span><br><span class="line">112         while (inputLen - offset &gt; 0) &#123;</span><br><span class="line">113             if (inputLen - offset &gt; MAX_DECRYPT_BLOCK) &#123;</span><br><span class="line">114                 cache &#x3D; cipher.doFinal(dataBytes, offset, MAX_DECRYPT_BLOCK);</span><br><span class="line">115             &#125; else &#123;</span><br><span class="line">116                 cache &#x3D; cipher.doFinal(dataBytes, offset, inputLen - offset);</span><br><span class="line">117             &#125;</span><br><span class="line">118             out.write(cache, 0, cache.length);</span><br><span class="line">119             i++;</span><br><span class="line">120             offset &#x3D; i * MAX_DECRYPT_BLOCK;</span><br><span class="line">121         &#125;</span><br><span class="line">122         byte[] decryptedData &#x3D; out.toByteArray();</span><br><span class="line">123         out.close();</span><br><span class="line">124         &#x2F;&#x2F; 解密后的内容 </span><br><span class="line">125         return new String(decryptedData, &quot;UTF-8&quot;);</span><br><span class="line">126     &#125;</span><br><span class="line">127 </span><br><span class="line">128     &#x2F;**</span><br><span class="line">129      * 签名</span><br><span class="line">130      * </span><br><span class="line">131      * @param data 待签名数据</span><br><span class="line">132      * @param privateKey 私钥</span><br><span class="line">133      * @return 签名</span><br><span class="line">134      *&#x2F;</span><br><span class="line">135     public static String sign(String data, PrivateKey privateKey) throws Exception &#123;</span><br><span class="line">136         byte[] keyBytes &#x3D; privateKey.getEncoded();</span><br><span class="line">137         PKCS8EncodedKeySpec keySpec &#x3D; new PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">138         KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line">139         PrivateKey key &#x3D; keyFactory.generatePrivate(keySpec);</span><br><span class="line">140         Signature signature &#x3D; Signature.getInstance(&quot;MD5withRSA&quot;);</span><br><span class="line">141         signature.initSign(key);</span><br><span class="line">142         signature.update(data.getBytes());</span><br><span class="line">143         return new String(Base64.encodeBase64(signature.sign()));</span><br><span class="line">144     &#125;</span><br><span class="line">145 </span><br><span class="line">146     &#x2F;**</span><br><span class="line">147      * 验签</span><br><span class="line">148      * </span><br><span class="line">149      * @param srcData 原始字符串</span><br><span class="line">150      * @param publicKey 公钥</span><br><span class="line">151      * @param sign 签名</span><br><span class="line">152      * @return 是否验签通过</span><br><span class="line">153      *&#x2F;</span><br><span class="line">154     public static boolean verify(String srcData, PublicKey publicKey, String sign) throws Exception &#123;</span><br><span class="line">155         byte[] keyBytes &#x3D; publicKey.getEncoded();</span><br><span class="line">156         X509EncodedKeySpec keySpec &#x3D; new X509EncodedKeySpec(keyBytes);</span><br><span class="line">157         KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line">158         PublicKey key &#x3D; keyFactory.generatePublic(keySpec);</span><br><span class="line">159         Signature signature &#x3D; Signature.getInstance(&quot;MD5withRSA&quot;);</span><br><span class="line">160         signature.initVerify(key);</span><br><span class="line">161         signature.update(srcData.getBytes());</span><br><span class="line">162         return signature.verify(Base64.decodeBase64(sign.getBytes()));</span><br><span class="line">163     &#125;</span><br><span class="line">164 </span><br><span class="line">165     public static void main(String[] args) &#123;</span><br><span class="line">166         try &#123;</span><br><span class="line">167             &#x2F;&#x2F; 生成密钥对</span><br><span class="line">168             KeyPair keyPair &#x3D; getKeyPair();</span><br><span class="line">169             String privateKey &#x3D; new String(Base64.encodeBase64(keyPair.getPrivate().getEncoded()));</span><br><span class="line">170             String publicKey &#x3D; new String(Base64.encodeBase64(keyPair.getPublic().getEncoded()));</span><br><span class="line">171             System.out.println(&quot;私钥:&quot; + privateKey);</span><br><span class="line">172             System.out.println(&quot;公钥:&quot; + publicKey);</span><br><span class="line">173             &#x2F;&#x2F; RSA加密</span><br><span class="line">174             String data &#x3D; &quot;待加密的文字内容&quot;;</span><br><span class="line">175             String encryptData &#x3D; encrypt(data, getPublicKey(publicKey));</span><br><span class="line">176             System.out.println(&quot;加密后内容:&quot; + encryptData);</span><br><span class="line">177             &#x2F;&#x2F; RSA解密</span><br><span class="line">178             String decryptData &#x3D; decrypt(encryptData, getPrivateKey(privateKey));</span><br><span class="line">179             System.out.println(&quot;解密后内容:&quot; + decryptData);</span><br><span class="line">180             </span><br><span class="line">181             &#x2F;&#x2F; RSA签名</span><br><span class="line">182             String sign &#x3D; sign(data, getPrivateKey(privateKey));</span><br><span class="line">183             &#x2F;&#x2F; RSA验签</span><br><span class="line">184             boolean result &#x3D; verify(data, getPublicKey(publicKey), sign);</span><br><span class="line">185             System.out.print(&quot;验签结果:&quot; + result);</span><br><span class="line">186         &#125; catch (Exception e) &#123;</span><br><span class="line">187             e.printStackTrace();</span><br><span class="line">188             System.out.print(&quot;加解密异常&quot;);</span><br><span class="line">189         &#125;</span><br><span class="line">190     &#125;</span><br><span class="line">191 &#125;</span><br></pre></td></tr></table></figure>

<p>　　PS:RSA加密对明文的长度有所限制，规定需加密的明文最大长度=密钥长度-11（单位是字节，即byte），所以在<strong>加密和解密的过程中需要分块进行</strong>。而密钥默认是1024位，即1024位/8位-11=128-11=117字节。所以默认加密前的明文最大长度117字节，解密密文最大长度为128字。那么为啥两者相差11字节呢？是因为RSA加密使用到了填充模式（padding），即内容不足117字节时会自动填满，用到填充模式自然会占用一定的字节，而且这部分字节也是参与加密的。</p>
<p>　　密钥长度的设置就是上面例子的第32行。可自行调整，当然非对称加密随着密钥变长，安全性上升的同时性能也会有所下降。</p>
<p>改编自：<a href="https://www.cnblogs.com/pcheng/p/9629621.html，https://blog.csdn.net/weixin_42510528/java/article/details/80765361" target="_blank" rel="noopener">https://www.cnblogs.com/pcheng/p/9629621.html，https://blog.csdn.net/weixin_42510528/java/article/details/80765361</a></p>
]]></content>
  </entry>
  <entry>
    <title>开关app，terminal上网</title>
    <url>/2020/05/05/%E5%BC%80%E5%85%B3app/</url>
    <content><![CDATA[<h1 id="Use-terminal-to-open-and-close-application-or-file"><a href="#Use-terminal-to-open-and-close-application-or-file" class="headerlink" title="Use terminal to open and close application or file"></a>Use terminal to open and close application or file</h1><h2 id="What-the-heck-a-new-world"><a href="#What-the-heck-a-new-world" class="headerlink" title="What the heck, a new world!"></a>What the heck, a new world!</h2><p>Very simple, so first of all, if we want to open a application</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open -a applicationname</span><br><span class="line">#我这里用的是Google Chrome</span><br><span class="line">open -a &quot;Google Chrome&quot;#不加”“也可以,最好别加，好像有bug，因为下面atom加了显示失败</span><br><span class="line">如果要打开某个文件</span><br><span class="line">open .&#x2F;Desktop&#x2F;a.cpp -a Atom  #打开桌面的c++文件用atom打开</span><br></pre></td></tr></table></figure>

<p>Hell no, how to close</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">osascript -e &#39;quit app &quot;Atom&quot;&#39;#osascript -e &#39;quit app &quot;Applicationname&quot;&#39;</span><br></pre></td></tr></table></figure>



<p>用terminal玩转web browser</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You’ll want to install the main w3m package and the w3m-img package if you want inline image support. Use the following command on Ubuntu:</span><br><span class="line"></span><br><span class="line">sudo apt-get install w3m w3m-img</span><br><span class="line"></span><br><span class="line">For Mac following command will install:</span><br><span class="line"></span><br><span class="line">brew install w3m</span><br><span class="line"></span><br><span class="line">You can use the arrow keys to move the cursor around or click at the desired location to move the cursor there. If you want to type in a text box, select the text box with your cursor and press Enter before typing your text. Load a hyperlink by selecting it with your cursor and pressing Enter.</span><br><span class="line">Shortcuts:</span><br><span class="line">Tab: Press the Tab key to position your cursor over the next hyperlink on the page.</span><br><span class="line">Shift-B: will take you back a page.</span><br><span class="line">Shif-U: If you want to load a different URL, you’ll get an URL prompt.</span><br><span class="line">Shift-H: To view the help page if you want to see a more complete list of keyboard shortcuts.</span><br><span class="line">Shift-T: To open a new tab and then you can press Shift-U and enter the new URL. Yes, it does support tab browsing:)</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w3m 网址</span><br><span class="line">w3m baidu.com</span><br><span class="line">Tab: move to next interaction point</span><br><span class="line">Enter:Trigger interaction item(click&#x2F;enter)</span><br><span class="line">有text的话可以输入想search的内容</span><br><span class="line">jk，上下左右 移动光标</span><br><span class="line">qy 退出w3m</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>带你学c带你飞day06</title>
    <url>/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday06/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机网络1（1-20）</title>
    <url>/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>操作系统：</p>
<p>网络基础服务： DNS DHCP RAS FTP Web </p>
<p>网络：思科CCNA OSI参考模型 TCPIP协议</p>
<p>计算机网络书分为五层：物理层，数据链路层，网络层，运输层，应用层</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>网络：电信网络，计算机网络，有线电视网络。</p>
<p>有3个特点：数字化，网络化，信息化</p>
<p>计算机网络分为：因特网，其他网络</p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><h3 id="网络互联网因特网区别"><a href="#网络互联网因特网区别" class="headerlink" title="网络互联网因特网区别"></a>网络互联网因特网区别</h3><p>网络（Network）：许多计算机连接在一起</p>
<p>互联网（Network of Networks，internet）：许多网络连接在一起</p>
<p>因特网（Internet）：全球最大的一个互联网</p>
<p>因特网是美国发明的属于美国国家的网络。<br>互联网是基于因特网，百全球各网络与网络之间所串连成的庞大网络。<br>注意：因特网属于美国其有最高权利，又链接世界，拥有世界唯度一服务器，可以随时停止某些地区网络内的服务，历史案例有伊拉克和叙利亚。中国用的不是互联网而是美国的因特网，所以这方面国家网络安全堪忧！而国家网络安全是国家主权非常重要的延伸和表现！因容特网也是维持美国霸权的一个重要方面。</p>
<p>n网络(network)由若干结点(node)和连接这些结点的链路(link)组成。 </p>
<p>n互联网是“网络的网络”(network of networks)。</p>
<p>n连接在因特网上的计算机都称为主机(host)。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node</span><br><span class="line">在网络中的 node 的标准译名是“结点”而不是“节点”。</span><br><span class="line">但数据结构的树(tree)中的 node 应当译为“节点”</span><br></pre></td></tr></table></figure>

<h3 id="因特网发展3阶段"><a href="#因特网发展3阶段" class="headerlink" title="因特网发展3阶段"></a>因特网发展3阶段</h3><p>第一阶段是从单个网络 ARPANET 向互联网发展的过程。 </p>
<p>1983 年 TCP/IP 协议成为 ARPANET 上的标准协议。</p>
<p>人们把 1983 年作为因特网的诞生时间。 </p>
<p>第二阶段的特点是建成了三级结构的因特网。 </p>
<p>三级计算机网络，分为主干网、地区网和校园网（或企业网）</p>
<p>第三阶段的特点是逐渐形成了多层次 ISP 结构的因特网。</p>
<p>出现了因特网服务提供者 ISP (Internet Service Provider)。 </p>
<p>根据提供服务的覆盖面积大小以及所拥有的IP 地址数目的不同，ISP 也分成为不同的层次。</p>
<p>主机A → 本地 ISP → 第二层 ISP → NAP → 第一层 ISP → NAP → 第二层 ISP → 本地 ISP → 主机B</p>
<p>因特网的迅猛发展始于 20 世纪 90 年代。由欧洲原子核研究组织 CERN 开发的万维网 <strong>WWW</strong> (World Wide Web)被广泛使用在因特网上，大大方便了广大非网络专业人员对网络的使用，成为因特网的这种指数级增长的主要驱动力。 </p>
<h3 id="万维网因特网互联网区别"><a href="#万维网因特网互联网区别" class="headerlink" title="万维网因特网互联网区别"></a>万维网因特网互联网区别</h3><p>互联网包含因特网，因特网包含万维网。即互联网&gt;因特网&gt;万维网。</p>
<p>互联网是设备之间互联通信， 万维网是服务与数据资源之间的共享利用</p>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><h3 id="因特网组成"><a href="#因特网组成" class="headerlink" title="因特网组成"></a>因特网组成</h3><p>从因特网的工作方式上看，可以划分为以下的两大块：</p>
<p>(1) 边缘部分 由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</p>
<p>(2) 核心部分 由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）</p>
<h3 id="两种通信方式"><a href="#两种通信方式" class="headerlink" title="两种通信方式"></a>两种通信方式</h3><p>在网络边缘的端系统中运行的程序之间的通信方式通常可划分为两大类：</p>
<p>客户服务器方式（C/S 方式） 即Client/Server方式 ：客户是服务的请求方，服务器是服务的提供方。</p>
<p>对等方式（P2P 方式） 即 Peer-to-Peer方式 ：对等连接(peer-to-peer，简写为 P2P)是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。只要两个主机都运行了对等连接软件（P2P 软件），它们就可以进行平等的、对等连接通信。双方都可以下载对方已经存储在硬盘中的共享文档。主机既是客户又同时是服务器</p>
<h3 id="因特网核心：数据交换方式"><a href="#因特网核心：数据交换方式" class="headerlink" title="因特网核心：数据交换方式"></a>因特网核心：数据交换方式</h3><p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p>
<p>在网络核心部分起特殊作用的是<strong>路由器(router)</strong>。</p>
<p>路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。 </p>
<h4 id="电路交换Circuit-Switching-电路交换必定是面向连接的。"><a href="#电路交换Circuit-Switching-电路交换必定是面向连接的。" class="headerlink" title="电路交换Circuit Switching:电路交换必定是面向连接的。"></a>电路交换Circuit Switching:电路交换必定是面向连接的。</h4><p>电路交换的三个阶段：建立连接,通信,释放连接</p>
<p>一般打电话就是电路交换</p>
<h4 id="报文交换Message-Switching：比分组长很多，交换时延也长，基本不用了"><a href="#报文交换Message-Switching：比分组长很多，交换时延也长，基本不用了" class="headerlink" title="报文交换Message Switching：比分组长很多，交换时延也长，基本不用了"></a>报文交换Message Switching：比分组长很多，交换时延也长，基本不用了</h4><h4 id="分组交换Packet-Switching：在发送端，先把较长的报文划分成较短的、固定长度的数据段。"><a href="#分组交换Packet-Switching：在发送端，先把较长的报文划分成较短的、固定长度的数据段。" class="headerlink" title="分组交换Packet Switching：在发送端，先把较长的报文划分成较短的、固定长度的数据段。"></a>分组交换Packet Switching：在发送端，先把较长的报文划分成较短的、固定长度的数据段。</h4><p>每个数据段前添加首部构成分组，接收端收到分组后剥去首部还原成报文，最后还原成原来的报文</p>
<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><h3 id="不同类别网络"><a href="#不同类别网络" class="headerlink" title="不同类别网络"></a>不同类别网络</h3><h3 id="不同作用范围的网络"><a href="#不同作用范围的网络" class="headerlink" title="不同作用范围的网络"></a>不同作用范围的网络</h3><p>广域网 <strong>WAN</strong> (Wide Area Network)：花钱买服务 花钱买带宽</p>
<p>局域网 <strong>LAN</strong> (Local Area Network)：自己买设备，自己维护，带宽固定 100M100M 距离100米以内</p>
<p>城域网 <strong>MAN</strong> (Metropolitan Area Network)</p>
<h3 id="个人区域网-PAN-Personal-Area-Network"><a href="#个人区域网-PAN-Personal-Area-Network" class="headerlink" title="个人区域网 PAN (Personal Area Network)"></a>个人区域网 <strong>PAN</strong> (Personal Area Network)</h3><p>从网络的使用者进行分类</p>
<p>公用网 (public network) </p>
<p>专用网 (private network) </p>
<h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p>星型，总线型，环形，树形，网状</p>
<h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><h3 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h3><p>1.速率</p>
<p>比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。Bit 来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。</p>
<p>速率即数据率(data rate)或比特率(bit rate)是计算机网络中最重要的一个性能指标。速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等。速率往往是指额定速率或标称速率。 </p>
<p>2.带宽</p>
<p>带宽”(bandwidth)本来是指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等）。</p>
<p>现在“带宽”是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s)。  </p>
<p>兆比每秒，即 Mb/s</p>
<p>3.吞吐量</p>
<p>吞吐量(throughput)表示在单位时间内通过某个网络（或信道、接口）的数据量。</p>
<p>吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p>
<p>吞吐量受网络的带宽或网络的额定速率的限制。 </p>
<p>4.时延(delay 或 latency)</p>
<p>传输时延（发送时延 ）  发送数据时，数据块从结点进入到传输媒体所需要的时间。</p>
<p>也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 </p>
<p>数据经历的总时延就是发送时延、传播时延、处理时延和排队时延</p>
<p>5.时延带宽积</p>
<p>时延带宽积 = 传播时延 *带宽</p>
<p>链路的时延带宽积又称为以比特为单位的链路长度。 </p>
<p>6.往返时间 Round-Trip TIme</p>
<p>7.利用率</p>
<p>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。</p>
<p>网络利用率则是全网络的信道利用率的加权平均值。</p>
<p>信道利用率并非越高越好。 </p>
<h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p>ISO：国家标准化组织</p>
<p>OSI/RM：互联网法律上的国际标准</p>
<p>TCP/IP Suite：因特网事实上的国际标准</p>
<p>Network Protocols：数据交换遵循的规则.标准或约定</p>
<p>网络体系结构：计算机网络各层及其协议的集合</p>
<h3 id="OSI七层模型："><a href="#OSI七层模型：" class="headerlink" title="OSI七层模型："></a>OSI七层模型：</h3><p>Application应用层：能够产生网络流量，能够和用户交互的应用程序</p>
<p>Presentation表示层：加密，压缩，开发人员</p>
<p>Session会话层：服务和客户端建立的会话，查木马， netstat -nb</p>
<p>网络工程师解决下面三层传输，不包括物理层</p>
<p>Transport传输层：可靠传输建立对话， 不可靠传输，流量控制</p>
<p>Network网络层：ip地址编制，选择最佳路径</p>
<p>Date Link数据链路层：数据如何封装，添加物理层地址 MAC地址</p>
<p>Physical物理层：电压 接口标准</p>
<h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p>网络排错：从底层到高层</p>
<h3 id="网络完全："><a href="#网络完全：" class="headerlink" title="网络完全："></a>网络完全：</h3><p>物理层安全</p>
<p>数据链路层安全 ADSL AP密码</p>
<p>网络层安全</p>
<p>应用层安全 SQL注入漏洞 上传漏洞</p>
<h2 id="13"><a href="#13" class="headerlink" title="13"></a>13</h2><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3><p>Application, Transport,Internet,Network Access</p>
<p>TCP/IP 是四层的体系结构：应用层、运输层、网际层和网络接口层。</p>
<p>往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构 。 </p>
<h3 id="本书5层模型："><a href="#本书5层模型：" class="headerlink" title="本书5层模型："></a>本书5层模型：</h3><p>Application, Transport,Internet,Data Link，Physical</p>
<p>应用层(application layer) ：传输数据单元PDU</p>
<p>运输层(transport layer) ：运输层报文</p>
<p>网络层(network layer) ：ip数据报（ip分组）</p>
<p>数据链路层(data link layer) ：数据帧</p>
<p>物理层(physical layer) ：0101</p>
<h3 id="发送数据过程"><a href="#发送数据过程" class="headerlink" title="发送数据过程"></a>发送数据过程</h3><p>应用层数据加上运输层首部，网络层首部，链路层首部和尾部，最后转化为比特流</p>
<h2 id="15"><a href="#15" class="headerlink" title="15"></a>15</h2><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>  物理层的主要任务描述为确定与传输媒体的接口的一些特性，即： </p>
<p>机械特性  指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</p>
<p>电气特性  指明在接口电缆的各条线上出现的电压的范围。</p>
<p>功能特性  指明某条线上出现的某一电平的电压表示何种意义。</p>
<p>过程特性  指明对于不同功能的各种可能事件的出现顺序。 </p>
<h3 id="数据通信系统模型"><a href="#数据通信系统模型" class="headerlink" title="数据通信系统模型"></a>数据通信系统模型</h3><p>输入信息到源点，然后输入数据到发送器然后发送信号到传输系统，然后接收器接受信号，然后输出数据到终点，然后输出信息。</p>
<h2 id="16"><a href="#16" class="headerlink" title="16"></a>16</h2><h3 id="几个术语"><a href="#几个术语" class="headerlink" title="几个术语"></a>几个术语</h3><p>通信的目的是传送消息。</p>
<p>数据(data)——运送消息的实体。</p>
<p>信号(signal)——数据的电气的或电磁的表现。 </p>
<p>“模拟的”(analogous)——代表消息的参数的取值是连续的。 </p>
<p>“数字的”(digital)——代表消息的参数的取值是离散的。 </p>
<p>码元(code)——在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p>
<h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>信道一般表示向一个方向传送信息的媒体。</p>
<p>单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。</p>
<p>双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</p>
<p>双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。 </p>
<h3 id="基带-baseband-信号和-带通-band-pass-信号"><a href="#基带-baseband-信号和-带通-band-pass-信号" class="headerlink" title="基带(baseband)信号和 带通(band pass)信号"></a>基带(baseband)信号和 带通(band pass)信号</h3><p>基带信号（即基本频带信号）——来自信源的信号</p>
<p>带通信号——把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。 </p>
<h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号进行调制(modulation)。 </p>
<p>最基本的二元制调制方法有以下几种：</p>
<p>调幅(AM)：载波的振幅随基带数字信号而变化。 </p>
<p>调频(FM)：载波的频率随基带数字信号而变化。</p>
<p>调相(PM) ：载波的初始相位随基带数字信号而变化。 </p>
<h3 id="数据通信常见编码"><a href="#数据通信常见编码" class="headerlink" title="数据通信常见编码"></a>数据通信常见编码</h3><p>单极性不归零码：只用一个电压值，用高电平表示1，没电平表示0 </p>
<p>双极性不归零码：正负电平表示二进制1，0，正负幅值相等</p>
<p>双极性归零码：正负零三电平</p>
<p>曼彻斯特编码(Manchester Encoding): 位中间电平从低到高跳变表示”0”;位中间电平从高到低跳变表示”1”。 </p>
<p>差分曼彻斯特编码(differential Manchester encoding): 在最初信号的时候,即第一个信号时:如果中间位电平从低到高,则表示0;如果中间位电平从高到低,则表示1。抗干扰能力比曼彻斯特编码强</p>
<h2 id="17"><a href="#17" class="headerlink" title="17"></a>17</h2><h3 id="信道极限容量"><a href="#信道极限容量" class="headerlink" title="信道极限容量"></a>信道极限容量</h3><p>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 </p>
<p>码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重。 </p>
<p>数字信号通过实际的信道 ：1.有失真，但是可识别 2. 失真大，无法识别 </p>
<h3 id="1-信道能够通过的频率范围"><a href="#1-信道能够通过的频率范围" class="headerlink" title="1.信道能够通过的频率范围"></a>1.信道能够通过的频率范围</h3><p>奈氏准则**。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">理想低通信道下的最高码元传输速率＝2W Baud</span><br><span class="line"></span><br><span class="line">其中W是理想低通信道的带宽，单位为赫兹；Baud是波特，即码元传输速率的单位，1波特为每秒传送1个码元。</span><br></pre></td></tr></table></figure>

<p>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</p>
<p> <strong>奈氏准则</strong>指出，码元传输速率是受限的；香农定理则给出了信息传输速率的极限。也就是说，奈氏准则认为码元编码足够好，就不会限制信息传输速率。<br>码元传输速率（波特率），是指传输码元的速率（废话）。与制信息传输速率（比特率）的区别在于，一个码元通过调频调相，可以显示出多种变化，就可以代表多个比特。一般来讲，信息传输速率=码元传输速率*log2(码元变化数量百)。<br>所以其实区别只有一个度，那就是奈氏准则是针对波特率的，没有限制比特率，他认为码元传输速率一旦确定，再确定码元所载的比特数，极限知信息传输速率也就确定了；而香农公式通过极其复杂的推演（我看不懂），得出了结论：信息传输速率也是有极限的，且这个极限不是由波特率单独决定，还是由传输带宽和信道噪比决定的。</p>
<h3 id="2-信噪比"><a href="#2-信噪比" class="headerlink" title="2.信噪比"></a>2.信噪比</h3><p><strong>香农公式</strong></p>
<p>香农(Shannon)用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。</p>
<p>信道的极限信息传输速率 <em>C</em> 可表达为</p>
<p>​    <em>C</em> = <em>W</em> log2(1+<em>S</em>/<em>N</em>) b/s </p>
<p><em>W</em> 为信道的带宽（以 Hz 为单位）；</p>
<p><em>S</em> 为信道内所传信号的平均功率；</p>
<p><em>N</em> 为信道内部的高斯噪声功率。 </p>
<p>结论：信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 </p>
<p>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。 </p>
<p>若信道带宽 <em>W</em> 或信噪比 <em>S</em>/<em>N</em> 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 <em>C</em> 也就没有上限。</p>
<p>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。 </p>
<h4 id="信息传输速率受香农公式限制，而码元传输速率受奈氏准则的限制"><a href="#信息传输速率受香农公式限制，而码元传输速率受奈氏准则的限制" class="headerlink" title="信息传输速率受香农公式限制，而码元传输速率受奈氏准则的限制"></a>信息传输速率受香农公式限制，而码元传输速率受奈氏准则的限制</h4><h2 id="18"><a href="#18" class="headerlink" title="18"></a>18</h2><h3 id="电信领域使用电磁波频率"><a href="#电信领域使用电磁波频率" class="headerlink" title="电信领域使用电磁波频率"></a>电信领域使用电磁波频率</h3><p>数据通信：小于10^-4HZ 大于10^16HZ</p>
<h3 id="导向传输媒体"><a href="#导向传输媒体" class="headerlink" title="导向传输媒体"></a>导向传输媒体</h3><p>双绞线：屏蔽双绞线 STP (Shielded Twisted Pair)，无屏蔽双绞线 UTP (Unshielded Twisted Pair)</p>
<p>同轴电缆：50 W 同轴电缆，75 W 同轴电缆</p>
<p>光缆 ：光线在纤芯中传输的方式是不断地全反射</p>
<h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>（Hub）是指将多条以太网双绞线或光纤集合连接在同一段物理介质下的设备；是一个多端口的转发器，当以HUB为中心设备时，网络中某条线路产生了故障，并不影响其它线路的工作。主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。<br>它工作于OSI参考模型第一层，即“物理层”，属于局域网中的基础设备版，采用CSMA/CD（即带冲突检测的载波监听多路访问技术)介质访问控制机制。集线器每个接口简单的收发比特，收到权1就转发1，收到0就转发0，不进行碰撞检测。HUB不具备交换机所具有的MAC地址表，所以它发送数据时都是没有针对性的，而是采用广播方式发送。在局域网中得到广泛应用。</p>
<h2 id="20"><a href="#20" class="headerlink" title="20"></a>20</h2><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><p>复用(multiplexing)是通信技术中的基本概念。 就是共享信道。</p>
<h4 id="频分复用-FDM-Frequency-Division-Multiplexing-：常用，电话就是。"><a href="#频分复用-FDM-Frequency-Division-Multiplexing-：常用，电话就是。" class="headerlink" title="频分复用 FDM(Frequency Division Multiplexing) ：常用，电话就是。"></a>频分复用 FDM(Frequency Division Multiplexing) ：常用，电话就是。</h4><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p>
<p>频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率</p>
<h4 id="时分复用TDM-Time-Division-Multiplexing"><a href="#时分复用TDM-Time-Division-Multiplexing" class="headerlink" title="时分复用TDM (Time Division Multiplexing)"></a>时分复用TDM (Time Division Multiplexing)</h4><p>时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</p>
<p>每一个用户所占用的时隙是周期性地出现（其周期就是 TDM 帧的长度）。</p>
<p>TDM 信号也称为等时(isochronous)信号。</p>
<p>时分复用的所有用户是在不同的时间占用同样的频带宽度。</p>
<p>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。时分复用可能会造成线路资源的浪费 </p>
<h4 id="统计时分复用-STDM-Statistic-TDM"><a href="#统计时分复用-STDM-Statistic-TDM" class="headerlink" title="统计时分复用 STDM (Statistic TDM)"></a>统计时分复用 STDM (Statistic TDM)</h4><h4 id="波分复用-WDM-Wavelength-Division-Multiplexing-：光的频分复用"><a href="#波分复用-WDM-Wavelength-Division-Multiplexing-：光的频分复用" class="headerlink" title="波分复用 WDM(Wavelength Division Multiplexing)  ：光的频分复用"></a>波分复用 WDM(Wavelength Division Multiplexing)  ：光的频分复用</h4><h3 id="码分复用-CDM-Code-Division-Multiplexing"><a href="#码分复用-CDM-Code-Division-Multiplexing" class="headerlink" title="码分复用 CDM (Code Division Multiplexing)"></a>码分复用 CDM (Code Division Multiplexing)</h3><p>常用的名词是码分多址 CDMA  (Code Division Multiple Access)。</p>
<p>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</p>
<p>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 </p>
<p>每一个比特时间划分为 <em>m</em> 个短的间隔，称为码片(chip)。</p>
<p>CDMA特点：每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(orthogonal)。在实用的系统中是使用伪随机码序列。 </p>
<h4 id="码片序列的正交关系"><a href="#码片序列的正交关系" class="headerlink" title="码片序列的正交关系"></a>码片序列的正交关系</h4><p>令向量 <strong>S</strong> 表示站 S 的码片向量，令 <strong>T</strong> 表示其他任何站的码片向量。 </p>
<p>两个不同站的码片序列正交，就是向量 <strong>S</strong> 和<strong>T</strong> 的规格化内积(inner product)都是 0： </p>
<img src="/Users/mengxiaowang/Library/Application Support/typora-user-images/image-20200508103821364.png" alt="image-20200508103821364" style="zoom:25%;" />

<p>任何一个码片向量和该码片向量自己的规格化内积都是1 。</p>
<p>一个码片向量和该码片反码的向量的规格化内积值是 –1。 </p>
<img src="/Users/mengxiaowang/Library/Application Support/typora-user-images/image-20200508103923650.png" alt="image-20200508103923650" style="zoom:25%;" />

<h3 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h3><p>1.脉码调制 PCM 体制 </p>
<p>脉码调制 PCM 体制最初是为了在电话局之间的中继线上传送多路的电话。</p>
<p>由于历史上的原因，PCM 有两个互不兼容的国际标准，即北美的 24 路 PCM（简称为 T1）和欧洲的 30 路 PCM（简称为 E1）。我国采用的是欧洲的 E1 标准。</p>
<ol start="2">
<li>同步光纤网 SONET 和 同步数字系列 SDH </li>
</ol>
<p>速率标准不统一，不是同步传输。</p>
<h3 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h3><h4 id="xDSL技术"><a href="#xDSL技术" class="headerlink" title="xDSL技术"></a>xDSL技术</h4><p>xDSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。</p>
<p>虽然标准模拟电话信号的频带被限制在 300~3400 kHz 的范围内，但用户线本身实际可通过的信号频率仍然超过 1 MHz。</p>
<p>xDSL 技术就把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。</p>
<p>DSL 就是数字用户线(Digital Subscriber Line)的缩写。而 DSL 的前缀 x 则表示在数字用户线上实现的不同宽带方案。 </p>
<p>分为</p>
<p>ADSL (Asymmetric Digital Subscriber Line)：非对称数字用户线</p>
<p>HDSL (High speed DSL)：高速数字用户线</p>
<p>SDSL (Single-line DSL)：1 对线的数字用户线</p>
<p>VDSL (Very high speed DSL)：甚高速数字用户线</p>
<p>DSL ：ISDN 用户线。</p>
<p>RADSL (Rate-Adaptive DSL)：速率自适应 DSL，是 ADSL 的一个子集，可自动调节线路速率）。 </p>
<h4 id="ADSL特点"><a href="#ADSL特点" class="headerlink" title="ADSL特点"></a>ADSL特点</h4><p>上行和下行带宽做成不对称的。</p>
<p>上行指从用户到 ISP，而下行指从 ISP 到用户。</p>
<p>ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。</p>
<p>我国目前采用的方案是离散多音调 <strong>DMT</strong> (Discrete Multi-Tone)调制技术。这里的“多音调”就是“多载波”或“多子信道”的意思。</p>
<p>光纤同轴混合网</p>
<h4 id="HFC-Hybrid-Fiber-Coax"><a href="#HFC-Hybrid-Fiber-Coax" class="headerlink" title="HFC (Hybrid Fiber Coax)"></a>HFC (Hybrid Fiber Coax)</h4><p>HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。</p>
<p>HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。</p>
<p>现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。而 HFC 网则需要对 CATV 网进行改造， </p>
<p>HFC特点：(1) HFC网的主干线路采用光纤(2) HFC 网采用结点体系结构 (3) HFC 网具有比 CATV 网更宽的频谱，且具有双向传输功能 </p>
<h4 id="FTTx-技术"><a href="#FTTx-技术" class="headerlink" title="FTTx 技术"></a>FTTx 技术</h4><p>实现宽带居民接入网的方案。这里字母 x 可代表不同意思。</p>
<p>光纤到家 FTTH (Fiber To The Home)：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法。</p>
<p>光纤到大楼 FTTB (Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。</p>
<p>光纤到路边 FTTC (Fiber To The Curb)：从路边到各用户可使用星形结构双绞线作为传输媒体。</p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络2（25-53）</title>
    <url>/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/</url>
    <content><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h3 id="数据链路层使用的信道主要有以下两种类型："><a href="#数据链路层使用的信道主要有以下两种类型：" class="headerlink" title="数据链路层使用的信道主要有以下两种类型："></a>数据链路层使用的信道主要有以下两种类型：</h3><p>点对点信道。这种信道使用一对一的点对点通信方式。</p>
<p>广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发 </p>
<h2 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h2><h3 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h3><p>链路(link)是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。</p>
<p>一条链路只是一条通路的一个组成部分。</p>
<p>数据链路(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p>
<p>现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。</p>
<p>一般的适配器都包括了数据链路层和物理层这两层的功能。  常常在两个对等的数据链路层之间画出一个数字管道，而在这条数字管道上传输的数据单位是帧。</p>
<p><strong>数据链路层传送的是帧</strong></p>
<h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><p>(1) 封装成帧：封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。</p>
<p>首部和尾部的一个重要作用就是进行帧定界，头SOH，尾EOT</p>
<p>(2) 透明传输：若数据部分有EOT，则后面会当成无效帧丢弃，</p>
<p>解决办法：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是 1B)。</p>
<p>字节填充(byte stuffing)或字符填充(character stuffing)——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</p>
<p>如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 </p>
<p>(3) 差错控制 ：在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。</p>
<p>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。</p>
<p>误码率与信噪比有很大的关系。</p>
<p>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 </p>
<h3 id="循环冗余检验的原理-（解决差错控制的）"><a href="#循环冗余检验的原理-（解决差错控制的）" class="headerlink" title="循环冗余检验的原理 （解决差错控制的）"></a>循环冗余检验的原理 （解决差错控制的）</h3><p>在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。</p>
<p>在发送端，先把数据划分为组。假定每组 <em>k</em> 个比特。 </p>
<p>假设待传送的一组数据 <em>M</em> = 101001（现在 <em>k</em> = 6）。我们在 <em>M</em> 的后面再添加供差错检测用的 <em>n</em> 位冗余码一起发送。 </p>
<p><em>冗余码计算：（很重要）</em></p>
<p>用二进制的模 2 运算进行 2<em>n</em> 乘 <em>M</em> 的运算，这相当于在 <em>M</em> 后面添加 <em>n</em> 个 0。</p>
<p>得到的 (<em>k</em> + <em>n</em>) 位的数除以事先选定好的长度为 (<em>n</em> + 1) 位的除数 <em>P</em>，得出商是 <em>Q</em> 而余数是 <em>R</em>，余数 <em>R</em> 比除数 <em>P</em> 少1 位，即 <em>R</em> 是 <em>n</em> 位。 </p>
<p>举例：现在 <em>k</em> = 6, <em>M</em> = 101001。</p>
<p>设 <em>n</em> = 3, 除数 <em>P</em> = 1101，</p>
<p>被除数是 2^n*M = 101001000。 </p>
<p>模 2 运算的结果是：商 <em>Q</em> = 110101，</p>
<p>​      余数 <em>R</em> = 001。</p>
<p>把余数 <em>R</em> 作为冗余码添加在数据 <em>M</em> 的后面发送出去。发送的数据是：2^n<em>M + *R</em> </p>
<p>  即：101001001，共 (<em>k</em> + <em>n</em>) 位。 </p>
<p>接收端对收到的每一帧进行 CRC 检验 :(1) 若得出的余数 <em>R</em> = 0，则判定这个帧没有差错，就接受(accept)。</p>
<p>(2) 若余数 <em>R</em> ¹ 0，则判定这个帧有差错，就丢弃。</p>
<p>但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。</p>
<p>只要经过严格的挑选，并使用位数足够多的除数 <em>P</em>，那么出现检测不到的差错的概率就很小很小。 </p>
<h3 id="帧检验序列-FCS"><a href="#帧检验序列-FCS" class="headerlink" title="帧检验序列 FCS"></a>帧检验序列 FCS</h3><p>在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。</p>
<p>循环冗余检验 CRC 和帧检验序列 FCS并不等同。</p>
<p>CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。</p>
<p>FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。 </p>
<h4 id="注意：仅用循环冗余检验-CRC-差错检测技术只能做到无差错接受-accept-。"><a href="#注意：仅用循环冗余检验-CRC-差错检测技术只能做到无差错接受-accept-。" class="headerlink" title="注意：仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受(accept)。"></a>注意：仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受(accept)。</h4><p>“无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。要做到“可靠传输”（即发送什么就收到什么）就必须再加上确认和重传机制。 </p>
<h2 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h2><h3 id="PPP-协议的特点-："><a href="#PPP-协议的特点-：" class="headerlink" title="PPP 协议的特点 ："></a>PPP 协议的特点 ：</h3><p>现在全世界使用得最多的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。</p>
<p>用户使用拨号电话线接入因特网时，一般都是使用 PPP 协议。 </p>
<h3 id="PPP-协议应满足的需求"><a href="#PPP-协议应满足的需求" class="headerlink" title="PPP 协议应满足的需求"></a>PPP 协议应满足的需求</h3><p>简单——这是首要的要求</p>
<p>封装成帧 </p>
<p>透明性 </p>
<p>多种网络层协议 </p>
<p>多种类型链路 </p>
<p>差错检测 </p>
<p>检测连接状态 </p>
<p>最大传送单元 </p>
<p>网络层地址协商 </p>
<p>数据压缩协商 </p>
<h3 id="PPP-协议不需要的功能"><a href="#PPP-协议不需要的功能" class="headerlink" title="PPP 协议不需要的功能"></a>PPP 协议不需要的功能</h3><p>纠错 </p>
<p>流量控制 </p>
<p>序号 </p>
<p>多点线路 </p>
<p>半双工或单工链路 </p>
<h3 id="PPP-协议有三个组成部分"><a href="#PPP-协议有三个组成部分" class="headerlink" title="PPP 协议有三个组成部分"></a>PPP 协议有三个组成部分</h3><p>一个将 IP 数据报封装到串行链路的方法。</p>
<p>从底层到高层分为</p>
<p>高级数据链路控制协议 HDLC</p>
<p>链路控制协议 LCP (Link Control Protocol)。</p>
<p>网络控制协议 NCP (Network Control Protocol)。  </p>
<h3 id="PPP-协议的帧格式"><a href="#PPP-协议的帧格式" class="headerlink" title="PPP 协议的帧格式"></a>PPP 协议的帧格式</h3><p>标志字段 F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110）。表示开始，和结束帧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">					首部                    ip数据报									  尾部</span><br><span class="line">	     F  A  C  协议					    信息部分									FCS  F</span><br><span class="line">字节数  1  1  1  2             不超过1500字节&lt;&#x3D;MTU           2    1</span><br><span class="line">字节    7E FF 03                                                7E</span><br><span class="line">&lt;--------------------------------PPP帧-----------------------------&gt;</span><br></pre></td></tr></table></figure>

<p>PPP 有一个 2 个字节的协议字段。</p>
<p>当协议字段为 0x0021 时，PPP 帧的信息字段就是IP 数据报。</p>
<p>若为 0xC021, 则信息字段是 PPP 链路控制数据。</p>
<p>若为 0x8021，则表示这是网络控制数据。 </p>
<p>地址字段 A 只置为 0xFF。地址字段实际上并不起作用。</p>
<p>控制字段 C 通常置为 0x03。</p>
<p>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。   </p>
<h4 id="透明传输问题"><a href="#透明传输问题" class="headerlink" title="透明传输问题 :"></a>透明传输问题 :</h4><p>当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充（和 HDLC 的做法一样）。 当 PPP 用在异步传输时，就使用一种特殊的字符填充法。 </p>
<h4 id="字符填充"><a href="#字符填充" class="headerlink" title="字符填充 :"></a>字符填充 :</h4><p>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列(0x7D, 0x5E)。 </p>
<p>若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列(0x7D, 0x5D)。</p>
<p>若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。 </p>
<h4 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h4><p>PPP 协议用在 SONET/SDH 链路时，是使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。</p>
<p>在发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除，</p>
<h4 id="不提供使用序号和确认-的可靠传输"><a href="#不提供使用序号和确认-的可靠传输" class="headerlink" title="不提供使用序号和确认 的可靠传输"></a>不提供使用序号和确认 的可靠传输</h4><p>PPP 协议之所以不使用序号和确认机制是出于以下的考虑：</p>
<p>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</p>
<p>在因特网环境下，PPP 的信息字段放入的数据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</p>
<p>帧检验序列 FCS 字段可保证无差错接受。  </p>
<h3 id="PPP-协议的工作状态"><a href="#PPP-协议的工作状态" class="headerlink" title="PPP 协议的工作状态"></a>PPP 协议的工作状态</h3><p>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</p>
<p>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</p>
<p>这些分组及其响应选择一些 PPP 参数，和进行网络层配置，NCP 给新接入的 PC机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</p>
<p>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。  </p>
<p>33集</p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络3</title>
    <url>/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机网络4</title>
    <url>/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机网络5</title>
    <url>/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机网络8</title>
    <url>/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机网络6</title>
    <url>/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机网络7</title>
    <url>/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C7/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>黑客大全1</title>
    <url>/2020/05/07/%E9%BB%91%E5%AE%A2%E5%A4%A7%E5%85%A81/</url>
    <content><![CDATA[<p>可以使用insecam网站各国摄像头，观看摄像头</p>
<p>如何你想监控摄像头，可以使用ssh登录他主机，然后brew install imagesnap</p>
<p>然后Take a Photo</p>
<p>To take a photo using the default video input device (<em>FaceTime HD Camera</em> is the default in most newer Macs), simply execute this:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Take image, <span class="built_in">let</span> camera warm up 1 second</span></span><br><span class="line">imagesnap -w 1 snapshot.png</span><br></pre></td></tr></table></figure>

<p>You’ll wait a brief second or two, your green camera indicator will light up, and will then quickly fade out.  The image will be saved to a <code>snapshot.png</code> file.</p>
<p>ImageSnap also has the functionality to take a photo every <em>n</em> seconds:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> imagesnap -t &#123;x&#125;:&#123;yy&#125; seconds</span></span><br><span class="line">imagesnap -t 1 -w 1</span><br></pre></td></tr></table></figure>

<p>The command above takes a photo every second until the process is killed.</p>
<p>While I looked for this ability out of curiosity, there are some great use cases for taking images from command line, like <a href="http://hints.macworld.com/article.php?story=20080824185920426" target="_blank" rel="noopener">tracking your Mac if it’s stolen</a> or taking a photo upon invalid login.  Imagesnap is an incredible utility:  simple to use and doesn’t try to accomplish too much!</p>
<h2 id="如何免密进入苹果电脑"><a href="#如何免密进入苹果电脑" class="headerlink" title="如何免密进入苹果电脑"></a>如何免密进入苹果电脑</h2><p>重启电脑中 command+s进入开发者模式，</p>
<p>然后输入以下命令新建一个user</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -uw &#x2F;</span><br><span class="line">rm &#x2F;var&#x2F;db&#x2F;.applesetupdone</span><br><span class="line">shutdown -h now</span><br></pre></td></tr></table></figure>

<p>通过另一个user账户改其他账户的密码。</p>
<p>注册新的账号，然后system prefenrences，然后user and group, 然后onlock，然后改其他用户密码。</p>
<h2 id="追踪ip，通过发链接"><a href="#追踪ip，通过发链接" class="headerlink" title="追踪ip，通过发链接"></a>追踪ip，通过发链接</h2><p><a href="https://grabify.link/track/O1RFRW网站进入，然后进而查ip地址。" target="_blank" rel="noopener">https://grabify.link/track/O1RFRW网站进入，然后进而查ip地址。</a></p>
<h2 id="vnc-viewer"><a href="#vnc-viewer" class="headerlink" title="vnc viewer"></a>vnc viewer</h2><p>电脑手机下载后可以远程电脑控制手机。免费版只可在同一局域网下</p>
<h2 id="isentry："><a href="#isentry：" class="headerlink" title="isentry："></a>isentry：</h2><p>监控摄像头，锁屏也可以用</p>
]]></content>
  </entry>
  <entry>
    <title>申请学校</title>
    <url>/2020/05/14/%E7%94%B3%E8%AF%B7%E5%AD%A6%E6%A0%A1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>作者：AdmitWrite<em>硕士</em>留学<br>链接：<a href="https://www.zhihu.com/question/64316943/answer/1214032948" target="_blank" rel="noopener">https://www.zhihu.com/question/64316943/answer/1214032948</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="个人背景及申请结果"><a href="#个人背景及申请结果" class="headerlink" title="个人背景及申请结果"></a><strong>个人背景及申请结果</strong></h2><blockquote>
<p>本科专业：物联网工程 GPA：84（WES 3.46） 22/120 TOEFL：106（S22） GRE：153+168+3.5 科研经历/paper：学院里一段比较水的科研和一段web开发，无paper 竞赛：美赛H，大创国家级</p>
</blockquote>
<p><strong>申请结果（括号内为提交申请的日期和收到结果的日期）</strong></p>
<p><strong>AD</strong></p>
<blockquote>
<p>CMU,MITS(1.13/4.17)；CMU,eBiz(12.12/1.27)；UChicago,CS(12.5/1.28)；Duke,ECE(1.21/3.11)；NYU-Tandon,CS(1.17/3.24)(奖学金4000刀)；Brandies,CS（1.15/4.19）（奖学金10000刀）</p>
</blockquote>
<p><strong>Rej</strong></p>
<blockquote>
<p>UPenn,CIS(11.14/12.16)；Columbia,CS(1.2/3.7)；Dartmouth,CS(12.14/2.28)；CMU,MISM-21(1.9,3.31)；UCSD,CS(12.9/3.7)；JHU,CS(1.15/4.16)</p>
</blockquote>
<p><strong>Pending</strong></p>
<blockquote>
<p>USC,CS-general（12.5）；CMU-SV,SE(12.14)；Cornell,CS-Meng(1.6)；UMich,MSI(1.13)；NWU,CS（1.16）最后Pending的结果是USC的CS general变成了春季的AD，其他全是Rej。</p>
</blockquote>
<p>作者：纽约大叔<br>链接：<a href="https://zhuanlan.zhihu.com/p/137654432" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/137654432</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="一、专为非计算机背景学生设置的项目"><a href="#一、专为非计算机背景学生设置的项目" class="headerlink" title="一、专为非计算机背景学生设置的项目"></a><strong>一、专为非计算机背景学生设置的项目</strong></h2><p><strong>1.芝加哥大学</strong></p>
<p>芝加哥大学计算机系专门设置了一个针对转专业学生的项目：MS in Computer Science program。与其他普通的MSCS不同，该项目主要多了两门课程：Concepts of Programming和Math for Computer Science: Discrete Math。</p>
<p>● 适合对象：无任何编程或计算机背景的申请人<br>● 前置课程：编程基础、集散数学等<br>● 学制：9门课程学位：2个月前置课程+9个月正式课程；12门课程学位：2个月前置课程+15个月正式课程（含夏季实习）</p>
<p>院校背景：芝加哥大学的计算机系是美国最强的计算机系之一，最大特点就是注重计算机与商业需要的结合，并运用到商业和市场应用及各种决策分析中。</p>
<p><strong>2.宾夕法尼亚大学</strong></p>
<p>宾夕法尼亚大学的Master of Computer and Information Technology program（MCIT）项目是专门为非计算机背景的学生设置的。该项目主要有5门必修课：计算机科学数学基础、计算机系统概述、数据结构和软件设计、软件发展概述以及计算机系统编程和算法等。</p>
<p>该项目历届录取学生的背景很多样化，包括法律、数学、文学、历史、化学、医学等。</p>
<p>● 适合对象：无任何编程或计算机背景的申请人<br>● 前置课程：6门前置课程<br>● 学制：一年半到两年</p>
<p>院校背景：除MCIT项目外，同系还开设有CIS，CGGT，EMBS，Robotics等硕士项目。CS专业的学生很多会选择申请CIS项目，对图像感兴趣的学生会考虑CGGT，对嵌入式系统感兴趣的学生会考虑EMBS，对机器人感兴趣的学生会考虑Robotics项目。</p>
<p>另外，宾大的MCIT项目在为数不多的转专业项目中，算是难度最高的一个项目了。海本学生，至少3.7以上的GPA，GRE330以上，会有比较大的机会。</p>
<p><strong>3.布兰迪斯大学</strong></p>
<p>布兰迪斯大学的计算机科学硕士 MA in Computer Science for Non-majors 是针对非计算机专业背景人士开设。与普通的CS专业相比，该专业多了一个学期的课程，主要补的是计算机的基础课程。</p>
<p>● 适合对象：无任何编程或计算机背景的申请人<br>● 前置课程：4门本科计算机基础课程 COSI 11a, COSI 12b, COSI 21a, and COSI 29a<br>● 学制：2年，四个学期</p>
<p>院校背景：该项目不仅提供计算机基础相关的课程学习，也提供一些热门领域的课程，如大数据。选修课涵盖各个领域，学生可以根据自己的兴趣去选择。另外，项目提供较为丰富的资助机会，将有可能拿到奖学金。</p>
<p><strong>4.南加利福尼亚大学</strong></p>
<p>南加利福尼亚大学计算机方向针对转专业学生重点推荐的是计算机科学硕士—科工方向Master of Science in ComputerScience - Scientists and Engineers。科工方向是37个学分，比其他方向多了5个学分，也会有一些计算机科学基础和预备课程。</p>
<p>● 适合对象：适合计算机背景有限、拥有工程或理科专业背景的学生申请<br>● 学制：两年</p>
<p>院校背景：南加利福尼亚大学的计算机系Department of Computer Science方向非常齐全，共开设了8个硕士课程，每个program计划招生40人左右，人数庞大，因此申请难度要低于其他院校。</p>
<p><strong>5.东北大学</strong></p>
<p>美国东北大学计算机学院专门针对转专业学生设置的项目为Align MS in CS (For people new to CS)。</p>
<p>相比其他项目，本项目多了四门计算机的基础课程：计算机基础离散结构、计算机系统/算法和面向对象的语言。该项目在课程上完以后，学校还会推荐实习。目前和这个项目合作的公司主要有Amazon , Facebook,Google以及美国有名的差旅费管理服务商Concur，房产信息平台Zillow等。</p>
<p>● 适合对象：针对那些非CS专业但是想要找CS相关工作的学生</p>
<p>院校背景：近年来，由于地理位置、COOP政策、招生规模扩大等因素，东北大学的CS项目热度非常高。因此，该其项目的申请难度波动也非常大。按前几年的录取趋势来看，普通985学校3.5左右的GPA，GT中等偏上就有很大机会被录。</p>
<blockquote>
<p>如果对美国CS专业申请有任何疑问，可以添加我的微信免费咨询，微信：bayergogo，还可以免费领取托福、雅思、GRE、GMAT等学习资料。</p>
</blockquote>
<p><strong>二、其他对转专业申CS较友好的项目</strong></p>
<p><strong>1.卡耐基梅隆大学</strong><br>卡耐基梅隆大学拥有全美最大的计算机学院，其CS下的细分专业是十分全面。对于转专业申请，首先要提的就是设置在计算机学院下的Master of Science in InformationTechnology (MSIT) Programs in eBusiness Technology（EBIZ）项目。</p>
<p>● 课程设置方面，该项目十分重视动手能力，课程也完全由项目组成，包含16个Task和一个Practicum。因此在申请材料中一定要突出动手能力或是领导经验。</p>
<p>● 招生方面，该项目每年招生60人左右，会录取很多非CS、非技术出身的申请者。录取者构成基本1/3为CS专业，1/3为电子，化工工程类专业，剩下1/3则是商科/人文（金融，经济，会计等）专业。</p>
<p>● 申请方面，该项目比较看重雅思/托福成绩，对拥有理工科背景的申请者会适当放宽托福口语要求，而文商科类申请者托福或雅思成绩要求就比较高。</p>
<p><strong>2.纽约大学</strong></p>
<p>纽约大学分别在文理学院和工学院下设置了CS的master项目。尽管如此，两个学院的CS项目排名大大不同，分别为29和70。其中，工学院的CS提供preparatory bridge courses, 是专门针对CS背景较弱的学生设置的，所以转专业申请的话，可以申请工学院的CS，难度相比文理学院的CS要低。</p>
<h2 id="学校分层"><a href="#学校分层" class="headerlink" title="学校分层"></a>学校分层</h2><p>作者：<em>申</em>荣教育<br>链接：<a href="https://zhuanlan.zhihu.com/p/75261927" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/75261927</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p><strong>学校分档</strong></p>
<p><img src="https://pic4.zhimg.com/v2-efbd28322aee77dda546da042d6ccc3f_b.jpg" alt="img"></p>
<p><strong>1、哥伦比亚大学</strong></p>
<p>哥大的 CS 系成立于 1979 年，研究的领域涵盖了 CS 领域的各个研究方向，包括计算生物学、计算机工程、算法和用户界面、安全与隐私、软件系统、计算机理论、视觉与机器人等等。共开设有 25 个研究小组和实验室。其中，实力较强的专业方向包括机器学习、安全与隐私、软件系统以及计算机理论。</p>
<p><strong>申请特点</strong></p>
<p>该校较为注重申请者的综合素质，需要申请者在硬件和软件方面有一定的积累。在硬件方面，GPA 85 分左右，TOEFL 100 分左右，GRE325 以上的条件拿到录取有较大的保障。</p>
<p><strong>2、卡耐基梅隆大学</strong></p>
<p>对于一般的美国院校来说，计算机科学只是设置为一个系，即Department of Computer Science，然而，CMU 对 CS 的建设非常有诚意，直接就开设成为了一个院——School of Computer Science。CMU 拥有数量庞大的教授队伍，多位曾获图灵奖，此华丽阵容，使得 CMU 当之无愧地成为 CS 专排第一的牛校。</p>
<p>基于CMU研究人员的庞大，本校涵盖了计算机科学的所有研究方向，不单细致地做每一个研究方向，并且将这些研究方向的应用也有较为深入的研究。</p>
<p><strong>申请特点</strong></p>
<p>硕士课程有较大的面试几率。曾经有申请软件工程和游戏设计的客户收到了 CMU 的面试电话。面试的内容都非常带有本所的特色，如软件研究所注重软件项目经历，需要客户口头描述下自己的项目经历。</p>
<p>从整体来看，CMU 比较看重研究背景。</p>
<p><strong>3、纽约大学</strong></p>
<p>研究内容包括算法与理论，密码学，计算生物学，计算机图形图像与用户界面，形式化方法，机器学习与知识呈现网络，科学计算等。CS 的特色在于与别系（尤其是数学系）合作非常紧密，CS 学生跨学科学习和合作的机会较多，如化学，物理，生物，神经科学等。</p>
<p><strong>申请特点</strong></p>
<p>NYU 开设了 MS 和 Ph.D 学位，对于 Master 的申请者，学校校求 T100，G 每部分在85%，或至少一部分达 92%；除此以外，还要求申请者掌握 C++，Java，汇编语言，操作系统等。</p>
<p><strong>4、加利福尼亚大学洛杉矶分校</strong></p>
<p>历史上 UCLA 的 CS 曾经一度辉煌，上到过第 6，由此可见UCLA 的强大程度。UCLA 辉煌的历史可能在于它对 Internet 的发展所作出的巨大贡献，它作为INTERNET 的先驱，地处阳光灿烂的南加州，应当成为 CS 学生的乐土。UCLA 的 CS 系很大，教授数量也很多。</p>
<p><strong>申请特点</strong></p>
<p>UCLA 的录取难度向来很高。外本和港本的学生在申请时会容易一些，而国内名校的学生在申请时会有一些优势。UCLA 除了看重硬件条件以外，也是非常看重申请者的研究背景。因此，如果只硬件好的学生在很多情况下也拿不到 UCLA 的录取。</p>
<p><strong>5、伊利诺伊大学香槟分校</strong></p>
<p>伊利诺伊大学香槟分校从美国国家科学基金获得研究经费量，年年在全美名列第一。计算机系和很多著名的公司保持着合作关系，例如拥有数百万美元的并行计算和云计算研究中心。</p>
<p>学生有很多实践机会，着重计算机和其他学科的交叉研究。本专业的学生在毕业以后可以继续攻读与计算机科学相关的更高层次的学位课程，也可以直接就业。</p>
<p><strong>申请特点</strong></p>
<p>计算机系写明了对于申请学生 GPA 的要求，并且告知历年录取的学生平均 GPA 为 3.7。由此说明学校对于学生的本科硬件条件有着比较严格的要求。</p>
<p><strong>6、西北大学</strong></p>
<p>西北大学计算机专业研究领域包括：Artificial intelligence, Human computer interaction.,Distributed interactive systems., Theoretical computer science, Programming languages, Computer graphics and human computer interfaces, Robotics, Parallel processing, Computer architecture,Large-scale systems.</p>
<p><strong>申请特点</strong></p>
<p>西北大学的 CS 专业近两年，也成为那些要去综合排名前 20 的申请者的一个不错的选择。从发放的录取结果看来，该校的 CS 专业并不算很难申，而且发的录取也相对多。同时也适合非 CS 专业的学生申请，以往就看到有一些 EE的学生拿到录取。</p>
<p><img src="https://pic1.zhimg.com/v2-b0b7af7691ced6b48a1e2ca9a65fe440_b.jpg" alt="img"></p>
<p><strong>7、华盛顿大学圣路易斯分校</strong></p>
<p>CS专业开设在工程与应用科学学院，总的来说工程学院确实不是WUSTI的一个强势学院，但是最近几年学校已经在大力发展。计算机科学与工程系共开设了3个研究生学位项目：计算机科学理学硕士，计算机工程理学硕士，计算机科学与工程硕士。</p>
<p><strong>申请要求</strong></p>
<p>GPA一般在3.3左右，GRE平均320，托福平均100分。</p>
<p><strong>8、南加州大学</strong></p>
<p>研究领域包括 1 Artificial Intelligence, Agents, Natural Language; 2 Databases and Information Management; 3 Graphics Games &amp; Multimedia; 4 Parallel and Distributed Computations; 5 Robotics, Brain Theory, and Computational Neuroscience; 6 Software Systems and Engineering; 7 Systems, Distributed Systems, Communication Networks; 8 Theory and Computational Sciences 八大方向。每个大的方向下设很多实验室和研究中心，分别有不同的教授带领着。</p>
<p><strong>申请特点</strong></p>
<p>招生人数较为庞大，这也是相对而言在专业排名前 30 的学校中它的申请难度大大低于其他高校的原因。但是随着历年来很多学生扎堆申请 USC 的 CS 专业，学校对于申请者的要求也在提高。</p>
<p><strong>9、加利福尼亚大学尔湾分校</strong></p>
<p>UCI 的 CS 系设置于该校的信息与计算机科学学院下，是该院最大的系。</p>
<p>研究方面，该系涉及到了 CS 领域下在的 11 个研究方向，包括：算法与复杂性，人工智能与机器学习、生物医学信息学、计算机体系结构与嵌入式系统、计算机图形学与可视化计算、数据库与数据挖掘、网络与分布式系统、编程语言与编译、安全隐私与密码学、科学计算以及普适计算。</p>
<p>其中，网络与系统、人工智能和计算机安全这几个方面的研究实力最为突出。</p>
<p><strong>申请特点</strong></p>
<p>UCI 是 UC 系列的院校里录取中国学生较多的院校之一，CS 专业更是如此，总的申请难度并不是太高，不过，就会很注重硬件成绩，GPA 3.5 左右，GRE 321以上，TOEFL 100 分以上的申请者才有较大的录取可能性。</p>
<p><strong>10、东北大学</strong></p>
<p>东北大学的 CS 系成立于 1982 年，设置在计算机与信息科学学院下面，从事 4 大专业领域，包括健康信息学、信息安全、网络科学、软件可靠性的研究。</p>
<p>这 4 大专业领域又可以分为11 个研究组，包括：算法与理论、人工智能、形式化方法、人机交互、信息检索与数据挖掘、网络安全、编程语言、机器人技术、软件工程、社会网络以及系统等研究组。</p>
<p><strong>申请特点</strong></p>
<p>该校属于申请热门院校，被很多申请者拿到作为保底的选择。过去几年来看，它的录取标准是 GPA 3.0 以上，GRE 320分以上，TOEFL 90 分以上这样的水平，但东北的 CS 专业的申请难度已经逐年提高。</p>
<p><img src="https://pic2.zhimg.com/v2-288cff649fcffc7fdaaf330bf382060d_b.jpg" alt="img"></p>
<p><strong>11、雪城大学</strong></p>
<p>雪城大学的 CS 系与 EE 系合并在同一系下，这也是作为雪城的办学特色，因为学生可以跨学科学习。学校非常重视研究能力，学生在学习过程中也有机会参与到研究项目当中。</p>
<p>由于 EECS 合办的原因，该系的研究方向是有比较大的交叉性的，共有 11 个研究方向。其中属于 CS 领域的专业方向比较少包括：人工智能、网络安全，硬件设计和计算机体系结构。</p>
<p><strong>申请特点</strong></p>
<p>雪城的录取难度比第三档的其它学校要高一些，是介于第二档跟第三档间的。学校每年发放的录取非常多，门槛也较低。申请者的条件只要达到 GPA 80 分左右，GRE315以上，TOEFL 95分以上，拿到该校的录取就不难。</p>
<p><strong>12、佛罗里达大学</strong></p>
<p>CS设置在名为计算机信息科学与工程系下，此系同时归属两个大院，college of engineering 和college of liberal arts and science。该 department 的研究领域有：计算机图形模拟与艺术，计算机系统，数据库与信息系统，高能计算/应用算法，智能系统与计算机视觉。</p>
<p><strong>申请特点</strong></p>
<p>一般 GPA83 以上，GRE320 以上，TOEFL90 以上都有较大可能获得录取，并且此校有一个发AA 奖的传统，即无论硕士博士，条件相对较好的申请者都能拿到一半的学费减免。这一点对于申请硕士，希望拿到奖学金的学生来说是个好消息。</p>
<p><strong>13、伍斯特理工学院</strong></p>
<p>WPI 的 CS 有 37 个教授，大概方向有 6 个，分别是数据科学，生物信息与计算生物学，计算机安全，交互媒体和游戏开发，Learning Sciences &amp; Technologies， 机器人工程。研究最热门的是人工智能、人机交互和网络/分布式系统。</p>
<p>MS 课程招生有两个方向，分别是computer/communications networks program 和 computer security。</p>
<p><strong>申请特点</strong></p>
<p>分数要求不算特别严格，特别是托福分数，目前看到我们有好几个案例都是托福分数不到 90 的；比较注重研究背景。这样的学校比较适合有一定的工作经验或者有比较丰富的项目经历，但是分数比较一般的学生去申请。</p>
<p><strong>14、乔治华盛顿大学</strong></p>
<p>GWU 的 CS 系比较小巧，主要从事 CS 专业下 8 个专业方向的研究：算法与理论、生物信息学与生物医学计算、计算机与信息安全、数字媒体、机器智能与认知、网络与移动计算、普适计算与嵌入式系统、软件工程与系统等。</p>
<p>其中，较有实力的方面是算法与理论以及生物信息学与生物医学计算。</p>
<p><strong>申请特点</strong></p>
<p>GWU 的 CS 系在招生方面录取门槛非常低，堪称又一个高综合排名 AD 狂。如果你的目标是申请综百前 50 的 CS，而分数不好，GWU 会是一个好的选择。从前几年的录取来看，GPA80 分左右，GRE310 分以上，TOEFL 90 分以上的申请者拿到录取的可能性非常高。</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>计算机学习必备网站</title>
    <url>/2020/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%BF%85%E5%A4%87%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h2 id="Computer-Science-website"><a href="#Computer-Science-website" class="headerlink" title="Computer Science website"></a>Computer Science website</h2><p><a href="http://yun.itheima.com/course/c26/p/1.html?hm/" target="_blank" rel="noopener"> 黑马程序员</a> <br><br>        <a href="https://www.bilibili.com/" target="_blank" rel="noopener"> b站</a> <br><br>        <a href="https://www.y2mate.com/en10" target="_blank" rel="noopener"> 免费下载youtube</a><br><br>        <a href="https://www.slader.com/textbook/9780321982384-linear-algebra-and-its-applications-5th-edition/" target="_blank" rel="noopener">slader查课本答案</a><br><br>        <a href="https://www.youtube.com/" target="_blank" rel="noopener">youtube </a><br><br>        <a href="https://docs.python.org/3.9/tutorial/index.html" target="_blank" rel="noopener"> Python官方文档</a><br><br>        <a href="https://obook.cc/forum-1-1.htm?tagids=13___" target="_blank" rel="noopener">电子书免费下载 </a><br><br>        <a href="https://www.zhihu.com/" target="_blank" rel="noopener"> 知乎</a><br><br>        <a href="https://coolshell.cn/articles/20793.html" target="_blank" rel="noopener">酷壳博客学内核 </a><br><br>        <a href="http://cmsblogs.com/?vip=1" target="_blank" rel="noopener">java技术驿站 </a><br><br>        <a href="https://www.freetechbooks.com/operating-systems-f36.html" target="_blank" rel="noopener">免费下载英文计算机pdf </a><br><br>        <a href="https://online.tipp10.com/en/training/" target="_blank" rel="noopener">免费练打字 </a><br><br>        <a href="https://how2j.cn/k/interface-inheritance/interface-inheritance-interface/289.html" target="_blank" rel="noopener"> java在线课程</a><br><br>        <a href="https://www.bilibili.com/video/av11361088" target="_blank" rel="noopener">动力节点所有课链接 </a><br><br>        <a href="https://leetcode.com/problems/two-sum/submissions/" target="_blank" rel="noopener">LeetCode </a><br><br>        <a href="https://captainbed.vip/4-1-2/" target="_blank" rel="noopener">人工智能自学 </a><br><br>        <a href="https://www.baidu.com" target="_blank" rel="noopener">百度 </a><br><br>        <a href="https://www.runoob.com/java/java-operators.html" target="_blank" rel="noopener"> 菜鸟教程</a><br><br>        <a href="https://gre.kmf.com/practise" target="_blank" rel="noopener">GRE考满分 </a><br><br>        <a href="https://gre.viplgw.cn" target="_blank" rel="noopener"> GRE雷哥</a><br><br>        <a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">github </a><br><br>        <a href="https://www.jiumodiary.com" target="_blank" rel="noopener">鸠摩搜书免费搜书</a><br><br>        <a href="https://www.zhihu.com/question/311758187/answer/902621271" target="_blank" rel="noopener">知乎java讲解</a><br></p>
<p><a href="https://bilibili.iiilab.com/" target="_blank" rel="noopener">下载b站视频网站youtube也可以</a><br></p>
]]></content>
  </entry>
  <entry>
    <title>linux基础（61-80集）</title>
    <url>/2020/04/26/linux4/</url>
    <content><![CDATA[<h2 id="P60-61（用户文件权限）"><a href="#P60-61（用户文件权限）" class="headerlink" title="P60-61（用户文件权限）"></a>P60-61（用户文件权限）</h2><p>用户管理包括用户与组管理。</p>
<p> Linux操作系统对多用户的管理，是非常繁琐的，所以用组的概念来管理用户就变得简单，每个用户可以在一个独立的组，每个组也可以有零个用户或者多个用户。</p>
<p>Linux系统用户是根据用户ID来识别的，默认ID长度为32位，从默认ID编号从0开始，但是为了和老式系统兼容，用户ID限制在60000以下，Linux用户分总共分为三种，分别如下：</p>
<p> root用户  （ID 0）</p>
<p> 系统用户 （ID 1-499）</p>
<p>普通用户 （ID 500以上）</p>
<p>Linux系统中的每个文件或者文件夹，都有一个所属用户及所属组，使用id命令可以显示当前用户的信息，使用passwd命令可以修改当前用户密码。Linux操作系统用户的特点如下：</p>
<p>每个用户拥有一个UserID，操作系统实际读取的是UID，而非用户名；</p>
<p>每个用户属于一个主组，属于一个或多个附属组，一个用户最多有31个附属组；</p>
<p>每个组拥有一个GroupID；</p>
<p>每个进程以一个用户身份运行，该用户可对进程拥有资源控制权限；</p>
<p>每个可登陆用户拥有一个指定的Shell环境。</p>
<h2 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h2><p>Linux用户在操作系统可以进行日常管理和维护，涉及到的相关配置文件如下：</p>
<p>/etc/passwd   保存用户信息</p>
<p> /etc/shdaow   保存用户密码（以加密形式保存）</p>
<p> /etc/group    保存组信息</p>
<p> /etc/login.defs  用户属性限制,密码过期时间,密码最大长度等限制</p>
<p> /etc/default/useradd 显示或更改默认的useradd配置文件</p>
<p>如需创建新用户，可以使用命令useradd，执行命令useradd test1即可创建test1用户，同时会创建一个同名的组test1，默认该用户属于test1主组。</p>
<p>Useradd test1命令默认创建用户test1，会根据如下步骤进行操作：</p>
<p> 在/etc/passwd文件中添加用户信息；</p>
<p>如使用passwd命令创建密码，密码会被加密保存在/etc/shdaow中；</p>
<p> 为test1创建家目录：/home/test1；</p>
<p> 将/etc/skel中的.bash开头的文件复制至/home/test1家目录；</p>
<p> 创建与用户名相同的test1组，test1用户默认属于test1同名组；</p>
<p> test1组信息保存在/etc/group配置文件中。</p>
<p>在使用useradd命令创建用户时，可以支持如下参数：</p>
<p>用法：useradd [选项] 登录</p>
<p>useradd -D</p>
<p>useradd -D [选项]</p>
<p>选项：</p>
<p>-b, –base-dir BASE_DIR     指定新账户的家目录；</p>
<p>-c, –comment COMMENT      新账户的 GECOS 字段；</p>
<p>-d, –home-dir HOME_DIR     新账户的主目录；</p>
<p>-D, –defaults         显示或更改默认的 useradd 配置；</p>
<p>-e, –expiredate EXPIRE_DATE  新账户的过期日期；</p>
<p>-f, –inactive INACTIVE     新账户的密码不活动期；</p>
<p>-g, –gid GROUP         新账户主组的名称或ID；</p>
<p>-G, –groups GROUPS     新账户的附加组列表；</p>
<p>-h, –help           显示此帮助信息并推出；</p>
<p>-k, –skel SKEL_DIR       使用此目录作为骨架目录；</p>
<p>-K, –key KEY=VALUE       不使用 /etc/login.defs 中的默认值；</p>
<p>-l, –no-log-init      不要将此用户添加到最近登录和登录失败数据库；</p>
<p>-m, –create-home      创建用户的主目录；</p>
<p>-M, –no-create-home    不创建用户的主目录；</p>
<p>-N, –no-user-group     不创建同名的组；</p>
<p>-o, –non-unique        允许使用重复的 UID 创建用户；</p>
<p>-p, –password  PASSWORD     加密后的新账户密码；</p>
<p>-r, –system          创建一个系统账户；</p>
<p>-R, –root CHROOT_DIR      chroot 到的目录；</p>
<p>-s, –shell SHELL        新账户的登录 shell；</p>
<p>-u, –uid UID          新账户的用户 ID；</p>
<p>-U, –user-group        创建与用户同名的组；</p>
<p>-Z, –selinux-user SEUSER    为SELinux 用户映射使用指定 SEUSER。</p>
<h2 id="Linux组管理"><a href="#Linux组管理" class="headerlink" title="Linux组管理"></a>Linux组管理</h2><p> 所有的Linux或者Windows系统都有组的概念，通过组可以更加方便的管理用户，组的概念应用于各行行业，例如企业会使用部门、职能或地理区域的分类方式来管理成员，映射在Linux系统，同样可以创建用户，并用组的概念对其管理。</p>
<p>Linux组有如下特点：</p>
<p> 每个组有一个组ID；</p>
<p> 组信息保存在/etc/group中；</p>
<p> 每个用户至少拥有一个主组，同时还可以拥有31个附属组。</p>
<p>通过命令groupadd、groupdel、groupmod来对组进行管理，详细参数使用如下：</p>
<p>groupadd用法</p>
<p>-f, –force       如果组已经存在则成功退出；</p>
<p>并且如果 GID 已经存在则取消 –g；</p>
<p>-g, –gid GID       为新组使用 GID；</p>
<p>-h, –help         显示此帮助信息并推出；</p>
<p>-K, –key KEY=VALUE    不使用 /etc/login.defs 中的默认值；</p>
<p>-o, –non-unique      允许创建有重复 GID 的组；</p>
<p>-p, –password PASSWORD  为新组使用此加密过的密码；</p>
<p>-r, –system        创建一个系统账户；</p>
<p>groupmod用法</p>
<p>-g, –gid GID       将组 ID 改为 GID；</p>
<p>-h, –help         显示此帮助信息并推出；</p>
<p>-n, –new-name NEW_GROUP 改名为 NEW_GROUP；</p>
<p>-o, –non-unique      允许使用重复的 GID；</p>
<p>-p, –password PASSWORD  将密码更改为(加密过的) PASSWORD；</p>
<p>groupdel用法</p>
<p>groupdel admin         删除admin组；</p>
<h2 id="二、-Linux权限管理"><a href="#二、-Linux权限管理" class="headerlink" title="二、 Linux权限管理"></a>二、 Linux权限管理</h2><p>Linux权限是操作系统用来限制对资源访问的机制，权限一般分为读、写、执行。系统中每个文件都拥有特定的权限、所属用户及所属组，通过这样的机制来限制哪些用户或用户组可以对特定文件进行相应的操作。</p>
<p>Linux每个进程都是以某个用户身份运行，进程的权限与该用户的权限一样，用户的权限越大，则进程拥有的权限就越大。</p>
<p>Lnux中有的文件及文件夹都有至少权限三种权限，常见的权限如表5-1所示:</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>r（读取）</td>
<td>可读取文件内容</td>
<td>可列出目录内容</td>
</tr>
<tr>
<td>w（写入）</td>
<td>可修改文件内容</td>
<td>可在目录中创建删除内容</td>
</tr>
<tr>
<td>x（执行）</td>
<td>可作为命令执行</td>
<td>可访问目录内容</td>
</tr>
<tr>
<td>目录必须拥有 x 权限，否则无法查看其内容</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Linux权限授权，默认是授权给三种角色，分别是user、group、other，Linux权限与用户之间的关联如下：</p>
<p>U代表User，G代表Group，O代表Other；</p>
<p> 每个文件的权限基于UGO进行设置；</p>
<p>权限三位一组（rwx），同时需授权给三种角色，UGO；</p>
<p> 每个文件拥有一个所属用户和所属组，对应UGO，不属于该文件所属用户或所属组使用O来表示；</p>
<p>在Linux系统中，可以通过ls –l查看peter.net目录的详细属性，如图5-1所示：</p>
<p>drwxrwxr-x  2 peter1 peter1 4096 Dec 10 01:36 peter.net</p>
<p>peter.net目录属性参数详解如下：</p>
<p> d 表示目录，同一位置如果为-则表示普通文件；</p>
<p> rwxrwxr-x 表示三种角色的权限，每三位为一种角色，依次为u，g，o权限，如上则表示user的权限为rwx，group的权限为rwx，other的权限为r-x；</p>
<p> 2表示文件夹的链接数量，可理解为该目录下子目录的数量；</p>
<p> 从左到右，第一个peter1表示该用户名，第二个peter1则为组名，其他人角色默认不显示；</p>
<p> 4096表示该文件夹占据的字节数；</p>
<p> Dec 10 01:36 表示文件创建或者修改的时间；</p>
<p>peter.net 为目录的名，或者文件名。</p>
<p>peter.net目录属性参数详解如下：</p>
<p> d 表示目录，同一位置如果为-则表示普通文件；</p>
<p> rwxrwxr-x 表示三种角色的权限，每三位为一种角色，依次为u，g，o权限，如上则表示user的权限为rwx，group的权限为rwx，other的权限为r-x；</p>
<p> 2表示文件夹的链接数量，可理解为该目录下子目录的数量；</p>
<p> 从左到右，第一个peter1表示该用户名，第二个peter1则为组名，其他人角色默认不显示；</p>
<p> 4096表示该文件夹占据的字节数；</p>
<p> Dec 10 01:36 表示文件创建或者修改的时间；</p>
<p>peter.net 为目录的名，或者文件名。</p>
<h2 id="Chmod用户及组权限"><a href="#Chmod用户及组权限" class="headerlink" title="Chmod用户及组权限"></a>Chmod用户及组权限</h2><p>修改某个用户、组对文件夹的权限，用命令chmod实现，其中以代指ugo，、-、=代表加入、删除和等于对应权限，具体案例如下：</p>
<p>（1） 授予用户对peter.net目录拥有rwx权限</p>
<p>chmod  –R  u+rwx  peter.net</p>
<p>（2） 授予组对peter.net目录拥有rwx权限</p>
<p>chmod  –R  g+rwx  peter.net</p>
<p>（3） 授予用户、组、其他人对jpeter.net目录拥有rwx权限</p>
<p>chmod  –R  u+rwx,g+rwx,o+rwx  peter.net</p>
<p>（4） 撤销用户对peter.net目录拥有w权限</p>
<p>chmod  –R  u-w  peter.net</p>
<p>（5） 撤销用户、组、其他人对peter.net目录拥有x权限</p>
<p>chmod  –R  u-x,g-x,o-x peter.net</p>
<p>（6） 授予用户、组、其他人对jpeter.net目录只有rx权限</p>
<p>chmod  –R  u=rx,g=rx,o=rx  peter.net</p>
<h2 id="Chmod二进制权限"><a href="#Chmod二进制权限" class="headerlink" title="Chmod二进制权限"></a>Chmod二进制权限</h2><p>Linux权限默认使用rwx来表示，为了更简化在系统中对权限进行配置和修改，Linux权限引入二进制表示方法，如下代码：</p>
<p>Linux权限可以将rwx用二进制来表示，其中有权限用1表示，没有权限用0表示；Linux权限用二进制显示如下：rwx=111r-x=101rw-=110r–=100依次类推，转化为十进制，对应十进制结果显示如下：rwx=111=4+2+1=7r-x=101=4+0+1=5rw-=110=4+4+0=6r–=100=4+0+0=4得出结论，用r=4,w=2,x=1来表示权限。</p>
<p>使用二进制方式来修改权限案例演示如下，其中默认peter.nett目录权限为755：</p>
<p>（1） 授予用户对peter.net目录拥有rwx权限</p>
<p>chmod  –R  755 peter.net</p>
<p>（2） 授予组对peter.net目录拥有rwx权限</p>
<p>chmod  –R  775 peter.net</p>
<p>（3） 授予用户、组、其他人对peter.net目录拥有rwx权限</p>
<p>chmod  –R  777  peter.net</p>
<h2 id="Linux特殊权限及掩码"><a href="#Linux特殊权限及掩码" class="headerlink" title="Linux特殊权限及掩码"></a>Linux特殊权限及掩码</h2><p>Linux权限除了常见的rwx权限之外，还有很多特殊的权限，细心的读者会发现，为什么Linux目录默认权限755，而文件默认权限为644呢，这是因为Linux权限掩码umask导致。</p>
<p>每个Linux终端都拥有一个umask属性，umask熟悉可以用来确定新建文件、目录的默认权限，默认系统权限掩码为022。在系统中每创建一个文件或者目录，文件默认权限是666，而目录权限则为777，权限对外开放比较大，所以设置了权限掩码之后，默认的文件和目录权限减去umask值才是真实的文件和目录的权限。</p>
<p> 对应目录权限为：777-022=755；</p>
<p> 对应文件权限为：666-022=644；</p>
<p> 执行umask命令可以查看当前默认的掩码，umask -S 023可以设置默认的权限掩码。</p>
<p>在Linux权限中，除了普通权限外，还有如下表5-2所示，三个特殊权限：</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>Suid</td>
<td>以文件的所属用户身份执行，而非执行文件的用户</td>
<td>无</td>
</tr>
<tr>
<td>sgid</td>
<td>以文件所属组身份去执行</td>
<td>在该目录中创建任意新文件的所属组与该目录的所属组相同</td>
</tr>
<tr>
<td>sticky</td>
<td>无</td>
<td>对目录拥有写入权限的用户仅可以删除其拥有的文件，无法删除其他用户所拥有的文件</td>
</tr>
</tbody></table>
<p>表5-2 Linux三种特殊权限</p>
<p>Linux中设置特殊权限方法如下：</p>
<p>q 设置suid： chmod u+s peter.net</p>
<p>q 设置sgid： chmod g+s peter.net</p>
<p>q 设置sticky： chmod o+t peter.net</p>
<p>特殊权限与设置普通权限一样，可以使用数字方式表示：</p>
<p> SUID   = 4</p>
<p> SGID   = 2</p>
<p> Sticky = 1</p>
<p>可以通过chmod 4755 peter.net对该目录授予特殊权限为s的权限，Linux系统中s权限的应用常见包括：su、passwd、sudo，</p>
<h2 id="P62-63-ls-l"><a href="#P62-63-ls-l" class="headerlink" title="P62-63(ls -l)"></a>P62-63(ls -l)</h2><table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>r（读取）</td>
<td>可读取文件内容</td>
<td>可列出目录内容</td>
</tr>
<tr>
<td>w（写入）</td>
<td>可修改文件内容</td>
<td>可在目录中创建删除内容</td>
</tr>
<tr>
<td>x（执行）</td>
<td>可作为命令执行</td>
<td>可访问目录内容</td>
</tr>
<tr>
<td>目录必须拥有 x 权限，否则无法查看其内容</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>-rw-rw-r–: rw, rw, r</p>
<p>drwxrwxr-x:目录，rwx,rwx,r-x</p>
<p><em>d是目录，第一组是拥有者权限，第二组是组权限，第三组是其他用户权限，每3个一组。</em></p>
<p><em>”/“是根目录，”~“是家目录。Linux存储是以挂载的方式，相当于是树状的，源头就是”/“，也就是根目录。而每个用户都有”家“目录，也就是用户的个人目录，比如root用户的”家“目录就是/root,普通用户a的家目录就是/home/a</em></p>
<h3 id="ls常见命令参数"><a href="#ls常见命令参数" class="headerlink" title="ls常见命令参数"></a>ls常见命令参数</h3><p>ls: -F 给不同的文件添加不同表示,添加帽子</p>
<p>d/   l*  =s </p>
<p>-a: 显示隐藏文件  以.开头的文件</p>
<p>-p: 只给目录添加/</p>
<p>-t: 按照修改时间排序 time </p>
<p>   –time-style=long-iso: ls -l –time-style=long-iso  显示友好长格式时间</p>
<p>-r: 倒着排序 reverse</p>
<p>-S: 按照文件大小排序</p>
<p>-h: 以人类理解的范围显示</p>
<p>-i: 索引节点(inode==书的目录) print the index number of each file(内核根据此区别文件是否同一文件)</p>
<h3 id="ls-–l-文件显示内容分析"><a href="#ls-–l-文件显示内容分析" class="headerlink" title="ls –l 文件显示内容分析"></a>ls –l 文件显示内容分析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一列： 文件类型(共10个字符) + 权限  --&gt; &#96;&#96;man&#96; &#96;find&#96; &#96;搜索&#96;&#96;type&#96;&#96;可看</span><br><span class="line">      &#96;&#96;-:普通文件</span><br><span class="line">      &#96;&#96;d:目录</span><br><span class="line">      &#96;&#96;c:字符设备 --&gt; &#96;&#96;&#x2F;dev&#x2F;tty&#96;   &#96;例如 USB接口、猫等一些串行端口设备</span><br><span class="line">      &#96;&#96;b:块设备  --&gt; &#96;&#96;&#x2F;dev&#96;&#96;下查找 例如光驱，硬盘等属于块设备</span><br><span class="line">      &#96;&#96;.:SELINUX相关 </span><br><span class="line">      &#96;&#96;l:链接文件 --&gt; 软连接</span><br><span class="line">第二列：硬链接个数 默认从1开始 如果是目录，则默认是2(目录不做硬链接)：几种到达的方法</span><br><span class="line">第三列：文件属主</span><br><span class="line">第四列：文件属组</span><br><span class="line">第五列：文件大小</span><br><span class="line">第六-八列：创建时间&#x2F;最后一次修改时间</span><br><span class="line">第九列：文件名</span><br></pre></td></tr></table></figure>

<p><a href="https://images2018.cnblogs.com/blog/519608/201806/519608-20180630125442504-449878811.png" target="_blank" rel="noopener"><img src="https://images2018.cnblogs.com/blog/519608/201806/519608-20180630125442922-137320976.png" alt="image"></a></p>
<h2 id="P64-65-chmod"><a href="#P64-65-chmod" class="headerlink" title="P64-65(chmod)"></a>P64-65(chmod)</h2><p>Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。</p>
<p><strong>使用权限</strong> : 所有使用者</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod [-cfvR] [--help] [--version] mode file...</span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>mode : 权限设定字串，格式如下 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ugoa...][[+-&#x3D;][rwxX]...][,...]</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li>
<li>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li>
</ul>
<p>其他参数说明：</p>
<ul>
<li>-c : 若该文件权限确实已经更改，才显示其更改动作</li>
<li>-f : 若该文件权限无法被更改也不要显示错误讯息</li>
<li>-v : 显示权限变更的详细资料</li>
<li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>将文件 file1.txt 设为所有人皆可读取 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod ugo+r file1.txt</span><br></pre></td></tr></table></figure>

<p>将文件 file1.txt 设为所有人皆可读取 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod a+r file1.txt</span><br></pre></td></tr></table></figure>

<p>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod ug+w,o-w file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p>将 ex1.py 设定为只有该文件拥有者可以执行 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod u+x ex1.py</span><br></pre></td></tr></table></figure>

<p>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod -R a+r *</span><br></pre></td></tr></table></figure>

<p>此外chmod也可以用数字来表示权限如 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure>

<p>语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod abc file</span><br></pre></td></tr></table></figure>

<p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p>
<h4 id="r-4，w-2，x-1"><a href="#r-4，w-2，x-1" class="headerlink" title="r=4，w=2，x=1"></a>r=4，w=2，x=1</h4><ul>
<li>若要rwx属性则4+2+1=7；</li>
<li>若要rw-属性则4+2=6；</li>
<li>若要r-x属性则4+1=5。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod a&#x3D;rwx file</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure>

<p>效果相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod ug&#x3D;rwx,o&#x3D;x file</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 771 file</span><br></pre></td></tr></table></figure>

<p>效果相同</p>
<p>若用chmod 4755 filename可使此程序具有root的权限</p>
<h2 id="P65-66（超级用户）"><a href="#P65-66（超级用户）" class="headerlink" title="P65-66（超级用户）"></a>P65-66（超级用户）</h2><p>sudo的全称为Superuser do的意思</p>
<p>日常使用用标准用户administrator，root用户用来系统维护和管理，对所有资源都有访问权限</p>
<p>默认安装完成之后并不知道root用户的密码，那么如何应用root权限呢？</p>
<h3 id="1-sudo-命令"><a href="#1-sudo-命令" class="headerlink" title="(1)sudo 命令"></a>(1)sudo 命令</h3><p>xzm@ubuntu:~$ sudo</p>
<p>这样输入当前管理员用户密码就可以得到超级用户的权限。但默认的情况下5分钟root权限就失效了。</p>
<h3 id="2-sudo-i"><a href="#2-sudo-i" class="headerlink" title="(2)sudo -i"></a>(2)sudo -i</h3><p>xzm@ubuntu:~$ sudo -i</p>
<p>通过这种方法输入当前管理员用户的密码就可以进到root用户。</p>
<h3 id="3-如果想一直使用root权限，要通过su切换到root用户。"><a href="#3-如果想一直使用root权限，要通过su切换到root用户。" class="headerlink" title="(3)如果想一直使用root权限，要通过su切换到root用户。"></a>(3)如果想一直使用root权限，要通过su切换到root用户。</h3><p>那我们首先要重设置root用户的密码：</p>
<p>xzm@ubuntu:~$ sudo passwd root</p>
<p>这样就可以设置root用户的密码了。</p>
<h3 id="4-之后就可以自由的切换到root用户了"><a href="#4-之后就可以自由的切换到root用户了" class="headerlink" title="(4)之后就可以自由的切换到root用户了"></a>(4)之后就可以自由的切换到root用户了</h3><p>xzm@ubuntu:~$ su</p>
<p>输入root用户的密码即可。</p>
<p>su “king” 或者 exit回到用户权限</p>
<p>Linux su命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。</p>
<p>使用权限：所有使用者。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su [-fmp] [-c command] [-s shell] [--help] [--version] [-] [USER [ARG]]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-f 或 –fast 不必读启动档（如 csh.cshrc 等），仅用于 csh 或 tcsh</li>
<li>-m -p 或 –preserve-environment 执行 su 时不改变环境变数</li>
<li>-c command 或 –command=command 变更为帐号为 USER 的使用者并执行指令（command）后再变回原来使用者</li>
<li>-s shell 或 –shell=shell 指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者（USER） shell</li>
<li>–help 显示说明文件</li>
<li>–version 显示版本资讯</li>
<li>- -l 或 –login 这个参数加了之后，就好像是重新 login 为该使用者一样，大部份环境变数（HOME SHELL USER等等）都是以该使用者（USER）为主，并且工作目录也会改变，如果没有指定 USER ，内定是 root</li>
<li>USER 欲变更的使用者帐号</li>
<li>ARG 传入新的 shell 参数</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>变更帐号为 root 并在执行 ls 指令后退出变回原使用者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su -c ls root</span><br></pre></td></tr></table></figure>

<p>变更帐号为 root 并传入 -f 参数给新执行的 shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su root -f</span><br></pre></td></tr></table></figure>

<p>变更帐号为 clsung 并改变工作目录至 clsung 的家目录（home dir）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - clsung</span><br></pre></td></tr></table></figure>

<p>切换用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hnlinux@runoob.com:~$ whoami &#x2F;&#x2F;显示当前用户</span><br><span class="line">hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ su root &#x2F;&#x2F;切换到root用户</span><br><span class="line">密码： </span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# whoami </span><br><span class="line">root</span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# pwd</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br></pre></td></tr></table></figure>

<p>切换用户，改变环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hnlinux@runoob.com:~$ whoami &#x2F;&#x2F;显示当前用户</span><br><span class="line">hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ su - root &#x2F;&#x2F;切换到root用户</span><br><span class="line">密码： </span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# whoami </span><br><span class="line">root</span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;root</span><br></pre></td></tr></table></figure>



<h2 id="P67-69（组管理）"><a href="#P67-69（组管理）" class="headerlink" title="P67-69（组管理）"></a>P67-69（组管理）</h2><p>sudo来创建删除组，不用sudo会permission denied</p>
<ol>
<li>groupadd 组名：添加组</li>
<li>groupdel 组名 ：删除组</li>
<li>cat /etc/group： 确认组信息</li>
<li>chgrp -R 组名 文件/目录名：递归修改文件/目录所属组</li>
</ol>
<p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 </p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。 </li>
<li>用户口令的管理。</li>
<li>用户组的管理。 </li>
</ul>
<hr>
<h2 id="一、Linux系统用户账号的管理"><a href="#一、Linux系统用户账号的管理" class="headerlink" title="一、Linux系统用户账号的管理"></a>一、Linux系统用户账号的管理</h2><p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p>
<p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。</p>
<h3 id="1、添加新的用户账号使用useradd命令，其语法如下："><a href="#1、添加新的用户账号使用useradd命令，其语法如下：" class="headerlink" title="1、添加新的用户账号使用useradd命令，其语法如下："></a>1、添加新的用户账号使用useradd命令，其语法如下：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><p>选项:</p>
<ul>
<li>-c comment 指定一段注释性描述。</li>
<li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li>
<li>-g 用户组 指定用户所属的用户组。</li>
<li>-G 用户组，用户组 指定用户所属的附加组。</li>
<li>-s Shell文件 指定用户的登录Shell。</li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
</ul>
</li>
<li><p>用户名: </p>
<p>指定新账号的登录名。</p>
</li>
</ul>
<h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># useradd –d  &#x2F;home&#x2F;sam -m sam</span><br></pre></td></tr></table></figure>

<p>此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）。</p>
<h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># useradd -s &#x2F;bin&#x2F;sh -g group –G adm,root gem</span><br></pre></td></tr></table></figure>

<p>此命令新建了一个用户gem，该用户的登录Shell是 <code>/bin/sh</code>，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。</p>
<p>这里可能新建组：<code>#groupadd group及groupadd adm</code></p>
<p>增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。</p>
<p>Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。</p>
<h3 id="2、删除帐号"><a href="#2、删除帐号" class="headerlink" title="2、删除帐号"></a>2、删除帐号</h3><p>如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p>
<p>删除一个已有的用户账号使用<code>userdel</code>命令，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userdel 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项是 <strong>-r</strong>，它的作用是把用户的主目录一起删除。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># userdel -r sam</span><br></pre></td></tr></table></figure>

<p>此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p>
<h3 id="3、修改帐号"><a href="#3、修改帐号" class="headerlink" title="3、修改帐号"></a>3、修改帐号</h3><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p>
<p>修改已有用户的信息使用<code>usermod</code>命令，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项包括<code>-c, -d, -m, -g, -G, -s, -u以及-o等</code>，这些选项的意义与<code>useradd</code>命令中的选项一样，可以为用户指定新的资源值。</p>
<p>另外，有些系统可以使用选项：-l 新用户名</p>
<p>这个选项指定一个新的账号，即将原来的用户名改为新的用户名。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># usermod -s &#x2F;bin&#x2F;ksh -d &#x2F;home&#x2F;z –g developer sam</span><br></pre></td></tr></table></figure>

<p>此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。</p>
<h3 id="4、用户口令的管理"><a href="#4、用户口令的管理" class="headerlink" title="4、用户口令的管理"></a>4、用户口令的管理</h3><p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p>
<p>指定和修改用户口令的Shell命令是<code>passwd</code>。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>可使用的选项：</p>
<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。</li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
<p>如果默认用户名，则修改当前用户的口令。</p>
<p>例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ passwd </span><br><span class="line">Old password:****** </span><br><span class="line">New password:******* </span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>如果是超级用户，可以用下列形式指定任何用户的口令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># passwd sam </span><br><span class="line">New password:******* </span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p>
<p>为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。</p>
<p>为用户指定空口令时，执行下列形式的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># passwd -d sam</span><br></pre></td></tr></table></figure>

<p>此命令将用户 sam 的口令删除，这样用户 sam 下一次登录时，系统就不再允许该用户登录了。</p>
<p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># passwd -l sam</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、Linux系统用户组的管理"><a href="#二、Linux系统用户组的管理" class="headerlink" title="二、Linux系统用户组的管理"></a>二、Linux系统用户组的管理</h2><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p>
<h3 id="1、增加一个新的用户组使用groupadd命令。其格式如下："><a href="#1、增加一个新的用户组使用groupadd命令。其格式如下：" class="headerlink" title="1、增加一个新的用户组使用groupadd命令。其格式如下："></a>1、增加一个新的用户组使用groupadd命令。其格式如下：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd 选项 用户组</span><br></pre></td></tr></table></figure>

<p>可以使用的选项有：</p>
<ul>
<li>-g GID 指定新用户组的组标识号（GID）。</li>
<li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li>
</ul>
<h4 id="实例1："><a href="#实例1：" class="headerlink" title="实例1："></a>实例1：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># groupadd group1</span><br></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p>
<h4 id="实例2："><a href="#实例2：" class="headerlink" title="实例2："></a>实例2：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># groupadd -g 101 group2</span><br></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。</p>
<h3 id="2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下："><a href="#2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下：" class="headerlink" title="2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下："></a>2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure>

<h4 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># groupdel group1</span><br></pre></td></tr></table></figure>

<p>此命令从系统中删除组group1。</p>
<h3 id="3、修改用户组的属性使用groupmod命令。其语法如下："><a href="#3、修改用户组的属性使用groupmod命令。其语法如下：" class="headerlink" title="3、修改用户组的属性使用groupmod命令。其语法如下："></a>3、修改用户组的属性使用groupmod命令。其语法如下：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br></pre></td></tr></table></figure>

<p>常用的选项有：</p>
<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li>-n新用户组 将用户组的名字改为新名字</li>
</ul>
<h4 id="实例1：-1"><a href="#实例1：-1" class="headerlink" title="实例1："></a>实例1：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># groupmod -g 102 group2</span><br></pre></td></tr></table></figure>

<p>此命令将组group2的组标识号修改为102。</p>
<h4 id="实例2：-1"><a href="#实例2：-1" class="headerlink" title="实例2："></a>实例2：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># groupmod –g 10000 -n group3 group2</span><br></pre></td></tr></table></figure>

<p>此命令将组group2的标识号改为10000，组名修改为group3。</p>
<h3 id="4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。"><a href="#4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。" class="headerlink" title="4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。"></a>4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</h3><p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ newgrp root</span><br></pre></td></tr></table></figure>

<p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。</p>
<hr>
<h2 id="三、与用户账号有关的系统文件"><a href="#三、与用户账号有关的系统文件" class="headerlink" title="三、与用户账号有关的系统文件"></a>三、与用户账号有关的系统文件</h2><p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p>
<p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。</p>
<p>下面分别介绍这些文件的内容。</p>
<h3 id="1、-etc-passwd文件是用户管理工作涉及的最重要的一个文件。"><a href="#1、-etc-passwd文件是用户管理工作涉及的最重要的一个文件。" class="headerlink" title="1、/etc/passwd文件是用户管理工作涉及的最重要的一个文件。"></a>1、/etc/passwd文件是用户管理工作涉及的最重要的一个文件。</h3><p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p>
<p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">＃ cat &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">root:x:0:0:Superuser:&#x2F;:</span><br><span class="line">daemon:x:1:1:System daemons:&#x2F;etc:</span><br><span class="line">bin:x:2:2:Owner of system commands:&#x2F;bin:</span><br><span class="line">sys:x:3:3:Owner of system files:&#x2F;usr&#x2F;sys:</span><br><span class="line">adm:x:4:4:System accounting:&#x2F;usr&#x2F;adm:</span><br><span class="line">uucp:x:5:5:UUCP administrator:&#x2F;usr&#x2F;lib&#x2F;uucp:</span><br><span class="line">auth:x:7:21:Authentication administrator:&#x2F;tcb&#x2F;files&#x2F;auth:</span><br><span class="line">cron:x:9:16:Cron daemon:&#x2F;usr&#x2F;spool&#x2F;cron:</span><br><span class="line">listen:x:37:4:Network daemon:&#x2F;usr&#x2F;net&#x2F;nls:</span><br><span class="line">lp:x:71:18:Printer administrator:&#x2F;usr&#x2F;spool&#x2F;lp:</span><br><span class="line">sam:x:200:50:Sam san:&#x2F;home&#x2F;sam:&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>

<p>从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure>

<h3 id="1）”用户名”是代表用户账号的字符串。"><a href="#1）”用户名”是代表用户账号的字符串。" class="headerlink" title="1）”用户名”是代表用户账号的字符串。"></a>1）”用户名”是代表用户账号的字符串。</h3><p>通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</p>
<p>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p>
<h3 id="2）“口令”一些系统中，存放着加密后的用户口令字。"><a href="#2）“口令”一些系统中，存放着加密后的用户口令字。" class="headerlink" title="2）“口令”一些系统中，存放着加密后的用户口令字。"></a>2）“口令”一些系统中，存放着加密后的用户口令字。</h3><p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p>
<h3 id="3）“用户标识号”是一个整数，系统内部用它来标识用户。"><a href="#3）“用户标识号”是一个整数，系统内部用它来标识用户。" class="headerlink" title="3）“用户标识号”是一个整数，系统内部用它来标识用户。"></a>3）“用户标识号”是一个整数，系统内部用它来标识用户。</h3><p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p>
<p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p>
<h3 id="4）“组标识号”字段记录的是用户所属的用户组。"><a href="#4）“组标识号”字段记录的是用户所属的用户组。" class="headerlink" title="4）“组标识号”字段记录的是用户所属的用户组。"></a>4）“组标识号”字段记录的是用户所属的用户组。</h3><p>它对应着/etc/group文件中的一条记录。</p>
<h3 id="5-“注释性描述”字段记录着用户的一些个人情况。"><a href="#5-“注释性描述”字段记录着用户的一些个人情况。" class="headerlink" title="5)“注释性描述”字段记录着用户的一些个人情况。"></a>5)“注释性描述”字段记录着用户的一些个人情况。</h3><p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。</p>
<h3 id="6-“主目录”，也就是用户的起始工作目录。"><a href="#6-“主目录”，也就是用户的起始工作目录。" class="headerlink" title="6)“主目录”，也就是用户的起始工作目录。"></a>6)“主目录”，也就是用户的起始工作目录。</h3><p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p>
<h3 id="7-用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。"><a href="#7-用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。" class="headerlink" title="7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。"></a>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</h3><p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p>
<p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</p>
<p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p>
<p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p>
<h3 id="8-系统中有一类用户称为伪用户（pseudo-users）。"><a href="#8-系统中有一类用户称为伪用户（pseudo-users）。" class="headerlink" title="8)系统中有一类用户称为伪用户（pseudo users）。"></a>8)系统中有一类用户称为伪用户（pseudo users）。</h3><p>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p>
<p>常见的伪用户如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">伪 用 户 含 义 </span><br><span class="line">bin 拥有可执行的用户命令文件 </span><br><span class="line">sys 拥有系统文件 </span><br><span class="line">adm 拥有帐户文件 </span><br><span class="line">uucp UUCP使用 </span><br><span class="line">lp lp或lpd子系统使用 </span><br><span class="line">nobody NFS使用</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="拥有帐户文件"><a href="#拥有帐户文件" class="headerlink" title="拥有帐户文件"></a>拥有帐户文件</h2><p><strong>1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</strong></p>
<p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>
<p><strong>2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生</strong></p>
<p>它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></pre></td></tr></table></figure>

<ol>
<li>“登录名”是与/etc/passwd文件中的登录名相一致的用户账号</li>
<li>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</li>
<li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li>
<li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li>
<li>“最大时间间隔”指的是口令保持有效的最大天数。</li>
<li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li>
<li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li>
<li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li>
</ol>
<p>下面是/etc/shadow的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">＃ cat &#x2F;etc&#x2F;shadow</span><br><span class="line"></span><br><span class="line">root:Dnakfw28zf38w:8764:0:168:7:::</span><br><span class="line">daemon:*::0:0::::</span><br><span class="line">bin:*::0:0::::</span><br><span class="line">sys:*::0:0::::</span><br><span class="line">adm:*::0:0::::</span><br><span class="line">uucp:*::0:0::::</span><br><span class="line">nuucp:*::0:0::::</span><br><span class="line">auth:*::0:0::::</span><br><span class="line">cron:*::0:0::::</span><br><span class="line">listen:*::0:0::::</span><br><span class="line">lp:*::0:0::::</span><br><span class="line">sam:EkdiSECLWPdSa:9740:0:0::::</span><br></pre></td></tr></table></figure>

<h3 id="3、用户组的所有信息都存放在-etc-group文件中。"><a href="#3、用户组的所有信息都存放在-etc-group文件中。" class="headerlink" title="3、用户组的所有信息都存放在/etc/group文件中。"></a>3、用户组的所有信息都存放在/etc/group文件中。</h3><p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p>
<p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p>
<p>当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p>
<p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p>
<p>用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">组名:口令:组标识号:组内用户列表</span><br></pre></td></tr></table></figure>

<ol>
<li>“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</li>
<li>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</li>
<li>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</li>
<li>“组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li>
</ol>
<p>/etc/group文件的一个例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root::0:root</span><br><span class="line">bin::2:root,bin</span><br><span class="line">sys::3:root,uucp</span><br><span class="line">adm::4:root,adm</span><br><span class="line">daemon::5:root,daemon</span><br><span class="line">lp::7:root,lp</span><br><span class="line">users::20:root,sam</span><br></pre></td></tr></table></figure>

<h3 id="四、添加批量用户"><a href="#四、添加批量用户" class="headerlink" title="四、添加批量用户"></a>四、添加批量用户</h3><p>添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：</p>
<h3 id="（1）先编辑一个文本用户文件。"><a href="#（1）先编辑一个文本用户文件。" class="headerlink" title="（1）先编辑一个文本用户文件。"></a>（1）先编辑一个文本用户文件。</h3><p>每一列按照<code>/etc/passwd</code>密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user001::600:100:user:&#x2F;home&#x2F;user001:&#x2F;bin&#x2F;bash</span><br><span class="line">user002::601:100:user:&#x2F;home&#x2F;user002:&#x2F;bin&#x2F;bash</span><br><span class="line">user003::602:100:user:&#x2F;home&#x2F;user003:&#x2F;bin&#x2F;bash</span><br><span class="line">user004::603:100:user:&#x2F;home&#x2F;user004:&#x2F;bin&#x2F;bash</span><br><span class="line">user005::604:100:user:&#x2F;home&#x2F;user005:&#x2F;bin&#x2F;bash</span><br><span class="line">user006::605:100:user:&#x2F;home&#x2F;user006:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<h3 id="（2）以root身份执行命令-usr-sbin-newusers，从刚创建的用户文件user-txt中导入数据，创建用户："><a href="#（2）以root身份执行命令-usr-sbin-newusers，从刚创建的用户文件user-txt中导入数据，创建用户：" class="headerlink" title="（2）以root身份执行命令 /usr/sbin/newusers，从刚创建的用户文件user.txt中导入数据，创建用户："></a>（2）以root身份执行命令 <code>/usr/sbin/newusers</code>，从刚创建的用户文件<code>user.txt</code>中导入数据，创建用户：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># newusers &lt; user.txt</span><br></pre></td></tr></table></figure>

<p>然后可以执行命令 <code>vipw</code> 或 <code>vi /etc/passwd</code> 检查 <code>/etc/passwd</code> 文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。</p>
<h3 id="（3）执行命令-usr-sbin-pwunconv。"><a href="#（3）执行命令-usr-sbin-pwunconv。" class="headerlink" title="（3）执行命令/usr/sbin/pwunconv。"></a>（3）执行命令/usr/sbin/pwunconv。</h3><p>将 <code>/etc/shadow</code> 产生的 <code>shadow</code> 密码解码，然后回写到 <code>/etc/passwd</code> 中，并将<code>/etc/shadow</code>的<code>shadow</code>密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 <code>shadow password</code> 功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pwunconv</span><br></pre></td></tr></table></figure>

<h3 id="（4）编辑每个用户的密码对照文件。"><a href="#（4）编辑每个用户的密码对照文件。" class="headerlink" title="（4）编辑每个用户的密码对照文件。"></a>（4）编辑每个用户的密码对照文件。</h3><p>格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户名:密码</span><br></pre></td></tr></table></figure>

<p>实例文件 <code>passwd.txt</code> 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user001:123456</span><br><span class="line">user002:123456</span><br><span class="line">user003:123456</span><br><span class="line">user004:123456</span><br><span class="line">user005:123456</span><br><span class="line">user006:123456</span><br></pre></td></tr></table></figure>

<h3 id="（5）以-root-身份执行命令-usr-sbin-chpasswd。"><a href="#（5）以-root-身份执行命令-usr-sbin-chpasswd。" class="headerlink" title="（5）以 root 身份执行命令 /usr/sbin/chpasswd。"></a>（5）以 root 身份执行命令 <code>/usr/sbin/chpasswd</code>。</h3><p>创建用户密码，<code>chpasswd</code> 会将经过 <code>/usr/bin/passwd</code> 命令编码过的密码写入 <code>/etc/passwd</code> 的密码栏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># chpasswd &lt; passwd.txt</span><br></pre></td></tr></table></figure>

<h3 id="（6）确定密码经编码写入-etc-passwd的密码栏后。"><a href="#（6）确定密码经编码写入-etc-passwd的密码栏后。" class="headerlink" title="（6）确定密码经编码写入/etc/passwd的密码栏后。"></a>（6）确定密码经编码写入/etc/passwd的密码栏后。</h3><p>执行命令 <code>/usr/sbin/pwconv</code> 将密码编码为 <code>shadow password</code>，并将结果写入 <code>/etc/shadow</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pwconv</span><br></pre></td></tr></table></figure>

<p>这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。</p>
<h2 id="P70-71-用户管理"><a href="#P70-71-用户管理" class="headerlink" title="P70-71(用户管理)"></a>P70-71(用户管理)</h2><ol>
<li><p>useradd -m -g 组 新建用户名：添加新用户 -m自动建立用户加目录， -g指定用户所在组，否则会建立一个同名的组。</p>
<p>例： sudo useradd -m -g dev zhangsan </p>
<p>drwxr-xr-x  2 zhangsan     dev          4096 Apr 26 18:30 zhangsan</p>
</li>
<li><p>passwd 用户名： 设置用户密码，如果是普通用户，直接passwd可以修改密码</p>
</li>
<li><p>userdel -r 用户名；删除用户， -r会自动删除用户家目录</p>
</li>
<li><p>cat /etc/passwd | grep 用户名 ：确认用户信息，新建用户后，用户信息会保存在/etc/passwd文件中</p>
</li>
</ol>
<h2 id="P72-75（id，whoami，who）"><a href="#P72-75（id，whoami，who）" class="headerlink" title="P72-75（id，whoami，who）"></a>P72-75（id，whoami，who）</h2><h3 id="id-用户名：查看用户UID和GID信息"><a href="#id-用户名：查看用户UID和GID信息" class="headerlink" title="id 用户名：查看用户UID和GID信息"></a>id 用户名：查看用户UID和GID信息</h3><p>passwd文件：/etc/passwd文件存放用户信息，6个分号组成7个信息</p>
<p>信息说明<br>第一字段: 用户名(vampire)<br>第二字段: 密码位(x),只是一个占位符,真正的密码存放在/etc/shadow文件中（x，表示加密密码）<br>第三字段: UID(501)用户id,0为超级用户,1~499系统用户,一般不能登录系统,也叫做伪用户,500及以上普通用户,管理员创建的,一般可登录（用户标识）<br>第四字段: GID(501)用户初始组id,一般添加用户时,系统自动分配的（组标识）<br>第五字段: GECOS 用户的一些说明信息（用户全名或本地账号）<br>第六字段: $HOME(/home/vampire) 用户家目录,也叫做宿主目录,普通用户家目录在/home下,root用户在/下（家目录）</p>
<p>第七字段: shell(/bin/bash)用户登录后的shell，ubuntu默认是dash</p>
<p> UID，gid，组 依次打印</p>
<p>Linux id命令用于显示用户的ID，以及所属群组的ID。</p>
<p>id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id [-gGnru][--help][--version][用户名称]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-g或–group 　显示用户所属群组的ID。</li>
<li>-G或–groups 　显示用户所属附加群组的ID。</li>
<li>-n或–name 　显示用户，所属群组或附加群组的名称。</li>
<li>-r或–real 　显示实际ID。</li>
<li>-u或–user 　显示用户ID。</li>
<li>-help 　显示帮助。</li>
<li>-version 　显示版本信息。</li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>显示当前用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># id &#x2F;&#x2F;显示当前用户ID</span><br><span class="line">uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel) context&#x3D;root:system_r:unconfined_t</span><br></pre></td></tr></table></figure>

<p>显示用户群组的ID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># id -g</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>显示所有群组的ID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># id -g</span><br><span class="line">0 1 2 3 4 5 6 10</span><br></pre></td></tr></table></figure>

<p>显示指定用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># id hnlinux</span><br></pre></td></tr></table></figure>

<h3 id="who：查看当前所有登录的用户列表"><a href="#who：查看当前所有登录的用户列表" class="headerlink" title="who：查看当前所有登录的用户列表"></a>who：查看当前所有登录的用户列表</h3><p>Linux who命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。</p>
<p>使用权限：所有使用者都可使用。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">who - [husfV] [user]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-H 或 –heading：显示各栏位的标题信息列；</li>
<li>-i 或 -u 或 –idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成”.”号，如果该用户已超过24小时没有任何动作，则标示出”old”字符串；</li>
<li>-m：此参数的效果和指定”am i”字符串相同；</li>
<li>-q 或–count：只显示登入系统的帐号名称和总人数；</li>
<li>-s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题；</li>
<li>-w 或-T或–mesg或–message或–writable：显示用户的信息状态栏；</li>
<li>–help：在线帮助；</li>
<li>–version：显示版本信息。</li>
</ul>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>显示当前登录系统的用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># who  &#x2F;&#x2F;显示当前登录系统的用户</span><br><span class="line">root   tty7     2014-05-13 12:12 (:0)</span><br><span class="line">root   pts&#x2F;0    2014-05-14 17:09 (:0.0)</span><br><span class="line">root   pts&#x2F;1    2014-05-14 18:51 (192.168.1.17)</span><br><span class="line">root   pts&#x2F;2    2014-05-14 19:48 (192.168.1.17)</span><br></pre></td></tr></table></figure>

<p>显示标题栏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># who -H</span><br><span class="line">NAME   LINE     TIME       COMMENT</span><br><span class="line">root   tty7     2014-05-13 12:12 (:0)</span><br><span class="line">root   pts&#x2F;0    2014-05-14 17:09 (:0.0)</span><br><span class="line">root   pts&#x2F;1    2014-05-14 18:51 (192.168.1.17)</span><br><span class="line">root   pts&#x2F;2    2014-05-14 19:48 (192.168.1.17)</span><br></pre></td></tr></table></figure>

<p>显示用户登录来源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># who -l -H</span><br><span class="line">NAME   LINE     TIME       IDLE     PID COMMENT</span><br><span class="line">LOGIN  tty4     2014-05-13 12:11        852 id&#x3D;4</span><br><span class="line">LOGIN  tty5     2014-05-13 12:11        855 id&#x3D;5</span><br><span class="line">LOGIN  tty2     2014-05-13 12:11        862 id&#x3D;2</span><br><span class="line">LOGIN  tty3     2014-05-13 12:11        864 id&#x3D;3</span><br><span class="line">LOGIN  tty6     2014-05-13 12:11        867 id&#x3D;6</span><br><span class="line">LOGIN  tty1     2014-05-13 12:11       1021 id&#x3D;1</span><br></pre></td></tr></table></figure>

<p>显示终端属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># who -T -H</span><br><span class="line">NAME    LINE     TIME       COMMENT</span><br><span class="line">root   + tty7     2014-05-13 12:12 (:0)</span><br><span class="line">root   + pts&#x2F;0    2014-05-14 17:09 (:0.0)</span><br><span class="line">root   - pts&#x2F;1    2014-05-14 18:51 (192.168.1.17)</span><br><span class="line">root   - pts&#x2F;2    2014-05-14 19:48 (192.168.1.17)</span><br></pre></td></tr></table></figure>

<p>只显示当前用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># who -m -H</span><br><span class="line">NAME   LINE     TIME       COMMENT</span><br><span class="line">root   pts&#x2F;1    2014-05-14 18:51 (192.168.1.17)</span><br></pre></td></tr></table></figure>

<p>精简模式显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># who -q</span><br><span class="line">root root root root</span><br><span class="line"># users&#x3D;4</span><br></pre></td></tr></table></figure>

<h3 id="whoami：查看当前登录用户的账户名"><a href="#whoami：查看当前登录用户的账户名" class="headerlink" title="whoami：查看当前登录用户的账户名"></a>whoami：查看当前登录用户的账户名</h3><p>Linux whoami命令用于显示自身用户名称。</p>
<p>显示自身的用户名称，本指令相当于执行”id -un”指令。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whoami [--help][--version]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>–help 　在线帮助。</li>
<li>–version 　显示版本信息。</li>
</ul>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>显示用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># whoami </span><br><span class="line">root</span><br></pre></td></tr></table></figure>

<h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><p>用来设置用户主组/附加组 和登录shell</p>
<p>Linux系统以组Group方式管理用户，用户和组的对应关系为多对多，即某个用户可加入/属于一个或多个组，某个组可以有0个、1个或多个用户。</p>
<p>组的分类<br>从用户的角度，分为主组和附属组。<br>主组：也被称为primary group、first group或initial login group，用户的默认组，用户的gid所标识的组。<br>附属组：也被称为Secondary group或supplementary group，用户的附加组。</p>
<p>通过id命令可查看当前用户的主组和附属组</p>
<p>[root@localhost ~]# id root<br>uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel)</p>
<p>[root@localhost ~]# id gg<br>uid=503(gg) gid=503(gg) groups=503(gg)</p>
<p>[root@localhost ~]# id mm<br>uid=502(mm) gid=500(jww) groups=500(jww)</p>
<p>gid标识主组，groups表示用户所属的全部组（主组和附属组）</p>
<ol>
<li><p>用户必须有且只能有一个主组，可以有0个、1个或多个附属组，就如我们一定会有一个用来安家的房子（类同主组），还可以有n个用于投资或其他打算的房子（附属组）。</p>
</li>
<li><p>主组也为默认组，当用户own某个文件或目录时，默认该文件或目录的group owner为该用户的主组（当然，可以通过chgrp修改group owner）。</p>
</li>
<li><p>在/etc/passwd文件中，记录行第四个字段为gid，即用户的主组id。</p>
</li>
<li><p>在/etc/group文件中，记录行第四个字段为组的成员，不显示将该组作为主组的组成员，只显示将该组作为附属组的组成员，因此，/etc/group的记录行的第四个字段没有完整地列出该组的全部成员。</p>
</li>
<li><p>当通过useradd命令创建新用户时，可以通过-g参数指定已存在的某个组为其主组，若没有使用-g参数，<br>则系统自动创建名称和用户名相同的组作为该用户的主组（前提是variable in /etc/login.defs的USERGROUPS_ENAB属性值为yes），如命令手册的useradd关于-g参数的描述所示：<br>-g, –gid GROUP<br>The group name or number of the user′s initial login group. The<br>group name must exist. A group number must refer to an already<br>existing group.<br>If not specified, the bahavior of useradd will depend on the<br>USERGROUPS_ENAB variable in /etc/login.defs. If this variable is<br>set to yes (or -U/–user-group is specified on the command line), a<br>group will be created for the user, with the same name as her<br>loginname. If the variable is set to no (or -N/–no-user-group is<br>specified on the command line), useradd will set the primary group<br>of the new user to the value specified by the GROUP variable in<br>/etc/default/useradd, or 100 by default.</p>
</li>
</ol>
<p>另外，可通过usermod -g 将普通用户的主组/gid设置为系e799bee5baa6e79fa5e98193e4b893e5b19e31333337613161统中存在的任意某个组（永久性）；<br>也可以通过newgrp暂时性变更当前用户的主组/gid（只对于当前login session有效，非永久性）。<br>通过usermod -G 设置普通用户的附属组。</p>
<p>Linux usermod命令用于修改用户帐号。</p>
<p>usermod可用来修改用户帐号的各项设定。</p>
<p>usermod 命令通过修改系统帐户文件来修改用户账户信息<br>usermod [options] user_name<br>选项(options)<br>-a|–append ##把用户追加到某些组中，仅与-G选项一起使用<br>-c|–comment ##修改/etc/passwd文件第五段comment<br>-d|–home ##修改用户的家目录通常和-m选项一起使用<br>-e|–expiredate ##指定用户帐号禁用的日期，格式YY-MM-DD<br>-f|–inactive ##用户密码过期多少天后采用就禁用该帐号，0表示密码已过期就禁用帐号，-1表示禁用此功能，默认值是-1<br>-g|–gid ##修改用户的gid，改组一定存在<br>-G|–groups ##把用户追加到某些组中，仅与-a选项一起使用<br>-l|–login ##修改用户的登录名称<br>-L|–lock ##锁定用户的密码<br>-m|–move-home ##修改用户的家目录通常和-d选项一起使用<br>-s|–shell ##修改用户的shell<br>-u|–uid ##修改用户的uid，该uid必须唯一<br>-U|–unlock ##解锁用户的密码</p>
<h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod [-LU][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-l &lt;帐号名称&gt;][-s &lt;shell&gt;][-u &lt;uid&gt;][用户帐号]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li><p>-c&lt;备注&gt; 　修改用户帐号的备注文字。</p>
</li>
<li><p>-d登入目录&gt; 　修改用户登入时的目录。</p>
</li>
<li><p>-e&lt;有效期限&gt; 　修改帐号的有效期限。</p>
</li>
<li><p>-f&lt;缓冲天数&gt; 　修改在密码过期后多少天即关闭该帐号。</p>
</li>
<li><p>-g&lt;群组&gt; 　修改用户所属的群组。（常用）</p>
</li>
<li><p>-G&lt;群组&gt; 　修改用户所属的附加群组。（常用）</p>
</li>
<li><p>-l&lt;帐号名称&gt; 　修改用户帐号名称。</p>
</li>
<li><p>-L 　锁定用户密码，使密码无效。</p>
</li>
<li><p>-s<shell> 　修改用户登入后所使用的shell。（常用）</p>
<p>例：usermod -S /bin/bash 用户名</p>
</li>
<li><p>-u<uid> 　修改用户ID。</p>
</li>
<li><p>-U 　解除密码锁定。</p>
</li>
</ul>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>更改登录目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># usermod -d &#x2F;home&#x2F;hnlinux root</span><br></pre></td></tr></table></figure>

<p>改变用户的uid</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># usermod -u 777 root</span><br></pre></td></tr></table></figure>



<h3 id="usermod-S-bin-bash-用户名"><a href="#usermod-S-bin-bash-用户名" class="headerlink" title="usermod -S /bin/bash 用户名"></a>usermod -S /bin/bash 用户名</h3><p>用户ubuntu默认是dash，而windows不是，想windows登录也是dash，需要上面的命令修改shell为dash</p>
<p>Bash(GNU Bourne-Again Shell)是许多Linux平台的内定Shell，事实上，还有许多传统UNIX上用的Shell，像tcsh、csh、ash、bsh、ksh等等。</p>
<p>GNU/Linux 操作系统中的 /bin/sh 本是 bash (Bourne-Again Shell) 的符号链接，但鉴于 bash 过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash (Debian Almquist Shell)，并建议将 /bin/sh 指向它，以获得更快的脚本执行速度。Dash Shell 比 Bash Shell 小的多，符合POSIX标准。</p>
<p>Debian和Ubuntu中，/bin/sh默认已经指向dash，这是一个不同于bash的shell，它主要是为了执行脚本而出现，而不是交互，它速度更快，但功能相比bash要少很多，语法严格遵守POSIX标准。</p>
<p>就是这个倒霉的dash解释器使得我按照bash语法写的shell 脚本不能运行。</p>
<p>要知道自己的/bin/sh指向何种解释器，可以用 <strong>ls /bin/sh -al</strong> 命令查看：</p>
<p>​    $ ls /bin/sh -al</p>
<p>​    lrwxrwxrwx 1 root root 4 11月 16 15:33 /bin/sh -&gt; bash</p>
<p>以上结果就表示当前系统用的是dash解释器。</p>
<p>切换到bash的方式其实挺简单的，关键是一直没找出这个原因……</p>
<p>修改默认的sh，可以采用命令<strong>sudo dpkg-reconfigure dash</strong></p>
<p>会出现一个图片状的配置菜单，选no就可以了</p>
<p>再次检查一下， <strong>ls /bin/sh -al</strong> 发现软链接指向/bin/bash</p>
<p>​     lrwxrwxrwx 1 root root 4 11月 16 15:33 /bin/sh -&gt; bash</p>
<h2 id="P76which"><a href="#P76which" class="headerlink" title="P76which"></a>P76which</h2><p>Linux which命令用于查找文件。可以查看指向命令所在位置</p>
<p>/etc/passwd: 用于保存用户信息的文件</p>
<p>/etc/bin/passwd:用于修改用户密码的程序</p>
<p>which指令会在环境变量$PATH设置的目录里查找符合条件的文件。</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which [文件...]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-n&lt;文件名长度&gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</li>
<li>-p&lt;文件名长度&gt; 　与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。</li>
<li>-w 　指定输出时栏位的宽度。</li>
<li>-V 　显示版本信息。</li>
</ul>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>使用指令”which”查看指令”bash”的绝对路径，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ which bash</span><br></pre></td></tr></table></figure>

<p>上面的指令执行后，输出信息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;bash                   #bash可执行程序的绝对路径</span><br></pre></td></tr></table></figure>

<p>我们经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：</p>
<p><strong>which</strong> 　查看可执行文件的位置。</p>
<p><strong>whereis</strong> 查看文件的位置。</p>
<p><strong>locate</strong> 　配合数据库查看文件位置。</p>
<p><strong>find</strong> 　　实际搜寻硬盘查询文件名称。</p>
<p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
<p><strong>1．命令格式：</strong></p>
<p>which 可执行文件名称</p>
<p><strong>2．命令功能：</strong></p>
<p>which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p>
<p><strong>3．命令参数：</strong></p>
<p><strong>-n</strong> 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</p>
<p><strong>-p</strong> 与-n参数相同，但此处的包括了文件的路径。</p>
<p><strong>-w</strong> 指定输出时栏位的宽度。</p>
<p><strong>-V</strong> 显示版本信息</p>
<p><strong>4．使用实例：</strong></p>
<p><strong>实例1：</strong>查找文件、显示命令路径</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which lsmod</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# which pwd</span><br><span class="line">&#x2F;bin&#x2F;pwd</span><br><span class="line">[root@localhost ~]# which adduser</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;adduser</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>which 是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！</p>
<p><strong>实例2：</strong>用 which 去找出 which</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which which</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# which which</span><br><span class="line">alias which&#x3D;&#39;alias | &#x2F;usr&#x2F;bin&#x2F;which --tty-only --read-alias --show-dot --show-tilde&#39;</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;which</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>竟然会有两个 which ，其中一个是 alias 这就是所谓的『命令别名』，意思是输入 which 会等於后面接的那串命令！</p>
<p><strong>实例3：</strong>找出 cd 这个命令</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which cd</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>cd 这个常用的命令竟然找不到啊！为什么呢？这是因为 cd 是bash 内建的命令！ 但是 which 默认是找 PATH 内所规范的目录，所以当然一定找不到的！</p>
<p>bin:<br>bin为binary的简写主要放置一些<strong>系统的必备执行</strong>档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。</p>
<p>/usr/bin:<br>主 要放置一些<strong>应用软体工具的必备执行</strong>档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome<em>、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb</em>、wget等。 </p>
<p>/sbin:<br>主 要放置一些<strong>系统管理的必备</strong>程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。</p>
<p>/usr/sbin: </p>
<p>放置一些<strong>网路管理的必备</strong>程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等</p>
<h2 id="P77（su切换用户）"><a href="#P77（su切换用户）" class="headerlink" title="P77（su切换用户）"></a>P77（su切换用户）</h2><p>Linux su命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。不安全，会返回root。然后无需sudo了，即可改系统等。</p>
<p>使用权限：所有使用者。</p>
<h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su [-fmp] [-c command] [-s shell] [--help] [--version] [-] [USER [ARG]]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-f 或 –fast 不必读启动档（如 csh.cshrc 等），仅用于 csh 或 tcsh</li>
<li>-m -p 或 –preserve-environment 执行 su 时不改变环境变数</li>
<li>-c command 或 –command=command 变更为帐号为 USER 的使用者并执行指令（command）后再变回原来使用者</li>
<li>-s shell 或 –shell=shell 指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者（USER） shell</li>
<li>–help 显示说明文件</li>
<li>–version 显示版本资讯</li>
<li>- -l 或 –login 这个参数加了之后，就好像是重新 login 为该使用者一样，大部份环境变数（HOME SHELL USER等等）都是以该使用者（USER）为主，并且工作目录也会改变，如果没有指定 USER ，内定是 root</li>
<li>USER 欲变更的使用者帐号</li>
<li>ARG 传入新的 shell 参数</li>
</ul>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>变更帐号为 root 并在执行 ls 指令后退出变回原使用者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su -c ls root</span><br></pre></td></tr></table></figure>

<p>变更帐号为 root 并传入 -f 参数给新执行的 shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su root -f</span><br></pre></td></tr></table></figure>

<p>变更帐号为 clsung 并改变工作目录至 clsung 的家目录（home dir）（常用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - clsung</span><br></pre></td></tr></table></figure>

<p>切换用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hnlinux@runoob.com:~$ whoami &#x2F;&#x2F;显示当前用户</span><br><span class="line">hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ su root &#x2F;&#x2F;切换到root用户</span><br><span class="line">密码： </span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# whoami </span><br><span class="line">root</span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# pwd</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br></pre></td></tr></table></figure>

<p>切换用户，改变环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hnlinux@runoob.com:~$ whoami &#x2F;&#x2F;显示当前用户</span><br><span class="line">hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ su - root &#x2F;&#x2F;切换到root用户</span><br><span class="line">密码： </span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# whoami </span><br><span class="line">root</span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;root</span><br></pre></td></tr></table></figure>

<h2 id="P78修改文件权限"><a href="#P78修改文件权限" class="headerlink" title="P78修改文件权限"></a>P78修改文件权限</h2><p>1。 chown: 修改拥有者</p>
<p>2。chgrp：修改组</p>
<p>3 。chmod：修改权限</p>
<p>想要改文件的权限，只有管理员root和所有者才能修改</p>
<p>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。</p>
<p>一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限把自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。</p>
<p><strong>使用权限</strong> : root</p>
<h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown [-cfhvR] [--help] [--version] user[:group] file...</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong> :</p>
<ul>
<li>user : 新的文件拥有者的使用者 ID</li>
<li>group : 新的文件拥有者的使用者组(group)</li>
<li>-c : 显示更改的部分的信息</li>
<li>-f : 忽略错误信息</li>
<li>-h :修复符号链接</li>
<li>-v : 显示详细的处理信息</li>
<li>-R : 处理指定目录以及其子目录下的所有文件</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown runoob:runoobgroup file1.txt</span><br></pre></td></tr></table></figure>

<p>将目前目录下的所有文件与子目录的拥有者皆设为 runoob，群体的使用者 runoobgroup:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R runoob:runoobgroup *</span><br></pre></td></tr></table></figure>

<h3 id="1、chmod：更改文件9个属性"><a href="#1、chmod：更改文件9个属性" class="headerlink" title="1、chmod：更改文件9个属性"></a>1、chmod：更改文件9个属性</h3><p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626161252656-1763498520.png" alt="img"></p>
<p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p>
<h4 id="①-数字改变文件权限（常用）"><a href="#①-数字改变文件权限（常用）" class="headerlink" title="① 数字改变文件权限（常用）"></a>① 数字改变文件权限（常用）</h4><p>我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<ul>
<li>r:4</li>
<li>w:2</li>
<li>x:1</li>
</ul>
<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p>
<ul>
<li>owner = rwx = 4+2+1 = 7</li>
<li>group = rwx = 4+2+1 = 7</li>
<li>others= — = 0+0+0 = 0</li>
</ul>
<p>所以等我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure>

<ul>
<li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li>
<li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li>
</ul>
<h4 id="②-符号类型改变文件权限"><a href="#②-符号类型改变文件权限" class="headerlink" title="② 符号类型改变文件权限"></a>② 符号类型改变文件权限</h4><p> 我们就可以藉由u, g, o来代表三种身份的权限！</p>
<p>此外， a 则代表 all 亦即全部的身份！那么读写的权限就可以写成r, w, x！也就是可以使用底下的方式来看：</p>
<table>
<thead>
<tr>
<th>chmod</th>
<th>u g o a</th>
<th>+(加入) -(除去) =(设定)</th>
<th>r w x</th>
<th>文件或目录</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>如果我们需要将文件权限设置为 <strong>-rwxr-xr–</strong> ，可以使用 chmod u=rwx,g=rx,o=r 文件名 来设定。</p>
<p>注意：如果一个目录有写的权限，其他用户对于这个目录下的文件也可以删除。</p>
<h3 id="2、chown：更改文件属主，也可以同时更改文件属组"><a href="#2、chown：更改文件属主，也可以同时更改文件属组" class="headerlink" title="2、chown：更改文件属主，也可以同时更改文件属组"></a>2、chown：更改文件属主，也可以同时更改文件属组</h3><p>注意：这个命令只有管理员root才可以操作。而且系统里是必须存在这个用户。</p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626165146255-1650931601.png" alt="img"></p>
<p>语法：</p>
<p>chown [–R] 属主名： 文件名</p>
<p>chown [-R] 属主名：属组名 文件名</p>
<h3 id="3、chgrp：更改文件属组。"><a href="#3、chgrp：更改文件属组。" class="headerlink" title="3、chgrp：更改文件属组。"></a>3、chgrp：更改文件属组。</h3><p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626170509313-1815193220.png" alt="img"></p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chgrp [-R] 属组名 文件名</span><br></pre></td></tr></table></figure>

<p>参数选项</p>
<ul>
<li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li>
</ul>
<h3 id="4、umask设置预设的权限掩码"><a href="#4、umask设置预设的权限掩码" class="headerlink" title="4、umask设置预设的权限掩码"></a><strong>4、umask设置预设的权限掩码</strong></h3><p>Linux umask命令指定在建立文件时预设的权限掩码，在学习这个命令之前，先了解一下默认的所有者和所属组是哪来的？</p>
<p>一个文件创建的时候所有者和所属组是哪来的？</p>
<p>所有者：谁创建的文件谁就是这个文件的所有者。</p>
<p>所属组：就是这个文件创建者的缺省组，每个用户只能有一个缺省组。</p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626172146490-1231316404.png" alt="img"></p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626172519622-446882410.png" alt="img">显示新建文件的缺省权限。</p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626173131946-156221821.png" alt="img"></p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626173426757-2120027575.png" alt="img"></p>
<p>创建一个目录的时候查看发现 权限跟缺省权限是一致的，但是在test目录里创建一个文件后，查看文件缺省权限跟默认缺省权限不一致，这个是为什么呢？</p>
<p>rwxr-xr-x</p>
<p>rw-r–r–  对比发现都少了一个x可执行权限，这是因为在Linux里缺省权限创建的文件是不可具有可执行权限的。</p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626174110254-908588857.png" alt="img"></p>
<p>单独执行  <strong>umask</strong>  发现现实出 <strong>0022</strong> ，这是什么意思呢？</p>
<p>022是权限掩码意思，真正的权限是777-022=755 写出来就是rwxr-xr-x.</p>
<p>如果我们自己要是想修改这个缺省权限，该怎么修改的。</p>
<p>先把想修改的权限格式表示出来，算出对应的数字，再用777-对应的数字就可以，例如：</p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626174709974-11233329.png" alt="img"></p>
<h2 id="P79chmod详解"><a href="#P79chmod详解" class="headerlink" title="P79chmod详解"></a>P79chmod详解</h2><p>这是使用chmod命令时的正确语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod [options] mode [，mode] file1 [file2 ...]</span><br></pre></td></tr></table></figure>

<p>以下是chmod使用的一些常用选项：</p>
<p>　●　-f， - silent， - quiet（抑制大多数错误消息）</p>
<p>　●　-v， - verbose（为每个处理的文件输出诊断信息）</p>
<p>　●　-c， - changes（类似于详细但仅在进行更改时报告）</p>
<p>　●　-R， - recursive（递归更改文件和目录）（常用）</p>
<p>　●　–help（显示帮助和退出）</p>
<p>　●　–version（输出版本信息和退出）</p>
<p>下面是可以为用户，组以及计算机上的其他所有人设置的几个数字权限的列表。数字旁边是读/写/执行字母等价物。</p>
<p>　●　7：表示rwx，拥有读、写和执行的权限</p>
<p>　●　6：表示rw-，拥有读和写的权限</p>
<p>　●　5：表示rx，拥有读取和执行的权限</p>
<p>　●　4：表示r–，拥有只读权限</p>
<p>　●　3：表示-wx，拥有写入和执行的权限</p>
<p>　●　2：表示-w-，拥有只写权限</p>
<p>　●　1：表示 - x，仅拥有执行权限</p>
<p>　●　0：表示—，无权限</p>
<p>注：如果需要列出文件的权限，需要使用ls命令。</p>
<p><strong>chmod命令示例</strong></p>
<p>如果用户想要更改文件“participants”的权限，以便所有人都可以完全访问该文件，需要输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 participants</span><br></pre></td></tr></table></figure>

<p>说明：第1个7设置用户的权限，第2个7设置组的权限，第3个7设置其他所有者的权限。</p>
<p>如果用户想成为唯一可以访问它的人，可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 700 participants</span><br></pre></td></tr></table></figure>

<p>用户想要为自己和其小组成员提供完全访问权限，可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 770 participants</span><br></pre></td></tr></table></figure>

<p>如果用户想为自己保留完全访问权限，但希望阻止其他人修改文件，可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 755 participants</span><br></pre></td></tr></table></figure>

<p>以下使用上面的字母来更改文件“participants”的权限，以便所有者可以读取和写入文件，但不会更改其他任何人的权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod u&#x3D;rw participants</span><br></pre></td></tr></table></figure>

<p><strong>设置模式</strong> </p>
<p>使用chmod命令可以为文件和目录设置其他文件系统模式。例如，要设置粘滞位 - 这意味着只有文件所有者，目录所有者或超级用户可以删除该文件，而不管文件的读写组权限如何 - 在数字序列前加1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 1755 participants</span><br></pre></td></tr></table></figure>

<p>其他：</p>
<p>用户还可以使用chgrp命令更改现有文件和文件夹的组所有权，使用newgrp命令更改新文件和文件夹的默认组。</p>
<p>请记住，chmod命令中使用的符号链接将影响真实的目标对象。</p>
]]></content>
  </entry>
  <entry>
    <title>动态规划之其他题</title>
    <url>/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%85%B6%E4%BB%96%E9%A2%98/</url>
    <content><![CDATA[<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></h2><p>难度困难804收藏分享切换为英文关注反馈</p>
<p>给你两个单词 <em>word1</em> 和 <em>word2*，请你计算出将 *word1</em> 转换成 <em>word2</em> 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (插入 &#39;u&#39;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">动态规划</span><br><span class="line"></span><br><span class="line">定义 dp[i][j]</span><br><span class="line">21. dp[i][j] 代表 word1 中前 i 个字符，变换到 word2 中前 j 个字符，最短需要操作的次数</span><br><span class="line">22. 需要考虑 word1 或 word2 一个字母都没有，即全增加&#x2F;删除的情况，所以预留 dp[0][j] 和 dp[i][0]</span><br><span class="line"></span><br><span class="line">状态转移</span><br><span class="line">31. 增，dp[i][j] &#x3D; dp[i][j - 1] + 1</span><br><span class="line">32. 删，dp[i][j] &#x3D; dp[i - 1][j] + 1</span><br><span class="line">33. 改，dp[i][j] &#x3D; dp[i - 1][j - 1] + 1</span><br><span class="line">34. 按顺序计算，当计算 dp[i][j] 时，dp[i - 1][j] ， dp[i][j - 1] ， dp[i - 1][j - 1] 均已经确定了</span><br><span class="line">35. 配合增删改这三种操作，需要对应的 dp 把操作次数加一，取三种的最小</span><br><span class="line">36. 如果刚好这两个字母相同 word1[i - 1] &#x3D; word2[j - 1] ，那么可以直接参考 dp[i - 1][j - 1] ，操作不用加一</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：ikaruga</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;edit-distance&#x2F;solution&#x2F;edit-distance-by-ikaruga&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dp solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=word1.length();</span><br><span class="line">        <span class="keyword">int</span> col=word2.length();</span><br><span class="line">        <span class="keyword">if</span>((row==<span class="number">0</span>) || (col==<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> row+col;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row+<span class="number">1</span>;i++)</span><br><span class="line">            dp[i][<span class="number">0</span>]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col+<span class="number">1</span>;j++)</span><br><span class="line">            dp[<span class="number">0</span>][j]=j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;col+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>)!=word2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                    dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+=<span class="number">1</span>;</span><br><span class="line">                dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,Math.min(dp[i][j-<span class="number">1</span>]+<span class="number">1</span>,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">132. 分割回文串 II</a></h2><p>难度困难130收藏分享切换为英文关注反馈</p>
<p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。</p>
<p>返回符合要求的最少分割次数。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 进行一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> n = c.length;</span><br><span class="line">    <span class="keyword">int</span>[] cut = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[j] == c[i] &amp;&amp; (j + <span class="number">1</span> &gt; i - <span class="number">1</span> || dp[j + <span class="number">1</span>][i - <span class="number">1</span>])) &#123;</span><br><span class="line">                dp[j][i] = <span class="keyword">true</span>;  </span><br><span class="line">                min = j == <span class="number">0</span> ? <span class="number">0</span> : Math.min(min, cut[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cut[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cut[n - <span class="number">1</span>];</span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h2><p>难度中等2038收藏分享切换为英文关注反馈</p>
<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> strLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> maxStart = <span class="number">0</span>;  <span class="comment">//最长回文串的起点</span></span><br><span class="line">        <span class="keyword">int</span> maxEnd = <span class="number">0</span>;    <span class="comment">//最长回文串的终点</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;  <span class="comment">//最长回文串的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[strLen][strLen];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; strLen; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; r; l++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(l) == s.charAt(r) &amp;&amp; (r - l &lt;= <span class="number">2</span> || dp[l + <span class="number">1</span>][r - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[l][r] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                        maxLen = r - l + <span class="number">1</span>;</span><br><span class="line">                        maxStart = l;</span><br><span class="line">                        maxEnd = r;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxStart, maxEnd + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> premax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curmax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=curmax;</span><br><span class="line">            curmax=Math.max(x+premax,curmax);</span><br><span class="line">            premax=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curmax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Algorithm</strong></p>
<p>It could be overwhelming thinking of all possibilities on which houses to rob.</p>
<p>A natural way to approach this problem is to work on the simplest case first.</p>
<p>Let us denote that:</p>
<blockquote>
<p><em>f</em>(<em>k</em>) = Largest amount that you can rob from the first <em>k</em> houses.<br>Ai = Amount of money at the ith house.</p>
</blockquote>
<p>Let us look at the case <code>n = 1</code>, clearly <em>f</em>(1) = A1.</p>
<p>Now, let us look at <code>n = 2</code>, which <em>f</em>(2) = max(A1, A2).</p>
<p>For <code>n = 3</code>, you have basically the following two options:</p>
<ol>
<li>Rob the third house, and add its amount to the first house’s amount.</li>
<li>Do not rob the third house, and stick with the maximum amount of the first two houses.</li>
</ol>
<p>Clearly, you would want to choose the larger of the two options at each step.</p>
<p>Therefore, we could summarize the formula as following:</p>
<blockquote>
<p><em>f</em>(<em>k</em>) = max(<em>f</em>(<em>k</em> – 2) + Ak, <em>f</em>(<em>k</em> – 1))</p>
</blockquote>
<p>We choose the base case as <em>f</em>(–1) = <em>f</em>(0) = 0, which will greatly simplify our code as you can see.</p>
<p>The answer will be calculated as <em>f</em>(<em>n</em>). We could use an array to store and calculate the result, but since at each step you only need the previous two maximum values, two variables are suffice.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prevMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : num) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = currMax;</span><br><span class="line">        currMax = Math.max(prevMax + x, currMax);</span><br><span class="line">        prevMax = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). Assume that n<em>n</em> is the number of houses, the time complexity is O(n)<em>O</em>(<em>n</em>).</li>
<li>Space complexity : O(1)<em>O</em>(1).</li>
</ul>
<h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h2><p>难度中等254收藏分享切换为英文关注反馈</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈，</strong>这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">2</span>)<span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob0(nums),rob1(nums));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob0</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;<span class="comment">//0~length-2</span></span><br><span class="line">        <span class="keyword">int</span> premax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curmax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] arr1=<span class="keyword">new</span> <span class="keyword">int</span>[l-<span class="number">1</span>];</span><br><span class="line">        System.arraycopy(nums,<span class="number">0</span>,arr1,<span class="number">0</span>,l-<span class="number">1</span>);<span class="comment">//copy array</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr1)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=curmax;</span><br><span class="line">            curmax=Math.max(x+premax,curmax);</span><br><span class="line">            premax=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curmax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;<span class="comment">//0~length-1</span></span><br><span class="line">        <span class="keyword">int</span> premax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curmax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] arr2=<span class="keyword">new</span> <span class="keyword">int</span>[l-<span class="number">1</span>];</span><br><span class="line">        System.arraycopy(nums,<span class="number">1</span>,arr2,<span class="number">0</span>,l-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr2)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=curmax;</span><br><span class="line">            curmax=Math.max(x+premax,curmax);</span><br><span class="line">            premax=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curmax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>), rob(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> include = <span class="number">0</span>, exclude = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lo; j &lt;= hi; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = include, e = exclude;</span><br><span class="line">            include = e + num[j];</span><br><span class="line">            exclude = Math.max(e, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(include, exclude);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Since this question is a follow-up to House Robber, we can assume we already have a way to solve the simpler question, i.e. given a 1 row of house, we know how to rob them. So we already have such a helper function. We modify it a bit to rob a given range of houses.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int rob(int[] num, int lo, int hi) &#123;</span><br><span class="line">    int include &#x3D; 0, exclude &#x3D; 0;</span><br><span class="line">    for (int j &#x3D; lo; j &lt;&#x3D; hi; j++) &#123;</span><br><span class="line">        int i &#x3D; include, e &#x3D; exclude;</span><br><span class="line">        include &#x3D; e + num[j];</span><br><span class="line">        exclude &#x3D; Math.max(e, i);</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.max(include, exclude);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Now the question is how to rob a circular row of houses. It is a bit complicated to solve like the simpler question. It is because in the simpler question whether to rob <em>num[lo]</em> is entirely our choice. But, it is now constrained by whether <em>num[hi]</em> is robbed.</p>
<p>However, since we already have a nice solution to the simpler problem. We do not want to throw it away. Then, it becomes how can we reduce this problem to the simpler one. Actually, extending from the logic that if house i is not robbed, then you are free to choose whether to rob house i + 1, you can break the circle by assuming a house is not robbed.</p>
<p>For example, 1 -&gt; 2 -&gt; 3 -&gt; 1 becomes 2 -&gt; 3 if 1 is not robbed.</p>
<p>Since every house is either robbed or not robbed and at least half of the houses are not robbed, the solution is simply the larger of two cases with consecutive houses, i.e. house i not robbed, break the circle, solve it, or house i + 1 not robbed. Hence, the following solution. I chose i = n and i + 1 = 0 for simpler coding. But, you can choose whichever two consecutive ones.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int rob(int[] nums) &#123;</span><br><span class="line">    if (nums.length &#x3D;&#x3D; 1) return nums[0];</span><br><span class="line">    return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></h2><p>难度中等403收藏分享切换为英文关注反馈</p>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.length, col=row&gt;<span class="number">0</span>? matrix[<span class="number">0</span>].length:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;col+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j]=Math.min(Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]),dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">                    max=Math.max(max,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max*max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Approach-1-Brute-Force-Accepted"><a href="#Approach-1-Brute-Force-Accepted" class="headerlink" title="Approach #1 Brute Force [Accepted]"></a>Approach #1 Brute Force [Accepted]</h4><p>The simplest approach consists of trying to find out every possible square of 1’s that can be formed from within the matrix. The question now is – how to go for it?</p>
<p>We use a variable to contain the size of the largest square found so far and another variable to store the size of the current, both initialized to 0. Starting from the left uppermost point in the matrix, we search for a 1. No operation needs to be done for a 0. Whenever a 1 is found, we try to find out the largest square that can be formed including that 1. For this, we move diagonally (right and downwards), i.e. we increment the row index and column index temporarily and then check whether all the elements of that row and column are 1 or not. If all the elements happen to be 1, we move diagonally further as previously. If even one element turns out to be 0, we stop this diagonal movement and update the size of the largest square. Now we, continue the traversal of the matrix from the element next to the initial 1 found, till all the elements of the matrix have been traversed.</p>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = rows &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxsqlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sqlen = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">while</span> (sqlen + i &lt; rows &amp;&amp; sqlen + j &lt; cols &amp;&amp; flag) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= sqlen + j; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[i + sqlen][k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                                flag = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= sqlen + i; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[k][j + sqlen] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                                flag = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag)</span><br><span class="line">                            sqlen++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (maxsqlen &lt; sqlen) &#123;</span><br><span class="line">                        maxsqlen = sqlen;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsqlen * maxsqlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O((mn))<em>O</em>((<em>m**n</em>)2). In worst case, we need to traverse the complete matrix for every 1.</li>
<li>Space complexity : O(1)<em>O</em>(1). No extra space is used.</li>
</ul>
<hr>
<h4 id="Approach-2-Dynamic-Programming-Accepted"><a href="#Approach-2-Dynamic-Programming-Accepted" class="headerlink" title="Approach #2 (Dynamic Programming) [Accepted]"></a>Approach #2 (Dynamic Programming) [Accepted]</h4><p><strong>Algorithm</strong></p>
<p>We will explain this approach with the help of an example.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 1 1 0</span><br><span class="line">1 1 1 1 1</span><br><span class="line">0 1 1 1 1</span><br><span class="line">0 1 1 1 1</span><br><span class="line">0 0 1 1 1</span><br></pre></td></tr></table></figure>

<p>We initialize another matrix (dp) with the same dimensions as the original one initialized with all 0’s.</p>
<p>dp(i,j) represents the side length of the maximum square whose bottom right corner is the cell with index (i,j) in the original matrix.</p>
<p>Starting from index (0,0), for every 1 found in the original matrix, we update the value of the current element as</p>
<p>dp(i,j)=min⁡(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1.dp(<em>i</em>,<em>j</em>)=min(dp(<em>i</em>−1,<em>j</em>),dp(<em>i</em>−1,<em>j</em>−1),dp(<em>i</em>,<em>j</em>−1))+1.</p>
<p>We also remember the size of the largest square found so far. In this way, we traverse the original matrix once and find out the required maximum size. This gives the side length of the square (say maxsqlen<em>m<strong>a</strong>x<strong>s</strong>q<strong>l</strong>e**n</em>). The required result is the area maxsqlen2<em>m*</em>a<strong>x</strong>s<strong>q</strong>l<strong>e</strong>n*2.</p>
<p>To understand how this solution works, see the figure below.</p>
<p><img src="https://leetcode.com/media/original_images/221_Maximal_Square.PNG?raw=true" alt="Max Square"></p>
<p>An entry 2 at (1,3)(1,3) implies that we have a square of side 2 up to that index in the original matrix. Similarly, a 2 at (1,2)(1,2) and (2,2)(2,2)implies that a square of side 2 exists up to that index in the original matrix. Now to make a square of side 3, only a single entry of 1 is pending at (2,3)(2,3). So, we enter a 3 corresponding to that position in the dp array.</p>
<p>Now consider the case for the index (3,4)(3,4). Here, the entries at index (3,3)(3,3) and (2,3)(2,3) imply that a square of side 3 is possible up to their indices. But, the entry 1 at index (2,4)(2,4) indicates that a square of side 1 only can be formed up to its index. Therefore, while making an entry at the index (3,4)(3,4), this element obstructs the formation of a square having a side larger than 2. Thus, the maximum sized square that can be formed up to this index is of size 2×22×2.</p>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = rows &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows + <span class="number">1</span>][cols + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> maxsqlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    maxsqlen = Math.max(maxsqlen, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsqlen * maxsqlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(mn)<em>O</em>(<em>m**n</em>). Single pass.</li>
<li>Space complexity : O(mn)<em>O</em>(<em>m**n</em>). Another matrix of same size is used for dp.</li>
</ul>
<hr>
<h4 id="Approach-3-Better-Dynamic-Programming-Accepted"><a href="#Approach-3-Better-Dynamic-Programming-Accepted" class="headerlink" title="Approach #3 (Better Dynamic Programming) [Accepted]"></a>Approach #3 (Better Dynamic Programming) [Accepted]</h4><p><strong>Algorithm</strong></p>
<p>In the previous approach for calculating dp of ith<em>i<strong>t</strong>h</em> row we are using only the previous element and the (i−1)(<em>i</em>−1)<em>t**h</em> row. Therefore, we don’t need 2D dp matrix as 1D dp array will be sufficient for this.</p>
<p>Initially the dp array contains all 0’s. As we scan the elements of the original matrix across a row, we keep on updating the dp array as per the equation dp[j]=min(dp[j−1],dp[j],prev)<em>d**p</em>[<em>j</em>]=<em>m<strong>i</strong>n</em>(<em>d**p</em>[<em>j</em>−1],<em>d**p</em>[<em>j</em>],<em>p<strong>r</strong>e**v</em>), where prev refers to the old dp[j−1]<em>d**p</em>[<em>j</em>−1]. For every row, we repeat the same process and update in the same dp array.</p>
<p><img src="https://leetcode.com/media/original_images/221_Maximal_Square1.png?raw=true" alt=" Max Square "></p>
<p><strong>java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = rows &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[cols + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> maxsqlen = <span class="number">0</span>, prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cols; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = dp[j];</span><br><span class="line">                <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    dp[j] = Math.min(Math.min(dp[j - <span class="number">1</span>], prev), dp[j]) + <span class="number">1</span>;</span><br><span class="line">                    maxsqlen = Math.max(maxsqlen, dp[j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsqlen * maxsqlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(mn)<em>O</em>(<em>m**n</em>). Single pass.</li>
<li>Space complexity : O(n)<em>O</em>(<em>n</em>). Another array which stores elements in a row is used for dp.</li>
</ul>
<h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></h2><p>给定一个整数数组，其中第 <em>i</em> 个元素代表了第 <em>i</em> 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sold=Integer.MIN_VALUE, held=Integer.MIN_VALUE, reset=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price: prices)&#123;</span><br><span class="line">            <span class="keyword">int</span> presold=sold;</span><br><span class="line">            sold=held+price;</span><br><span class="line">            held=Math.max(held,reset-price);</span><br><span class="line">            reset=Math.max(reset, presold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(sold, reset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Approach-1-Dynamic-Programming-with-State-Machine"><a href="#Approach-1-Dynamic-Programming-with-State-Machine" class="headerlink" title="Approach 1: Dynamic Programming with State Machine"></a>Approach 1: Dynamic Programming with State Machine</h4><p><strong>Intuition</strong></p>
<p>First of all, let us take a different perspective to look at the problem, unlike the other algorithmic problems.</p>
<p>Here, we will treat the problem as a game, and the trader as an agent in the game. The agent can take actions that lead to gain or lose of game points (<em>i.e.</em> profits). And the goal of the game for the agent is to gain the maximal points.</p>
<p>In addition, we will introduce a tool called <a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="noopener">state machine</a>, which is a mathematical model of computation. Later one will see how the state machine coupled with the dynamic programming technique can help us solve the problem easily.</p>
<p>In the following sections, we will first define a <strong><em>state machine</em></strong> that is used to model the behaviors and states of the game agent.</p>
<p>Then, we will demonstrate how to apply the state machine to solve the problem.</p>
<p><strong>Definition</strong></p>
<p>Let us define a <strong><em>state machine\</em></strong> to model our agent. The state machine consists of three states, which we define as follows:</p>
<ul>
<li>state <code>held</code>: in this state, the agent holds a stock that it bought at some point before. </li>
<li>state <code>sold</code>: in this state, the agent has just sold a stock right before entering this state. And the agent holds no stock at hand. </li>
<li>state <code>reset</code>: first of all, one can consider this state as the starting point, where the agent holds no stock and did not sell a stock before. More importantly, it is also the <em>transient</em> state before the <code>held</code> and <code>sold</code>. Due to the <strong><em>cooldown\</em></strong> rule, after the <code>sold</code> state, the agent can not immediately acquire any stock, but is <em>forced</em> into the <code>reset</code> state. One can consider this state as a “reset” button for the cycles of buy and sell transactions.</li>
</ul>
<p>At any moment, the agent can only be in <strong><em>one\</em></strong> state. The agent would transition to another state by performing some actions, namely:</p>
<ul>
<li>action <code>sell</code>: the agent sells a stock at the current moment. After this action, the agent would transition to the <code>sold</code> state.</li>
<li>action <code>buy</code>: the agent acquires a stock at the current moment. After this action, the agent would transition to the <code>held</code>state.</li>
<li>action <code>rest</code>: this is the action that the agent does no transaction, neither buy or sell. For instance, while holding a stock at the <code>held</code> state, the agent might simply do nothing, and at the next moment the agent would remain in the <code>held</code> state.</li>
</ul>
<p>Now, we can assemble the above states and actions into a <strong>state machine</strong>, which we show in the following graph where each node represents a state, and each edge represents a transition between two states. On top of each edge, we indicate the action that triggers the transition.</p>
<p><img src="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_state_machine.png" alt="state machine"></p>
<p>Notice that, in all states except the <code>sold</code> state, by doing nothing, we would remain in the same state, which is why there is a self-looped transition on these states.</p>
<p><strong>Deduction</strong></p>
<p>Now, one might wonder how exactly the state machine that we defined can help to solve the problem.</p>
<p>As we mentioned before, we model the problem as a <strong><em>game\</em></strong>, and the trader as an <strong><em>agent\</em></strong> in the game. And this is where our state machine comes into the picture. The behaviors and the states of the game agent can be modeled by our state machine.</p>
<p><img src="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_game.png" alt="mario game"></p>
<p>Given a list stock prices (<em>i.e.</em> <code>price[0...n]</code>), our agent would walk through each price point one by one. At each point, the agent would be in one of three states (<em>i.e.</em> <code>held</code>, <code>sold</code> and <code>reset</code>) that we defined before. And at each point, the agent would take one of the three actions (<em>i.e.</em> <code>buy</code>, <code>sell</code> and <code>rest</code>), which then would lead to the next state at the next price point.</p>
<blockquote>
<p>Now if we chain up each state at each price point, it would form a <strong><em>graph\</em></strong> where each <strong><em>path\</em></strong> that starts from the initial price point and ends at the last price point represents a combination of transactions that the agent could perform through out the game.</p>
</blockquote>
<p><img src="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_graph.png" alt="graph of state transition"></p>
<p>The above graph shows all possible paths that our game agent agent walks through the list, which corresponds to all possible combinations of transactions that the trader can perform with the given price sequence.</p>
<blockquote>
<p>In order to solve the problem, the goal is to find such a path in the above graph that maximizes the profits.</p>
</blockquote>
<p>In each node of graph, we also indicate the maximal profits that the agent has gained so far in each state of each step. And we highlight the path that generates the maximal profits. Don’t worry about them for the moment. We will explain in detail how to calculate in the next section.</p>
<p><strong>Algorithm</strong></p>
<p>In order to implement the above state machine, we could define three arrays (<em>i.e.</em> <code>held[i]</code>, <code>sold[i]</code> and <code>reset[i]</code>) which correspond to the three states that we defined before.</p>
<blockquote>
<p>Each element in each array represents the maximal profits that we could gain at the specific price point <code>i</code> with the specific state. For instance, the element <code>sold[2]</code> represents the maximal profits we gain if we sell the stock at the price point <code>price[2]</code>.</p>
</blockquote>
<p>According to the state machine we defined before, we can then deduce the formulas to calculate the values for the state arrays, as follows:</p>
<p>sold[i]=hold[i−1]+price[i]held[i]=max⁡(held[i−1],reset[i−1]−price[i])reset[i]=max⁡(reset[i−1],sold[i−1])sold[<em>i</em>]=hold[<em>i</em>−1]+price[<em>i</em>]held[<em>i</em>]=max(held[<em>i</em>−1],reset[<em>i</em>−1]−price[<em>i</em>])reset[<em>i</em>]=max(reset[<em>i</em>−1],sold[<em>i</em>−1])</p>
<p>Here is how we interpret each formulas:</p>
<ul>
<li>sold[i]sold[<em>i</em>]: the previous state of <code>sold</code> can only be <code>held</code>. Therefore, the maximal profits of this state is the maximal profits of the previous state plus the revenue by selling the stock at the current price. </li>
<li>held[i]held[<em>i</em>]: the previous state of <code>held</code> could also be <code>held</code>, <em>i.e.</em> one does no transaction. Or its previous state could be <code>reset</code>, from which state, one can acquire a stock at the current price point. </li>
<li>reset[i]reset[<em>i</em>]: the previous state of <code>reset</code> could either be <code>reset</code> or <code>sold</code>. Both transitions do not involve any transaction with the stock.</li>
</ul>
<blockquote>
<p>Finally, the maximal profits that we can gain from this game would be max⁡(sold[n],reset[n])max(sold[<em>n</em>],reset[<em>n</em>]), <em>i.e.</em> at the last price point, either we sell the stock or we simply do no transaction, to have the maximal profits. It makes no sense to acquire the stock at the last price point, which only leads to the reduction of profits.</p>
</blockquote>
<p>In particular, as a base case, the game should be kicked off from the state <code>reset</code>, since initially we don’t hold any stock and we don’t have any stock to sell neither. Therefore, we assign the initial values of <code>sold[-1]</code> and <code>held[-1]</code> to be <code>Integer.MIN_VALUE</code>, which are intended to <em>render</em> the paths that start from these two states impossible.</p>
<p>As one might notice in the above formulas, in order to calculate the value for each array, we reuse the intermediate values, and this is where the paradigm of <strong><em>dynamic programming</em></strong> comes into play.</p>
<p>More specifically, we only need the intermediate values at exactly one step before the current step. As a result, rather than keeping all the values in the three arrays, we could use a <strong><em>sliding window\</em></strong> of size <code>1</code> to calculate the value for max⁡(sold[n],reset[n])max(sold[<em>n</em>],reset[<em>n</em>]).</p>
<p>In the following animation, we demonstrate the process on how the three arrays are calculated step by step.</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAAEgCAYAAACO31PFAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAADSKADAAQAAAABAAABIAAAAAAYqXSkAABAAElEQVR4Ae3dB2BV1f3A8V/2HoQkhBAg7L03IrgrCoo4qlalrXW31hatrf/iqhu0Slu1rmrdE7FuERUVRPaUFfYKAbL3+t/fCTckYYWQ9959731PG997d51zPuclvN874wZUW0lICCCAAAIIIIAAAggggAACEogBAggggAACCCCAAAIIIIBAjQABEu8EBBBAAAEEEEAAAQQQQOCAAAESbwUEEEAAAQQQQAABBBBA4IAAARJvBQQQQAABBBBAAAEEEEDggAABEm8FBBBAAAEEEEAAAQQQQOCAAAESbwUEEEAAAQQQQAABBBBA4IAAARJvBQQQQAABBBBAAAEEEEDggAABEm8FBBBAAAEEEEAAAQQQQOCAAAESbwUEEEAAAQQQQAABBBBA4IAAARJvBQQQQAABBBBAAAEEEEDggECwJyQCAgI8ka1P5Tl58mSZNm2aT9WJyhwU4HfkoAXPEEAAAQQQQAABVwhUV1cf9rIeCZC0JEcq0GFLycZ6AlOnTpXMzMx623jhewL8jvhem9o1+umnn+SCCy6QNWvW2Jt49DEB/ZKD32Efa9QG1aGNG4D42MtzzjlHbrzxRhk3bpyP1Yzq2AJH+zKaIXa2Eo8IIIAAAggggAACCCDg9wIESH7/FgAAAQQQQAABBBBAAAEEbAECJFuCRwQQQAABBBBAAAEEEPB7AQIkv38LAIAAAggggAACCCCAAAK2AAGSLcEjAggggAACCCCAAAII+L0AAZLfvwUAQAABBBBAAAEEEEAAAVuAAMmW4BEBBBBAAAEEEEAAAQT8XoAAye/fAgAggAACCCCAAAIIIICALUCAZEvwiAACCCCAAAIIIIAAAn4vQIDk928BABBAAAEEEEAAAQQQQMAWIECyJXhEAAEEEEAAAQQQQAABvxcgQPL7twAACCCAAAIIIIAAAgggYAsQINkSBx4XL14sU6dOlfLy8gZ7eIkAAq4QKCoqkrPOOksiIiIkPz/fFVlwTQ8J6N/Ru+++W372s5/JmDFjZOLEiTJ//nwPlYZsm1ugqqpK3njjDbnoootk3Lhxcumll4r+G0ryHYHt27fLBRdcIB07dpTk5GQZOnSoPPzww75TQWoi+/btk8svv1xOO+00OfXUU+VXv/qV2ebvNMH+DtCw/ueff77oHwR9owwaNKjhbl4jgEAzCvz0009y5plnyo4dO8xV9QMXyTcE1q1bZ9p269at9So0Y8YMmT59uvzud7+rt50X3iWQnZ0to0ePlpUrV9Yr+Jtvvim33367PPTQQ/W288L7BLRtR4wYIQUFBbWFz8rKkgULFsimTZvk6aefrt3OE+8UeO+99+TCCy88pPCvv/66rFixQrp06XLIPn/ZQA9Sg5a++eab5ZJLLpH09PQGe3iJAALNKaAfsIYNG1YbHDXntbmWZwX0A9VJJ50kGhzpl01Lly41Xzz95S9/MQW79dZb6S30bBOdcO5r1qwxwZF+gNIPWRkZGfLSSy9JdHS0PProo+YD9AlnwgU8JlBSUmJ6jvR3edKkSbJ3716pqKiQr7/+2pTpueeekx9//NFj5SPjExdYuHBhbXD05z//2fy91i8tzz33XCktLZWzzz77xDPx4ivQg9Sg8W677bYGW3iJAAKuEAgKCpLg4GD505/+JM8//zxd+q5A9tA1q6urpVu3bnLTTTfJHXfcIaGhoaYkDzzwgHzwwQeyatUqKSwslJiYGA+VkGxPVEC/3FiyZIl07dpVIiMjzeV0GJYOk/3tb38rW7ZskQ4dOpxoNpzvIYHZs2fLhg0bpF+/fvKf//xHAgICTEl0qOz7778vEyZMMD2FX331lYdKSLYnKhASEiIDBw4U/eJKh8na6cUXX5SkpCS//xLL6wMk/YdYx0zqP7ba7bt+/Xrz07p1axkwYIDd3ubxrbfeMmPh4+LiZPny5fLMM8+Ifkvy4IMPmjeDHqTnR0VFSWpqar1z9YWOu9V/2PUf+2uuucaMxbX/aNgHa0SufzD0m5ZRo0bJyJEjRT8IkhBAoL5AbGysCYr0d0i783UcNMk3BDTw+e677w6pjA6l1J6GsLAw09NwyAFs8BqBwMBA6d+/f73y6r/HzEGqR+K1L15++WVTdv3c0/Bzzsknn2z2rV27VrTNG+732kr7WcE1+F20aNEhtba36Wdlf05eHyDpnIVvvvnG/IJqoGR3/2qj6jcd+i2I/iEvKyuTX/ziFyaY0n+8dUiAnVavXi3ff/+9uYYGNHrNPXv21AtsdHKxjp23k37jPX78ePNNil6/srJSdP7SRx99ZB9iHvVb1Dlz5pjJjfV28AIBBGr/YdXfn/j4eAkPD0fFRwVyc3Nl7Nix5kspncyvQ7FI3i+gv7v6b5x+yaFfEGqvkn7BqJP5Sd4poG2qw+cSEhLMZ6aGtdAvt9q0aWOGYREgNdTx7tc670x7BzVpj78/J5+Zg6S/pBocaUQ8efJkExRp4GQHQhr06DFffPGF2aarKv33v/8132TqZGLdp0n/MDRMf/vb30xw1Lt3b/nhhx/kww8/NH8c9Ll93nXXXWeCI+2ufO2110zgpAGafsPSMGhqeH1eI+DPAtqLqx+etbuf3lbffCd8++235m+zTvpNS0uTRx55xDcr6oe1+vvf/27mmT377LNmZIauRqlfTNrD7vyQxCeqrJ+F9Asr/bvcMOmXwtoLrPOTdK4KyfsF9DPyP//5T+nTp4/5Eks7HC6++GLvr9gJ1MDrAyS7a1cfdaicTgaeNm2aaK+QbtNFF+wgxnZ64okn5JNPPpErr7yy3reY+gZpGCDpMrWPP/64OVXP0XHXOoFt48aNZoy1fqDTD3f67Vm7du3M8LrLLrtMWrZsaSY16on2+Hs7fx4RQOCggA6t0yGyffv2NXOSDu7hmbcL6N/ev/71r2a1M52Tor0K+sVS27Ztvb1qlP+AgC5qdO+995oRFfrvp47WuPrqq80wc5C8W6DhZ6eGtdFeYA2USN4toPMGtXffXllU547OmjXLuyvVDKX3+iF2dQMknextJx3apsHLrl276gVIGh1r49vn3XnnndKjRw/T46TfZOu3IXqufkOiSe/xsH//frnnnnvMN5/29esGPR9//LHovVy0p0kDtPvvv18+//xzc+h5551n7v1hn8cjAggcXqBnz56H38FWrxTQv6f690977XUxDl3a+ze/+c1hv5H2ygpSaCOgXwxOmTLFPNfg95xzzjFD1nWO74033oiSlwroF8Ya7GrQq7+/dZN+TtL5hCyyUlfFO5/rcu06p0zbUxdmePvtt830FO+sTfOW2ut7kI7GYQdB+otuJx2CV3cYj/Yw6X1YNNnH1+1F+t///mf26U20jpR0vpKmu+66y7yxNDg644wzTG+SrvaiQw5ICCBwdIG6v6dHP5K93iDwhz/8wQRHusqZzku54YYbCI68oeFOoIzDhw+vHT45d+7cE7gSp3pSQD8j6XQBvRXD5s2bDylKZmam+TJZ5yjZXyYfchAbHC+gAbDejkGDI51Dr738OjWEVCPg9QGSBjXaK3S4ZHcP1/0F1pucHSvpBMSGwZJuO1LSPyKa9A+JjtnUiar6rekpp5xSe50jnct2BBCoEaj7xQUm3i2gq3jai9roo87fJPmWwM6dO83KsQ1rpSMwNNX9d7fhMbx2voB+yatfWukS3w3TzJkzzSYNokjeK6Ariuooq5SUFDM3ny/z67el1wdIdatjB0S6Te/irf9I6x9rO9ipe+zRntftTtYJxZr03h11U05OTu0/Dr169TK7NDjSBRoGDRpUe6hOStYATlfJIyGAwKEC9uIMusQ+yTcEdF6ZfsusE331RqL693L37t3mRoR681j920zybgFdDEnnlNWdq6BzdvUmsZrsQMm7a+m/pT/rrLNM5Z988klz+xNbQm8kesstt5gAmPtG2ire+agBkiaddqK9Sfp3W7/40J4k/Xvt76n+wFIv1tBvOvT+RTr+Wce+64IKmt59991GB0h2gKVvGr2efgOmNznUO0brfY/mzZtnxtTrOOt//etf5iZa+mbSrsn27dubsZv6j7/2HOm34dptqXOYdLyuTkInIYDAQQGd26e/r/pBWoe16u+s3r9MV8MaN27cwQN55rUCek+4uvM17YroMtDz58+vN6/T3sejdwiMHj3a/Pumv8N6C43ExEQz91bvMaiLcOjwdZL3CujQWP3grJ919H5XuhiHfkZ66aWXTKU0gKIHyXvbt27JdQ6hPY+w7nYdblf31jl19/nDc58JkLSxNBCxh3Xoa73Rmd27Ywc/Rxsqp6uxaJClPUD28IBWrVrJCy+8INdee6151Od20jH2OqlNe5y+/PJLs3KPLi2u//DbSe8sfvfdd9fOc7K384iAvwvo6o96z4W6Xx7ot1b6LTTJuwV08naHDh1EJwB3797dfGDW4Ru6Xb9U0g/Rded6endt/bP0emsL/TJRe4xefPHFWgRdjVInejOBv5bEa5/oisDFxcXms0/dNr7iiitE7wVJ8m4B/RutST/DDhgwwNz3Sj8D64/OG9Uv/P05BViBQ80NgNyooEPemjNb/YOsH7T0m2gdT6mBko55bzieUpeb1W9B9PgjJf1HW4OjhsPydBnEV155xfzjrqv26I20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" alt="Current"></p>
<p>1 / 7</p>
<blockquote>
<p>As a <strong><em>byproduct\</em></strong> of this algorithm, not only would we obtain the maximal profits at the end, but also we could recover each action that we should perform along the path, although this is not required by the problem.</p>
</blockquote>
<p>In the above graph, by starting from the final state, and walking backward following the path, we could obtain a sequence of actions that leads to the maximal profits at the end, <em>i.e.</em> [<code>buy</code>, <code>sell</code>, <code>cooldown</code>, <code>buy</code>, <code>sell</code>].</p>
<iframe src="https://leetcode.com/playground/G3tLgwPY/shared" frameborder="0" width="100%" height="378" name="G3tLgwPY" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li><p>Time Complexity: O(N)O(<em>N</em>) where N<em>N</em> is the length of the input price list.</p>
<ul>
<li>We have one loop over the input list, and the operation within one iteration takes constant time. </li>
</ul>
</li>
<li><p>Space Complexity: O(1)O(1), constant memory is used regardless the size of the input. </p>
</li>
</ul>
<hr>
<h4 id="Approach-2-Yet-Another-Dynamic-Programming"><a href="#Approach-2-Yet-Another-Dynamic-Programming" class="headerlink" title="Approach 2: Yet-Another Dynamic Programming"></a>Approach 2: Yet-Another Dynamic Programming</h4><p><strong>Intuition</strong></p>
<p>Most of the times, there are more than one approaches to decompose the problem, so that we could apply the technique of dynamic programming.</p>
<p>Here we would like to propose a different perspective on how to model the problem purely with mathematical formulas.</p>
<p>Again, this would be a journey loaded with mathematical notations, which might be complicated, but it showcases how the mathematics could help one with the dynamic <em>programming</em> (pun intended).</p>
<p><strong>Definition</strong></p>
<p>For a sequence of prices, denoted as price[0,1,…,n]price[0,1,…,<em>n</em>], let us first define our <strong>target</strong> function called MP(i)MP(<em>i</em>). The function MP(i)MP(<em>i</em>)gives the maximal profits that we can gain for the price <em>subsequence</em> starting from the index i<em>i</em>, <em>i.e.</em> price[i,i+1,…,n]price[<em>i</em>,<em>i</em>+1,…,<em>n</em>].</p>
<p>Given the definition of the MP(i)MP(<em>i</em>) function, one can see that when i=0<em>i</em>=0 the output of the function, <em>i.e.</em> MP(0)MP(0), is exactly the result that we need to solve the problem, which is the maximal profits that one can gain for the price subsequence of price[0,1,…,n]price[0,1,…,<em>n</em>].</p>
<p>Suppose that we know all the values for MP(i)MP(<em>i</em>) onwards until MP(n)MP(<em>n</em>), <em>i.e.</em> we know the maximal profits that we can gain for any subsequence of price[k…n]k∈[i,n]price[<em>k</em>…<em>n</em>]<em>k</em>∈[<em>i</em>,<em>n</em>].</p>
<p>Now, let us add a new price point price[i−1]price[<em>i</em>−1] into the subsequence price[i…n]price[<em>i</em>…<em>n</em>], all we need to do is to deduce the value for the <strong>unknown</strong> MP(i−1)MP(<em>i</em>−1).</p>
<blockquote>
<p>Up to this point, we have just modeled the problem with our <strong>target</strong> function MP(i)MP(<em>i</em>), along with a series of definitions. The problem now is boiled down to deducing the formula for MP(i−1)MP(<em>i</em>−1).</p>
</blockquote>
<p>In the following section, we will demonstrate how to deduce the formula for MP(i−1)MP(<em>i</em>−1).</p>
<p><strong>Deduction</strong></p>
<p>With the newly-added price point price[i−1]price[<em>i</em>−1], we need to consider <strong>all</strong> possible transactions that we can do to the stock at this price point, which can be broken down into two cases:</p>
<ul>
<li>Case 1): we buy this stock with price[i−1]price[<em>i</em>−1] and then sell it at some point in the following price sequence of price[i…n]price[<em>i</em>…<em>n</em>]. Note that, once we sell the stock at a certain point, we need to cool down for a day, then we can reengage with further transactions. Suppose that we sell the stock right after we bought it, at the next price point price[i]price[<em>i</em>], the maximal profits we would gain from this choice would be the profit of this transaction (<em>i.e.</em> price[i]−price[i−1]price[<em>i</em>]−price[<em>i</em>−1]) <strong>plus</strong> the maximal profits from the rest of the price sequence, as we show in the following:</li>
</ul>
<p><img src="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_formula.png" alt="example of profit calculation"></p>
<p>In addition, we need to <strong>enumerate</strong> all possible points to sell this stock, and take the maximum among them. The maximal profits that we could gain from this case can be represented by the following:</p>
<p>C1=max⁡{k∈[i,n]}(price[k]−p[i−1]+MP(k+2))<em>C</em>1=max{<em>k</em>∈[<em>i</em>,<em>n</em>]}(price[<em>k</em>]−p[<em>i</em>−1]+MP(<em>k</em>+2))</p>
<ul>
<li>Case 2): we simply do nothing with this stock. Then the maximal profits that we can gain from this case would be MP(i)MP(<em>i</em>), which are also the maximal profits that we can gain from the rest of the price sequence.</li>
</ul>
<p>C2=MP(i)<em>C</em>2=MP(<em>i</em>)</p>
<p>By combining the above two cases, <em>i.e.</em> selecting the max value among them, we can obtain the value for MP(i−1)MP(<em>i</em>−1), as follows:</p>
<p>MP(i−1)=max⁡(C1,C2)MP(<em>i</em>−1)=max(<em>C</em>1,<em>C</em>2)</p>
<p>MP(i−1)=max⁡(max⁡{k∈[i,n]}(price[k]−price[i−1]+MP(k+2)),MP(i))MP(<em>i</em>−1)=max(max{<em>k</em>∈[<em>i</em>,<em>n</em>]}(price[<em>k</em>]−price[<em>i</em>−1]+MP(<em>k</em>+2)),MP(<em>i</em>))</p>
<p>By the way, the base case for our recursive function MP(i)MP(<em>i</em>) would be MP(n)MP(<em>n</em>) which is the maximal profits that we can gain from the sequence with a single price point price[n]price[<em>n</em>]. And the best thing we should do with a single price point is to do no transaction, hence we would neither lose money nor gain any profit, <em>i.e.</em> MP(n)=0MP(<em>n</em>)=0.</p>
<p>The above formulas do model the problem soundly. In addition, one should be able to translate them directly into code.</p>
<p><strong>Algorithm</strong></p>
<p>With the final formula we derived for our target function MP(i)MP(<em>i</em>), we can now go ahead and translate it into any programming language.</p>
<ul>
<li>Since the formula deals with subsequences of price that start from the last price point, we then could do an <strong>iteration</strong> over the price list in the reversed order. </li>
<li>We define an array <code>MP[i]</code> to hold the values for our target function MP(i)MP(<em>i</em>). We initialize the array with zeros, which correspond to the base case where the minimal profits that we can gain is zero. Note that, here we did a trick to pad the array with two additional elements, which is intended to simplify the branching conditions, as one will see later. </li>
<li>To calculate the value for each element <code>MP[i]</code>, we need to look into two cases as we discussed in the previous section, namely:<ul>
<li>Case 1). we buy the stock at the price point <code>price[i]</code>, then we sell it at a later point. As one might notice, the initial padding on the <code>MP[i]</code> array saves us from getting out of boundary in the array.</li>
<li>Case 2). we do no transaction with the stock at the price point <code>price[i]</code>.</li>
</ul>
</li>
<li>At the end of each iteration, we then pick the largest value from the above two cases as the final value for <code>MP[i]</code>.</li>
<li>At the end of the loop, the <code>MP[i]</code> array will be populated. We then return the value of <code>MP[0]</code>, which is the desired solution for the problem.</li>
</ul>
<iframe src="https://leetcode.com/playground/MM2cVbSW/shared" frameborder="0" width="100%" height="463" name="MM2cVbSW" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time Complexity: O(N2)O(<em>N</em>2) where N<em>N</em> is the length of the price list.<ul>
<li>As one can see, we have nested loops over the price list. The number of iterations in the outer loop is N<em>N</em>. The number of iterations in the inner loop varies from 11 to N<em>N</em>. Therefore, the total number of iterations that we perform is ∑i=1Ni=N⋅(N+1)2∑<em>i</em>=1<em>N**i</em>=2<em>N</em>⋅(<em>N</em>+1).</li>
<li>As a result, the overall time complexity of the algorithm is O(N2)O(<em>N</em>2). </li>
</ul>
</li>
<li>Space Complexity: O(N)O(<em>N</em>) where N<em>N</em> is the length of the price list.<ul>
<li>We allocated an array to hold all the values for our target function MP(i)MP(<em>i</em>). </li>
</ul>
</li>
</ul>
<h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 3 + 3 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,5,1,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \   \ </span><br><span class="line"> 1   3   1</span><br><span class="line"></span><br><span class="line">输出: 9</span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 4 + 5 &#x3D; 9.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result=helper(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(result[<span class="number">0</span>],result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] helper(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];<span class="comment">//0 is not steal, 1 is steal</span></span><br><span class="line">        <span class="keyword">int</span>[] left=helper(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] right=helper(root.right);</span><br><span class="line">        result[<span class="number">0</span>]=Math.max(left[<span class="number">0</span>],left[<span class="number">1</span>])+Math.max(right[<span class="number">0</span>],right[<span class="number">1</span>]);</span><br><span class="line">        result[<span class="number">1</span>]=left[<span class="number">0</span>]+right[<span class="number">0</span>]+root.val;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明</p>
<p>本题目本身就是动态规划的树形版本，通过此题解，可以了解一下树形问题在动态规划问题解法<br>我们通过三个方法不断递进解决问题</p>
<p>解法一通过递归实现，虽然解决了问题，但是复杂度太高<br>解法二通过解决方法一中的重复子问题，实现了性能的百倍提升<br>解法三直接省去了重复子问题，性能又提升了一步<br>解法一、暴力递归 - 最优子结构</p>
<p>在解法一和解法二中，我们使用爷爷、两个孩子、4 个孙子来说明问题<br>首先来定义这个问题的状态<br>爷爷节点获取到最大的偷取的钱数呢</p>
<p>首先要明确相邻的节点不能偷，也就是爷爷选择偷，儿子就不能偷了，但是孙子可以偷<br>二叉树只有左右两个孩子，一个爷爷最多 2 个儿子，4 个孙子<br>根据以上条件，我们可以得出单个节点的钱该怎么算<br>4 个孙子偷的钱 + 爷爷的钱 VS 两个儿子偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数。这就是动态规划里面的最优子结构</p>
<p>由于是二叉树，这里可以选择计算所有子节点</p>
<p>4 个孙子投的钱加上爷爷的钱如下<br>int method1 = root.val + rob(root.left.left) + rob(root.left.right) + rob(root.right.left) + rob(root.right.right)<br>两个儿子偷的钱如下<br>int method2 = rob(root.left) + rob(root.right);<br>挑选一个钱数多的方案则<br>int result = Math.max(method1, method2);<br>将上述方案写成代码如下</p>
<p>Java<br>public int rob(TreeNode root) {<br>    if (root == null) return 0;</p>
<pre><code>int money = root.val;
if (root.left != null) {
    money += (rob(root.left.left) + rob(root.left.right));
}

if (root.right != null) {
    money += (rob(root.right.left) + rob(root.right.right));
}

return Math.max(money, rob(root.left) + rob(root.right));</code></pre><p>}<br>信心满满的提交，一次通过，然而 执行用时:837 ms,在所有 java 提交中击败了24.49%的用户 这个结果太没面子了，下个解法进行优化</p>
<p>解法二、记忆化 - 解决重复子问题</p>
<p>针对解法一种速度太慢的问题，经过分析其实现，我们发现爷爷在计算自己能偷多少钱的时候，同时计算了 4 个孙子能偷多少钱，也计算了 2 个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。</p>
<p>于是乎我们发现了一个动态规划的关键优化点</p>
<p>重复子问题</p>
<p>我们这一步针对重复子问题进行优化，我们在做斐波那契数列时，使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。<br>由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，TreeNode 当做 key，能偷的钱当做 value</p>
<p>解法一加上记忆化优化后代码如下：</p>
<p>Java<br>public int rob(TreeNode root) {<br>    HashMap&lt;TreeNode, Integer&gt; memo = new HashMap&lt;&gt;();<br>    return robInternal(root, memo);<br>}</p>
<p>public int robInternal(TreeNode root, HashMap&lt;TreeNode, Integer&gt; memo) {<br>    if (root == null) return 0;<br>    if (memo.containsKey(root)) return memo.get(root);<br>    int money = root.val;</p>
<pre><code>if (root.left != null) {
    money += (robInternal(root.left.left, memo) + robInternal(root.left.right, memo));
}
if (root.right != null) {
    money += (robInternal(root.right.left, memo) + robInternal(root.right.right, memo));
}
int result = Math.max(money, robInternal(root.left, memo) + robInternal(root.right, memo));
memo.put(root, result);
return result;</code></pre><p>}<br>提交代码，执行用时：4 ms, 在所有 java 提交中击败了 54.92% 的用户，速度提高了 200 倍。太开心了。别着急，还有一个终极方案呢，连记忆化消耗的时间都省了，能省则省么。</p>
<p>解法三、终极解法</p>
<p>上面两种解法用到了孙子节点，计算爷爷节点能偷的钱还要同时去计算孙子节点投的钱，虽然有了记忆化，但是还是有性能损耗。</p>
<p>我们换一种办法来定义此问题</p>
<p>每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷</p>
<p>当前节点选择偷时，那么两个孩子节点就不能选择偷了<br>当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系)<br>我们使用一个大小为 2 的数组来表示 int[] res = new int[2] 0 代表不偷，1 代表偷<br>任何一个节点能偷到的最大钱的状态可以定义为</p>
<p>当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱<br>当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数<br>表示为公式如下</p>
<p>root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) + Math.max(rob(root.right)[0], rob(root.right)[1])<br>root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;<br>将公式做个变换就是代码啦</p>
<p>Java<br>public int rob(TreeNode root) {<br>    int[] result = robInternal(root);<br>    return Math.max(result[0], result[1]);<br>}</p>
<p>public int[] robInternal(TreeNode root) {<br>    if (root == null) return new int[2];<br>    int[] result = new int[2];</p>
<pre><code>int[] left = robInternal(root.left);
int[] right = robInternal(root.right);

result[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
result[1] = left[0] + right[0] + root.val;

return result;</code></pre><p>}<br>再提交一次：<br>执行用时 1 ms, 在所有 java 提交中击败了 99.87% 的用户，这样的结果，我觉得可以了。</p>
<h2 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413. 等差数列划分"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices/" target="_blank" rel="noopener">413. 等差数列划分</a></h2><p>难度中等122收藏分享切换为英文关注反馈</p>
<p>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<p>例如，以下数列为等差数列:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br></pre></td></tr></table></figure>

<p>以下数列不是等差数列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, 1, 2, 5, 7</span><br></pre></td></tr></table></figure>



<p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。</p>
<p>如果满足以下条件，则称子数组(P, Q)为等差数组：</p>
<p>元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。</p>
<p>函数要返回数组 A 中所有为等差数组的子数组个数。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &#x3D; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=A.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;l;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]-A[i-<span class="number">1</span>]==A[i-<span class="number">1</span>]-A[i-<span class="number">2</span>])&#123;</span><br><span class="line">                dp[i]=<span class="number">1</span>+dp[i-<span class="number">1</span>];</span><br><span class="line">                result+=dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Approach-1-Brute-Force-Accepted-1"><a href="#Approach-1-Brute-Force-Accepted-1" class="headerlink" title="Approach #1 Brute Force [Accepted]"></a>Approach #1 Brute Force [Accepted]</h4><p>The most naive solution is to consider every pair of elements(with atleast 1 element between them), so that the range of elements lying between these two elements acts as a slice. Then, we can iterate over every such slice(range) to check if all the consecutive elements within this range have the same difference. For every such range found, we can increment the count<em>c<strong>o</strong>u<strong>n</strong>t</em> that is used to keep a track of the required result.</p>
<iframe src="https://leetcode.com/playground/HT3WjgGf/shared" frameborder="0" name="HT3WjgGf" width="100%" height="343" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n3)<em>O</em>(<em>n</em>3). We iterate over the range formed by every pair of elements. Here, n<em>n</em> refers to the number of elements in the given array A<em>A</em>.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant extra space is used.</li>
</ul>
<hr>
<h4 id="Approach-2-Better-Brute-Force-Accepted"><a href="#Approach-2-Better-Brute-Force-Accepted" class="headerlink" title="Approach #2 Better Brute Force [Accepted]"></a>Approach #2 Better Brute Force [Accepted]</h4><p><strong>Algorithm</strong></p>
<p>In the last approach, we considered every possible range and then iterated over the range to check if the difference between every consercutive element in this range is the same. We can optimize this approach to some extent, by making a small observation.</p>
<p>We can see, that if we are currently considering the range bound by the elements, let’s say, A[s]<em>A</em><a href="start"><em>s</em></a> and A[e]<em>A</em><a href="end"><em>e</em></a>, we have checked the consecutive elements in this range to have the same difference. Now, when we move on to the next range between the indices s<em>s</em> and e+1<em>e</em>+1, we again perform a check on all the elements in the range s:e<em>s</em>:<em>e</em>, along with one additional pair A[e+1]<em>A</em>[<em>e</em>+1]and A[e]<em>A</em>[<em>e</em>]. We can remove this redundant check in the range s:e<em>s</em>:<em>e</em> and just check the last pair to have the same difference as the one used for the previous range(same s<em>s</em>, incremented e<em>e</em>).</p>
<p>Note that if the last range didn’t constitute an arithmetic slice, the same elements will be a part of the updated range as well. Thus, we can omit the rest of the ranges consisting of the same starting index. The rest of the process remains the same as in the last approach.</p>
<iframe src="https://leetcode.com/playground/NPDEAgTz/shared" frameborder="0" name="NPDEAgTz" width="100%" height="309" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n2)<em>O</em>(<em>n</em>2). Two for loops are used.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant extra space is used.</li>
</ul>
<hr>
<h4 id="Approach-3-Using-Recursion-Accepted"><a href="#Approach-3-Using-Recursion-Accepted" class="headerlink" title="Approach #3 Using Recursion [Accepted]"></a>Approach #3 Using Recursion [Accepted]</h4><p><strong>Algorithm</strong></p>
<p>By making use of the observation discussed in the last approach, we know, that if a range of elements between the indices (i,j)(<em>i</em>,<em>j</em>)constitute an Arithmetic Slice, and another element A[j+1]<em>A</em>[<em>j</em>+1] is included such that A[j+1]<em>A</em>[<em>j</em>+1] and A[j]<em>A</em>[<em>j</em>] have the same difference as that of the previous common difference, the ranges between (i,j+1)(<em>i</em>,<em>j</em>+1) will constitutes an arithmetic slice. Further, if the original range (i,j)(<em>i</em>,<em>j</em>) doesn’t form an arithmetic slice, adding new elements to this range won’t do us any good. Thus, no more arithmetic slices can be obtained by adding new elements to it.</p>
<p>By making use of this observation, we can develop a recursive solution for the given problem as well. Assume that a sum<em>s<strong>u</strong>m</em> variable is used to store the total number of arithmetic slices in the given array A<em>A</em>. We make use of a recursive function <code>slices(A,i)</code>which returns the number of Arithmetic Slices in the range (k,i)(<em>k</em>,<em>i</em>), but which are not a part of any range (k,j)(<em>k</em>,<em>j</em>) such that j&lt;i<em>j</em>&lt;<em>i</em>. It also updates sum<em>s<strong>u</strong>m</em> with the number of arithmetic slices(total) in the current range. Thus, k<em>k</em> refers to the minimum index such that the range (k,i)(<em>k</em>,<em>i</em>) constitutes a valid arithmetic slice.</p>
<p>Now, suppose we know the number of arithmetic slices in the range (0,i−1)(0,<em>i</em>−1) constituted by the elements [a0,a1,a2,…a(i−1)][<em>a</em>0,<em>a</em>1,<em>a</em>2,…<em>a</em>(<em>i</em>−1)], to be say x<em>x</em>. If this range itself is an arithmetic slice, all the consecutive elements have the same difference(equal to say, a(i−1)−a(i−2)<em>a</em>(<em>i</em>−1)−<em>a</em>(<em>i</em>−2)). Now, adding a new element ai<em>a**i</em> to it to extend the range to (0,i)(0,<em>i</em>) will constitute an arithmetic slice only if this new element satisfies ai−a(i−1)=a(i−1)−a(i−2)<em>a*<em>i</em>−*a</em>(<em>i</em>−1)=<em>a</em>(<em>i</em>−1)−<em>a</em>(<em>i</em>−2). Thus, now, the addition of this new element, will lead to an addition of ap<em>a**p</em> number of arithmetic slices to the ones obtained in the range (0,i−1)(0,<em>i</em>−1). The new arithmetic slices will be the ones constituting the ranges (0,i),(1,i),…(i−2,i)(0,<em>i</em>),(1,<em>i</em>),…(<em>i</em>−2,<em>i</em>), which are a total of x+1<em>x</em>+1 additional arithmetic slices. This is because, apart from the range (0,i)(0,<em>i</em>) the rest of the ranges (1,i),(2,i),…(i−2,i)(1,<em>i</em>),(2,<em>i</em>),…(<em>i</em>−2,<em>i</em>) can be mapped to (0,i−1),(1,i−1),…(i−3,i−1)(0,<em>i</em>−1),(1,<em>i</em>−1),…(<em>i</em>−3,<em>i</em>−1), with count equal to x<em>x</em>.</p>
<p>Thus, in every call to <code>slices</code>, if the ith<em>i<strong>t</strong>h</em> element has the same common difference with the last element as the previous common difference, we can find the number of new arithmetic slices added by the use of this element, ap<em>a**p</em> and also update the sum<em>s<strong>u</strong>m</em> to include this ap<em>a**p</em> into it, apart from the count obtained by the smaller ranges. But, if the new element doesn’t have the same common difference, extra arithmetic slices can’t be contributed by it and hence, no addition is done to sum<em>s<strong>u</strong>m</em> for the current element. But, of course sum<em>s<strong>u</strong>m</em> will be updated as per the count obtained from the smaller ranges.</p>
<iframe src="https://leetcode.com/playground/WGzuREMw/shared" frameborder="0" name="WGzuREMw" width="100%" height="360" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). The recursive function is called at most n−2<em>n</em>−2 times.</li>
<li>Space complexity : O(n)<em>O</em>(<em>n</em>). The depth of the recursion tree goes upto n−2<em>n</em>−2.</li>
</ul>
<hr>
<h4 id="Approach-5-Dynamic-Programming-Accepted"><a href="#Approach-5-Dynamic-Programming-Accepted" class="headerlink" title="Approach #5 Dynamic Programming [Accepted]:"></a>Approach #5 Dynamic Programming [Accepted]:</h4><p><strong>Algorithm</strong></p>
<p>In the last approach, we start with the full range (0,n−1)(0,<em>n</em>−1), where n<em>n</em> is the number of elements in the given A<em>A</em> array. We can observe that the result for the range (0,i)(0,<em>i</em>) only depends on the elements in the range (0,i)(0,<em>i</em>) and not on any element beyond this range. Thus, we can make use of Dynamic Programming to solve the given problem.</p>
<p>We can make use of a 1-D dp<em>d**p</em> with number of elements equal to n<em>n</em>. dp[i]<em>d**p</em>[<em>i</em>] is used to store the number of arithmetic slices possible in the range (k,i)(<em>k</em>,<em>i</em>) and not in any range (k,j)(<em>k</em>,<em>j</em>) such that j&lt;i<em>j</em>&lt;<em>i</em>. Again, k<em>k</em> refers to the minimum index possible such that (k,j)(<em>k</em>,<em>j</em>)constitutes a valid Arithmetic Slice.</p>
<p>Instead of going in the reverse order as in the recursive approach, we can start filling the dp<em>d**p</em> in a forward manner. The intuition remains the same as in the last approach. For the ith<em>i<strong>t</strong>h</em> element being considered, we check if this element satsfies the common difference criteria with the previous element. If so, we know the number of new arithmetic slices added will be 1+dp[i−1]1+<em>d**p</em>[<em>i</em>−1] as discussed in the last approach. The sum<em>s<strong>u</strong>m</em> is also updated by the same count to reflect the new arithmetic slices added.</p>
<p>The following animation illustrates the dp<em>d**p</em> filling process.</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAAHZCAYAAAC8QhsUAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAADSKADAAQAAAABAAAB2QAAAABdjUaIAABAAElEQVR4AezdB3wURRsG8Ody6b2RkJCQhNB770WkShOkgyJNBAFFqqh0UERB9KOLIL0K0hHpvfcaSAiBJKSH9Ha331w4ILm7hNCTu2f9RW77zn9nd+ednd2VSaIDOwpQgAIUoAAFKEABClCAAhSAEQ0oQAEKUIACFKAABShAAQpQ4LEAAyTmBApQgAIUoAAFKEABClCAAmoBBkjMChSgAAUoQAEKUIACFKAABdQCDJCYFShAAQpQgAIUoAAFKEABCqgFGCAxK1CAAhSgAAUoQAEKUIACFFALMEBiVqAABShAAQpQgAIUoAAFKKAWYIDErEABClCAAhSgAAUoQAEKUEAtwACJWYECFKAABShAAQpQgAIUoIBagAESswIFKEABClCAAhSgAAUoQAG1AAMkZgUKUIACFKAABShAAQpQgAJqAQZIzAoUoAAFKEABClCAAhSgAAXUAgyQmBUoQAEKUIACFKAABShAAQqoBRggMStQgAIUoAAFKEABClCAAhRQCzBAYlagAAUoQAEKUIACFKAABSigFmCAxKxAAQpQgAIUoAAFKEABClBALcAAiVmBAhSgAAUoQAEKUIACFKCAWoABErMCBShAAQpQgAIUoAAFKEABtQADJGYFClCAAhSgAAUoQAEKUIACagEGSMwKFKAABShAAQpQgAIUoAAF1AIMkJgVKEABClCAAhSgAAUoQAEKqAUYIDErUIACFKAABShAAQpQgAIUUAswQGJWoAAFKEABClCAAhSgAAUooBZggMSsQAEKUIACFKAABShAAQpQQC3AAIlZgQIUoAAFKEABClCAAhSggFqAARKzAgUoQAEKUIACFKAABShAAbUAAyRmBQpQgAIUoAAFKEABClCAAmoBBkjMChSgAAUoQAEKUIACFKAABdQCDJCYFShAAQpQgAIUoAAFKEABCqgFGCAxK1CAAhSgAAUoQAEKUIACFFALMEBiVqAABShAAQpQgAIUoAAFKKAWYIDErEABClCAAhSgAAUoQAEKUEAtwACJWYECFKAABShAAQpQgAIUoIBagAESswIFKEABClCAAhSgAAUoQAG1AAMkZgUKUIACFKAABShAAQpQgAJqAQZIzAoUoAAFKEABClCAAhSgAAXUAgyQmBUoQAEKUIACFKAABShAAQqoBRggMStQgAIUoAAFKEABClCAAhRQCzBAYlagAAUoQAEKUIACFKAABSigFmCAxKxAAQpQgAIUoAAFKEABClBALcAAiVmBAhSgAAUoQAEKUIACFKCAWoABErMCBShAAQpQgAIUoAAFKEABtQADJGYFClCAAhSgAAUoQAEKUIACagEGSMwKFKAABShAAQpQgAIUoAAF1AIMkJgVKEABClCAAhSgAAUoQAEKqAUYIDErUIACFKAABShAAQpQgAIUUAswQGJWoAAFKEABClCAAhSgAAUooBZggMSsQAEKUIACFKAABShAAQpQQC3AAIlZgQIUoAAFKEABClCAAhSggFqAARKzAgUoQAEKUIACFKAABShAAbUAAyRmBQpQgAIUoAAFKEABClCAAmoBBkjMChSgAAUoQAEKUIACFKAABdQCDJCYFShAAQpQgAIUoAAFKEABCqgFGCAxK1CAAhSgAAUoQAEKUIACFFALMEBiVqAABShAAQpQgAIUoAAFKKAWYIDErEABClCAAhSgAAUoQAEKUEAtwACJWYECFKAABShAAQpQgAIUoIBagAESswIFKEABClCAAhSgAAUoQAG1AAMkZgUKUIACFKAABShAAQpQgAJqAQZIzAoUoAAFKEABClCAAhSgAAXUAgyQmBUoQAEKUIACFKAABShAAQqoBRggMStQgAIUoAAFKEABClCAAhRQCzBAYlagAAUoQAEKUIACFKAABSigFmCAxKxAAQpQgAIUoAAFKEABClBALcAAiVmBAhSgAAUoQAEKUIACFKCAWoABErMCBShAAQpQgAIUoAAFKEABtQADJGYFClCAAhSgAAUoQAEKUIACagEGSMwKFKAABShAAQpQgAIUoAAF1AIMkJgVKEABClCAAhSgAAUoQAEKqAUYIDErUIACFKAABShAAQpQgAIUUAswQGJWoAAFKEABClCAAhSgAAUooBZggMSsQAEKUIACFKAABShAAQpQQC3AAIlZgQIUoAAFKEABClCAAhSggFqAARKzAgUoQAEKUIACFKAABShAAbUAAyRmBQpQgAIUoAAFKEABClCA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AktvTt7O9WRHjx4d991337jwwgvP9Sj/03//1157bbzwwgvc5lA/ceLE2L179xzP7H7K888/P7Zv3z42bdrUDTFj+pMnT44zZ86M888/f8Znnt2H/7+/fLz88svjxRdfHLt27Tq7EAv2s09fG44fPz727NmzYMnObpw33nhjPPvss+Oiiy46u/+gBfzZn3vuubFz586xvOzr9rPUO31tmJpt3bp1lqfVP/b06dNj375944EHHhgrKyvRYyEG0qlTp8b0E68tW7bEkI5ZYPrJzSuvvDLW1tbyA1zXFZh+4sVtXZ51f2D68ba6uupFcF2h/APTT1inv16ndt7eusB0VL766qt+rb51sv88cvqJ/vR1ddu2bTM+08Onbj5Znf3jYPrasHnz5tmfWP6M6WvD0tLS2LBhQ7nEbPGnrw3TYfnfvni2EANpNhaPJkCAAAECBAgQIECAQBbwe5nZxZUAAQIECBAgQIAAgUIBA6mwdJEJECBAgAABAgQIEMgCBlJ2cSVAgAABAgQIECBAoFDAQCosXWQCBAgQIECAAAECBLKAgZRdXAkQIECAAAECBAgQKBQwkApLF5kAAQIECBAgQIAAgSxgIGUXVwIECBAgQIAAAQIECgUMpMLSRSZAgAABAgQIECBAIAsYSNnFlQABAgQIECBAgACBQgEDqbB0kQkQIECAAAECBAgQyAIGUnZxJUCAAAECBAgQIECgUMBAKixdZAIECBAgQIAAAQIEsoCBlF1cCRAgQIAAAQIECBAoFDCQCksXmQABAgQIECBAgACBLGAgZRdXAgQIECBAgAABAgQKBQykwtJFJkCAAAECBAgQIEAgCxhI2cWVAAECBAgQIECAAIFCAQOpsHSRCRAgQIAAAQIECBDIAgZSdnElQIAAAQIECBAgQKBQwEAqLF1kAgQIECBAgAABAgSygIGUXVwJECBAgAABAgQIECgUMJAKSxeZAAECBAgQIECAAIEsYCBlF1cCBAgQIECAAAECBAoFDKTC0kUmQIAAAQIECBAgQCALGEjZxZUAAQIECBAgQIAAgUIBA6mwdJEJECBAgAABAgQIEMgCBlJ2cSVAgAABAgQIECBAoFDAQCosXWQCBAgQIECAAAECBLKAgZRdXAkQIECAAAECBAgQKBQwkApLF5kAAQIECBAgQIAAgSxgIGUXVwIECBAgQIAAAQIECgUM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" alt="Current"></p>
<p>1 / 9</p>
<iframe src="https://leetcode.com/playground/w8UZ2q6u/shared" frameborder="0" name="w8UZ2q6u" width="100%" height="292" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). We traverse over the given A<em>A</em> array with n<em>n</em> elements once only.</li>
<li>Space complexity : O(n)<em>O</em>(<em>n</em>). 1-D dp<em>d**p</em> of size n<em>n</em> is used.</li>
</ul>
<hr>
<h4 id="Approach-5-Constant-Space-Dynamic-Programming-Accepted"><a href="#Approach-5-Constant-Space-Dynamic-Programming-Accepted" class="headerlink" title="Approach #5 Constant Space Dynamic Programming [Accepted]:"></a>Approach #5 Constant Space Dynamic Programming [Accepted]:</h4><p><strong>Algorithm</strong></p>
<p>In the last approach, we can observe that we only require the element dp[i−1]<em>d**p</em>[<em>i</em>−1] to determine the value to be entered at dp[i]<em>d**p</em>[<em>i</em>]. Thus, instead of making use of a 1-D array to store the required data, we can simply keep a track of just the last element.</p>
<iframe src="https://leetcode.com/playground/mGEcWWi3/shared" frameborder="0" name="mGEcWWi3" width="100%" height="292" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). We traverse over the given A<em>A</em> array with n<em>n</em> elements once only.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant extra space is used.</li>
</ul>
<hr>
<h4 id="Approach-6-Using-Formula-Accepted"><a href="#Approach-6-Using-Formula-Accepted" class="headerlink" title="Approach #6 Using Formula [Accepted]:"></a>Approach #6 Using Formula [Accepted]:</h4><p><strong>Algorithm</strong></p>
<p>From the dp<em>d**p</em> solution, we can observe that for k<em>k</em> consecutive elements sastisfying the common difference criteria, we update the sum<em>s<strong>u</strong>m</em> for each such element by 1,2,3,…,k1,2,3,…,<em>k</em> counts in that order. Thus, instead of updating the sum<em>s<strong>u</strong>m</em> at the same time, we can just keep a track of the number of consecutive elements satisfying the common differnce criteria in a count<em>c<strong>o</strong>u<strong>n</strong>t</em> variable and just update the sum<em>s<strong>u</strong>m</em> directly as count∗(count+1)/2<em>c<strong>o</strong>u<strong>n</strong>t<em>∗(</em>c<strong>o</strong>u<strong>n</strong>t</em>+1)/2 whenver an element not satisfying this criteria is found. At the same time, we also need to reset the count<em>c<strong>o</strong>u<strong>n</strong>t</em> value.</p>
<iframe src="https://leetcode.com/playground/fQULWrDF/shared" frameborder="0" name="fQULWrDF" width="100%" height="309" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). We iterate over A<em>A</em> with n<em>n</em> elements exactly once.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant extra space is used.</li>
</ul>
<h2 id="1039-多边形三角剖分的最低得分"><a href="#1039-多边形三角剖分的最低得分" class="headerlink" title="1039. 多边形三角剖分的最低得分"></a><a href="https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/" target="_blank" rel="noopener">1039. 多边形三角剖分的最低得分</a></h2><p>难度中等41收藏分享切换为英文关注反馈</p>
<p>给定 <code>N</code>，想象一个凸 <code>N</code> 边多边形，其顶点按顺时针顺序依次标记为 <code>A[0], A[i], ..., A[N-1]</code>。</p>
<p>假设您将多边形剖分为 <code>N-2</code> 个三角形。对于每个三角形，该三角形的值是顶点标记的<strong>乘积</strong>，三角剖分的分数是进行三角剖分后所有 <code>N-2</code> 个三角形的值之和。</p>
<p>返回多边形进行三角剖分后可以得到的最低分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：多边形已经三角化，唯一三角形的分数为 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/minimum-score-triangulation-of-polygon-1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,7,4,5]</span><br><span class="line">输出：144</span><br><span class="line">解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 &#x3D; 245，或 3*4*5 + 3*4*7 &#x3D; 144。最低分数为 144。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,3,1,4,1,5]</span><br><span class="line">输出：13</span><br><span class="line">解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 &#x3D; 13。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minScoreTriangulation</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=A.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[l][l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l-<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">2</span>;j&lt;l;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j]==<span class="number">0</span>)</span><br><span class="line">                        dp[i][j]=dp[i][k]+dp[k][j]+A[i]*A[j]*A[k];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=Math.min(dp[i][k]+dp[k][j]+A[i]*A[j]*A[k],dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][l-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解题思路</p>
<p>dp[i][j]表示从i到j序列的最低分。记底边为ij的三角形顶点为m，三角形imj将多边形分成三部分，总分即为三部分的分数和（如果m=i+1或m=j-1，则对应第一或第三部分分数为0）。<br>那么m在什么位置分数最低呢，将m从i+1到j-1遍历，分别计算dp[i][m]+A[i]<em>A[j]</em>A[m]+dp[m][j],取其中最小值即为dp[i][j]。<br>dp[i][j]=min(dp[i][m]+A[i]<em>A[j]</em>A[m]+dp[m][j]),for m in range [i+1,j-1]</p>
<p>dp table只用到右上半部分，初始化相邻两元素序列结果为0（两元素序列不能构成三角形）；采用自底向上、自左向右的方向计算dp table。最终输出dp[0][n-1]。</p>
<h2 id="1043-分隔数组以得到最大和"><a href="#1043-分隔数组以得到最大和" class="headerlink" title="1043. 分隔数组以得到最大和"></a><a href="https://leetcode-cn.com/problems/partition-array-for-maximum-sum/" target="_blank" rel="noopener">1043. 分隔数组以得到最大和</a></h2><p>难度中等48收藏分享切换为英文关注反馈</p>
<p>给出整数数组 <code>A</code>，将该数组分隔为长度最多为 K 的几个（连续）子数组。分隔完成后，每个子数组的中的值都会变为该子数组中的最大值。</p>
<p>返回给定数组完成分隔后的最大和。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,15,7,9,2,5,10], K &#x3D; 3</span><br><span class="line">输出：84</span><br><span class="line">解释：A 变为 [15,15,15,9,10,10,10]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= K &lt;= A.length &lt;= 500</code></li>
<li><code>0 &lt;= A[i] &lt;= 10^6</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=A.length;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">0</span>||A==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[l+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> max=dp[i];</span><br><span class="line">            <span class="keyword">while</span>((i-j)&lt;=K &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                max=Math.max(A[j],max);</span><br><span class="line">                dp[i]=Math.max(dp[i],dp[j]+max*(i-j));</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法1：DP"><a href="#方法1：DP" class="headerlink" title="方法1：DP"></a>方法1：DP</h5><p><img src="https://pic.leetcode-cn.com/ddf9ff236598ff79b00e7365354cdaf961463cc78dfed7505334ad2628a60d73-e7c5ca8d4c19bed3e8652951c6f37c6.jpg" alt="e7c5ca8d4c19bed3e8652951c6f37c6.jpg"></p>
<p><img src="https://pic.leetcode-cn.com/a49b3279d3d2e9b9d9617da384d72dbcfe395dc3a0f0d1fe6fc4e4587f2c6d12-image.png" alt="image.png"></p>
<h2 id="1218-最长定差子序列"><a href="#1218-最长定差子序列" class="headerlink" title="1218. 最长定差子序列"></a><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/" target="_blank" rel="noopener">1218. 最长定差子序列</a></h2><p>难度中等27收藏分享切换为英文关注反馈</p>
<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>difference</code>，请你找出 <code>arr</code> 中所有相邻元素之间的差等于给定 <code>difference</code> 的等差子序列，并返回其中最长的等差子序列的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,3,4], difference &#x3D; 1</span><br><span class="line">输出：4</span><br><span class="line">解释：最长的等差子序列是 [1,2,3,4]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,3,5,7], difference &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：最长的等差子序列是任意单个元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,5,7,8,5,3,4,2,1], difference &#x3D; -2</span><br><span class="line">输出：4</span><br><span class="line">解释：最长的等差子序列是 [7,5,3,1]。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= arr[i], difference &lt;= 10^4</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">1</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: arr)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=map.getOrDefault(i-difference, <span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">            map.put(i,tmp);</span><br><span class="line">            result=Math.max(result,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路<br>这道题思路比较简单，跟经典问题最长递增（减）子序列有点相似，而这道题称为最长等差子序列, 也就是说是固定公差的递增（减），相对还更简单一点。</p>
<p>可以用dp[i]来记录以数字i为结尾的最长等差子序列的长度，那么它应该只有两种情况：</p>
<p>dp[i] = 1 // 表示在 i 之前没有出现等差子序列<br>dp[i] = dp[i - difference] + 1 // 表示在 i 之前出现了等差子序列，长度为 dp[i - difference], 而 i 也是满足这个等差序列的，所以等差序列的长度在此基础上加 1 就可以了<br>考虑元素值会出现负数，所以用数组存放是不行的，那么可以用一个 map来维护以 i 结尾的最长等差序列的长度，所以也就不难得出如下代码：</p>
<p>可以为下标加一个偏置，解决出现负值的情况，这是很OK，因为这道题arr[i]、difference的数据范围已经给的很明确了，而且比较小。</p>
<h2 id="1269-停在原地的方案数"><a href="#1269-停在原地的方案数" class="headerlink" title="1269. 停在原地的方案数"></a><a href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/" target="_blank" rel="noopener">1269. 停在原地的方案数</a></h2><p>难度困难23收藏分享切换为英文关注反馈</p>
<p>有一个长度为 <code>arrLen</code> 的数组，开始有一个指针在索引 <code>0</code> 处。</p>
<p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p>
<p>给你两个整数 <code>steps</code> 和 <code>arrLen</code> ，请你计算并返回：在恰好执行 <code>steps</code> 次操作以后，指针仍然指向索引 <code>0</code> 处的方案数。</p>
<p>由于答案可能会很大，请返回方案数 <strong>模</strong> <code>10^9 + 7</code> 后的结果。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：steps &#x3D; 3, arrLen &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。</span><br><span class="line">向右，向左，不动</span><br><span class="line">不动，向右，向左</span><br><span class="line">向右，不动，向左</span><br><span class="line">不动，不动，不动</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：steps &#x3D; 2, arrLen &#x3D; 4</span><br><span class="line">输出：2</span><br><span class="line">解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。</span><br><span class="line">向右，向左</span><br><span class="line">不动，不动</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：steps &#x3D; 4, arrLen &#x3D; 2</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= steps &lt;= 500</code></p>
</li>
<li><p><code>1 &lt;= arrLen &lt;= 10^6</code></p>
<p>s: steps</p>
<pre><code>l：经过s步，停留的坐标
p[s][l]: 经过s步，停留在坐标l的总方案数
arrLen: 数组长度</code></pre></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MOD = <span class="number">1_000_000_007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> steps, <span class="keyword">int</span> arrLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p[][] = <span class="keyword">new</span> <span class="keyword">int</span>[steps+<span class="number">1</span>][steps+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        p[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">1</span>; s&lt;=steps; s++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">0</span>; l &lt; Math.min(steps+<span class="number">1</span>, arrLen); l++) &#123;                        </span><br><span class="line">                <span class="keyword">if</span> (s == l) &#123;</span><br><span class="line">                    p[s][l] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s &lt; l) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p[s][l] = p[s-<span class="number">1</span>][l];</span><br><span class="line">                <span class="keyword">if</span> (l-<span class="number">1</span> &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                    p[s][l] += p[s-<span class="number">1</span>][l-<span class="number">1</span>];</span><br><span class="line">                    p[s][l] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l+<span class="number">1</span> &lt; arrLen) &#123;</span><br><span class="line">                    p[s][l] += p[s-<span class="number">1</span>][l+<span class="number">1</span>];</span><br><span class="line">                    p[s][l] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[steps][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<pre><code>动态规划解法三要素：
1、最优子结构
指针可以向左、向右、停在原地，所有最后一步可以前面的基础上往这三个方向前进，即子结构为：
p[s-1][l], p[s-1][l-1] , p[s-1][l+1]   PS: 原地、向右、向左
2、状态转移方程
p[s][l] = p[s-1][l] + p[s-1][l-1] + p[s-1][l+1]
3、边界条件
p[0][0] = 1;
p[s][l] = 0 if s &lt; l  

问题求解：
p[s][0]
arrLen


注意点：
1、 中间结果数组，注意边界条件p[s][l] = 0 if s &lt; l  ，所以只需要定义int[steps+1][steps+1] 而不需要是int[steps+1][arrLen]，不然会超出内存限制；
2、 结果是返回模 10^9 + 7 后的结果，p[s][l] = p[s-1][l] + p[s-1][l-1] + p[s-1][l+1]  状态方程是两两相加就要求mod，而不是三个求和之后再求mod，之前结果总有用例不过
就是因为三个求和之后再求的mod。</code></pre><h2 id="1312-让字符串成为回文串的最少插入次数"><a href="#1312-让字符串成为回文串的最少插入次数" class="headerlink" title="1312. 让字符串成为回文串的最少插入次数"></a><a href="https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/" target="_blank" rel="noopener">1312. 让字符串成为回文串的最少插入次数</a></h2><p>难度困难34收藏分享切换为英文关注反馈</p>
<p>给你一个字符串 <code>s</code> ，每一次操作你都可以在字符串的任意位置插入任意字符。</p>
<p>请你返回让 <code>s</code> 成为回文串的 <strong>最少操作次数</strong> 。</p>
<p>「回文串」是正读和反读都相同的字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;zzazz&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：字符串 &quot;zzazz&quot; 已经是回文串了，所以不需要做任何插入操作。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;mbadm&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：字符串可变为 &quot;mbdadbm&quot; 或者 &quot;mdbabdm&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcode&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：插入 5 个字符后字符串变为 &quot;leetcodocteel&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;g&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;no&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 中所有字符都是小写字母。</li>
</ul>
<p>我们用 dp[i][j] 表示对于字符串 s 的子串 s[i:j]（这里的下标从 0 开始，并且 s[i:j] 包含 s 中的第 i 和第 j 个字符），最少添加的字符数量，使得 s[i:j] 变为回文串。</p>
<p>我们从外向内考虑 s[i:j]：</p>
<p>如果 s[i] == s[j]，那么最外层已经形成了回文，我们只需要继续考虑 s[i+1:j-1]；</p>
<p>如果 s[i] != s[j]，那么我们要么在 s[i:j] 的末尾添加字符 s[i]，要么在 s[i:j] 的开头添加字符 s[j]，才能使得最外层形成回文。如果我们选择前者，那么需要继续考虑 s[i+1:j]；如果我们选择后者，那么需要继续考虑 s[i:j-1]。</p>
<p>因此我们可以得到如下的状态转移方程：</p>
<p>dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1)                     if s[i] != s[j]<br>dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1, dp[i + 1][j - 1])   if s[i] == s[j]<br>边界条件为：</p>
<p>dp[i][j] = 0   if i &gt;= j<br>注意该动态规划为区间动态规划，需要注意 dp[i][j] 的计算顺序。一种可行的方法是，我们递增地枚举子串 s[i:j] 的长度 span = j - i + 1，再枚举起始位置 i，通过 j = i + span - 1 得到 j 的值并计算 dp[i][j]。这样的计算顺序可以保证在计算 dp[i][j] 时，状态转移方程中的状态 dp[i + 1][j]，dp[i][j - 1] 和 dp[i + 1][j - 1] 均已计算过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> span = <span class="number">2</span>; span &lt;= n; ++span) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - span; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + span - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></h2><p>难度简单118收藏分享切换为英文关注反馈</p>
<p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为<strong>斐波那契数列</strong>。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>

<p>给定 <code>N</code>，计算 <code>F(N)</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2.</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3.</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>0 ≤ <code>N</code> ≤ 30</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private Integer[] cache &#x3D; new Integer[31];</span><br><span class="line"></span><br><span class="line">    public int fib(int N) &#123;</span><br><span class="line">        if (N &lt;&#x3D; 1) &#123;</span><br><span class="line">            return N;</span><br><span class="line">        &#125;</span><br><span class="line">        cache[0] &#x3D; 0;</span><br><span class="line">        cache[1] &#x3D; 1;</span><br><span class="line">        return memoize(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int memoize(int N) &#123;</span><br><span class="line">      if (cache[N] !&#x3D; null) &#123;</span><br><span class="line">          return cache[N];</span><br><span class="line">      &#125;</span><br><span class="line">      cache[N] &#x3D; memoize(N-1) + memoize(N-2);</span><br><span class="line">      return memoize(N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Approach-1-Recursion"><a href="#Approach-1-Recursion" class="headerlink" title="Approach 1: Recursion"></a>Approach 1: Recursion</h4><p><strong>Intuition</strong></p>
<p>Use recursion to compute the Fibonacci number of a given integer.</p>
<p><img src="https://leetcode.com/problems/fibonacci-number/Figures/509/fibonacciRecursion5.png" alt="fib(5) Recursion diagram"></p>
<p><em>Figure 1. An example tree representing what <code>fib(5)</code> would look like</em></p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Check if the provided input value, N, is less than or equal to 1. If true, return N.</li>
<li>Otherwise, the function <code>fib(int N)</code> calls itself, with the result of the 2 previous numbers being added to each other, passed in as the argument. This is derived directly from the <code>recurrence relation</code>: Fn=Fn−1+Fn−2<em>F**n</em>=<em>F*</em>n<em>−1+</em>F*<em>n</em>−2</li>
<li>Do this until all numbers have been computed, then return the resulting answer.</li>
</ul>
<iframe src="https://leetcode.com/playground/uoCAvhCh/shared" frameborder="0" width="100%" height="191" name="uoCAvhCh" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(2N)<em>O</em>(2<em>N</em>). This is the slowest way to solve the <code>Fibonacci Sequence</code> because it takes exponential time. The amount of operations needed, for each level of recursion, grows exponentially as the depth approaches <code>N</code>.</li>
<li>Space complexity : O(N)<em>O</em>(<em>N</em>). We need space proportionate to <code>N</code> to account for the max size of the stack, in memory. This stack keeps track of the function calls to <code>fib(N)</code>. This has the potential to be bad in cases that there isn’t enough physical memory to handle the increasingly growing stack, leading to a <code>StackOverflowError</code>. The <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/StackOverflowError.html" target="_blank" rel="noopener">Java docs</a> have a good explanation of this, describing it as an error that occurs because an application recurses too deeply.</li>
</ul>
<hr>
<h4 id="Approach-2-Bottom-Up-Approach-using-Memoization"><a href="#Approach-2-Bottom-Up-Approach-using-Memoization" class="headerlink" title="Approach 2: Bottom-Up Approach using Memoization"></a>Approach 2: Bottom-Up Approach using Memoization</h4><p><strong>Intuition</strong></p>
<p>Improve upon the recursive option by using iteration, still solving for all of the sub-problems and returning the answer for N, using already computed Fibonacci values. In using a bottom-up approach, we can iteratively compute and store the values, only returning once we reach the result.</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>If <code>N</code> is less than or equal to 1, return <code>N</code></li>
<li>Otherwise, iterate through <code>N</code>, storing each computed answer in an array along the way.</li>
<li>Use this array as a reference to the 2 previous numbers to calculate the current Fibonacci number.</li>
<li>Once we’ve reached the last number, return it’s Fibonacci number.</li>
</ul>
<iframe src="https://leetcode.com/playground/uEUpwCPg/shared" frameborder="0" width="100%" height="361" name="uEUpwCPg" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(N)<em>O</em>(<em>N</em>). Each number, starting at 2 up to and including <code>N</code>, is visited, computed and then stored for O(1)<em>O</em>(1)access later on.</li>
<li>Space complexity : O(N)<em>O</em>(<em>N</em>). The size of the data structure is proportionate to <code>N</code>.</li>
</ul>
<hr>
<h4 id="Approach-3-Top-Down-Approach-using-Memoization"><a href="#Approach-3-Top-Down-Approach-using-Memoization" class="headerlink" title="Approach 3: Top-Down Approach using Memoization"></a>Approach 3: Top-Down Approach using Memoization</h4><p><strong>Intuition</strong></p>
<p>Solve for all of the sub-problems, use memoization to store the pre-computed answers, then return the answer for N. We will leverage recursion, but in a smarter way by not repeating the work to calculate existing values.</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Check if <code>N &lt;= 1</code>. If it is, return <code>N</code>.</li>
<li>Call and return <code>memoize(N)</code></li>
<li>If <code>N</code> exists in the map, return the cached value for <code>N</code></li>
<li>Otherwise set the value of <code>N</code>, in our mapping, to the value of <code>memoize(N-1) + memoize(N-2)</code></li>
</ul>
<iframe src="https://leetcode.com/playground/T6ZdXXX4/shared" frameborder="0" width="100%" height="395" name="T6ZdXXX4" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(N)<em>O</em>(<em>N</em>). Each number, starting at 2 up to and including <code>N</code>, is visited, computed and then stored for O(1)<em>O</em>(1)access later on.</li>
<li>Space complexity : O(N)<em>O</em>(<em>N</em>). The size of the stack in memory is proportionate to <code>N</code>.</li>
</ul>
<hr>
<h4 id="Approach-4-Iterative-Top-Down-Approach"><a href="#Approach-4-Iterative-Top-Down-Approach" class="headerlink" title="Approach 4: Iterative Top-Down Approach"></a>Approach 4: Iterative Top-Down Approach</h4><p><strong>Intuition</strong></p>
<p>Let’s get rid of the need to use all of that space and instead use the minimum amount of space required. We can achieve O(1)<em>O</em>(1)space complexity by only storing the value of the two previous numbers and updating them as we iterate to <code>N</code>.</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Check if <code>N &lt;= 1</code>, if it is then we should return <code>N</code>.</li>
<li>Check if <code>N == 2</code>, if it is then we should return <code>1</code> since <code>N</code> is 2 and <code>fib(2-1) + fib(2-2)</code> equals <code>1 + 0 = 1</code>.</li>
<li>To use an iterative approach, we need at least 3 variables to store each state <code>fib(N)</code>, <code>fib(N-1)</code> and <code>fib(N-2)</code>.</li>
<li>Preset the initial values:<ul>
<li>Initialize <code>current</code> with 0.</li>
<li>Initialize <code>prev1</code> with 1, since this will represent <code>fib(N-1)</code> when computing the current value.</li>
<li>Initialize <code>prev2</code> with 1, since this will represent <code>fib(N-2)</code> when computing the current value.</li>
</ul>
</li>
<li>Iterate, incrementally by 1, all the way up to and including <code>N</code>. Starting at 3, since <code>0</code>, <code>1</code> and <code>2</code> are pre-computed.</li>
<li>Set the <code>current</code> value to <code>fib(N-1) + fib(N-2)</code> because that is the value we are currently computing.</li>
<li>Set the <code>prev2</code> value to <code>fib(N-1)</code>.</li>
<li>Set the <code>prev1</code> value to <code>current_value</code>.</li>
<li>When we reach <code>N+1</code>, we will exit the loop and return the previously set <code>current</code> value.</li>
</ul>
<iframe src="https://leetcode.com/playground/pM6EDZh2/shared" frameborder="0" width="100%" height="412" name="pM6EDZh2" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(N)<em>O</em>(<em>N</em>). Each value from <code>2 to N</code> will be visited at least once. The time it takes to do this is directly proportionate to <code>N</code> where <code>N</code> is the <code>Fibonacci Number</code> we are looking to compute.</li>
<li>Space complexity : O(1)<em>O</em>(1). This requires 1 unit of Space for the integer <code>N</code> and 3 units of Space to store the computed values (<code>curr</code>, <code>prev1</code> and <code>prev2</code>) for every loop iteration. The amount of Space doesn’t change so this is constant Space complexity.</li>
</ul>
<hr>
<h4 id="Approach-5-Matrix-Exponentiation"><a href="#Approach-5-Matrix-Exponentiation" class="headerlink" title="Approach 5: Matrix Exponentiation"></a>Approach 5: Matrix Exponentiation</h4><p><strong>Intuition</strong></p>
<p>Use Matrix Exponentiation to get the Fibonacci number from the element at (0, 0) in the resultant matrix.</p>
<p>In order to do this we can rely on the matrix equation for the Fibonacci sequence, to find the <code>Nth</code> Fibonacci number: (1  11  0)n=( F(n+1)     F(n) F(n)     F(n−1))(1110)<em>n</em>=(<em>F</em>(<em>n</em>+1)<em>F</em>(<em>n</em>)<em>F</em>(<em>n</em>)<em>F</em>(<em>n</em>−1))</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Check if <code>N</code> is less than or equal to 1. If it is, return <code>N</code>.</li>
<li>Use a recursive function, <code>matrixPower</code>, to calculate the power of a given matrix <code>A</code>. The power will be <code>N-1</code>, where <code>N</code> is the <code>Nth Fibonacci number</code>.</li>
<li>The <code>matrixPower</code> function will be performed for <code>N/2</code> of the Fibonacci numbers.</li>
<li>Within <code>matrixPower</code>, call the <code>multiply</code> function to multiply 2 matrices.</li>
<li>Once we finish doing the calculations, return <code>A[0][0]</code> to get the <code>Nth</code> Fibonacci number.</li>
</ul>
<iframe src="https://leetcode.com/playground/y9EwghPh/shared" frameborder="0" width="100%" height="500" name="y9EwghPh" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(log⁡N)<em>O</em>(log<em>N</em>). By halving the <code>N</code> value in every <code>matrixPower</code>‘s call to itself, we are halving the work needed to be done.</li>
<li>Space complexity : O(log⁡N)<em>O</em>(log<em>N</em>). The size of the stack in memory is proportionate to the function calls to <code>matrixPower</code> plus the memory used to account for the matrices which takes up constant space.</li>
</ul>
<hr>
<h4 id="Approach-6-Math"><a href="#Approach-6-Math" class="headerlink" title="Approach 6: Math"></a>Approach 6: Math</h4><p><strong>Intuition</strong> Using the <code>golden ratio</code>, a.k.a <code>Binet&#39;s forumula</code>: φ=1+52≈1.6180339887….<em>φ</em>=21+5≈1.6180339887….</p>
<p>Here’s a <a href="http://demonstrations.wolfram.com/GeneralizedFibonacciSequenceAndTheGoldenRatio/" target="_blank" rel="noopener">link</a> to find out more about how the Fibonacci sequence and the golden ratio work.</p>
<p>We can derive the most efficient solution to this problem using only constant time and constant space!</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Use the <code>golden ratio</code> formula to calculate the <code>Nth</code> Fibonacci number.</li>
</ul>
<iframe src="https://leetcode.com/playground/vgmYRSh2/shared" frameborder="0" width="100%" height="157" name="vgmYRSh2" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(1)<em>O</em>(1). Constant time complexity since we are using no loops or recursion and the time is based on the result of performing the calculation using <code>Binet&#39;s formula</code>.</li>
<li>Space complexity : O(1)<em>O</em>(1). The space used is the space needed to create the variable to store the <code>golden ratio</code> formula.</li>
</ul>
<h4 id="面试题-17-16-按摩师"><a href="#面试题-17-16-按摩师" class="headerlink" title="面试题 17.16. 按摩师"></a><a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">面试题 17.16. 按摩师</a></h4><p>难度简单98收藏分享切换为英文关注反馈</p>
<p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p><strong>注意：</strong>本题相对原题稍作改动</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [1,2,3,1]</span><br><span class="line">输出： 4</span><br><span class="line">解释： 选择 1 号预约和 3 号预约，总时长 &#x3D; 1 + 3 &#x3D; 4。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [2,7,9,3,1]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 &#x3D; 2 + 9 + 1 &#x3D; 12。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [2,1,4,5,3,1,1,3]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 &#x3D; 2 + 4 + 3 + 3 &#x3D; 12。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> premax=<span class="number">0</span>;<span class="comment">//记录上一个max</span></span><br><span class="line">        <span class="keyword">int</span> curmax=<span class="number">0</span>;<span class="comment">//当前max</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=curmax;</span><br><span class="line">            curmax=Math.max(premax+i, curmax);<span class="comment">//取当时max还是之前max加上目前值</span></span><br><span class="line">            premax=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curmax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>《程序员面试金典（第 6 版）》独家授权<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/11/logo20190828-02.png" alt="img"></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/30/book_2.jpg" alt="img"></p>
<p>本书是原谷歌资深面试官的经验之作，帮助了许多想要加入脸书、苹果、谷歌等 IT 名企的求职者拿到 Dream offer。本专题的 100+ 编程面试题是在原书基础上精心挑选出来的，帮助你轻松应战 IT 名企技术面试。</p>
]]></content>
  </entry>
  <entry>
    <title>计算机考虑院校</title>
    <url>/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E8%99%91%E9%99%A2%E6%A0%A1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>



<p><strong>Carnegie Mellon University（CS专业排名第1名）</strong></p>
<p>CMU拥有全世界最大的计算机学院，按研究方向分为很多系。申请者需具备较强的数学、编程和逻辑推理能力。</p>
<p>如果特别想去这所学校，建议同时申请MISM Program或者MS in INI Program，他们不在计算机学院，难度相对小一些。</p>
<p><strong>Columbia University（CS专业排名第15名）</strong></p>
<p>哥伦比亚大学的计算机系，设置在工程与应用科学学院（School of Engineering and Applied Sciences，即SEAS），分为MS in Computer Science(MS CS)，MS in Computer Engineering (MS CE)两个项目。</p>
<p>如果你的三围在3.6+/4.0、105+和325+，也有较强的研究背景，你可尝试申请MS CS，如果相对弱一点，可以考虑申请MS CE。</p>
<p><strong>University of Pennsylvania（CS专业排名第19名）</strong></p>
<p>宾大的计算机系叫做Computer and Information Science(CIS)，提供的以下硕士项目： MSE in Computer and Information Science，MSE in Computer Graphics and Game Technology，MSE in Robotics 和Master of Computer and Information Technology。宾大计算机科学在其工学院内一枝独秀，竞争非常激烈。</p>
<p>需要注意的是宾大的申请有两轮，第一轮截止日期是当年的11月15日，第二轮截止日期是次年的3月15日，两轮申请的难度都很大。其中MCIT接受各种转专业申请。</p>
<p><strong>Northwestern University（CS专业排名第34名）</strong></p>
<p>西北大学的计算机专业，设置在Electrical Engineering and Computer Science系，这个系开设了三个专业，即EE, CE和CS，其中CS的申请难度最大。</p>
<p>如果你很想去西北大学，建议可以先申请EE或CE，然后再去转专业到CS，转专业相对来说还是比较容易的。西北大学建议尽早申请，也可尝试直接申请博士，审核时会同时考虑硕士录取可能性。</p>
<p><strong>University of California-</strong> <strong>Los Angeles（CS专业排名第13名）</strong></p>
<p>洛杉矶的计算机系，有两种硕士学位：论文型和综合性考试型。</p>
<p>学校对三围有明确的要求，TOEFL总分87+(写作25+，口语24+)，录取学生的平均GPA平均GPA：3.67/4.00，GRE单项平均分：V: 157 (74%); Q: 167 (95%);AW: 3.7 (41%)。</p>
<p>另外，申请人还需要很强的计算机专业知识和研究背景</p>
<p><strong>9. New York University（CS专业排名第30名）</strong></p>
<p>纽约大学的研究生院，开设了计算机专业，其硕士项目有：MSCS 和 Masters in Information Systems ，大学地理位置比较好，申请人不少。另外，新加入的工学院的计算机项目比较好申请。</p>
<p><strong>Washington University IN St. Louis（CS专业排名第40名）</strong></p>
<p>华大的计算机专业设置在Computer Science &amp;Engineering系，这个系提供三种硕士项目，即MS CS, MS CE和MEng CSE，其中CS的申请难度最大。</p>
<p>如果你非常想去这个学校，建议你可以先申请CE，然后去那边多选修一些CS的课程，若表现优异的话，就有机会转到CS，或者你可以选择申请MEng项目。对于本科专业是物联网等非正统CS的学生，还可以选择申请Master of Science in Information Systems (MSIS)项目，申请难度会相对小一些。这个项目需要面试，但是比较容易，网上有很多相关的面经。</p>
<p><strong>University of Southern California（CS专业排名第20名）</strong></p>
<p>南加州大学计算机专业，有广泛的硕士项目：MS CS；和具体的分支项目：Computer Security, Game Development, Computer Networks, Software Engineering,High Performance Computing and Simulation, Intelligent Robotics, Multimedia andCreative Technologies, Data Science.。你可以根据自己的研究背景或者喜好来选择。南加大还有专门接受转专业申请的项目，MS CS (Scientist and Engineer)，优秀学生很容易申请到。</p>
<p>美国绝大部分学校都开设了计算机科学专业，此专业基本开设在工学院下。</p>
<p>总的来说，计算机专业前20名的学校可分成三类：</p>
<p>A．4个最为优秀的CS Program：Stanford，MIT，U.C.Berkeley，CMU.</p>
<p>B．6个其他前10名的：UIUC，Cornell，U.Washington，Princeton，U.Wisconsin- Madison和 U.Texas-Austin.</p>
<p>C．其他非常非常优秀的CS：CalTech，U.Maryland-College Park，UCLA，U.Michigan, GIT，Brown，Harvard，Yale，Purdue和 Rice.</p>
<a id="more"></a>]]></content>
  </entry>
</search>
