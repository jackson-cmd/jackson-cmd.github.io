<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="python面向对象类定义数据类型的属性(数据)和方法(行为),也就是说，“类将行为和状态打 包在一起”。 对象是类的具体实体，一般称为“类的实例”。“方法代码是共享的，属性数据不共享”。 定义类的语法格式如下: class 类名: 类体 要点如下:  类名必须符合“标识符”的规则;一般规定，首字母大写，多个单词使用“驼峰原则”。  类体中我们可以定义属性和方法。 . 属性用来描述数据，方法(即函">
<meta property="og:type" content="article">
<meta property="og:title" content="python400集3">
<meta property="og:url" content="http://yoursite.com/2020/04/29/python400%E9%9B%863/index.html">
<meta property="og:site_name" content="Jackson Blog">
<meta property="og:description" content="python面向对象类定义数据类型的属性(数据)和方法(行为),也就是说，“类将行为和状态打 包在一起”。 对象是类的具体实体，一般称为“类的实例”。“方法代码是共享的，属性数据不共享”。 定义类的语法格式如下: class 类名: 类体 要点如下:  类名必须符合“标识符”的规则;一般规定，首字母大写，多个单词使用“驼峰原则”。  类体中我们可以定义属性和方法。 . 属性用来描述数据，方法(即函">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-04-29T20:09:28.000Z">
<meta property="article:modified_time" content="2020-05-02T04:12:23.909Z">
<meta property="article:author" content="Jackson">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/04/29/python400%E9%9B%863/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>python400集3 | Jackson Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jackson Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/python400%E9%9B%863/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          python400集3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 15:09:28" itemprop="dateCreated datePublished" datetime="2020-04-29T15:09:28-05:00">2020-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-01 23:12:23" itemprop="dateModified" datetime="2020-05-01T23:12:23-05:00">2020-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="python面向对象"><a href="#python面向对象" class="headerlink" title="python面向对象"></a>python面向对象</h1><p>类定义数据类型的属性(数据)和方法(行为),也就是说，“类将行为和状态打 包在一起”。</p>
<p>对象是类的具体实体，一般称为“类的实例”。“方法代码是共享的，属性数据不共享”。</p>
<p>定义类的语法格式如下: class 类名:</p>
<p>类体</p>
<p>要点如下:</p>
<ol>
<li><p>类名必须符合“标识符”的规则;一般规定，首字母大写，多个单词使用“驼峰原则”。</p>
<ol start="2">
<li>类体中我们可以定义属性和方法。</li>
<li>. 属性用来描述数据，方法(即函数)用来描述这些数据相关的操作。</li>
</ol>
</li>
</ol>
<h2 id="init构造方法和new方法"><a href="#init构造方法和new方法" class="headerlink" title="init构造方法和new方法"></a><strong><strong>init</strong>构造方法和<strong>new</strong>方法</strong></h2><p>类是抽象的，也称之为“对象的模板”。我们需要通过类这个模板，创建类的实例对象，然 后才能使用类定义的功能。</p>
<p>我们前面说过一个 Python 对象包含三个部分:id(identity 识别码)、type(对象类型)、 value(对象的值)。</p>
<p>现在，我们可以更进一步的说，一个 Python 对象包含如下部分: 1. id(identity 识别码)</p>
<ol start="2">
<li>type(对象类型) 3. value(对象的值)：(1) 属性(attribute) (2) 方法(method)</li>
</ol>
<h4 id="创建对象，我们需要定义构造函数init-方法。构造方法用于执行“实例对象的初始化工-作”，即对象创建后，初始化当前对象的相关属性，无返回值。"><a href="#创建对象，我们需要定义构造函数init-方法。构造方法用于执行“实例对象的初始化工-作”，即对象创建后，初始化当前对象的相关属性，无返回值。" class="headerlink" title="创建对象，我们需要定义构造函数init()方法。构造方法用于执行“实例对象的初始化工 作”，即对象创建后，初始化当前对象的相关属性，无返回值。"></a>创建对象，我们需要定义构造函数<strong>init</strong>()方法。构造方法用于执行“实例对象的初始化工 作”，即对象创建后，初始化当前对象的相关属性，无返回值。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_init_()</span><br></pre></td></tr></table></figure>

<p>的要点如下:<br> \1. 名称固定，必须为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__init__()</span><br></pre></td></tr></table></figure>

<p> \2. 第一个参数固定，必须为:self。 self 指的就是刚刚创建好的实例对象。<br> \3. 构造函数通常用来初始化实例对象的实例属性，如下代码就是初始化实例属性:name 和 score。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,score)</span>:</span></span><br><span class="line">	self.name = name <span class="comment">#实例属性 </span></span><br><span class="line">	self.score = score</span><br></pre></td></tr></table></figure>

<p>\4. 通过“类名(参数列表)”来调用构造函数。调用后，将创建好的对象返回给相应的变量。 比如:s1 = Student(‘张三’, 80)</p>
<p>\5. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__init__()方法:初始化创建好的对象，初始化指的是:“给实例属性赋值”</span><br></pre></td></tr></table></figure>


<p> \6. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__new__()方法: 用于创建对象，但我们一般无需重定义该方法。</span><br></pre></td></tr></table></figure>


<p> \7.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果我们不定义__init__方法，系统会提供一个默认的__init__方法。如果我们定义了带参 的__init__方法，系统不创建默认的__init__方法。</span><br></pre></td></tr></table></figure>

<p>注:<br> \1. Python中的self相当于C++中的self指针，JAVA和C#中的this关键字。Python中， self 必须为构造函数的第一个参数，名字可以任意修改。但一般遵守惯例，都叫做 self。</p>
<h2 id="实例属性和实例方法"><a href="#实例属性和实例方法" class="headerlink" title="实例属性和实例方法"></a>实例属性和实例方法</h2><h3 id="实例属性instance（其实跟java差不多）"><a href="#实例属性instance（其实跟java差不多）" class="headerlink" title="实例属性instance（其实跟java差不多）"></a>实例属性instance（其实跟java差不多）</h3><p>实例属性是从属于实例对象的属性，也称为“实例变量”。他的使用有如下几个要点: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\1. 实例属性一般在__init__()方法中通过如下代码定义:</span><br><span class="line"></span><br><span class="line">self.实例属性名 &#x3D; 初始值</span><br><span class="line"> \2. 在本类的其他实例方法中，也是通过 self 进行访问:</span><br><span class="line"></span><br><span class="line">self.实例属性名</span><br><span class="line"> \3. 创建实例对象后，通过实例对象访问:</span><br><span class="line"></span><br><span class="line">obj01 &#x3D; 类名() #创建对象，调用__init__()初始化属性 </span><br><span class="line">obj01.实例属性名 &#x3D; 值 #可以给已有属性赋值，也可以新加属性</span><br></pre></td></tr></table></figure>



<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a><strong>实例方法</strong></h3><p>实例方法是从属于实例对象的方法。实例方法的定义格式如下: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def 方法名(self [, 形参列表]):</span><br><span class="line">	函数体</span><br><span class="line">方法的调用格式如下:</span><br><span class="line">	对象.方法名([实参列表])</span><br></pre></td></tr></table></figure>



<p>要点:<br> \1. 定义实例方法时，第一个参数必须为 self。和前面一样，self 指当前的实例对象。 2. 调用实例方法时，不需要也不能给 self 传参。self 由解释器自动传参。</p>
<h3 id="·-函数和方法的区别"><a href="#·-函数和方法的区别" class="headerlink" title="· 函数和方法的区别"></a><strong>· 函数和方法的区别</strong></h3><ol>
<li><p>都是用来完成一个功能的语句块，本质一样。</p>
</li>
<li><p>方法调用时，通过对象来调用。方法从属于特定实例对象，普通函数没有这个特点。 </p>
</li>
<li><p>直观上看，方法定义时需要传递 self，函数不需要。</p>
</li>
</ol>
<p><strong>· 实例对象的方法调用本质:</strong></p>
<p><strong>a = Student()</strong></p>
<p><strong>a.say_score()</strong></p>
<p>解释器翻译:</p>
<p><strong>Student.say_score(a)</strong></p>
<p><strong>· 其他操作:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> dir(obj)可以获得对象的所有属性、方法</span><br><span class="line"><span class="number">2.</span>obj.__dict__ 对象的属性字典</span><br><span class="line"><span class="number">3.</span><span class="keyword">pass</span> 空语句</span><br><span class="line"><span class="number">4.</span>isinstance(对象,类型) 判断“对象”是不是“指定类型”</span><br></pre></td></tr></table></figure>

<h2 id="类对象、类属性、类方法、静态方法"><a href="#类对象、类属性、类方法、静态方法" class="headerlink" title="类对象、类属性、类方法、静态方法"></a><strong>类对象、类属性、类方法、静态方法</strong></h2><p><strong>类对象</strong></p>
<p>我们在前面讲的类定义格式中，“class 类名:”。实际上，当解释器执行 class 语句时， 就会创建一个类对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	<span class="keyword">pass</span> <span class="comment">#空语句</span></span><br><span class="line">print(type(Student)) </span><br><span class="line">print(id(Student))</span><br><span class="line">Stu2 = Student </span><br><span class="line">s1 = Stu2() </span><br><span class="line">print(s1)</span><br></pre></td></tr></table></figure>

<p>执行结果如下:<br> &lt;class ‘type’&gt;</p>
<p>51686328<br> &lt;<strong>main</strong>.Student object at 0x0000000002B5FDD8&gt;</p>
<p>我们可以看到实际上生成了一个变量名就是类名“Student”的对象。我们通过赋值给新变 量 Stu2，也能实现相关的调用。说明，确实创建了“类对象”。</p>
<p>【注】pass 为空语句。就是表示什么都不做，只是作为一个占位符存在。当你写代码时， 遇到暂时不知道往方法或者类中加入什么时，可以先用 pass 占位，后期再补上。</p>
<h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a><strong>类属性</strong></h3><p>类属性是从属于“类对象”的属性，也称为“类变量”。由于，类属性从属于类对象，可以 被所有实例对象共享。</p>
<p>类属性的定义方式:<br> class 类名:</p>
<p>类变量名= 初始值 在类中或者类的外面，我们可以通过:“类名.类变量名”来读写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	company = <span class="string">"SXT"</span> <span class="comment">#类属性 </span></span><br><span class="line">	count = <span class="number">0</span> <span class="comment">#类属性</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,score)</span>:</span> </span><br><span class="line">		self.name = name 	</span><br><span class="line">		self.score = score <span class="comment">#实例属性</span></span><br><span class="line">		Student.count = Student.count+<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_score</span><span class="params">(self)</span>:</span> <span class="comment">#实例方法 </span></span><br><span class="line">  print(<span class="string">"我的公司是:"</span>,Student.company) </span><br><span class="line">  print(self.name,<span class="string">'的分数是:'</span>,self.score)</span><br><span class="line">s1 = Student(<span class="string">'张三'</span>,<span class="number">80</span>) <span class="comment">#s1 是实例对象，自动调用__init__()方法 </span></span><br><span class="line">s1.say_score()</span><br><span class="line">print(<span class="string">'一共创建&#123;0&#125;个 Student 对象'</span>.format(Student.count))</span><br><span class="line">```</span><br><span class="line">执行结果:</span><br><span class="line">我的公司是: SXT</span><br><span class="line">张三 的分数是: <span class="number">80</span> </span><br><span class="line">一共创建 <span class="number">1</span> 个 Student 对象</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a><strong>类方法</strong></h3><p>类方法是从属于“类对象”的方法。类方法通过装饰器@classmethod 来定义，格式如下: @classmethod</p>
<p>def 类方法名(cls [，形参列表]) : 函数体</p>
<p>要点如下:<br> \1. @classmethod 必须位于方法上面一行<br> \2. 第一个 cls 必须有;cls 指的就是“类对象”本身;<br> \3. 调用类方法格式:“类名.类方法名(参数列表)”。 参数列表中，不需要也不能给 cls 传 值。<br> \4. 类方法中访问实例属性和实例方法会导致错误<br> \5. 子类继承父类方法时，传入 cls 是子类对象，而非父类对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	company = <span class="string">"SXT"</span> <span class="comment">#类属性 </span></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printCompany</span><span class="params">(cls)</span>:</span> </span><br><span class="line">    print(cls.company)</span><br><span class="line">Student.printCompany()</span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a><strong>静态方法</strong></h3><p>Python 中允许定义与“类对象”无关的方法，称为“静态方法”。</p>
<p>“静态方法”和在模块中定义普通函数没有区别，只不过“静态方法”放到了“类的名字空 间里面”，需要通过“类调用”。</p>
<p>静态方法通过装饰器@staticmethod 来定义，格式如下: @staticmethod</p>
<p>def 静态方法名([形参列表]) : 函数体</p>
<p>要点如下:</p>
<ol>
<li><p>@staticmethod 必须位于方法上面一行</p>
</li>
<li><p>调用静态方法格式:“类名.静态方法名(参数列表)”。 </p>
</li>
<li><p>静态方法中访问实例属性和实例方法会导致错误</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	company = <span class="string">"SXT"</span> <span class="comment"># 类属性</span></span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span> <span class="comment"># 静态方法</span></span><br><span class="line"> 		print(<span class="string">"&#123;0&#125;+&#123;1&#125;=&#123;2&#125;"</span>.format(a,b,(a+b)))</span><br><span class="line"> 		<span class="keyword">return</span> a+b</span><br><span class="line"> Student.add(<span class="number">20</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h2 id="del方法-析构函数-和垃圾回收机制"><a href="#del方法-析构函数-和垃圾回收机制" class="headerlink" title="del方法(析构函数)和垃圾回收机制"></a><strong><strong>del</strong>方法(析构函数)和垃圾回收机制</strong></h2><p><strong>del</strong>方法称为“析构方法”，用于实现对象被销毁时所需的操作。比如:释放对象 占用的资源，例如:打开的文件资源、网络连接等。</p>
<p>Python 实现自动的垃圾回收，当对象没有被引用时(引用计数为 0)，由垃圾回收器 调用<strong>del</strong>方法。</p>
<p>我们也可以通过 del 语句删除对象，从而保证调用<strong>del</strong>方法。 系统会自动提供<strong>del</strong>方法，一般不需要自定义析构方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#析构函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span> </span><br><span class="line">  print(<span class="string">"销毁对象:&#123;0&#125;"</span>.format(self))</span><br><span class="line">p1 = Person() </span><br><span class="line">p2 = Person()</span><br><span class="line"><span class="keyword">del</span> p2</span><br><span class="line">print(<span class="string">"end"</span>)</span><br><span class="line">```</span><br><span class="line">运算结果:</span><br><span class="line">销毁对象:&lt;__main__.Person object at <span class="number">0x02175610</span>&gt; 程序结束</span><br><span class="line">销毁对象:&lt;__main__.Person object at <span class="number">0x021755D0</span>&gt;</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="call方法和可调用对象"><a href="#call方法和可调用对象" class="headerlink" title="call方法和可调用对象"></a><strong><strong>call</strong>方法和可调用对象</strong></h2><p>定义了<strong>call</strong>方法的对象，称为“可调用对象”，即该对象可以像函数一样被调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalaryAccount</span>:</span> <span class="string">'''工资计算类'''</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, salary)</span>:</span> </span><br><span class="line">    yearSalary = salary*<span class="number">12</span> </span><br><span class="line">    daySalary = salary//<span class="number">30</span></span><br><span class="line">		hourSalary = daySalary//<span class="number">8</span> </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">dict(monthSalary=salary,yearSalary=yearSalary,daySalary=daySalary ,hourSalary=hourSalary)</span><br><span class="line">s = SalaryAccount()</span><br><span class="line">print(s(<span class="number">5000</span>)) <span class="comment">#可以像调用函数一样调用对象的__call__方法</span></span><br><span class="line"><span class="comment">#&#123;'monthSalary': 5000, 'yearSalary': 60000, 'daySalary': 166, 'hourSalary': 20&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="方法没有重载"><a href="#方法没有重载" class="headerlink" title="方法没有重载"></a><strong>方法没有重载</strong></h2><p>在其他语言中，可以定义多个重名的方法，只要保证方法签名唯一即可。方法签名包含 3 个部分:方法名、参数数量、参数类型。</p>
<p>Python 中，方法的的参数没有声明类型(调用时确定参数的类型)，参数的数量也可以由 可变参数控制。因此，Python 中是没有方法的重载的。定义一个方法即可有多种调用方式， 相当于实现了其他语言中的方法的重载。</p>
<h3 id="如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。-建议-不要使用重名的方法-Python-中方法没有重载。"><a href="#如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。-建议-不要使用重名的方法-Python-中方法没有重载。" class="headerlink" title="如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。 建议:不要使用重名的方法!Python 中方法没有重载。"></a>如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。 建议:不要使用重名的方法!Python 中方法没有重载。</h3><h2 id="方法的动态性"><a href="#方法的动态性" class="headerlink" title="方法的动态性"></a><strong>方法的动态性</strong></h2><p>Python 是动态语言，我们可以动态的为类添加新的方法，或者动态的修改类的已有的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"努力上班!"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_game</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;0&#125;玩游戏"</span>.format(self))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work2</span><span class="params">(s)</span>:</span></span><br><span class="line">    print(<span class="string">"好好工作，努力上班!"</span>)</span><br><span class="line">Person.play = play_game</span><br><span class="line">Person.work = work2 </span><br><span class="line">p = Person()</span><br><span class="line">p.play()</span><br><span class="line">p.work()</span><br><span class="line">```</span><br><span class="line">&lt;__main__.Person object at <span class="number">0x7fb0405fdee0</span>&gt;玩游戏</span><br><span class="line">好好工作，努力上班!</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>我们可以看到，Person 动态的新增了 play_game 方法，以及用 work2 替换了 work 方法。</p>
<h2 id="私有属性和私有方法-实现封装"><a href="#私有属性和私有方法-实现封装" class="headerlink" title="私有属性和私有方法(实现封装)"></a><strong>私有属性和私有方法(实现封装)</strong></h2><p>Python 对于类的成员没有严格的访问控制限制，这与其他面向对象语言有区别。关于私有 属性和私有方法，有如下要点:</p>
<ol>
<li><p>通常我们约定，两个下划线开头的属性是私有的(private)。其他为公共的(public)。 </p>
</li>
<li><p>类内部可以访问私有属性(方法)</p>
</li>
<li><p>类外部不能直接访问私有属性(方法)</p>
</li>
<li><p>类外部可以通过“_类名__私有属性(方法)名”访问私有属性(方法)</p>
</li>
</ol>
<p>【注】方法本质上也是属性!只不过是可以通过()执行而已。所以，此处讲的私有属性和公有属性，也同时讲解了私有方法和公有方法的用法。如下测试中，同时也包含了私有方法和 公有方法的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试私有属性、私有方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">	__company = <span class="string">"google"</span> <span class="comment">#私有类属性. 通过 dir 可以查到_Employee__company</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.__age = age <span class="comment">#私有实例属性</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">say_company</span><span class="params">(self)</span>:</span> </span><br><span class="line">    print(<span class="string">"我的公司是:"</span>,Employee.__company) <span class="comment">#类内部可以直接访问私有属性</span></span><br><span class="line">		print(self.name,<span class="string">"的年龄是:"</span>,self.__age) </span><br><span class="line">    self.__work()</span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">__work</span><span class="params">(self)</span>:</span> <span class="comment">#私有实例方法 通过 dir 可以查到 _Employee__work</span></span><br><span class="line">		print(<span class="string">"工作!好好工作，好好赚钱，娶个媳妇!"</span>)</span><br><span class="line">p1 = Employee(<span class="string">"高淇"</span>,<span class="number">32</span>)</span><br><span class="line">print(p1.name)</span><br><span class="line">print(dir(p1)) <span class="comment"># </span></span><br><span class="line">p1.say_company()</span><br><span class="line">print(p1._Employee__age) <span class="comment">#通过这种方式可以直接访问到私有属性 。通过 dir 可以查到属性:_Employee__age </span></span><br><span class="line"><span class="comment">#print(p1.__age) #直接访问私有属性，报错</span></span><br><span class="line"> <span class="comment">#p1.__sleep() #直接访问私有方法，报错</span></span><br><span class="line">  ```</span><br><span class="line">  执行结果:</span><br><span class="line">高淇</span><br><span class="line">[<span class="string">'_Person__age'</span>, <span class="string">'_Person__leg_num'</span>, <span class="string">'_Person__sleep'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'name'</span>, <span class="string">'say_age'</span>]</span><br><span class="line">腿的数目: <span class="number">2</span></span><br><span class="line">高淇 的年龄是: <span class="number">18</span></span><br><span class="line">睡觉</span><br><span class="line"><span class="number">18</span></span><br><span class="line">从打印的 Person 对象所有属性我们可以看出。私有属性“__age”在实际存储时是按照 “_Person__age”这个属性来存储的。这也就是为什么我们不能直接使用“__age”而可以 使用“_Person__age”的根本原因。</span><br><span class="line">  ```</span><br></pre></td></tr></table></figure>

<h2 id="property-装饰器"><a href="#property-装饰器" class="headerlink" title="@property 装饰器"></a><strong>@property 装饰器</strong></h2><p>@property 可以将一个方法的调用方式变成“属性调用”</p>
<p>@property 主要用于帮助我们处理属性的读操作、写操作。对于某一个属性，我们可以直 接通过:</p>
<p>emp1.salary = 30000 如上的操作读操作、写操作。但是，这种做法不安全。比如，我需要限制薪水必须为 1-10000 的数字。这时候，我们就需要通过 getter、setter 方法来处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,salary)</span>:</span> </span><br><span class="line">    self.name = name</span><br><span class="line"> 		self.__salary = salary</span><br><span class="line"><span class="meta">	@property #相当于 salary 属性的 getter 方法</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">salary</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"月薪为&#123;0&#125;,年薪为 &#123;1&#125;"</span>.format(self.__salary,(<span class="number">12</span>*self.__salary)))</span><br><span class="line"> 		<span class="keyword">return</span> self.__salary;</span><br><span class="line"><span class="meta"> 	@salary.setter</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">salary</span><span class="params">(self,salary)</span>:</span> <span class="comment">#相当于 salary 属性的 setter 方法</span></span><br><span class="line"> 		<span class="keyword">if</span>(<span class="number">0</span>&lt;salary&lt;<span class="number">1000000</span>): </span><br><span class="line">      self.__salary = salary</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line"> 			print(<span class="string">"薪水录入错误!只能在 0-1000000 之间"</span>)</span><br><span class="line">emp1 = Employee(<span class="string">"高淇"</span>,<span class="number">100</span>) </span><br><span class="line">print(emp1.salary)</span><br><span class="line">emp1.salary = <span class="number">-200</span></span><br></pre></td></tr></table></figure>

<p>运行结果:<br> 月薪为 100,年薪为 1200</p>
<p>100<br> 月薪为 100,年薪为 1200<br> 100<br> 薪水录入错误!只能在 0-1000000 之间</p>
<h2 id="属性和方法命名总结"><a href="#属性和方法命名总结" class="headerlink" title="属性和方法命名总结"></a><strong>属性和方法命名总结</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· _xxx:保护成员，不能用“from module import * ”导入，只有类对象和子类对象能访 问这些成员。(类似java 的proetected)</span><br><span class="line"> · __xxx__:系统定义的特殊成员</span><br><span class="line"> · __xxx: 类中的私有成员，只有类对象自己能访问，子类对象也不能访问。(但，在类外 部可以通过“对象名. _类名__xxx”这种特殊方式访问。Python 不存在严格意义的私有成员)（类似java的private）</span><br></pre></td></tr></table></figure>

<p>注:再次强调，方法和属性都遵循上面的规则。</p>
<p>私有属性是无法被继承的。由此可知，在 Python 中私有属性为假私有属性。那为什么不从语法上保证 private 字段的私密性呢？用最简单的一句话来说：We are all consenting adults here。正如Python 程序员的观点：开放要比封闭好。</p>
<p>综上所述：</p>
<p>Python 编译器无法严格保证 private 字段的私密性。</p>
<p>只有当子类不受自己控制的时候，才可以考虑使用 private 属性来避免名称冲突。所以python还是不如java啊。</p>
<h2 id="类编码风格"><a href="#类编码风格" class="headerlink" title="类编码风格"></a><strong>类编码风格</strong></h2><p>\1. 类名首字母大写，多个单词之间采用驼峰原则。<br> \2. 实例名、模块名采用小写，多个单词之间采用下划线隔开。<br> \3. 每个类，应紧跟“文档字符串”，说明这个类的作用。<br> \4. 可以用空行组织代码，但不能滥用。在类中，使用一个空行隔开方法;模块中，使用两 个空行隔开多个类。</p>
<h1 id="面向对象进阶"><a href="#面向对象进阶" class="headerlink" title="面向对象进阶"></a>面向对象进阶</h1><p><strong>面向对象三大特征介绍</strong></p>
<p>Python 是面向对象的语言，也支持面向对象编程的三大特性:继承、封装(隐藏)、多态。</p>
<p><strong>·封装(隐藏)</strong></p>
<p>隐藏对象的属性和实现细节，只对外提供必要的方法。相当于将“细节封装起来”，只 对外暴露“相关调用方法”。</p>
<p>通过前面学习的“私有属性、私有方法”的方式，实现“封装”。Python 追求简洁的 语法，没有严格的语法级别的“访问控制符”，更多的是依靠程序员自觉实现。</p>
<p><strong>·继承</strong></p>
<p>继承可以让子类具有父类的特性，提高了代码的重用性。</p>
<p>从设计上是一种增量进化，原有父类设计不变的情况下，可以增加新的功能，或者改进 已有的算法。</p>
<p><strong>·多态</strong></p>
<p>多态是指同一个方法调用由于对象不同会产生不同的行为。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h2><p>继承是面向对象程序设计的重要特征，也是实现“代码复用”的重要手段。</p>
<p>如果一个新类继承自一个设计好的类，就直接具备了已有类的特征，就大大降低了工作 难度。已有的类，我们称为“父类或者基类”，新的类，我们称为“子类或者派生类”。</p>
<h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a><strong>语法格式</strong></h3><p>Python 支持多重继承，一个子类可以继承多个父类。继承的语法格式如下: </p>
<p>class 子类类名(父类 1[，父类 2，…]):</p>
<p>​    类体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果在类定义中没有指定父类，则默认父类是 object 类。也就是说，object 是所有类的父 类，里面定义了一些所有类共有的默认实现，比如:__new__()。</span><br><span class="line"></span><br><span class="line">定义子类时，必须在其构造函数中调用父类的构造函数。调用格式如下: 父类名.__init__(self, 参数列表)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,score)</span>:</span></span><br><span class="line"> 		self.score = score</span><br><span class="line">		Person.__init__(self,name,age) <span class="comment">#构造函数中包含调用父类构造函数。根据需要，不是必须。 子类并不会自动调用父类的__init__()，我们必须显式的调用它</span></span><br></pre></td></tr></table></figure>

<h3 id="类成员的继承和重写"><a href="#类成员的继承和重写" class="headerlink" title="类成员的继承和重写"></a><strong>类成员的继承和重写</strong></h3><p>\1. 成员继承:子类继承了父类除构造方法之外的所有成员。<br> \2. 方法重写:子类可以重新定义父类中的方法，这样就会覆盖父类的方法，也称为“重写”</p>
<h3 id="查看类的继承层次结构"><a href="#查看类的继承层次结构" class="headerlink" title="查看类的继承层次结构"></a><strong>查看类的继承层次结构</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过类的方法 mro()或者类的属性__mro__可以输出这个类的继承层次结构。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">pass</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span><span class="keyword">pass</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B)</span>:</span><span class="keyword">pass</span></span><br><span class="line">print(C.mro())</span><br><span class="line"><span class="comment">#[&lt;class '__main__.C'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]</span></span><br><span class="line"><span class="comment">#c继承B，继承A，继承object</span></span><br></pre></td></tr></table></figure>

<h3 id="object-根类"><a href="#object-根类" class="headerlink" title="object 根类"></a><strong>object 根类</strong></h3><p>object 类是所有类的父类，因此所有的类都有 object 类的属性和方法。我们显然有必要深 入研究一下 object 类的结构。对于我们继续深入学习 Python 很有好处。</p>
<p><strong>dir()查看对象属性</strong></p>
<p>为了深入学习对象，我们先学习内置函数 dir()，他可以让我们方便的看到指定对象所有的 属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span> </span><br><span class="line">    self.name = name</span><br><span class="line"> 		self.age = age</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say_age</span><span class="params">(self)</span>:</span> </span><br><span class="line">    print(self.name,<span class="string">"的年龄是:"</span>,self.age)</span><br><span class="line">obj = object() </span><br><span class="line">print(dir(obj))</span><br><span class="line">s2 = Person(<span class="string">"高淇"</span>,<span class="number">18</span>)</span><br><span class="line">print(dir(s2))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;]</span><br><span class="line">[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;age&#39;, &#39;name&#39;, &#39;say_age&#39;]</span><br></pre></td></tr></table></figure>

<p>从上面我们可以发现这样几个要点: </p>
<ol>
<li>Person 对象增加了六个属性:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__dict__ __module__ __weakref__ age name say_age</span><br></pre></td></tr></table></figure>

<p>\2. object 的所有属性，Person 类作为 object 的子类，显然包含了所有的属性。<br> \3. 我们打印 age、name、say_age，发现 say_age 虽然是方法，实际上也是属性。只不过， 这个属性的类型是“method”而已。</p>
<p>age &lt;class ‘int’&gt;<br> name &lt;class ‘str’&gt;</p>
<p>say_age &lt;class ‘method’&gt;</p>
<h2 id="重写str-方法"><a href="#重写str-方法" class="headerlink" title="重写str()方法"></a><strong>重写<strong>str</strong>()方法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object 有一个__str__()方法，用于返回一个对于“对象的描述”，对应于内置函数 str() 经常用于 print()方法，帮助我们查看对象的信息。__str__()可以重写。</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"> <span class="string">'''将对象转化成一个字符串，一般用于 print 方法'''</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"名字是:&#123;0&#125;,年龄是&#123;1&#125;"</span>.format(self.name,self.__age)</span><br></pre></td></tr></table></figure>

<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a><strong>多重继承</strong></h2><p>Python 支持多重继承，一个子类可以有多个“直接父类”。这样，就具备了“多个父 类”的特点。但是由于，这样会被“类的整体层次”搞的异常复杂，尽量避免使用。<strong>class</strong> C(B,A):</p>
<h2 id="MRO"><a href="#MRO" class="headerlink" title="MRO()"></a><strong>MRO()</strong></h2><p>Python 支持多继承，如果父类中有相同名字的方法，在子类没有指定父类名时，解释器将 “从左向右”按顺序搜索。<br> MRO(Method Resolution Order):方法解析顺序。 我们可以通过 mro()方法获得 “类的层次结构”，方法解析顺序也是按照这个“类的层次结构”寻找的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">aa</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"aa"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span> </span><br><span class="line">    print(<span class="string">"say AAA!"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">bb</span><span class="params">(self)</span>:</span></span><br><span class="line">			print(<span class="string">"bb"</span>)</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span> </span><br><span class="line">      print(<span class="string">"say BBB!"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B,A)</span>:</span> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cc</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"cc"</span>)</span><br><span class="line">c = C()</span><br><span class="line">print(C.mro()) <span class="comment">#打印类的层次结构</span></span><br><span class="line">c.say() <span class="comment">#解释器寻找方法是“从左到右”的方式寻找，此时会执行 B 类中的 say()</span></span><br></pre></td></tr></table></figure>

<p>[&lt;class ‘<strong>main</strong>.C’&gt;, &lt;class ‘<strong>main</strong>.B’&gt;, &lt;class ‘<strong>main</strong>.A’&gt;, &lt;class ‘object’&gt;]<br>say BBB!</p>
<h2 id="super-获得父类定义"><a href="#super-获得父类定义" class="headerlink" title="super()获得父类定义"></a><strong>super()获得父类定义</strong></h2><p>在子类中，如果想要获得父类的方法时，我们可以通过 super()来做。super()代表父类的定义，不是父类对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def say(self):</span><br><span class="line"> #A.say(self) 调用父类的 say 方法 </span><br><span class="line"> super().say() #通过 super()调用父类的方法</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h2><p>多态(polymorphism)是指同一个方法调用由于对象不同可能会产生不同的行为。在现实 生活中，我们有很多例子。比如:同样是调用人的休息方法，张三的休息是睡觉，李四的休 息是玩游戏，高淇老师是敲代码。同样是吃饭的方法，中国人用筷子吃饭，英国人用刀叉吃 饭，印度人用手吃饭。</p>
<p>关于多态要注意以下 2 点:<br> \1. 多态是方法的多态，属性没有多态。<br> \2. 多态的存在有 2 个必要条件:继承、方法重写。</p>
<h2 id="特殊方法和运算符重载"><a href="#特殊方法和运算符重载" class="headerlink" title="特殊方法和运算符重载"></a><strong>特殊方法和运算符重载</strong></h2><p>Python 的运算符实际上是通过调用对象的特殊方法实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span> </span><br><span class="line">b = <span class="number">30</span></span><br><span class="line">c = a+b</span><br><span class="line">d = a.__add__(b) </span><br><span class="line">print(<span class="string">"c="</span>,c)</span><br><span class="line">print(<span class="string">"d="</span>,d)</span><br><span class="line"><span class="comment">#运算结果: c= 50</span></span><br><span class="line">d= <span class="number">50</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">常见的特殊方法统计如下:</span><br><span class="line"></span><br><span class="line">__init__  构造方法      对象创建:p &#x3D; Person()</span><br><span class="line">__del__  析构方法 对象回收</span><br><span class="line">__repr__,__str__  打印，转换     rint(a)</span><br><span class="line">__call__ 函数调用 a()</span><br><span class="line">__getattr__ 点号运算 a.xxx</span><br><span class="line">__setattr__ 属性赋值 a.xxx &#x3D; value</span><br><span class="line">__getitem__ 索引运算 a[key]</span><br><span class="line">__setitem__ 索引赋值 a[key]&#x3D;value</span><br><span class="line">__len__ 长度 len(a)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运算符+ __add__ 加法</span><br><span class="line">运算符- __sub__ 减法</span><br><span class="line">&lt;,&lt;&#x3D;,&#x3D;&#x3D;  __lt__,__le__，__eq__ 比较运算符</span><br><span class="line">&gt;,&gt;&#x3D;,!&#x3D; __gt__,__ge__,__ne__ 比较运算符</span><br><span class="line">|,^,&amp; __or__,__xor__,__and__  或、异或、与</span><br><span class="line">&lt;&lt;,&gt;&gt; __lshift__,__rshift__ 左移、右移</span><br><span class="line">*,&#x2F;,%,&#x2F;&#x2F; __mul__,__truediv__,__mod__,_ _floordiv__ 乘、浮点除、模运算 (取余)、整数除</span><br><span class="line">** __pow__ 指数运算</span><br></pre></td></tr></table></figure>

<p>我们可以重写上面的特殊方法，即实现了“运算符的重载”。</p>
<h2 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a><strong>特殊属性</strong></h2><p>Python 对象中包含了很多双下划线开始和结束的属性，这些是特殊属性，有特殊用法。这 里我们列出常见的特殊属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">obj.__dict__对象的属性字典</span><br><span class="line">obj.__class__对象所属的类</span><br><span class="line">class.__bases__类的基类元组(多继承)</span><br><span class="line">class.__base__类的基类</span><br><span class="line">class.__mro__类层次结构</span><br><span class="line">class.__subclasses__()子类列表</span><br><span class="line">print(dir(c)) </span><br><span class="line">print(c.__dict__) </span><br><span class="line">print(c.__class__) </span><br><span class="line">print(C.__bases__) </span><br><span class="line">print(C.mro()) </span><br><span class="line">print(A.__subclasses__())</span><br></pre></td></tr></table></figure>

<p><strong>对象的浅拷贝和深拷贝</strong></p>
<p><strong>·变量的赋值操作</strong></p>
<p>只是形成两个变量，实际还是指向同一个对象。</p>
<p><strong>·浅拷贝</strong></p>
<p>Python 拷贝一般都是浅拷贝。拷贝时，对象包含的子对象内容不拷贝。因此，源对象 和拷贝对象会引用同一个子对象。<br> <strong>·深拷贝</strong></p>
<p>使用 copy 模块的 deepcopy 函数，递归拷贝对象中包含的子对象。源对象和拷贝对象 所有的子对象也不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">m2 &#x3D; copy.copy(m) #m2 是新拷贝的另一个手机对象</span><br><span class="line">m3 &#x3D; copy.deepcopy(m)</span><br></pre></td></tr></table></figure>

<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a><strong>组合</strong></h2><p>“is-a”关系，我们可以使用“继承”。从而实现子类拥有的父类的方法和属性。“is-a” 关系指的是类似这样的关系:狗是动物，dog is animal。狗类就应该继承动物类。</p>
<p>“has-a”关系，我们可以使用“组合”，也能实现一个类拥有另一个类的方法和属性。” has-a”关系指的是这样的关系:手机拥有 CPU。 MobilePhone has a CPU。self.cpu=cpu</p>
<h2 id="设计模式-工厂模式实现"><a href="#设计模式-工厂模式实现" class="headerlink" title="设计模式_工厂模式实现"></a><strong>设计模式_工厂模式实现</strong></h2><p>设计模式是面向对象语言特有的内容，是我们在面临某一类问题时候固定的做法，设计 模式有很多种，比较流行的是:GOF(Goup Of Four)23 种设计模式。当然，我们没有 必要全部学习，学习几个常用的即可。</p>
<p>对于初学者，我们学习两个最常用的模式:工厂模式和单例模式。</p>
<p>工厂模式实现了创建者和调用者的分离，使用专门的工厂类将选择实现类、创建对象进 行统一的管理和控制。</p>
<h2 id="设计模式-单例模式实现"><a href="#设计模式-单例模式实现" class="headerlink" title="设计模式_单例模式实现"></a><strong>设计模式_单例模式实现</strong></h2><p>单例模式(Singleton Pattern)的核心作用是确保一个类只有一个实例，并且提供一 个访问该实例的全局访问点。</p>
<p>单例模式只生成一个实例对象，减少了对系统资源的开销。当一个对象的产生需要比较 多的资源，如读取配置文件、产生其他依赖对象时，可以产生一个“单例对象”，然后永久 驻留内存中，从而极大的降低开销。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单例模式有多种实现的方式，我们这里推荐重写__new__()的方法。</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/29/python400%E9%9B%862/" rel="prev" title="python400集2">
      <i class="fa fa-chevron-left"></i> python400集2
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/29/python400%E9%9B%864/" rel="next" title="python400集4">
      python400集4 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#python面向对象"><span class="nav-number">1.</span> <span class="nav-text">python面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#init构造方法和new方法"><span class="nav-number">1.1.</span> <span class="nav-text">init构造方法和new方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建对象，我们需要定义构造函数init-方法。构造方法用于执行“实例对象的初始化工-作”，即对象创建后，初始化当前对象的相关属性，无返回值。"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">创建对象，我们需要定义构造函数init()方法。构造方法用于执行“实例对象的初始化工 作”，即对象创建后，初始化当前对象的相关属性，无返回值。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例属性和实例方法"><span class="nav-number">1.2.</span> <span class="nav-text">实例属性和实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实例属性instance（其实跟java差不多）"><span class="nav-number">1.2.1.</span> <span class="nav-text">实例属性instance（其实跟java差不多）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例方法"><span class="nav-number">1.2.2.</span> <span class="nav-text">实例方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#·-函数和方法的区别"><span class="nav-number">1.2.3.</span> <span class="nav-text">· 函数和方法的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类对象、类属性、类方法、静态方法"><span class="nav-number">1.3.</span> <span class="nav-text">类对象、类属性、类方法、静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类属性"><span class="nav-number">1.3.1.</span> <span class="nav-text">类属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类方法"><span class="nav-number">1.3.2.</span> <span class="nav-text">类方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态方法"><span class="nav-number">1.3.3.</span> <span class="nav-text">静态方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#del方法-析构函数-和垃圾回收机制"><span class="nav-number">1.4.</span> <span class="nav-text">del方法(析构函数)和垃圾回收机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call方法和可调用对象"><span class="nav-number">1.5.</span> <span class="nav-text">call方法和可调用对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法没有重载"><span class="nav-number">1.6.</span> <span class="nav-text">方法没有重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。-建议-不要使用重名的方法-Python-中方法没有重载。"><span class="nav-number">1.6.1.</span> <span class="nav-text">如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。 建议:不要使用重名的方法!Python 中方法没有重载。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法的动态性"><span class="nav-number">1.7.</span> <span class="nav-text">方法的动态性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#私有属性和私有方法-实现封装"><span class="nav-number">1.8.</span> <span class="nav-text">私有属性和私有方法(实现封装)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#property-装饰器"><span class="nav-number">1.9.</span> <span class="nav-text">@property 装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性和方法命名总结"><span class="nav-number">1.10.</span> <span class="nav-text">属性和方法命名总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类编码风格"><span class="nav-number">1.11.</span> <span class="nav-text">类编码风格</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象进阶"><span class="nav-number">2.</span> <span class="nav-text">面向对象进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">2.1.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法格式"><span class="nav-number">2.1.1.</span> <span class="nav-text">语法格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类成员的继承和重写"><span class="nav-number">2.1.2.</span> <span class="nav-text">类成员的继承和重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看类的继承层次结构"><span class="nav-number">2.1.3.</span> <span class="nav-text">查看类的继承层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#object-根类"><span class="nav-number">2.1.4.</span> <span class="nav-text">object 根类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重写str-方法"><span class="nav-number">2.2.</span> <span class="nav-text">重写str()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多重继承"><span class="nav-number">2.3.</span> <span class="nav-text">多重继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MRO"><span class="nav-number">2.4.</span> <span class="nav-text">MRO()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super-获得父类定义"><span class="nav-number">2.5.</span> <span class="nav-text">super()获得父类定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态"><span class="nav-number">2.6.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊方法和运算符重载"><span class="nav-number">2.7.</span> <span class="nav-text">特殊方法和运算符重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊属性"><span class="nav-number">2.8.</span> <span class="nav-text">特殊属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合"><span class="nav-number">2.9.</span> <span class="nav-text">组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计模式-工厂模式实现"><span class="nav-number">2.10.</span> <span class="nav-text">设计模式_工厂模式实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计模式-单例模式实现"><span class="nav-number">2.11.</span> <span class="nav-text">设计模式_单例模式实现</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jackson</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jackson</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
