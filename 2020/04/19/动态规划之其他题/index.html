<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="72. 编辑距离难度困难804收藏分享切换为英文关注反馈 给你两个单词 word1 和 word2*，请你计算出将 *word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作：  插入一个字符 删除一个字符 替换一个字符  示例 1： 123456输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&amp;qu">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划之其他题">
<meta property="og:url" content="http://yoursite.com/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%85%B6%E4%BB%96%E9%A2%98/index.html">
<meta property="og:site_name" content="Jackson Blog">
<meta property="og:description" content="72. 编辑距离难度困难804收藏分享切换为英文关注反馈 给你两个单词 word1 和 word2*，请你计算出将 *word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作：  插入一个字符 删除一个字符 替换一个字符  示例 1： 123456输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&amp;qu">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://leetcode.com/media/original_images/221_Maximal_Square.PNG?raw=true">
<meta property="og:image" content="https://leetcode.com/media/original_images/221_Maximal_Square1.png?raw=true">
<meta property="og:image" content="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_state_machine.png">
<meta property="og:image" content="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_game.png">
<meta property="og:image" content="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_graph.png">
<meta property="og:image" content="data:image/png;base64,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oeFOoIzDhw+vHT45d+7cE7gSp3pSQD8j6XQBvRXD5s2bDylKZmam+TJZ5yjZXyYfchAbHC+gAbDejkGDI51Dr738OjWEVCPg9QGSBjXaK3S4ZHcP1/0F1pucHSvpBMSGwZJuO1LSPyKa9A+JjtnUiar6rekpp5xSe50jnct2BBCoEaj7xQUm3i2gq3jai9roo87fJPmWwM6dO83KsQ1rpSMwNNX9d7fhMbx2voB+yatfWukS3w3TzJkzzSYNokjeK6Ariuooq5SUFDM3ny/z67el1wdIdatjB0S6Te/irf9I6x9rO9ipe+zRntftTtYJxZr03h11U05OTu0/Dr169TK7NDjSBRoGDRpUe6hOStYATlfJIyGAwKEC9uIMusQ+yTcEdF6ZfsusE331RqL693L37t3mRoR681j920zybgFdDEnnlNWdq6BzdvUmsZrsQMm7a+m/pT/rrLNM5Z988klz+xNbQm8kesstt5gAmPtG2ire+agBkiaddqK9Sfp3W7/40J4k/Xvt76n+wFIv1tBvOvT+RTr+Wce+64IKmt59991GB0h2gKVvGr2efgOmNznUO0brfY/mzZtnxtTrOOt//etf5iZa+mbSrsn27dubsZv6j7/2HOm34dptqXOYdLyuTkInIYDAQQGd26e/r/pBWoe16u+s3r9MV8MaN27cwQN55rUCek+4uvM17YroMtDz58+vN6/T3sejdwiMHj3a/Pumv8N6C43ExEQz91bvMaiLcOjwdZL3CujQWP3grJ919H5XuhiHfkZ66aWXTKU0gKIHyXvbt27JdQ6hPY+w7nYdblf31jl19/nDc58JkLSxNBCxh3Xoa73Rmd27Ywc/Rxsqp6uxaJClPUD28IBWrVrJCy+8INdee6151Od20jH2OqlNe5y+/PJLs3KPLi2u//DbSe8sfvfdd9fOc7K384iAvwvo6o96z4W6Xx7ot1b6LTTJuwV08naHDh1EJwB3797dfGDW4Ru6Xb9U0g/Rded6endt/bP0emsL/TJRe4xefPHFWgRdjVInejOBv5bEa5/oisDFxcXms0/dNr7iiitE7wVJ8m4B/RutST/DDhgwwNz3Sj8D64/OG9Uv/P05BViBQ80NgNyooEPemjNb/YOsH7T0m2gdT6mBko55bzieUpeb1W9B9PgjJf1HW4OjhsPydBnEV155xfzjrqv26I20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">
<meta property="og:image" content="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_formula.png">
<meta property="og:image" content="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAAHZCAYAAAC8QhsUAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAADSKADAAQAAAABAAAB2QAAAABdjUaIAABAAElEQVR4AezdB3wURRsG8Ody6b2RkJCQhNB770WkShOkgyJNBAFFqqh0UERB9KOLIL0K0hHpvfcaSAiBJKSH9Ha331w4ILm7hNCTu2f9RW77zn9nd+ednd2VSaIDOwpQgAIUoAAFKEABClCAAhSAEQ0oQAEKUIACFKAABShAAQpQ4LEAAyTmBApQgAIUoAAFKEABClCAAmoBBkjMChSgAAUoQAEKUIACFKAABdQCDJCYFShAAQpQgAIUoAAFKEABCqgFGCAxK1CAAhSgAAUoQAEKUIACFFALMEBiVqAABShAAQpQgAIUoAAFKKAWYIDErEABClCAAhSgAAUoQAEKUEAtwACJWYECFKAABShAAQpQgAIUoIBagAESswIFKEABClCAAhSgAAUoQAG1AAMkZgUKUIACFKAABShAAQpQgAJqAQZIzAoUoAAFKEABClCAAhSgAAXUAgyQmBUoQAEKUIACFKAABShAAQqoBRggMStQgAIUoAAFKEABClCAAhRQCzBAYlagAAUoQAEKUIACFKAABSigFmCAxKxAAQpQgAIUoAAFKEABClBALcAAiVmBAhSgAAUoQAEKUIACFKCAWoABErMCBShAAQpQgAIUoAAFKEABtQADJGYFClCAAhSgAAUoQAEKUIACagEGSMwKFKAABShAAQpQgAIUoAAF1AIMkJgVKEABClCAAhSgAAUoQAEKqAUYIDErUIACFKAABShAAQpQgAIUUAswQGJWoAAFKEABClCAAhSgAAUooBZggMSsQAEKUIACFKAABShAAQpQQC3AAIlZgQIUoAAFKEABClCAAhSggFqAARKzAgUoQAEKUIACFKAABShAAbUAAyRmBQpQgAIUoAAFKEABClCAAmoBBkjMChSgAAUoQAEKUIACFKAABdQCDJCYFShAAQpQgAIUoAAFKEABCqgFGCAxK1CAAhSgAAUoQAEKUIACFFALMEBiVqAABShAAQpQgAIUoAAFKKAWYIDErEABClCAAhSgAAUoQAEKUEAtwACJWYECFKAABShAAQpQgAIUoIBagAESswIFKEABClCAAhSgAAUoQAG1AAMkZgUKUIACFKAABShAAQpQgAJqAQZIzAoUoAAFKEABClCAAhSgAAXUAgyQmBUoQAEKUIACFKAABShAAQqoBRggMStQgAIUoAAFKEABClCAAhRQCzBAYlagAAUoQAEKUIACFKAABSigFmCAxKxAAQpQgAIUoAAFKEABClBALcAAiVmBAhSgAAUoQAEKUIACFKCAWoABErMCBShAAQpQgAIUoAAFKEABtQADJGYFClCAAhSgAAUoQAEKUIACagEGSMwKFKAABShAAQpQgAIUoAAF1AIMkJgVKEABClCAAhSgAAUoQAEKqAUYIDErUIACFKAABShAAQpQgAIUUAswQGJWoAAFKEABClCAAhSgAAUooBZggMSsQAEKUIACFKAABShAAQpQQC3AAIlZgQIUoAAFKEABClCAAhSggFqAARKzAgUoQAEKUIACFKAABShAAbUAAyRmBQpQgAIUoAAFKEABClCAAmoBBkjMChSgAAUoQAEKUIACFKAABdQCDJCYFShAAQpQgAIUoAAFKEABCqgFGCAxK1CAAhSgAAUoQAEKUIACFFALMEBiVqAABShAAQpQgAIUoAAFKKAWYIDErEABClCAAhSgAAUoQAEKUEAtwACJWYECFKAABShAAQpQgAIUoIBagAESswIFKEABClCAAhSgAAUoQAG1AAMkZgUKUIACFKAABShAAQpQgAJqAQZIzAoUoAAFKEABClCAAhSgAAXUAgyQmBUoQAEKUIACFKAABShAAQqoBRggMStQgAIUoAAFKEABClCAAhRQCzBAYlagAAUoQAEKUIACFKAABSigFmCAxKxAAQpQgAIUoAAFKEABClBALcAAiVmBAhSgAAUoQAEKUIACFKCAWoABErMCBShAAQpQgAIUoAAFKEABtQADJGYFClCAAhSgAAUoQAEKUIACagEGSMwKFKAABShAAQpQgAIUoAAF1AIMkJgVKEABClCAAhSgAAUoQAEKqAUYIDErUIACFKAABShAAQpQgAIUUAswQGJWoAAFKEABClCAAhSgAAUooBZggMSsQAEKUIACFKAABShAAQpQQC3AAIlZgQIUoAAFKEABClCAAhSggFqAARKzAgUoQAEKUIACFKAABShAAbUAAyRmBQpQgAIUoAAFKEABClCA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AktvTt7O9WRHjx4d991337jwwgvP9Sj/03//1157bbzwwgvc5lA/ceLE2L179xzP7H7K888/P7Zv3z42bdrUDTFj+pMnT44zZ86M888/f8Znnt2H/7+/fLz88svjxRdfHLt27Tq7EAv2s09fG44fPz727NmzYMnObpw33nhjPPvss+Oiiy46u/+gBfzZn3vuubFz586xvOzr9rPUO31tmJpt3bp1lqfVP/b06dNj375944EHHhgrKyvRYyEG0qlTp8b0E68tW7bEkI5ZYPrJzSuvvDLW1tbyA1zXFZh+4sVtXZ51f2D68ba6uupFcF2h/APTT1inv16ndt7eusB0VL766qt+rb51sv88cvqJ/vR1ddu2bTM+08Onbj5Znf3jYPrasHnz5tmfWP6M6WvD0tLS2LBhQ7nEbPGnrw3TYfnfvni2EANpNhaPJkCAAAECBAgQIECAQBbwe5nZxZUAAQIECBAgQIAAgUIBA6mwdJEJECBAgAABAgQIEMgCBlJ2cSVAgAABAgQIECBAoFDAQCosXWQCBAgQIECAAAECBLKAgZRdXAkQIECAAAECBAgQKBQwkApLF5kAAQIECBAgQIAAgSxgIGUXVwIECBAgQIAAAQIECgUMpMLSRSZAgAABAgQIECBAIAsYSNnFlQABAgQIECBAgACBQgEDqbB0kQkQIECAAAECBAgQyAIGUnZxJUCAAAECBAgQIECgUMBAKixdZAIECBAgQIAAAQIEsoCBlF1cCRAgQIAAAQIECBAoFDCQCksXmQABAgQIECBAgACBLGAgZRdXAgQIECBAgAABAgQKBQykwtJFJkCAAAECBAgQIEAgCxhI2cWVAAECBAgQIECAAIFCAQOpsHSRCRAgQIAAAQIECBDIAgZSdnElQIAAAQIECBAgQKBQwEAqLF1kAgQIECBAgAABAgSygIGUXVwJECBAgAABAgQIECgUMJAKSxeZAAECBAgQIECAAIEsYCBlF1cCBAgQIECAAAECBAoFDKTC0kUmQIAAAQIECBAgQCALGEjZxZUAAQIECBAgQIAAgUIBA6mwdJEJECBAgAABAgQIEMgCBlJ2cSVAgAABAgQIECBAoFDAQCosXWQCBAgQIECAAAECBLKAgZRdXAkQIECAAAECBAgQKBQwkApLF5kAAQIECBAgQIAAgSxgIGUXVwIECBAgQIAAAQIECgUM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">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/minimum-score-triangulation-of-polygon-1.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/ddf9ff236598ff79b00e7365354cdaf961463cc78dfed7505334ad2628a60d73-e7c5ca8d4c19bed3e8652951c6f37c6.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/a49b3279d3d2e9b9d9617da384d72dbcfe395dc3a0f0d1fe6fc4e4587f2c6d12-image.png">
<meta property="og:image" content="https://leetcode.com/problems/fibonacci-number/Figures/509/fibonacciRecursion5.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/11/logo20190828-02.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/30/book_2.jpg">
<meta property="article:published_time" content="2020-04-19T15:16:32.000Z">
<meta property="article:modified_time" content="2020-05-19T19:39:56.042Z">
<meta property="article:author" content="Jackson">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leetcode.com/media/original_images/221_Maximal_Square.PNG?raw=true">

<link rel="canonical" href="http://yoursite.com/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%85%B6%E4%BB%96%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>动态规划之其他题 | Jackson Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jackson Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%85%B6%E4%BB%96%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          动态规划之其他题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-19 10:16:32" itemprop="dateCreated datePublished" datetime="2020-04-19T10:16:32-05:00">2020-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-19 14:39:56" itemprop="dateModified" datetime="2020-05-19T14:39:56-05:00">2020-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></h2><p>难度困难804收藏分享切换为英文关注反馈</p>
<p>给你两个单词 <em>word1</em> 和 <em>word2*，请你计算出将 *word1</em> 转换成 <em>word2</em> 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (插入 &#39;u&#39;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">动态规划</span><br><span class="line"></span><br><span class="line">定义 dp[i][j]</span><br><span class="line">21. dp[i][j] 代表 word1 中前 i 个字符，变换到 word2 中前 j 个字符，最短需要操作的次数</span><br><span class="line">22. 需要考虑 word1 或 word2 一个字母都没有，即全增加&#x2F;删除的情况，所以预留 dp[0][j] 和 dp[i][0]</span><br><span class="line"></span><br><span class="line">状态转移</span><br><span class="line">31. 增，dp[i][j] &#x3D; dp[i][j - 1] + 1</span><br><span class="line">32. 删，dp[i][j] &#x3D; dp[i - 1][j] + 1</span><br><span class="line">33. 改，dp[i][j] &#x3D; dp[i - 1][j - 1] + 1</span><br><span class="line">34. 按顺序计算，当计算 dp[i][j] 时，dp[i - 1][j] ， dp[i][j - 1] ， dp[i - 1][j - 1] 均已经确定了</span><br><span class="line">35. 配合增删改这三种操作，需要对应的 dp 把操作次数加一，取三种的最小</span><br><span class="line">36. 如果刚好这两个字母相同 word1[i - 1] &#x3D; word2[j - 1] ，那么可以直接参考 dp[i - 1][j - 1] ，操作不用加一</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：ikaruga</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;edit-distance&#x2F;solution&#x2F;edit-distance-by-ikaruga&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=word1.length();</span><br><span class="line">        <span class="keyword">int</span> col=word2.length();</span><br><span class="line">        <span class="keyword">if</span>((row==<span class="number">0</span>) || (col==<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> row+col;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row+<span class="number">1</span>;i++)</span><br><span class="line">            dp[i][<span class="number">0</span>]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col+<span class="number">1</span>;j++)</span><br><span class="line">            dp[<span class="number">0</span>][j]=j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;col+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>)!=word2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                    dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+=<span class="number">1</span>;</span><br><span class="line">                dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,Math.min(dp[i][j-<span class="number">1</span>]+<span class="number">1</span>,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">132. 分割回文串 II</a></h2><p>难度困难130收藏分享切换为英文关注反馈</p>
<p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。</p>
<p>返回符合要求的最少分割次数。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 进行一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> n = c.length;</span><br><span class="line">    <span class="keyword">int</span>[] cut = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[j] == c[i] &amp;&amp; (j + <span class="number">1</span> &gt; i - <span class="number">1</span> || dp[j + <span class="number">1</span>][i - <span class="number">1</span>])) &#123;</span><br><span class="line">                dp[j][i] = <span class="keyword">true</span>;  </span><br><span class="line">                min = j == <span class="number">0</span> ? <span class="number">0</span> : Math.min(min, cut[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cut[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cut[n - <span class="number">1</span>];</span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h2><p>难度中等2038收藏分享切换为英文关注反馈</p>
<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> strLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> maxStart = <span class="number">0</span>;  <span class="comment">//最长回文串的起点</span></span><br><span class="line">        <span class="keyword">int</span> maxEnd = <span class="number">0</span>;    <span class="comment">//最长回文串的终点</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;  <span class="comment">//最长回文串的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[strLen][strLen];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; strLen; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; r; l++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(l) == s.charAt(r) &amp;&amp; (r - l &lt;= <span class="number">2</span> || dp[l + <span class="number">1</span>][r - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[l][r] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                        maxLen = r - l + <span class="number">1</span>;</span><br><span class="line">                        maxStart = l;</span><br><span class="line">                        maxEnd = r;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxStart, maxEnd + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> premax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curmax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=curmax;</span><br><span class="line">            curmax=Math.max(x+premax,curmax);</span><br><span class="line">            premax=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curmax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Algorithm</strong></p>
<p>It could be overwhelming thinking of all possibilities on which houses to rob.</p>
<p>A natural way to approach this problem is to work on the simplest case first.</p>
<p>Let us denote that:</p>
<blockquote>
<p><em>f</em>(<em>k</em>) = Largest amount that you can rob from the first <em>k</em> houses.<br>Ai = Amount of money at the ith house.</p>
</blockquote>
<p>Let us look at the case <code>n = 1</code>, clearly <em>f</em>(1) = A1.</p>
<p>Now, let us look at <code>n = 2</code>, which <em>f</em>(2) = max(A1, A2).</p>
<p>For <code>n = 3</code>, you have basically the following two options:</p>
<ol>
<li>Rob the third house, and add its amount to the first house’s amount.</li>
<li>Do not rob the third house, and stick with the maximum amount of the first two houses.</li>
</ol>
<p>Clearly, you would want to choose the larger of the two options at each step.</p>
<p>Therefore, we could summarize the formula as following:</p>
<blockquote>
<p><em>f</em>(<em>k</em>) = max(<em>f</em>(<em>k</em> – 2) + Ak, <em>f</em>(<em>k</em> – 1))</p>
</blockquote>
<p>We choose the base case as <em>f</em>(–1) = <em>f</em>(0) = 0, which will greatly simplify our code as you can see.</p>
<p>The answer will be calculated as <em>f</em>(<em>n</em>). We could use an array to store and calculate the result, but since at each step you only need the previous two maximum values, two variables are suffice.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prevMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : num) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = currMax;</span><br><span class="line">        currMax = Math.max(prevMax + x, currMax);</span><br><span class="line">        prevMax = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). Assume that n<em>n</em> is the number of houses, the time complexity is O(n)<em>O</em>(<em>n</em>).</li>
<li>Space complexity : O(1)<em>O</em>(1).</li>
</ul>
<h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h2><p>难度中等254收藏分享切换为英文关注反馈</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈，</strong>这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">2</span>)<span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob0(nums),rob1(nums));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob0</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;<span class="comment">//0~length-2</span></span><br><span class="line">        <span class="keyword">int</span> premax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curmax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] arr1=<span class="keyword">new</span> <span class="keyword">int</span>[l-<span class="number">1</span>];</span><br><span class="line">        System.arraycopy(nums,<span class="number">0</span>,arr1,<span class="number">0</span>,l-<span class="number">1</span>);<span class="comment">//copy array</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr1)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=curmax;</span><br><span class="line">            curmax=Math.max(x+premax,curmax);</span><br><span class="line">            premax=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curmax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;<span class="comment">//0~length-1</span></span><br><span class="line">        <span class="keyword">int</span> premax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curmax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] arr2=<span class="keyword">new</span> <span class="keyword">int</span>[l-<span class="number">1</span>];</span><br><span class="line">        System.arraycopy(nums,<span class="number">1</span>,arr2,<span class="number">0</span>,l-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr2)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=curmax;</span><br><span class="line">            curmax=Math.max(x+premax,curmax);</span><br><span class="line">            premax=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curmax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>), rob(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> include = <span class="number">0</span>, exclude = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lo; j &lt;= hi; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = include, e = exclude;</span><br><span class="line">            include = e + num[j];</span><br><span class="line">            exclude = Math.max(e, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(include, exclude);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Since this question is a follow-up to House Robber, we can assume we already have a way to solve the simpler question, i.e. given a 1 row of house, we know how to rob them. So we already have such a helper function. We modify it a bit to rob a given range of houses.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private int rob(int[] num, int lo, int hi) &#123;</span><br><span class="line">    int include &#x3D; 0, exclude &#x3D; 0;</span><br><span class="line">    for (int j &#x3D; lo; j &lt;&#x3D; hi; j++) &#123;</span><br><span class="line">        int i &#x3D; include, e &#x3D; exclude;</span><br><span class="line">        include &#x3D; e + num[j];</span><br><span class="line">        exclude &#x3D; Math.max(e, i);</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.max(include, exclude);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Now the question is how to rob a circular row of houses. It is a bit complicated to solve like the simpler question. It is because in the simpler question whether to rob <em>num[lo]</em> is entirely our choice. But, it is now constrained by whether <em>num[hi]</em> is robbed.</p>
<p>However, since we already have a nice solution to the simpler problem. We do not want to throw it away. Then, it becomes how can we reduce this problem to the simpler one. Actually, extending from the logic that if house i is not robbed, then you are free to choose whether to rob house i + 1, you can break the circle by assuming a house is not robbed.</p>
<p>For example, 1 -&gt; 2 -&gt; 3 -&gt; 1 becomes 2 -&gt; 3 if 1 is not robbed.</p>
<p>Since every house is either robbed or not robbed and at least half of the houses are not robbed, the solution is simply the larger of two cases with consecutive houses, i.e. house i not robbed, break the circle, solve it, or house i + 1 not robbed. Hence, the following solution. I chose i = n and i + 1 = 0 for simpler coding. But, you can choose whichever two consecutive ones.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int rob(int[] nums) &#123;</span><br><span class="line">    if (nums.length &#x3D;&#x3D; 1) return nums[0];</span><br><span class="line">    return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></h2><p>难度中等403收藏分享切换为英文关注反馈</p>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.length, col=row&gt;<span class="number">0</span>? matrix[<span class="number">0</span>].length:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;col+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j]=Math.min(Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]),dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">                    max=Math.max(max,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max*max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Approach-1-Brute-Force-Accepted"><a href="#Approach-1-Brute-Force-Accepted" class="headerlink" title="Approach #1 Brute Force [Accepted]"></a>Approach #1 Brute Force [Accepted]</h4><p>The simplest approach consists of trying to find out every possible square of 1’s that can be formed from within the matrix. The question now is – how to go for it?</p>
<p>We use a variable to contain the size of the largest square found so far and another variable to store the size of the current, both initialized to 0. Starting from the left uppermost point in the matrix, we search for a 1. No operation needs to be done for a 0. Whenever a 1 is found, we try to find out the largest square that can be formed including that 1. For this, we move diagonally (right and downwards), i.e. we increment the row index and column index temporarily and then check whether all the elements of that row and column are 1 or not. If all the elements happen to be 1, we move diagonally further as previously. If even one element turns out to be 0, we stop this diagonal movement and update the size of the largest square. Now we, continue the traversal of the matrix from the element next to the initial 1 found, till all the elements of the matrix have been traversed.</p>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = rows &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxsqlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sqlen = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">while</span> (sqlen + i &lt; rows &amp;&amp; sqlen + j &lt; cols &amp;&amp; flag) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= sqlen + j; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[i + sqlen][k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                                flag = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= sqlen + i; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[k][j + sqlen] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                                flag = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag)</span><br><span class="line">                            sqlen++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (maxsqlen &lt; sqlen) &#123;</span><br><span class="line">                        maxsqlen = sqlen;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsqlen * maxsqlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O((mn))<em>O</em>((<em>m**n</em>)2). In worst case, we need to traverse the complete matrix for every 1.</li>
<li>Space complexity : O(1)<em>O</em>(1). No extra space is used.</li>
</ul>
<hr>
<h4 id="Approach-2-Dynamic-Programming-Accepted"><a href="#Approach-2-Dynamic-Programming-Accepted" class="headerlink" title="Approach #2 (Dynamic Programming) [Accepted]"></a>Approach #2 (Dynamic Programming) [Accepted]</h4><p><strong>Algorithm</strong></p>
<p>We will explain this approach with the help of an example.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 1 0</span><br><span class="line">1 1 1 1 1</span><br><span class="line">0 1 1 1 1</span><br><span class="line">0 1 1 1 1</span><br><span class="line">0 0 1 1 1</span><br></pre></td></tr></table></figure>

<p>We initialize another matrix (dp) with the same dimensions as the original one initialized with all 0’s.</p>
<p>dp(i,j) represents the side length of the maximum square whose bottom right corner is the cell with index (i,j) in the original matrix.</p>
<p>Starting from index (0,0), for every 1 found in the original matrix, we update the value of the current element as</p>
<p>dp(i,j)=min⁡(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1.dp(<em>i</em>,<em>j</em>)=min(dp(<em>i</em>−1,<em>j</em>),dp(<em>i</em>−1,<em>j</em>−1),dp(<em>i</em>,<em>j</em>−1))+1.</p>
<p>We also remember the size of the largest square found so far. In this way, we traverse the original matrix once and find out the required maximum size. This gives the side length of the square (say maxsqlen<em>m<strong>a</strong>x<strong>s</strong>q<strong>l</strong>e**n</em>). The required result is the area maxsqlen2<em>m*</em>a<strong>x</strong>s<strong>q</strong>l<strong>e</strong>n*2.</p>
<p>To understand how this solution works, see the figure below.</p>
<p><img src="https://leetcode.com/media/original_images/221_Maximal_Square.PNG?raw=true" alt="Max Square"></p>
<p>An entry 2 at (1,3)(1,3) implies that we have a square of side 2 up to that index in the original matrix. Similarly, a 2 at (1,2)(1,2) and (2,2)(2,2)implies that a square of side 2 exists up to that index in the original matrix. Now to make a square of side 3, only a single entry of 1 is pending at (2,3)(2,3). So, we enter a 3 corresponding to that position in the dp array.</p>
<p>Now consider the case for the index (3,4)(3,4). Here, the entries at index (3,3)(3,3) and (2,3)(2,3) imply that a square of side 3 is possible up to their indices. But, the entry 1 at index (2,4)(2,4) indicates that a square of side 1 only can be formed up to its index. Therefore, while making an entry at the index (3,4)(3,4), this element obstructs the formation of a square having a side larger than 2. Thus, the maximum sized square that can be formed up to this index is of size 2×22×2.</p>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = rows &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows + <span class="number">1</span>][cols + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> maxsqlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    maxsqlen = Math.max(maxsqlen, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsqlen * maxsqlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(mn)<em>O</em>(<em>m**n</em>). Single pass.</li>
<li>Space complexity : O(mn)<em>O</em>(<em>m**n</em>). Another matrix of same size is used for dp.</li>
</ul>
<hr>
<h4 id="Approach-3-Better-Dynamic-Programming-Accepted"><a href="#Approach-3-Better-Dynamic-Programming-Accepted" class="headerlink" title="Approach #3 (Better Dynamic Programming) [Accepted]"></a>Approach #3 (Better Dynamic Programming) [Accepted]</h4><p><strong>Algorithm</strong></p>
<p>In the previous approach for calculating dp of ith<em>i<strong>t</strong>h</em> row we are using only the previous element and the (i−1)(<em>i</em>−1)<em>t**h</em> row. Therefore, we don’t need 2D dp matrix as 1D dp array will be sufficient for this.</p>
<p>Initially the dp array contains all 0’s. As we scan the elements of the original matrix across a row, we keep on updating the dp array as per the equation dp[j]=min(dp[j−1],dp[j],prev)<em>d**p</em>[<em>j</em>]=<em>m<strong>i</strong>n</em>(<em>d**p</em>[<em>j</em>−1],<em>d**p</em>[<em>j</em>],<em>p<strong>r</strong>e**v</em>), where prev refers to the old dp[j−1]<em>d**p</em>[<em>j</em>−1]. For every row, we repeat the same process and update in the same dp array.</p>
<p><img src="https://leetcode.com/media/original_images/221_Maximal_Square1.png?raw=true" alt=" Max Square "></p>
<p><strong>java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = rows &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[cols + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> maxsqlen = <span class="number">0</span>, prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cols; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = dp[j];</span><br><span class="line">                <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    dp[j] = Math.min(Math.min(dp[j - <span class="number">1</span>], prev), dp[j]) + <span class="number">1</span>;</span><br><span class="line">                    maxsqlen = Math.max(maxsqlen, dp[j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsqlen * maxsqlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(mn)<em>O</em>(<em>m**n</em>). Single pass.</li>
<li>Space complexity : O(n)<em>O</em>(<em>n</em>). Another array which stores elements in a row is used for dp.</li>
</ul>
<h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></h2><p>给定一个整数数组，其中第 <em>i</em> 个元素代表了第 <em>i</em> 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sold=Integer.MIN_VALUE, held=Integer.MIN_VALUE, reset=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price: prices)&#123;</span><br><span class="line">            <span class="keyword">int</span> presold=sold;</span><br><span class="line">            sold=held+price;</span><br><span class="line">            held=Math.max(held,reset-price);</span><br><span class="line">            reset=Math.max(reset, presold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(sold, reset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Approach-1-Dynamic-Programming-with-State-Machine"><a href="#Approach-1-Dynamic-Programming-with-State-Machine" class="headerlink" title="Approach 1: Dynamic Programming with State Machine"></a>Approach 1: Dynamic Programming with State Machine</h4><p><strong>Intuition</strong></p>
<p>First of all, let us take a different perspective to look at the problem, unlike the other algorithmic problems.</p>
<p>Here, we will treat the problem as a game, and the trader as an agent in the game. The agent can take actions that lead to gain or lose of game points (<em>i.e.</em> profits). And the goal of the game for the agent is to gain the maximal points.</p>
<p>In addition, we will introduce a tool called <a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="noopener">state machine</a>, which is a mathematical model of computation. Later one will see how the state machine coupled with the dynamic programming technique can help us solve the problem easily.</p>
<p>In the following sections, we will first define a <strong><em>state machine</em></strong> that is used to model the behaviors and states of the game agent.</p>
<p>Then, we will demonstrate how to apply the state machine to solve the problem.</p>
<p><strong>Definition</strong></p>
<p>Let us define a <strong><em>state machine\</em></strong> to model our agent. The state machine consists of three states, which we define as follows:</p>
<ul>
<li>state <code>held</code>: in this state, the agent holds a stock that it bought at some point before. </li>
<li>state <code>sold</code>: in this state, the agent has just sold a stock right before entering this state. And the agent holds no stock at hand. </li>
<li>state <code>reset</code>: first of all, one can consider this state as the starting point, where the agent holds no stock and did not sell a stock before. More importantly, it is also the <em>transient</em> state before the <code>held</code> and <code>sold</code>. Due to the <strong><em>cooldown\</em></strong> rule, after the <code>sold</code> state, the agent can not immediately acquire any stock, but is <em>forced</em> into the <code>reset</code> state. One can consider this state as a “reset” button for the cycles of buy and sell transactions.</li>
</ul>
<p>At any moment, the agent can only be in <strong><em>one\</em></strong> state. The agent would transition to another state by performing some actions, namely:</p>
<ul>
<li>action <code>sell</code>: the agent sells a stock at the current moment. After this action, the agent would transition to the <code>sold</code> state.</li>
<li>action <code>buy</code>: the agent acquires a stock at the current moment. After this action, the agent would transition to the <code>held</code>state.</li>
<li>action <code>rest</code>: this is the action that the agent does no transaction, neither buy or sell. For instance, while holding a stock at the <code>held</code> state, the agent might simply do nothing, and at the next moment the agent would remain in the <code>held</code> state.</li>
</ul>
<p>Now, we can assemble the above states and actions into a <strong>state machine</strong>, which we show in the following graph where each node represents a state, and each edge represents a transition between two states. On top of each edge, we indicate the action that triggers the transition.</p>
<p><img src="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_state_machine.png" alt="state machine"></p>
<p>Notice that, in all states except the <code>sold</code> state, by doing nothing, we would remain in the same state, which is why there is a self-looped transition on these states.</p>
<p><strong>Deduction</strong></p>
<p>Now, one might wonder how exactly the state machine that we defined can help to solve the problem.</p>
<p>As we mentioned before, we model the problem as a <strong><em>game\</em></strong>, and the trader as an <strong><em>agent\</em></strong> in the game. And this is where our state machine comes into the picture. The behaviors and the states of the game agent can be modeled by our state machine.</p>
<p><img src="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_game.png" alt="mario game"></p>
<p>Given a list stock prices (<em>i.e.</em> <code>price[0...n]</code>), our agent would walk through each price point one by one. At each point, the agent would be in one of three states (<em>i.e.</em> <code>held</code>, <code>sold</code> and <code>reset</code>) that we defined before. And at each point, the agent would take one of the three actions (<em>i.e.</em> <code>buy</code>, <code>sell</code> and <code>rest</code>), which then would lead to the next state at the next price point.</p>
<blockquote>
<p>Now if we chain up each state at each price point, it would form a <strong><em>graph\</em></strong> where each <strong><em>path\</em></strong> that starts from the initial price point and ends at the last price point represents a combination of transactions that the agent could perform through out the game.</p>
</blockquote>
<p><img src="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_graph.png" alt="graph of state transition"></p>
<p>The above graph shows all possible paths that our game agent agent walks through the list, which corresponds to all possible combinations of transactions that the trader can perform with the given price sequence.</p>
<blockquote>
<p>In order to solve the problem, the goal is to find such a path in the above graph that maximizes the profits.</p>
</blockquote>
<p>In each node of graph, we also indicate the maximal profits that the agent has gained so far in each state of each step. And we highlight the path that generates the maximal profits. Don’t worry about them for the moment. We will explain in detail how to calculate in the next section.</p>
<p><strong>Algorithm</strong></p>
<p>In order to implement the above state machine, we could define three arrays (<em>i.e.</em> <code>held[i]</code>, <code>sold[i]</code> and <code>reset[i]</code>) which correspond to the three states that we defined before.</p>
<blockquote>
<p>Each element in each array represents the maximal profits that we could gain at the specific price point <code>i</code> with the specific state. For instance, the element <code>sold[2]</code> represents the maximal profits we gain if we sell the stock at the price point <code>price[2]</code>.</p>
</blockquote>
<p>According to the state machine we defined before, we can then deduce the formulas to calculate the values for the state arrays, as follows:</p>
<p>sold[i]=hold[i−1]+price[i]held[i]=max⁡(held[i−1],reset[i−1]−price[i])reset[i]=max⁡(reset[i−1],sold[i−1])sold[<em>i</em>]=hold[<em>i</em>−1]+price[<em>i</em>]held[<em>i</em>]=max(held[<em>i</em>−1],reset[<em>i</em>−1]−price[<em>i</em>])reset[<em>i</em>]=max(reset[<em>i</em>−1],sold[<em>i</em>−1])</p>
<p>Here is how we interpret each formulas:</p>
<ul>
<li>sold[i]sold[<em>i</em>]: the previous state of <code>sold</code> can only be <code>held</code>. Therefore, the maximal profits of this state is the maximal profits of the previous state plus the revenue by selling the stock at the current price. </li>
<li>held[i]held[<em>i</em>]: the previous state of <code>held</code> could also be <code>held</code>, <em>i.e.</em> one does no transaction. Or its previous state could be <code>reset</code>, from which state, one can acquire a stock at the current price point. </li>
<li>reset[i]reset[<em>i</em>]: the previous state of <code>reset</code> could either be <code>reset</code> or <code>sold</code>. Both transitions do not involve any transaction with the stock.</li>
</ul>
<blockquote>
<p>Finally, the maximal profits that we can gain from this game would be max⁡(sold[n],reset[n])max(sold[<em>n</em>],reset[<em>n</em>]), <em>i.e.</em> at the last price point, either we sell the stock or we simply do no transaction, to have the maximal profits. It makes no sense to acquire the stock at the last price point, which only leads to the reduction of profits.</p>
</blockquote>
<p>In particular, as a base case, the game should be kicked off from the state <code>reset</code>, since initially we don’t hold any stock and we don’t have any stock to sell neither. Therefore, we assign the initial values of <code>sold[-1]</code> and <code>held[-1]</code> to be <code>Integer.MIN_VALUE</code>, which are intended to <em>render</em> the paths that start from these two states impossible.</p>
<p>As one might notice in the above formulas, in order to calculate the value for each array, we reuse the intermediate values, and this is where the paradigm of <strong><em>dynamic programming</em></strong> comes into play.</p>
<p>More specifically, we only need the intermediate values at exactly one step before the current step. As a result, rather than keeping all the values in the three arrays, we could use a <strong><em>sliding window\</em></strong> of size <code>1</code> to calculate the value for max⁡(sold[n],reset[n])max(sold[<em>n</em>],reset[<em>n</em>]).</p>
<p>In the following animation, we demonstrate the process on how the three arrays are calculated step by step.</p>
<p><img src="data:image/png;base64,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oeFOoIzDhw+vHT45d+7cE7gSp3pSQD8j6XQBvRXD5s2bDylKZmam+TJZ5yjZXyYfchAbHC+gAbDejkGDI51Dr738OjWEVCPg9QGSBjXaK3S4ZHcP1/0F1pucHSvpBMSGwZJuO1LSPyKa9A+JjtnUiar6rekpp5xSe50jnct2BBCoEaj7xQUm3i2gq3jai9roo87fJPmWwM6dO83KsQ1rpSMwNNX9d7fhMbx2voB+yatfWukS3w3TzJkzzSYNokjeK6Ariuooq5SUFDM3ny/z67el1wdIdatjB0S6Te/irf9I6x9rO9ipe+zRntftTtYJxZr03h11U05OTu0/Dr169TK7NDjSBRoGDRpUe6hOStYATlfJIyGAwKEC9uIMusQ+yTcEdF6ZfsusE331RqL693L37t3mRoR681j920zybgFdDEnnlNWdq6BzdvUmsZrsQMm7a+m/pT/rrLNM5Z988klz+xNbQm8kesstt5gAmPtG2ire+agBkiaddqK9Sfp3W7/40J4k/Xvt76n+wFIv1tBvOvT+RTr+Wce+64IKmt59991GB0h2gKVvGr2efgOmNznUO0brfY/mzZtnxtTrOOt//etf5iZa+mbSrsn27dubsZv6j7/2HOm34dptqXOYdLyuTkInIYDAQQGd26e/r/pBWoe16u+s3r9MV8MaN27cwQN55rUCek+4uvM17YroMtDz58+vN6/T3sejdwiMHj3a/Pumv8N6C43ExEQz91bvMaiLcOjwdZL3CujQWP3grJ919H5XuhiHfkZ66aWXTKU0gKIHyXvbt27JdQ6hPY+w7nYdblf31jl19/nDc58JkLSxNBCxh3Xoa73Rmd27Ywc/Rxsqp6uxaJClPUD28IBWrVrJCy+8INdee6151Od20jH2OqlNe5y+/PJLs3KPLi2u//DbSe8sfvfdd9fOc7K384iAvwvo6o96z4W6Xx7ot1b6LTTJuwV08naHDh1EJwB3797dfGDW4Ru6Xb9U0g/Rded6endt/bP0emsL/TJRe4xefPHFWgRdjVInejOBv5bEa5/oisDFxcXms0/dNr7iiitE7wVJ8m4B/RutST/DDhgwwNz3Sj8D64/OG9Uv/P05BViBQ80NgNyooEPemjNb/YOsH7T0m2gdT6mBko55bzieUpeb1W9B9PgjJf1HW4OjhsPydBnEV155xfzjrqv26I20NDhqmDZs2GDufaTfmupxnTt3rrcoRMPjm/J66tSppq76x4vkmwLN/Tvim0reWysdpnLBBRfImjVrvLcSlPyoAv7yO6xfdOiHKf1iQyfta69Cw38/jwrlxTv9pY21t1+DYa1venq66S304mZrdNG1d1RXYmREQ6PJvO7Ao/0O+0wPklZS7z10uKDFbrH77rvPfnrExyNNFNdvw3QVpmMlDYj0h4QAAggggICvC8TFxZlh5b5eT3+unwa++kNCwJ8EfGqRBn9qOOqKAAIIIIAAAggggAACzS9AgNT8plwRAQQQQAABBBBAAAEEvFTAJwIkXUhBh9jpDwkBBBBAAAEEEEAAAQQQaKqAT8xB0puy6tLeBEhNfRtwHgIIIIAAAggggAACCKiAT/QgaUXCw8P1gYQAAggggAACCCCAAAIINFnAZwKkJgtwIgIIIIAAAggggAACCCBwQIAAibcCAggggAACCCCAAAIIIHBAgACJtwICCCCAAAIIIIAAAgggcECAAIm3AgIIIIAAAggggAACCCBwQIAAibcCAggggAACCCCAAAIIIHBAwGPLfLMk94m9BydPnnxiF+BsxwvwO+L4JjrhAtLGJ0zo6AvQvo5unmYpHG3cLIyOvcgnn3zi2LJRMNcKBFRbybVZcHUEEEAAAQQQQAABBBBAwDsEGGLnHe1EKRFAAAEEEEAAAQQQQMANAgRIbkAmCwQQQAABBBBAAAEEEPAOAQIk72gnSokAAggggAACCCCAAAJuECBAcgMyWSCAAAIIIIAAAggggIB3CBAgeUc7UUoEEEAAAQQQQAABBBBwgwABkhuQyQIBBBBAAAEEEEAAAQS8Q4AAyTvaiVIigAACCCCAAAIIIICAGwQIkNyATBYIIIAAAggggAACCCDgHQIESN7RTpQSAQQQQAABBBBAAAEE3CBAgOQGZLJAAAEEEEAAAQQQQAAB7xAgQPKOdqKUCCCAAAIIIIAAAggg4AYBAiQ3IJMFAggggAACCCCAAAIIeIcAAZJ3tBOlRAABBBBAAAEEEEAAATcIECC5AZksEEAAAQQQQAABBBBAwDsECJC8o50oJQIIIIAAAggggAACCLhBgADJDchkgQACCCCAAAIIIIAAAt4hQIDkHe1EKRFAAAEEEEAAAQQQQMANAgRIbkAmCwQQQAABBBBAAAEEEPAOgWBPFDMgIMAT2fpUnpMnT5Zp06b5VJ2OVZnSskopLC2X4pIK2ZqZL9uzCmT3/iLJziuRguJyKSmrkOpqkaDAAIkIC5aYyFBJjIuQlJaR0q5VjKQkREpEeIhEhQdLcBDfDRzLm/0IIIAAAggggIA/CngkQFLoav0kS2qSwNSpUyUzM7NJ53rTSWXllZJbWCZLN2TJDyt3S3Z+iYSFhlg/wZKcEC3JLaKlZ+cEiYkKk8iwEAkNCRINviurqqWsvEIKi8skt6BE9ucUyldLrfPziqXUCqJKysqlc5t4GdE7RTq1iZM46/xAK6giIYAAAggggAACCCDgsQAJegQOJ1BZWS37rUDokx82y5J1WRIZHirpqQly+vDuktQi6nCnHLKtpgcpxOpFCpHE+CjplNbykGM279gv3yzfJe98nSGVlVVy+uC2MrxXihUshZog65AT2IAAAggggAACCCDgFwIESH7RzM6vpA6P04DozS/XSWREqPTv1kZuuKSLy4KV9DYJoj+aikrKZf7yLTJ78UKJtwKkS0/vKu1TYiUoiF4l579zKCECCCCAAAIIINC8AgRIzevJ1Y5TQIfRfb9il3zw3UZpnRQrV08cJuHWMDp3pkhrXtKpQzubn22ZOfLSZ2utXqVKmTS2h3RMjTNzmtxZHvJCAAEEEEAAAQQQ8JwAAZLn7P0+54wduTL9naWS1iperr9kpAQ6YPGOtlZZrjh3kGTtL5BXPl8rkaGBcvX4XmaxB79vMAAQQAABBBBAAAE/ECBA8oNGdloVS61eo2c/WCnb9hTIr88faobUOa2MSdYiEBoordu8Rx7470I5d2S6nDIgjd4kpzUU5UEAAQQQQAABBJpZgLWOmxmUyx1dIL+oTG7957cSGRUlv5k43JHBUd0adE1PlmsvGi4//pQl099eKmUVlXV38xwBBBBAAAEEEEDAxwQIkHysQZ1cHb130ZRnf5BLzuovJw/o4OSi1itbUGCgXHRmP2kRFyP3vbhA8qylx0kIIIAAAggggAACvilAgOSb7eq4Wm3alSt/f3OJXH/xCElJjHFc+RpToJOsoG5I7/by4MsLrPsrlTbmFI5BAAEEEEAAAQQQ8DIBAiQvazBvLK4Oq3vi7WVy489PspbO9u63XPcOyTJyQEcT7FVY908iIYAAAggggAACCPiWgHd/WvWttvDJ2ugy3v/377nWggcDfaZ+3a15SR3SkuTp91dIdXW1z9SLiiCAAAIIIIAAAgiIECDxLnCpwGNvLpYR/dIlLjrCpfm4++Ij+6dLQWmVuYeTu/MmPwQQQAABBBBAAAHXCRAgHcO2qqpKCgoKGt1TUFZW1uhjj5G11+/WZbyzckplcK+2jq+LtnNZaamUlZU2uv3OGNZV3v5qvRSWVDi+fhQQAQQQQAABBBBAoHECBEjHcLrvvvskJiZG5syZc4wjRZYsWSJhYWEyc+bMYx7r6wdUWUPPHnl1oVx29gCXVrWqslKKChsfwB6uMIsXzJPuqaHSu32U9G4XJf+b8frhDjtkW1x0uPTp3Fo+nrfpkH1sQAABBBBAAAEEEPBOAQKkY7RbeHj4MY44uPvbb781L8rLyw9u9NNnRVavSmhIsMTFNN6vKVRXTDxd+neKly8+fr8pp8vundvl0vEnm3NDQ8MkIjJK2qd3bvS1tHds3srdogEhCQEEEEAAAQQQQMD7BQiQmrENQ0NDzdWio6Ob8areealXP18jowe6/l5HickpEhISYgU2kU2C+tdj95vzxp53sazYUiDLNuZKv4FDG32tqIhQaZMcJ0vXZzX6HA5EAAEEEEAAAQQQcK5AsHOL1rwl09XGdJ5JUFDQcV24oqLx80t0iJ2m+Pj448rD1w6urKqWVZv2y2nDe7q8atOffeOE8li7ZoU5//Y7H5aAgIAmXatDmwT5afN+Gdg1uUnncxICCCCAAAIIIICAcwR8ugdJg6LCwkJ5/PHHTWAUHBwsO3fuPERfA6dKay7L4ZZstoOew3141vM0gNIfPdcOvnQekj8nvT9QUFDTgo3jdVP3eu1mvX7onj/JLmvonKbS0hJZs2qZ5GTvO+yl9+7JlLj4BElOaW2uU+9ahz3j0I2tWsbItsz8Q3ewBQEEEEAAAQQQQMDrBHy2B2n27Nlyxhln1P/wbDXPunXrJDU11TSUzhVKTk6WnJyc2obTeUSjRo2qfW0/ad26tf3UPL777rty0UUX1dvWvn1787pFixb1tvvbC+1BCgxwT+x99qhesiljnSzflC/hEREmMHrhqcckKDDQanuR556cVst/98P/kssnXWeCpltvuko++/C92n090w4uQz5nyRZJad2mdt+xnuhiDfvySo51GPsRQAABBBBAAAEEvEDAPZ9i3Qyxfft2Of3002uDo0ceeUS+++47U4r58+ebR+0p0ECmbnCkO04++WTJzMw0x9T9j/YW2emWW26pDY46duxob5YtW7aY5/4eIKltE0er1Vo29on2EGmy+pHqnfLsv6bVBkejTjnL7Hvs/v+zevvKZdniH+sFR/VO1GvVaeuG+w73Oiw0WErKKg+3i20IIIAAAggggAACXibgkwHSQw89ZJrh4YcfNkHSbbfdJieddJIsWrRIJk+ebPadc845Zvhdy5YtrXvf1Ny76LrrrjP7XnnllSM2ow6ne+GFF8z+ffv2SUZGhslj8+bNRzzH33a4Z3Bd41R/WLVbXnjjY+neq5/k5eVIcVGRDB0x2izGsGRDtkTHxMqAwSNk7a5yWbe7wvy0bnN8922qtAKqoEAn1bpxNhyFAAIIIIAAAgggcKiATwZIdjXvuOMO0ZXl/vOf/5ggZuDAgaLzkDTZ9zVav369WQVNt/3jH/8QXdb7o48+qu190u1102effSb5+fnmXkcJCQm1u3R43aBBgyQuLs7cC6l2hx8+CbS6j453Lo/eoHWJdT+ied/Olk8+eEdef+nf8uK/H5dyK3g9Wiqy5phpsof0VVUf7Ol7ZcZsSWiZaPbHWIFQ3aTLeYeGhZuFGTp27trkBRr0mkXF5RITWbOCYd08eI4AAggggAACCCDgfQI+OQdp+vTp8vTTT5uFF3TxhV//+tdyzTXXyNy5c2Xo0KHWHJRS02ukvUca0NjJLBdtzWNZtmzZEVe80zlMmtLT083j4f5jB2GH2+cP24KCAi37+kPejlXv+6f80QRFDY877azx0q5Dp4aba1/rUL6Wia0k2FrqW9O2LRvNY2xcvAwcMsI81/9o79ERk17kBNK+3EJJSWjaMuMnkC2nIoAAAggggAACCLhAwCd7kAKtCfq6AIMGQhs3bpRu3bqZYGn48OFmmwZNmrR36XCr0/Xq1Uv0GppWr15tHu0eEft4e8U6s7POf3Jzc83QvTqb/O5pSHCgWcWuoPjovT91Ye568B+yckuhrNxa87NqW5Gs3l581ODIPl/nFdlpzarl5ulNf/yr1VtYEzTphoADi0YcLlDanLH+uHu87Pz0cdvuHOmc5t9Lu9f14DkCCCCAAAIIIODNAj4ZIGmDaCCjAVCHDh1kzZo10rt3b/MheP/+/RJp3VRU9+3evVtKSg6uPqYLOWRnZ0v//v0PCZzshRfsler++c9/HtLuda91yE4/2zBxTCf56scNja61BqSh1vLooaE1PyEhofUCnMZeyF5MIzrmYM+gnhsdHWMuUXmY+1qVlBQ39vKHPS5j+z7p3bHlYfexEQEEEEAAAQQQQMC7BHwuQNKFE/Q+RKeccors2LHD9BjNmzfPBEnaNPY9inr06GECpu7du4v2+ui8Iz1Hk65Sd6R03nnnmaXBdQjfhAkTzCp4a9eulbZt28qqVavMaRpk+Xsa0iNFtu7a7zaGqqqaXkF7BbromJqAyC5ASmqaebpuzUp7U7M8btqxXxJiQqVNUnSzXI+LIIAAAggggAACCHhWwOcCJO0d0lXpvvnmG0lLSzOLLowcOdLczDUlJUXi42uGQul8pAhrvtHWrVvNtnHjxplheI899pjpdTpSs+jQulmzZpndM2fONEuFa5ClS4vb6XDLhNv7/OUx1BpmN7BrssxZWDMnyFX1DrKG0elS3/YQyB59BpisCvJy62XZo1d/87pKb450IBVY85IK8vMkNa3dIT2G9jHHepy/fIucOaTdsQ5jPwIIIIAAAggggICXCPhcgKRBT15enlmRzp5HNGDAABMwaRBjb9Mhdjrc7vbbb5cuXbqYYXcLFiwwvUf2PCNtwylTpsgDDzwgSUlJtU3ap08fKbKWi37uuefkqquukj/96U+yfPly0xOlN5AdMmRI7bH+/OTSM7vJsvU7XUrwyZwVMnfFDjM0TzMaOGS4nHnOBBk5+ox6+Y4cc7p5nWQt6GCn3bt2msAqzlrQoSlp5YbdEhcVLH061ayU15RrcA4CCCCAAAIIIICAswQCrG/eD36l7qayaQDigWzdVDvXZzN16lRzM9tp06a5PrMTzGF5xl7576dr5LqLDq4od4KXbPLp+p6rG/xWWAt53H37TXL5r2+Unr1repgae/HsvGJ59eNFMuWXQyUxLqKxp3EcAggggAACCCCAgMMFfK4HyeHefle8vlbvSo/2LWTmV80796cpkHWDIz1flwa/77Fnjjs4qqyqNvWZNLYHwVFTGoJzEEAAAQQQQAABBwsQIDm4cXylaL8+t5cUl5TKl/PX+0SV3vpsqYzul2rmWPlEhagEAggggAACCCCAQK0AAVItBU9cJaD3Yb3jqiGyZ5+1WuCcmvtKuSovV163rLxSXv5wkQzs0lLOGsrCDK605toIIIAAAggggICnBAiQPCXvZ/kGBQbIXycNlfDgannuvfleV/vM/QXywoz5MnZYWzl3ZAdrLpPXVYECI4AAAggggAACCDRCgACpEUgc0jwCgVaQdP0FfWXs8Hby1NtzZcsu77hf1LeLN8qML5fLTRf2lRG9WxMcNc/bgasggAACCCCAAAKOFAh2ZKkolE8LnDIgzczfueeFHyQ6KlwuP2egBDqwS2ZnVp588t1P0iElRu6/dqSEhwb5dLtQOQQQQAABBBBAAAFrIS8QEPCEQGxUqDxy08my4KdMefqtudI2JV7OPbmndZ8qz49dy7KG033xwzprKfpKuf783tI+JZZeI0+8ScgTAQQQQAABBBDwgAABkgfQybJGQOclDe+VIv27JMq8lbvkaWvYXVx0uJw2tIu0Top1O5Pe+HXBqq0SYpXrFz/rJp1S4yUoyPMBm9shyBABBBBAAAEEEPBjAQIkP258p1Q9PDRYTh3YVkb2SZWNO3PlrdnrpLC4wgRJg3u2lZTEGJcVde3mPbJk7Q7Jzi2W7u1ayE0T+0hKQpRo8EZCAAEEEEAAAQQQ8D8BAiT/a3PH1jgsJMi6qWyC3PWrYZJbWCprt2TLrIXrZV9eiUSEhZiAqWNaS2nXuoWEBh//fKC8whLZsjNbMrbvNQFRUUm59EhvIZed3llSW0ZLZDi/Do59c1AwBBBAAAEEEEDATQIB1VZyU1612QRYE/IHDBhQ+5onxyewZ88eufTSS2XatGnHd6KXHl1UWiH5hWWyYUeOrNy03wROWpUQK0gKDg60env0J+DAPKEAqdb/VVVLpfmpkoqKKimrqJSYiBArIEqQPh1bSmpitMREhTQp0PJSRoqNAAIIIIAAAggg0AgBjwRIixYtakTROORoAq1atZK0tLSjHeLT+0qtm7aWllWawEcDIA2GqjTWt/6vAbgVM5nAKcQKoEKtnintndLnJAQQQAABBBBAAAEEjibgkQDpaAViHwIIIIAAAggggAACCCDgKQG+UveUPPkigAACCCCAAAIIIICA4wQIkBzXJBQIAQQQQAABBBBAAAEEPCVAgOQpefJFAAEEEEAAAQQQQAABxwkQIDmuSSgQAggggAACCCCAAAIIeEqAAMlT8uSLAAIIIIAAAggggAACjhMgQHJck1AgBBBAAAEEEEAAAQQQ8JQAAZKn5MkXAQQQQAABBBBAAAEEHCdAgOS4JqFACCCAAAIIIIAAAggg4CkBAiRPyZMvAggggAACCCCAAAIIOE6AAMlxTUKBEEAAAQQQQAABBBBAwFMCBEiekidfBBBAAAEEEEAAAQQQcJwAAZLjmoQCIYAAAggggAACCCCAgKcECJA8JU++CCCAAAIIIIAAAggg4DgBAiTHNQkFQgABBBBAAAEEEEAAAU8JECB5Sp58EUAAAQQQQAABBBBAwHECBEiOaxIKhAACCCCAAAIIIIAAAp4SIEDylDz5IoAAAggggAACCCCAgOMECJAc1yQUCAEEEEAAAQQQQAABBDwlQIDkKXnyRQABBBBAAAEEEEAAAccJECA5rkkoEAIIIIAAAggggAACCHhKgADJU/LkiwACCCCAAAIIIIAAAo4TIEByXJNQIAQQQAABBBBAAAEEEPCUAAGSp+TJFwEEEEAAAQQQQAABBBwnQIDkuCahQAgggAACCCCAAAIIIOApAQIkT8mTLwIIIIAAAggggAACCDhOgADJcU1CgRBAAAEEEEAAAQQQQMBTAgRInpInXwQQQAABBBBAAAEEEHCcAAGS45qEAiGAAAIIIIAAAggggICnBAiQPCVPvggggAACCCCAAAIIIOA4AQIkxzUJBUIAAQQQQAABBBBAAAFPCRAgeUqefBFAAAEEEEAAAQQQQMBxAgRIjmsSCoQAAggggAACCCCAAAKeEiBA8pQ8+SKAAAIIIIAAAggggIDjBAiQHNckFAgBBBBAAAEEEEAAAQQ8JUCA5Cl58kUAAQQQQAABBBBAAAHHCRAgOa5JKBACCCCAAAIIIIAAAgh4SoAAyVPy5IsAAggggAACCCCAAAKOEwj2RImmT5/uiWx9Ks+BAwfKqFGjfKpOx1OZ3IJSyS0sk/yicikuLZey8kqpqKyW6upqCQwMkOCgQAkLDZKo8BCJiQyRuOgw8/x48uBYBBBAAAEEEEAAAf8TCLA+UFa7u9oBAQFy0003uTtbn8lvyZIlMmLECJk2bZrP1OloFcnKKZZtmfmycVeebNmdJ9v3FFjBT7BERYRKRFiIhFrPQ4ODTGBkvbWsIEmsYKlKyq2gqaSsQopLyqSguMwKmgKkXXKMpLeONT9tk6Ot4Cn0aFmzDwEEEEAAAQQQQMDPBDwWIHkgLvOZpp06dapkZmb6dIC0cWeuLM/YK0vWZUm51TOU3CJaWifFSkpijCQnxJgeouNt0KKSctmzL1927c2T3dbjnv0FkpIQKYO6JUvP9ARpZT0nIYAAAggggAACCPi3gEeG2Pk3ObU/kkCONWxuwU+Z8s2S7VavUKh0SEuQc0b3koTY5glcIq3hdultEsyPXYbtmTmydnOWfLFgm7SMC5NT+qdJn04tJTQkyD6ERwQQQAABBBBAAAE/EiBA8qPGdmpV9+YWy5cLt8mCNXukY5uWMv6UPpIQ1zxB0bHqnNYqXvRH0+ad+2X20p3y3pwMOWtIWxnWK0XCreF7JAQQQAABBBBAAAH/EeDTn/+0teNqqgsrfDxvs3y3Ypf07dparr1wuOj8NE+l9FSrd8n6yckvlnnLNsssK2gbf1JHGdQ9WYKshR9ICCCAAAIIIIAAAr4vQIDk+23syBqu25YtT81YIZ3bJno8MGoIFB8TIWNH9ZB9OYXy5YIN8u2yHTJpbA9JjI9oeCivEUAAAQQQQAABBHxMgADJxxrUG6rz1uz11gIM++TCM/taCyPEOLbILeOj5KIz+8ny9bvkkdcXy0WndJahPVo5trwUDAEEEEAAAQQQQODEBQiQTtyQKzRSQIfU/eOdZVIpgTLpvCGNPMvzh/Xt0lraWvOU/vfNKsnKLpKzh6cz5M7zzUIJEEAAAQQQQAABlwgEuuSqXBSBBgJ6P6K/vfijJLeMlwtO69Ngr/NftoiNkMvGDpDVW/LkjVlrpbLK7bcPcz4SJUQAAQQQQAABBHxAgADJBxrR6VWosu7c+sB/F0jvLqkyvF97pxf3iOULsW5GO+G03rI7u0ze+3rDEY9jBwIIIIAAAggggID3ChAgeW/beUXJrdjIDKtr17qlDOyR5hVlPlYhx43uKWu25crX1v2aSAgggAACCCCAAAK+JUCA5Fvt6bjafLN0u2Tnl8mYwZ0cV7amFijQWvL73JN7ykdzN8u2PflNvQznIYAAAggggAACCDhQgADJgY3iK0UqKqmQGdZNV39x7iBfqVJtPWKiwuTUoV3ktc+Zj1SLwhMEEEAAAQQQQMAHBHwuQKqsrJSJEyfKjz/+2GzN891338mwYcNk8+bNx7xmbm6u3HrrrbJx48ZjHuvrB/zno1Uyom+646tZkJ8n77z2H7nrTzfKvX+5WbZt2dSoMndplyjVAUGycE1mo47nIAQQQAABBBBAAAHnC/jcMt/79u2TGTNmSGFhoXz22WfN0gLz5s0zAZcGSOnp6Ue95qxZs+TRRx+VIUOGSMeOHY96rC/vLLWW9F6/I1fOGtXbpdX88L3X5R+P/k2ee/VDaZt+/N5lZaVy4dnDZVPGutpyDhp2krRt36H29dGeDOvTXmYvypBhPVOOdhj7EEAAAQQQQAABBLxEwOd6kGJjYw390qVLPdIEGqBpCgoK8kj+Tsn0m6U7pFv7JJcX5/mnHjPBzdLFTesxfOuV5835LZOS5ZlXPpAFa/bIuRN+3uhyp7WKk5Lyatm8K6/R53AgAggggAACCCCAgHMFfK4HKSwsTAICApo1QKnWpdgamVatWmWObNOmTSPP8L3DlOvTHzbLL88f6vLKvfDmJ/Lj3G/k1DPHNSmvWZ/ONOc99uQrMuLk05p0jU5pLWXlxn2S3romOG/SRTgJAQQQQAABBBBAwBECPteDVFxcLBrQjBgxotmAj2c+k86B0nQ8QVWzFdQhF6qorBK9j2pEWIjLS9QiIVF+Nu5CCbUCYztt3ZwhOnROk7ZDcVGhVFZW2LvrPe7L2iPBwSHSf9CwetuP50Wb5DjZuDP3eE7hWAQQQAABBBBAAAGHCvhcD1JgYE3MV1paKhUVFTJz5kwzFykiIkKuvvpq6du3b72m2Lt3rzz99NPy+uuvm+PHjh0rv/rVr6Rfv361x9nD5SIjI2u36RM996mnnpI333xT9PqXXHKJ7N+/3xzTunXresf60wsNkIKspbDdkT753zuStXuXXHH1TaJtv2vHNjljeDe5bcqDcrYVOF114ZmyY/sWE0DNnLVIOnXpLlVVVbJxwxrZvzdLcrL3We1eLu++8aIVVJVJi4SWZohdaOjBgOtY9WgZFymZ2UXHOoz9CCCAAAIIIIAAAl4g4HMBkm2uPQedOnWSrVu32ptk+vTpUlBQIFFRUWZbdna2dOjQwWyLi4szw/KeeOIJ0Z9ly5YdEkzFxMTUXmvNmjUyfPhw0VXrwsPDpaSkRBYuXFi7PyTE9b0ntZk57EmVZa/DHN2RHr7nT7Jz+1a5+IqrrSD1YAA7//tv5N/TH5a83ByJjWthPWbLbb+dJO98Mk+WLJwnl503pl7x7r3j97Wv+w0cKh07d699fawnEeGhUlBcfqzD2I8AAggggAACCCDgBQI+N8TONv/4449NcNS9e3cTuPTq1cvs2r59u32ICXA0YLruuutEF1fQn7vvvtvsnz9/fu1xDZ9o8DV+/HgTHN17772Sn58v2mN1xRVX1B5qB2G1G3jiVoE5sz81wdGU+58wCy+079BZVi5bJEWFBZLWroMZUtdv4DATFCclp8hLb38uH3y5SL5emHFcwZFWKsDqLbPeEiQEEEAAAQQQQAABHxDw2R4kbZu2bduKLpqgQ6/uu+8+ueCCC2Tbtm3SrVs3ycvLM/cq6tGjhzz55JOivUn6aAdIdkB1uDb+4YcfZMOGDfKXv/xFpkyZUnvIyy+/LCtWrJCVK1e6rQelNnMHPQm0eo+Odw6WHq/Biw5/0/lCOjxSn2vwcrTeqHJrWJymw/VX3fTHv8qV1tA7TXHxLcyj5tMqJVXe+uh7KS8vl+G9Uqxhdz1k+KhTj5qPOfkI/yktrbDmW/n3qoVHoGEzAggggAACCCDgdQI+HSCtXr3aBEfaKvaHbPtxzpw55kO49gDdeeedcv/995vGS0lJMfcxGjly5BEbU28cq0nnHDVMOrQuOjpaGs5XanicL7/W+UdVukrDcaR/Wvcy+se0ew8549PvV0nHTt0O2W5v0PlDLRNbSciBOUNbNm8wu4KCguWX195sH3bUxzbt2te+P4564BF25uQXS2JcxBH2shkBBBBAAAEEEEDAmwR8NkAaM2aMCVTsxrB7NDRoOv30080CC7rv4osvNoekpaWZHqHrr7++Nqiyz9VzNNkLQISGhprX9qN5Uec/Oi+pqKhIjrS/zqE++TQ4KNBaxa7aBEmBjVysYex5F5sFE7QvSBe8SGiZJAmJSdKufcdjGhUXF9b2WOkqhprOu/Byq9coofZcXYBBU3l5zWPtDutJpdVbdSJp1748adfq4Py0E7kW5yKAAAIIIIAAAgh4VsBnAyTtxambdC6Sph07dpjHxMRE85iQkCDPPPOMTJw4sV4vQkZGhrRv395aAjq49sN3fHy8Ocf+jw6n69mzp/3SPOqwME12QGZe+Nl/NCga3D1Zlq7dIQN7pDWq9p279hCdL9SUFBISWtt2mzasNZcYPPzkepeyg9WS4kNXm1u/drVpL7t3sd6JjXixafs+OWd420YcySEIIIAAAggggAACThfwuUUajhSYxMbGmg/R8+bNM22iy31rj5AGNIMHD64NaLTn54UXXpDOnTvLBx98cNj20wUaNHC69NJLRe+RpPc+0kUadLnwxYsXm3N0Do0/p4tO7SLzV2x1I0H9IX2pbeoHLJGRNSsX7tq5vVnLpMPr9ucWSZ+ONQF3s16ciyGAAAIIIIAAAgi4XcDnAiRdPEFTu3bt6mG2atXKBDW6FLcGNLp/yJAhkpOTI+np6WY1M+1l0NXn9H5JOoeo4T2T7At27NhRJkyYYF4OGzbMXFeX+r7hhhvsQ2qH8NVu8LMn4SHBEhIUILv25ru45gGSn5dj7mGkGdmB0U7r3kd1ky7EoGnfvqzazVVVlVaAXCknsiT7gpXb5OS+qbXX5AkCCCCAAAIIIICAdwv4XIDUpk0bc2+j3//+4H1ttIn0Zq96ryPtMbJ7mXQ1Ou0t0mBJ92kvk85Fuuyyy2TPnj2mF0nPTUpKEg2w6i7d/fbbb5uheZqfDr3TIXva66S9SHo9f16kQc30Nki3Xj5I3vtyub50WRo5+nRrMYbfW/eiqlkkoY21hHd0TKz1E1cvzz4DBpvXwdbiDXbK3rdXCq1l3rv16FM7RM/e15jHrOxC2bhjr5w5tH4w3phzOQYBBBBAAAEEEEDAmQIBVrBQf2ySG8qpcz08kK0bauaeLKZOnSqZmZkybdo092R4Ark8OWO5WWHulMGdT+AqzXNqfn6exFjBk530BrPnnT5Qfn3DH+XGW+6wNzfqsdIKtN/6bKmMG9leBnZNbtQ5HIQAAggggAACCCDgfIGDX6c7v6yU0AsFrju/j/z5qe+ka7skSU2u36vj7urUDY4079S0drJw7d4mFePrBRnSLjmK4KhJepyEAAIIIIAAAgg4V8Dnhtg5l9o/S6b3RHrw+pPk/a9WSlFJuU8gLP5pu+TmFcgvz6m/gqFPVI5KIIAAAggggAACfi5AgOTnbwB3VF/vi/R/k4bIf2b+KPmFJe7I0iV56GDURau3y5qNu+X3l/R3SR5cFAEEEEAAAQQQQMCzAgRInvX3m9wT4yLk7l8Pk1c/WiQbtjZtWJsnsXTO0efz1sqWHVnylysHS3goo1M92R7kjQACCCCAAAIIuEqAAMlVslz3EIH46DCZ9rvR8vXC9fLxdz9JRWXNTXUPOdBhG4pKyqzAbrFEhFTL7VcMltCQIIeVkOIggAACCCCAAAIINJcAAVJzSXKdRglYq3/LwzeMkoToIHnqze9lb3ZBo87zxEHaa7TYGlL30gcL5IKTO8jV43p5ohjkiQACCCCAAAIIIOBGAcYJuRGbrA4KXPmzHnLeSZ3kwZcXWDdqDZaLz+wnEeEhBw/w4LOqqmrZujvbDKlLT4mVh6xFJug18mCDkDUCCCCAAAIIIOBGAQIkN2KTVX2BuOhQeeiGk2TZhr3y8ocLrSAkWCac1ktioyIk0Fr9zt1Jh/xlbNtrDQHMkISYMLn9F4MlMS7c3cUgPwQQQAABBBBAAAEPChAgeRCfrGsE+nVOlH6dR8n6bdny/EfLpbikQvp2S5WhvdtJaHCQS4OlSisoyi0okTmLMmRnVp50aB0rU6wV9+Ks+VIkBBBAAAEEEEAAAf8TIEDyvzZ3bI27tG1hhrNpAT/4bqM19+dHKS+vkrYp8TKgR5q0ToyRoMDAJgdM1dY63VX6Yw2hW7c5SxZZ9zPSZcejI0Pl/FEdZUgPlu527JuDgiGAAAIIIIAAAm4S8FiAVFDg3Mn5brJvcjZlZWVNPtdbTjzPClj0R9OS9Vny1aIt8lFWgQluKq0AJyUx1gRMSQnRVm9PhERHhJp5Qjo0T3uFSssqJL+oTPbnFUnW/gLZkZUrufnFJrjSIKtPx5Zy7Xk9pW1yjLeQUE4EEEAAAQQQQAABNwgEWN+qW7e/dG+Kiopyb4Y+mNvNN98sDz74oA/WrHFV2rgzV/Rne1ahtRJekeRZwVBxaYUJoPTGtJHWgg/x1hynVglR0rZVtHRqEy8pCZGNuzhHIYAAAggggAACCPitgEcCJL/VpuIIIIAAAggggAACCCDgaAHug+To5qFwCCCAAAIIIIAAAggg4E4BAiR3apMXAggggAACCCCAAAIIOFqAAMnRzUPhEEAAAQQQQAABBBBAwJ0CBEju1CYvBBBAAAEEEEAAAQQQcLQAAZKjm4fCIYAAAggggAACCCCAgDsFCJDcqU1eCCCAAAIIIIAAAggg4GgBAiRHNw+FQwABBBBAAAEEEEAAAXcKECC5U5u8EEAAAQQQQAABBBBAwNECBEiObh4KhwACCCCAAAIIIIAAAu4UIEBypzZ5IYAAAggggAACCCCAgKMFCJAc3TwUDgEEEEAAAQQQQAABBNwpQIDkTm3yQgABBBBAAAEEEEAAAUcLECA5unkoHAIIIIAAAggggAACCLhTgADJndrkhQACCCCAAAIIIIAAAo4WIEBydPNQOAQQQAABBBBAAAEEEHCnAAGSO7XJCwEEEEAAAQQQQAABBBwtQIDk6OahcAgggAACCCCAAAIIIOBOAQIkd2qTFwIIIIAAAggggAACCDhagADJ0c1D4RBAAAEEEEAAAQQQQMCdAgRI7tQmLwQQQAABBBBAAAEEEHC0AAGSo5uHwiGAAAIIIIAAAggggIA7BQiQ3KlNXggggAACCCCAAAIIIOBoAQIkRzcPhUMAAQQQQAABBBBAAAF3ChAguVObvBBAAAEEEEAAAQQQQMDRAgRIjm4eCocAAggggAACCCCAAALuFCBAcqc2eSGAAAIIIIAAAggggICjBQiQHN08FA4BBBBAAAEEEEAAAQTcKUCA5E5t8kIAAQQQQAABBBBAAAFHCxAgObp5KBwCCCCAAAIIIIAAAgi4U4AAyZ3a5IUAAggggAACCCCAAAKOFiBAcnTzUDgEEEAAAQQQQAABBBBwpwABkju1yQsBBBBAAAEEEEAAAQQcLUCA5OjmoXAIIIAAAggggAACCCDgTgECJHdqkxcCCCCAAAIIIIAAAgg4WoAAydHNQ+EQQAABBBBAAAEEEEDAnQIESO7UJi8EEEAAAQQQQAABBBBwtAABkqObh8IhgAACCCCAAAIIIICAOwUIkNypTV4IIIAAAggggAACCCDgaIFgT5QuICDAE9n6VJ6TJ0+WadOm+VSdjlWZXfsKJWNHrmzelSfZ+aVSUFwmRaUVUlpWKeUVVVJZWSXV1kX0/RUcFCChwYESHhYskeEhEhMRIkktIqVD61jpkhYvsVGhx8qO/QgggAACCCCAAAJ+KOCRAEmdq6v1oyypKQJTp06VzMzMppzqVefsyS6SBT9lyrptObLbCo5CQ0OkTXKspCTGSutWiRIRHirhocESGhIkwVYwFBgQaAVHNe+tyqpqK2iqlLLySikpLZeiknLJziuSb1fskTe+XGedFyStW0ZJ306JMrh7srmOV+FQWAQQQAABBBBAAAGXCHgsQHJJbbio1wsUFJXL7MXbZHnGXiksqZRu6cnSv0c7aRkfJRFhIY2qn92DFBwUaM6Jiw4353Vok1B7fl5BiezNKZRlG/fK+99ulNSWkTKsZ4oMtX5CrGCLhAACCCCAAAIIIOCfAgRI/tnujqv1lt158tHczaa3qF+3VDl1aDdrSFy06RFyRWFjraBJfzqmtTTD83bvzZOF63fJh3M3yYCuyTJ2eHuJiWQYnivsuSYCCCCAAAIIIOBkAQIkJ7eOH5RN5xW989V62bWvWE4a0EFOG95DgqyeH3cm7TFqmxJvfvILS2VVxm65/78LZKAVKI0bmW7mMLmzPOSFAAIIIIAAAggg4DkBAiTP2ft9zq98tkYWrd0jZw7vKj8bleSy3qLjgY6JCpPhfdtL366psmTNdrn/pQVy9rD2cnL/NsdzGY5FAAEEEEAAAQQQ8FIBAiQvbThvLvbWzHx5/sNVkprcQq65cLg15yfIcdXRle9O6t9BenRoJbPmr5Pl1lylq87uwbA7x7UUBUIAAQQQQAABBJpXwL1jmZq37FzNCwXmrtgpU19bJGOGdJHThnZ2ZHBUlzUhLlIuPrOftIiPk0deXSQ7sgrq7uY5AggggAACCCCAgI8JECD5WIM6uTozv82Qj3/YKldfMEzatop3clHrlU1XxRvSq62MHtxZnpyxQlZv2ldvPy8QQAABBBBAAAEEfEeAAMl32tLRNXnfCo6WbdgvV40fLFER3rk6XHpqgowf00te/WKd/LRlv6O9KRwCCCCAAAIIIIBA0wQIkJrmxlnHITB/9W7rhq9Zctk5A62FGKw7uXpx0vsxnTu6l7zy2Vpr5b1CL64JRUcAAQQQQAABBBA4nAAB0uFU2NZsApn7i+S1z9fKZWMHNNs1PX2hpBZRMtJawOHfM1dIcWmFp4tD/ggggAACCCCAAALNKECA1IyYXKq+QFVVtUx/Z6lMPKOvhIX61oKJXdsnSZtWLayb226qX2leIYAAAggggAACCHi1AAGSVzefsws/d+Uua75RuKQmxTq7oE0s3Yi+6bJwbRYr2zXRj9MQQAABBBBAAAEnChAgObFVfKBMlZVV8tbs9TL+lF4ur83yJT/KLdddLqcO6WQtHd5Fbr7mUlm2+EeX56u9YgN7pMmn87e4PC8yQAABBBBAAAEEEHCPAAGSC52nT58uX331lQtzcO6lt1g3g02IjZBwFw+t+9+MN+TS8aPl45lvyY5tW2T71k3y6f/ekYvPGSnzvnO9fa9OKbJ2W47kF5U5tzEoGQIIIIAAAggggECjBQiQGk11fAeWlZXJnXfeKTfeeKNUVVUd38k+cPSbX66zbgbb2aU1ycvNlim3Xi8VFRVywy13yNKMHFm9rVh+d+udJt/rrzxf8nJzXFqG0JAgad+6hbWE+V6X5sPFEUAAAQQQQAABBNwjQIB0FOdVq1ZJRkbGUY448i57OeudO3eaD/BHPtL39lRYw+t2W6vXpSXHubRyD951mxQVFsiVV/9W/nD7PRIZFS3BISEmQBpzxlgpLi6S7+fMcmkZ9OIaIK3dmu3yfMgAAQQQQAABBBBAwPUCXr20mPbMfPrppzJ27Fhzf51FixbJhx9+aHps7rrrLgkMPBj/5ebmyueffy55eXmSmpoqo0ePlqioqEOEFy5cKO+++668//77smbNGrO/qKhIIiIiao/dsGGDfP/99ybw6dWrlwwePFiCg2so58yZI7NmzZIQ64N6SUmJOee+++6T6upqGTZsmIwbN672Or76pKKyWoLq2LuqnnNmf2oufeMf7hDrDVAvmxtv+T/5ZtYn8tH7b8rY8RfV29fcL5JaRMuS1Vub+7JcDwEEEEAAAQQQQMADAl4dIGnvzrnnnisPPPCAfPPNN/LZZ5/VEkZH6IPjowAAC49JREFUR8ttt91mXr/22mty1VVXSWVlZe1+fTJ79mw59dRTzbbs7GwTwKxfv77eMfpCgys7QLrlllvkiSeeqHdM586d5euvv5Y2bdrIPffcY66rB9hB09/+9jdzfO/evU157d6lehfxoRe6vHdgg4CluatXbg1hzM/LlY6du0mLhMRDLt+1ey8JCw+X/XuzTHDqSvOYqDDJKSg9pAxsQAABBBBAAAEEEPA+gYNdLN5XdtGeHU133HGHCY7OP/98efrpp802DZg06RA3Ozj6/e9/L2+99Zb89re/Nb1Ll1xySe38IO2F0uBIAyENgtatWycXXnihuYbOJ9L00EMPmeBIA6HHH39cXnzxRTnjjDNEe5T0upr+/ve/m8Ds5ptvlsjISAkKCpI//OEPJoh79NFHTU+XOdCH/1Mt1VaPjmsrqHlor1xK6zb1egrtXEPDwqxerCDZlLGuto3tfc39GBIcJGUV/jfPrLkduR4CCCCAAAIIIOAEAa/uQbIBtXdgxowZogGSfmi+4YYb7F0yYcIE03Nk9xYVFhbK4sWLzf66Q/A2baq54ef8+fNFe3r0mtrzlJWVZXqGtPdJg6Jwq1dCh+GlpKSYwEiP0WT3UPTt21ceeeQRs+3jjz+WPXv2mMAqNDTUbPOH/wRodGTFSO5IukDD0VKHTl0PG0Ad7Zzj3VdhBUchwV79XcPxVpnjEUAAAQQQQAABnxXwiU91F198sQmOtJU0UNEA6cEHHzSNtnTpUomNjZX+/fuLDnVLSEgwAUuY1cOgc4XsIMkeDqcBTqtWrUyvz65du0xwpBdavny5ZGZmypQpU8yQu9/85jfSpUsXM69p6NChMmnSJJNfw/9o75M9F6nhPl99HRgYIFVWoOrKpIGw5lBUVGiC4oZ5Ze/fJ6WlNXPAGu5r7tf5RSUSHx3W3JfleggggAACCCCAAAIeEPCJAGnixIn16P71r39Jnz59zDb9IK0LMyQlJZllt+0hbzrnyD5GD9Seo0svvVTi4+NNr5H2FqWnp8uyZcvMdbQnSdPLL78s3bt3l+eff1769etnepnmzp0rLVq0MPvr/kcXgdDg6Fi9HHXP8YXnwUEBUunipc3DwsLNIhtrf1px2EBowbw5puew74Ahtb17rrLNyi6U1MRDF/xwVX5cFwEEEEAAAQQQQMB1Aj4RIGmwc7ikgYkGSJpat25tepU0WHrsscdEe5DqprS0NHn99ddFr7V161bR+UmafvnLX5o5LLt37zavdWW7kSNHygcffGCG6l122WVmnpHZ2eA/OgfJH1NwUKAkxUfIrqw8l1Y/KTlFdLGGHVs3H5LPf5/7p9k26pQzD9nX3Bu27MqWru0ODZCbOx+uhwACCCCAAAIIIOB6AZ8IkI7EpMPm7CF0K1askD//+c+1K8vpOZdffrkZSqfzknTZbvuGrm3btpU33nhDYmJiZPXq1VYPRan07NnTZKNLdeuKdePHj6+9tgZPutS3bifVCFxyelf5euEGl3Jc/quauWa3/naSlB5YUl0z/PKzD2TJwnkSZLV/736DXFqG8opK2bJzv/TrnOTSfLg4AggggAACCCCAgHsEfGKRhqNR6dyg5557ziyqoPdG0qFwOTk58swzz4guzDBixAgTKGmP0EUXXWRea1Cl85Py8/PNfCRdYEEDoPbt25uheGPGjJGf//znZpU6vcZTTz1lrqk9T6QagY6tY2VvTpGUlldKWEiQS1gun3S9PPnY/bJq+WI5Z0wfmfjzSbJ922Z59/UXTX63T3lI4lu0dEne9kVXb8yUzm3iJC7KfxbhsOvOIwIIIIAAAggg4IsCXh0g2cPndGW5I6Vnn33WzAPS1eZ0OfC6SVe4e/XVV03vkd5D6Z133jE/9jE6DE9vGKvzljTpXCOdp/Ttt9/KvHnz7MMkMTHRLN7wi1/8onabPrHLV2+jn7zQYXYTx3SSj+aslomn18wHc0XVZ3yxQK6/aoKsWLpQnnjk7tosLpt0nVx1zc21r13xpMwK/hat3i43TujtistzTQQQQAABBBBAAAEPCARYH+Jdu9zYYSqlK801R7Z6H6Trr7/ezCnSIOVoSecWffnll6K9QTo3SIfK6RA6O+kwO12WW3uOdKjdKaecIrr4g32DWPs4fdT7HmmwpNdp166dDBgwQEJCQuoeYp7/+9//Fr3uH//4x0P2nciGqVOnmhX1pk2bdiKXcfm5ldYNY//6zFwZN6a3JCdEuzS/rZsyZN/ePeZ91b13P6ttXL9owpzFGyU6tFp+bg0nJCGAAAIIIIAAAgj4hoBXB0i+0QTHXwtvCZC0Zjv3FsrDry6Uay8cLqEhXt1hWa+hMrbtk++XZMhfrhwskeGHBsf1DuYFAggggAACCCCAgNcI+PQiDV7TCj5cUF3++qJTu8gbny71mVruzy2SbxdnyHUT+hAc+UyrUhEEEEAAAQQQQKBGgACJd4LLBU7umyq9O7SQN60gqTmGVrq8wEfJICe/WD74eqVcdkZXSUty7bDBoxSDXQgggAACCCCAAAIuEiBAchEsl60voPN0uqbFyCsfLpLikvL6O73k1fbMXHl/9gq55LTO0ruja1fH8xISiokAAggggAACCPicAAGSzzWpcyuk90Y6dUCqPPveD7J7X75zC9qgZNrrtWTNDvli3hq59rze3POogQ8vEUAAAQQQQAABXxLwnVnzvtQqPlyXUwe1lfbWPZJe+HCVdGyXLCP6thddEtypKbegRGb9sE7CrN+U268YzP2OnNpQlAsBBBBAAAEEEGgmAed+Mm2mCnIZ5wl0TI2T+64dKZVlJfLMO/Nky65sa26Ss8pZUlohC1ZulXe/WCqDu7WUP/x8AMGRs5qI0iCAAAIIIIAAAi4RoAfJJaxctDEC11jD1XZkFcjrs9bKVz+ul1OHdJG0lDgJCvRc3F5YXCZrN++xhtRtl17pCfJ/k4ZKdATLeDemPTkGAQQQQAABBBDwBQECJF9oRS+uQxtrJbhbLxskG3fkyszvNsqHc1bLkF5tpXO7RGkRFykBbqhbRWWV7M0ulOXrd8rWnfvNAgx3XDlEYqNC3ZA7WSCAAAIIIIAAAgg4SYAAyUmt4cdl6dgmzgxjyyssk0/mb5ZPvl0lZZXV0rtza2mXEi/xMRESFtp8b9fCojLJKSiWdVuyzE9iXLgM7dFKrhnXXUKDPdeD5cdvAaqOAAIIIIAAAgg4QqD5PnE6ojoUwtsFtNfm56d1NdXYta9Q5q7YKd8t3iD7coslMiJM2lrBUpvkOGvYW5gJmMJCg6xFHvQnUAIDa/qbdNW5qqpq0Z6h8opKKSuvlJLScsm27mGkS3VvteY8BQcFSGJ8uFmR7sozh0uErsJAQgABBBBAAAEEEPB7gQDrw6Tbp8cHBLhj4JRvt+3kyZNl2rRpvl3JBrXbbs1XWrs1WzK250puYakUWwsplJTVBEAaDGlQpG9mfXvpPKYQqycoNCRIwq0gKjI8RJLiI6RLWrz0aN9C4qLDGlydlwgggAACCCCAAAIIWJ8lPREgAY8AAggggAACCCCAAAIIOFGAyRZObBXKhAACCCCAAAIIIIAAAh4RIEDyCDuZIoAAAggggAACCCCAgBMFCJCc2CqUCQEEEEAAAQQQQAABBDwiQIDkEXYyRQABBBBAAAEEEEAAAScKECA5sVUoEwIIIIAAAggggAACCHhEgADJI+xkigACCCCAAAIIIIAAAk4UIEByYqtQJgQQQAABBBBAAAEEEPCIAAGSR9jJFAEEEEAAAQQQQAABBJwoQIDkxFahTAgggAACCCCAAAIIIOARAQIkj7CTKQIIIIAAAggggAACCDhRgADJia1CmRBAAAEEEEAAAQQQQMAjAgRIHmEnUwQQQAABBBBAAAEEEHCiAAGSE1uFMiGAAAIIIIAAAggggIBHBAiQPMJOpggggAACCCCAAAIIIOBEgf8HQZyrF+MTQg8AAAAASUVORK5CYII=" alt="Current"></p>
<p>1 / 7</p>
<blockquote>
<p>As a <strong><em>byproduct\</em></strong> of this algorithm, not only would we obtain the maximal profits at the end, but also we could recover each action that we should perform along the path, although this is not required by the problem.</p>
</blockquote>
<p>In the above graph, by starting from the final state, and walking backward following the path, we could obtain a sequence of actions that leads to the maximal profits at the end, <em>i.e.</em> [<code>buy</code>, <code>sell</code>, <code>cooldown</code>, <code>buy</code>, <code>sell</code>].</p>
<iframe src="https://leetcode.com/playground/G3tLgwPY/shared" frameborder="0" width="100%" height="378" name="G3tLgwPY" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li><p>Time Complexity: O(N)O(<em>N</em>) where N<em>N</em> is the length of the input price list.</p>
<ul>
<li>We have one loop over the input list, and the operation within one iteration takes constant time. </li>
</ul>
</li>
<li><p>Space Complexity: O(1)O(1), constant memory is used regardless the size of the input. </p>
</li>
</ul>
<hr>
<h4 id="Approach-2-Yet-Another-Dynamic-Programming"><a href="#Approach-2-Yet-Another-Dynamic-Programming" class="headerlink" title="Approach 2: Yet-Another Dynamic Programming"></a>Approach 2: Yet-Another Dynamic Programming</h4><p><strong>Intuition</strong></p>
<p>Most of the times, there are more than one approaches to decompose the problem, so that we could apply the technique of dynamic programming.</p>
<p>Here we would like to propose a different perspective on how to model the problem purely with mathematical formulas.</p>
<p>Again, this would be a journey loaded with mathematical notations, which might be complicated, but it showcases how the mathematics could help one with the dynamic <em>programming</em> (pun intended).</p>
<p><strong>Definition</strong></p>
<p>For a sequence of prices, denoted as price[0,1,…,n]price[0,1,…,<em>n</em>], let us first define our <strong>target</strong> function called MP(i)MP(<em>i</em>). The function MP(i)MP(<em>i</em>)gives the maximal profits that we can gain for the price <em>subsequence</em> starting from the index i<em>i</em>, <em>i.e.</em> price[i,i+1,…,n]price[<em>i</em>,<em>i</em>+1,…,<em>n</em>].</p>
<p>Given the definition of the MP(i)MP(<em>i</em>) function, one can see that when i=0<em>i</em>=0 the output of the function, <em>i.e.</em> MP(0)MP(0), is exactly the result that we need to solve the problem, which is the maximal profits that one can gain for the price subsequence of price[0,1,…,n]price[0,1,…,<em>n</em>].</p>
<p>Suppose that we know all the values for MP(i)MP(<em>i</em>) onwards until MP(n)MP(<em>n</em>), <em>i.e.</em> we know the maximal profits that we can gain for any subsequence of price[k…n]k∈[i,n]price[<em>k</em>…<em>n</em>]<em>k</em>∈[<em>i</em>,<em>n</em>].</p>
<p>Now, let us add a new price point price[i−1]price[<em>i</em>−1] into the subsequence price[i…n]price[<em>i</em>…<em>n</em>], all we need to do is to deduce the value for the <strong>unknown</strong> MP(i−1)MP(<em>i</em>−1).</p>
<blockquote>
<p>Up to this point, we have just modeled the problem with our <strong>target</strong> function MP(i)MP(<em>i</em>), along with a series of definitions. The problem now is boiled down to deducing the formula for MP(i−1)MP(<em>i</em>−1).</p>
</blockquote>
<p>In the following section, we will demonstrate how to deduce the formula for MP(i−1)MP(<em>i</em>−1).</p>
<p><strong>Deduction</strong></p>
<p>With the newly-added price point price[i−1]price[<em>i</em>−1], we need to consider <strong>all</strong> possible transactions that we can do to the stock at this price point, which can be broken down into two cases:</p>
<ul>
<li>Case 1): we buy this stock with price[i−1]price[<em>i</em>−1] and then sell it at some point in the following price sequence of price[i…n]price[<em>i</em>…<em>n</em>]. Note that, once we sell the stock at a certain point, we need to cool down for a day, then we can reengage with further transactions. Suppose that we sell the stock right after we bought it, at the next price point price[i]price[<em>i</em>], the maximal profits we would gain from this choice would be the profit of this transaction (<em>i.e.</em> price[i]−price[i−1]price[<em>i</em>]−price[<em>i</em>−1]) <strong>plus</strong> the maximal profits from the rest of the price sequence, as we show in the following:</li>
</ul>
<p><img src="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_formula.png" alt="example of profit calculation"></p>
<p>In addition, we need to <strong>enumerate</strong> all possible points to sell this stock, and take the maximum among them. The maximal profits that we could gain from this case can be represented by the following:</p>
<p>C1=max⁡{k∈[i,n]}(price[k]−p[i−1]+MP(k+2))<em>C</em>1=max{<em>k</em>∈[<em>i</em>,<em>n</em>]}(price[<em>k</em>]−p[<em>i</em>−1]+MP(<em>k</em>+2))</p>
<ul>
<li>Case 2): we simply do nothing with this stock. Then the maximal profits that we can gain from this case would be MP(i)MP(<em>i</em>), which are also the maximal profits that we can gain from the rest of the price sequence.</li>
</ul>
<p>C2=MP(i)<em>C</em>2=MP(<em>i</em>)</p>
<p>By combining the above two cases, <em>i.e.</em> selecting the max value among them, we can obtain the value for MP(i−1)MP(<em>i</em>−1), as follows:</p>
<p>MP(i−1)=max⁡(C1,C2)MP(<em>i</em>−1)=max(<em>C</em>1,<em>C</em>2)</p>
<p>MP(i−1)=max⁡(max⁡{k∈[i,n]}(price[k]−price[i−1]+MP(k+2)),MP(i))MP(<em>i</em>−1)=max(max{<em>k</em>∈[<em>i</em>,<em>n</em>]}(price[<em>k</em>]−price[<em>i</em>−1]+MP(<em>k</em>+2)),MP(<em>i</em>))</p>
<p>By the way, the base case for our recursive function MP(i)MP(<em>i</em>) would be MP(n)MP(<em>n</em>) which is the maximal profits that we can gain from the sequence with a single price point price[n]price[<em>n</em>]. And the best thing we should do with a single price point is to do no transaction, hence we would neither lose money nor gain any profit, <em>i.e.</em> MP(n)=0MP(<em>n</em>)=0.</p>
<p>The above formulas do model the problem soundly. In addition, one should be able to translate them directly into code.</p>
<p><strong>Algorithm</strong></p>
<p>With the final formula we derived for our target function MP(i)MP(<em>i</em>), we can now go ahead and translate it into any programming language.</p>
<ul>
<li>Since the formula deals with subsequences of price that start from the last price point, we then could do an <strong>iteration</strong> over the price list in the reversed order. </li>
<li>We define an array <code>MP[i]</code> to hold the values for our target function MP(i)MP(<em>i</em>). We initialize the array with zeros, which correspond to the base case where the minimal profits that we can gain is zero. Note that, here we did a trick to pad the array with two additional elements, which is intended to simplify the branching conditions, as one will see later. </li>
<li>To calculate the value for each element <code>MP[i]</code>, we need to look into two cases as we discussed in the previous section, namely:<ul>
<li>Case 1). we buy the stock at the price point <code>price[i]</code>, then we sell it at a later point. As one might notice, the initial padding on the <code>MP[i]</code> array saves us from getting out of boundary in the array.</li>
<li>Case 2). we do no transaction with the stock at the price point <code>price[i]</code>.</li>
</ul>
</li>
<li>At the end of each iteration, we then pick the largest value from the above two cases as the final value for <code>MP[i]</code>.</li>
<li>At the end of the loop, the <code>MP[i]</code> array will be populated. We then return the value of <code>MP[0]</code>, which is the desired solution for the problem.</li>
</ul>
<iframe src="https://leetcode.com/playground/MM2cVbSW/shared" frameborder="0" width="100%" height="463" name="MM2cVbSW" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time Complexity: O(N2)O(<em>N</em>2) where N<em>N</em> is the length of the price list.<ul>
<li>As one can see, we have nested loops over the price list. The number of iterations in the outer loop is N<em>N</em>. The number of iterations in the inner loop varies from 11 to N<em>N</em>. Therefore, the total number of iterations that we perform is ∑i=1Ni=N⋅(N+1)2∑<em>i</em>=1<em>N**i</em>=2<em>N</em>⋅(<em>N</em>+1).</li>
<li>As a result, the overall time complexity of the algorithm is O(N2)O(<em>N</em>2). </li>
</ul>
</li>
<li>Space Complexity: O(N)O(<em>N</em>) where N<em>N</em> is the length of the price list.<ul>
<li>We allocated an array to hold all the values for our target function MP(i)MP(<em>i</em>). </li>
</ul>
</li>
</ul>
<h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 3 + 3 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \   \ </span><br><span class="line"> 1   3   1</span><br><span class="line"></span><br><span class="line">输出: 9</span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 4 + 5 &#x3D; 9.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result=helper(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(result[<span class="number">0</span>],result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] helper(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];<span class="comment">//0 is not steal, 1 is steal</span></span><br><span class="line">        <span class="keyword">int</span>[] left=helper(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] right=helper(root.right);</span><br><span class="line">        result[<span class="number">0</span>]=Math.max(left[<span class="number">0</span>],left[<span class="number">1</span>])+Math.max(right[<span class="number">0</span>],right[<span class="number">1</span>]);</span><br><span class="line">        result[<span class="number">1</span>]=left[<span class="number">0</span>]+right[<span class="number">0</span>]+root.val;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明</p>
<p>本题目本身就是动态规划的树形版本，通过此题解，可以了解一下树形问题在动态规划问题解法<br>我们通过三个方法不断递进解决问题</p>
<p>解法一通过递归实现，虽然解决了问题，但是复杂度太高<br>解法二通过解决方法一中的重复子问题，实现了性能的百倍提升<br>解法三直接省去了重复子问题，性能又提升了一步<br>解法一、暴力递归 - 最优子结构</p>
<p>在解法一和解法二中，我们使用爷爷、两个孩子、4 个孙子来说明问题<br>首先来定义这个问题的状态<br>爷爷节点获取到最大的偷取的钱数呢</p>
<p>首先要明确相邻的节点不能偷，也就是爷爷选择偷，儿子就不能偷了，但是孙子可以偷<br>二叉树只有左右两个孩子，一个爷爷最多 2 个儿子，4 个孙子<br>根据以上条件，我们可以得出单个节点的钱该怎么算<br>4 个孙子偷的钱 + 爷爷的钱 VS 两个儿子偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数。这就是动态规划里面的最优子结构</p>
<p>由于是二叉树，这里可以选择计算所有子节点</p>
<p>4 个孙子投的钱加上爷爷的钱如下<br>int method1 = root.val + rob(root.left.left) + rob(root.left.right) + rob(root.right.left) + rob(root.right.right)<br>两个儿子偷的钱如下<br>int method2 = rob(root.left) + rob(root.right);<br>挑选一个钱数多的方案则<br>int result = Math.max(method1, method2);<br>将上述方案写成代码如下</p>
<p>Java<br>public int rob(TreeNode root) {<br>    if (root == null) return 0;</p>
<pre><code>int money = root.val;
if (root.left != null) {
    money += (rob(root.left.left) + rob(root.left.right));
}

if (root.right != null) {
    money += (rob(root.right.left) + rob(root.right.right));
}

return Math.max(money, rob(root.left) + rob(root.right));</code></pre><p>}<br>信心满满的提交，一次通过，然而 执行用时:837 ms,在所有 java 提交中击败了24.49%的用户 这个结果太没面子了，下个解法进行优化</p>
<p>解法二、记忆化 - 解决重复子问题</p>
<p>针对解法一种速度太慢的问题，经过分析其实现，我们发现爷爷在计算自己能偷多少钱的时候，同时计算了 4 个孙子能偷多少钱，也计算了 2 个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。</p>
<p>于是乎我们发现了一个动态规划的关键优化点</p>
<p>重复子问题</p>
<p>我们这一步针对重复子问题进行优化，我们在做斐波那契数列时，使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。<br>由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，TreeNode 当做 key，能偷的钱当做 value</p>
<p>解法一加上记忆化优化后代码如下：</p>
<p>Java<br>public int rob(TreeNode root) {<br>    HashMap&lt;TreeNode, Integer&gt; memo = new HashMap&lt;&gt;();<br>    return robInternal(root, memo);<br>}</p>
<p>public int robInternal(TreeNode root, HashMap&lt;TreeNode, Integer&gt; memo) {<br>    if (root == null) return 0;<br>    if (memo.containsKey(root)) return memo.get(root);<br>    int money = root.val;</p>
<pre><code>if (root.left != null) {
    money += (robInternal(root.left.left, memo) + robInternal(root.left.right, memo));
}
if (root.right != null) {
    money += (robInternal(root.right.left, memo) + robInternal(root.right.right, memo));
}
int result = Math.max(money, robInternal(root.left, memo) + robInternal(root.right, memo));
memo.put(root, result);
return result;</code></pre><p>}<br>提交代码，执行用时：4 ms, 在所有 java 提交中击败了 54.92% 的用户，速度提高了 200 倍。太开心了。别着急，还有一个终极方案呢，连记忆化消耗的时间都省了，能省则省么。</p>
<p>解法三、终极解法</p>
<p>上面两种解法用到了孙子节点，计算爷爷节点能偷的钱还要同时去计算孙子节点投的钱，虽然有了记忆化，但是还是有性能损耗。</p>
<p>我们换一种办法来定义此问题</p>
<p>每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷</p>
<p>当前节点选择偷时，那么两个孩子节点就不能选择偷了<br>当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系)<br>我们使用一个大小为 2 的数组来表示 int[] res = new int[2] 0 代表不偷，1 代表偷<br>任何一个节点能偷到的最大钱的状态可以定义为</p>
<p>当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱<br>当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数<br>表示为公式如下</p>
<p>root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) + Math.max(rob(root.right)[0], rob(root.right)[1])<br>root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;<br>将公式做个变换就是代码啦</p>
<p>Java<br>public int rob(TreeNode root) {<br>    int[] result = robInternal(root);<br>    return Math.max(result[0], result[1]);<br>}</p>
<p>public int[] robInternal(TreeNode root) {<br>    if (root == null) return new int[2];<br>    int[] result = new int[2];</p>
<pre><code>int[] left = robInternal(root.left);
int[] right = robInternal(root.right);

result[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
result[1] = left[0] + right[0] + root.val;

return result;</code></pre><p>}<br>再提交一次：<br>执行用时 1 ms, 在所有 java 提交中击败了 99.87% 的用户，这样的结果，我觉得可以了。</p>
<h2 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413. 等差数列划分"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices/" target="_blank" rel="noopener">413. 等差数列划分</a></h2><p>难度中等122收藏分享切换为英文关注反馈</p>
<p>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<p>例如，以下数列为等差数列:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br></pre></td></tr></table></figure>

<p>以下数列不是等差数列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 5, 7</span><br></pre></td></tr></table></figure>



<p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。</p>
<p>如果满足以下条件，则称子数组(P, Q)为等差数组：</p>
<p>元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。</p>
<p>函数要返回数组 A 中所有为等差数组的子数组个数。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=A.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;l;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]-A[i-<span class="number">1</span>]==A[i-<span class="number">1</span>]-A[i-<span class="number">2</span>])&#123;</span><br><span class="line">                dp[i]=<span class="number">1</span>+dp[i-<span class="number">1</span>];</span><br><span class="line">                result+=dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Approach-1-Brute-Force-Accepted-1"><a href="#Approach-1-Brute-Force-Accepted-1" class="headerlink" title="Approach #1 Brute Force [Accepted]"></a>Approach #1 Brute Force [Accepted]</h4><p>The most naive solution is to consider every pair of elements(with atleast 1 element between them), so that the range of elements lying between these two elements acts as a slice. Then, we can iterate over every such slice(range) to check if all the consecutive elements within this range have the same difference. For every such range found, we can increment the count<em>c<strong>o</strong>u<strong>n</strong>t</em> that is used to keep a track of the required result.</p>
<iframe src="https://leetcode.com/playground/HT3WjgGf/shared" frameborder="0" name="HT3WjgGf" width="100%" height="343" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n3)<em>O</em>(<em>n</em>3). We iterate over the range formed by every pair of elements. Here, n<em>n</em> refers to the number of elements in the given array A<em>A</em>.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant extra space is used.</li>
</ul>
<hr>
<h4 id="Approach-2-Better-Brute-Force-Accepted"><a href="#Approach-2-Better-Brute-Force-Accepted" class="headerlink" title="Approach #2 Better Brute Force [Accepted]"></a>Approach #2 Better Brute Force [Accepted]</h4><p><strong>Algorithm</strong></p>
<p>In the last approach, we considered every possible range and then iterated over the range to check if the difference between every consercutive element in this range is the same. We can optimize this approach to some extent, by making a small observation.</p>
<p>We can see, that if we are currently considering the range bound by the elements, let’s say, A[s]<em>A</em><a href="start"><em>s</em></a> and A[e]<em>A</em><a href="end"><em>e</em></a>, we have checked the consecutive elements in this range to have the same difference. Now, when we move on to the next range between the indices s<em>s</em> and e+1<em>e</em>+1, we again perform a check on all the elements in the range s:e<em>s</em>:<em>e</em>, along with one additional pair A[e+1]<em>A</em>[<em>e</em>+1]and A[e]<em>A</em>[<em>e</em>]. We can remove this redundant check in the range s:e<em>s</em>:<em>e</em> and just check the last pair to have the same difference as the one used for the previous range(same s<em>s</em>, incremented e<em>e</em>).</p>
<p>Note that if the last range didn’t constitute an arithmetic slice, the same elements will be a part of the updated range as well. Thus, we can omit the rest of the ranges consisting of the same starting index. The rest of the process remains the same as in the last approach.</p>
<iframe src="https://leetcode.com/playground/NPDEAgTz/shared" frameborder="0" name="NPDEAgTz" width="100%" height="309" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n2)<em>O</em>(<em>n</em>2). Two for loops are used.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant extra space is used.</li>
</ul>
<hr>
<h4 id="Approach-3-Using-Recursion-Accepted"><a href="#Approach-3-Using-Recursion-Accepted" class="headerlink" title="Approach #3 Using Recursion [Accepted]"></a>Approach #3 Using Recursion [Accepted]</h4><p><strong>Algorithm</strong></p>
<p>By making use of the observation discussed in the last approach, we know, that if a range of elements between the indices (i,j)(<em>i</em>,<em>j</em>)constitute an Arithmetic Slice, and another element A[j+1]<em>A</em>[<em>j</em>+1] is included such that A[j+1]<em>A</em>[<em>j</em>+1] and A[j]<em>A</em>[<em>j</em>] have the same difference as that of the previous common difference, the ranges between (i,j+1)(<em>i</em>,<em>j</em>+1) will constitutes an arithmetic slice. Further, if the original range (i,j)(<em>i</em>,<em>j</em>) doesn’t form an arithmetic slice, adding new elements to this range won’t do us any good. Thus, no more arithmetic slices can be obtained by adding new elements to it.</p>
<p>By making use of this observation, we can develop a recursive solution for the given problem as well. Assume that a sum<em>s<strong>u</strong>m</em> variable is used to store the total number of arithmetic slices in the given array A<em>A</em>. We make use of a recursive function <code>slices(A,i)</code>which returns the number of Arithmetic Slices in the range (k,i)(<em>k</em>,<em>i</em>), but which are not a part of any range (k,j)(<em>k</em>,<em>j</em>) such that j&lt;i<em>j</em>&lt;<em>i</em>. It also updates sum<em>s<strong>u</strong>m</em> with the number of arithmetic slices(total) in the current range. Thus, k<em>k</em> refers to the minimum index such that the range (k,i)(<em>k</em>,<em>i</em>) constitutes a valid arithmetic slice.</p>
<p>Now, suppose we know the number of arithmetic slices in the range (0,i−1)(0,<em>i</em>−1) constituted by the elements [a0,a1,a2,…a(i−1)][<em>a</em>0,<em>a</em>1,<em>a</em>2,…<em>a</em>(<em>i</em>−1)], to be say x<em>x</em>. If this range itself is an arithmetic slice, all the consecutive elements have the same difference(equal to say, a(i−1)−a(i−2)<em>a</em>(<em>i</em>−1)−<em>a</em>(<em>i</em>−2)). Now, adding a new element ai<em>a**i</em> to it to extend the range to (0,i)(0,<em>i</em>) will constitute an arithmetic slice only if this new element satisfies ai−a(i−1)=a(i−1)−a(i−2)<em>a*<em>i</em>−*a</em>(<em>i</em>−1)=<em>a</em>(<em>i</em>−1)−<em>a</em>(<em>i</em>−2). Thus, now, the addition of this new element, will lead to an addition of ap<em>a**p</em> number of arithmetic slices to the ones obtained in the range (0,i−1)(0,<em>i</em>−1). The new arithmetic slices will be the ones constituting the ranges (0,i),(1,i),…(i−2,i)(0,<em>i</em>),(1,<em>i</em>),…(<em>i</em>−2,<em>i</em>), which are a total of x+1<em>x</em>+1 additional arithmetic slices. This is because, apart from the range (0,i)(0,<em>i</em>) the rest of the ranges (1,i),(2,i),…(i−2,i)(1,<em>i</em>),(2,<em>i</em>),…(<em>i</em>−2,<em>i</em>) can be mapped to (0,i−1),(1,i−1),…(i−3,i−1)(0,<em>i</em>−1),(1,<em>i</em>−1),…(<em>i</em>−3,<em>i</em>−1), with count equal to x<em>x</em>.</p>
<p>Thus, in every call to <code>slices</code>, if the ith<em>i<strong>t</strong>h</em> element has the same common difference with the last element as the previous common difference, we can find the number of new arithmetic slices added by the use of this element, ap<em>a**p</em> and also update the sum<em>s<strong>u</strong>m</em> to include this ap<em>a**p</em> into it, apart from the count obtained by the smaller ranges. But, if the new element doesn’t have the same common difference, extra arithmetic slices can’t be contributed by it and hence, no addition is done to sum<em>s<strong>u</strong>m</em> for the current element. But, of course sum<em>s<strong>u</strong>m</em> will be updated as per the count obtained from the smaller ranges.</p>
<iframe src="https://leetcode.com/playground/WGzuREMw/shared" frameborder="0" name="WGzuREMw" width="100%" height="360" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). The recursive function is called at most n−2<em>n</em>−2 times.</li>
<li>Space complexity : O(n)<em>O</em>(<em>n</em>). The depth of the recursion tree goes upto n−2<em>n</em>−2.</li>
</ul>
<hr>
<h4 id="Approach-5-Dynamic-Programming-Accepted"><a href="#Approach-5-Dynamic-Programming-Accepted" class="headerlink" title="Approach #5 Dynamic Programming [Accepted]:"></a>Approach #5 Dynamic Programming [Accepted]:</h4><p><strong>Algorithm</strong></p>
<p>In the last approach, we start with the full range (0,n−1)(0,<em>n</em>−1), where n<em>n</em> is the number of elements in the given A<em>A</em> array. We can observe that the result for the range (0,i)(0,<em>i</em>) only depends on the elements in the range (0,i)(0,<em>i</em>) and not on any element beyond this range. Thus, we can make use of Dynamic Programming to solve the given problem.</p>
<p>We can make use of a 1-D dp<em>d**p</em> with number of elements equal to n<em>n</em>. dp[i]<em>d**p</em>[<em>i</em>] is used to store the number of arithmetic slices possible in the range (k,i)(<em>k</em>,<em>i</em>) and not in any range (k,j)(<em>k</em>,<em>j</em>) such that j&lt;i<em>j</em>&lt;<em>i</em>. Again, k<em>k</em> refers to the minimum index possible such that (k,j)(<em>k</em>,<em>j</em>)constitutes a valid Arithmetic Slice.</p>
<p>Instead of going in the reverse order as in the recursive approach, we can start filling the dp<em>d**p</em> in a forward manner. The intuition remains the same as in the last approach. For the ith<em>i<strong>t</strong>h</em> element being considered, we check if this element satsfies the common difference criteria with the previous element. If so, we know the number of new arithmetic slices added will be 1+dp[i−1]1+<em>d**p</em>[<em>i</em>−1] as discussed in the last approach. The sum<em>s<strong>u</strong>m</em> is also updated by the same count to reflect the new arithmetic slices added.</p>
<p>The following animation illustrates the dp<em>d**p</em> filling process.</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAAHZCAYAAAC8QhsUAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAADSKADAAQAAAABAAAB2QAAAABdjUaIAABAAElEQVR4AezdB3wURRsG8Ody6b2RkJCQhNB770WkShOkgyJNBAFFqqh0UERB9KOLIL0K0hHpvfcaSAiBJKSH9Ha331w4ILm7hNCTu2f9RW77zn9nd+ednd2VSaIDOwpQgAIUoAAFKEABClCAAhSAEQ0oQAEKUIACFKAABShAAQpQ4LEAAyTmBApQgAIUoAAFKEABClCAAmoBBkjMChSgAAUoQAEKUIACFKAABdQCDJCYFShAAQpQgAIUoAAFKEABCqgFGCAxK1CAAhSgAAUoQAEKUIACFFALMEBiVqAABShAAQpQgAIUoAAFKKAWYIDErEABClCAAhSgAAUoQAEKUEAtwACJWYECFKAABShAAQpQgAIUoIBagAESswIFKEABClCAAhSgAAUoQAG1AAMkZgUKUIACFKAABShAAQpQgAJqAQZIzAoUoAAFKEABClCAAhSgAAXUAgyQmBUoQAEKUIACFKAABShAAQqoBRggMStQgAIUoAAFKEABClCAAhRQCzBAYlagAAUoQAEKUIACFKAABSigFmCAxKxAAQpQgAIUoAAFKEABClBALcAAiVmBAhSgAAUoQAEKUIACFKCAWoABErMCBShAAQpQgAIUoAAFKEABtQADJGYFClCAAhSgAAUoQAEKUIACagEGSMwKFKAABShAAQpQgAIUoAAF1AIMkJgVKEABClCAAhSgAAUoQAEKqAUYIDErUIACFKAABShAAQpQgAIUUAswQGJWoAAFKEABClCAAhSgAAUooBZggMSsQAEKUIACFKAABShAAQpQQC3AAIlZgQIUoAAFKEABClCAAhSggFqAARKzAgUoQAEKUIACFKAABShAAbUAAyRmBQpQgAIUoAAFKEABClCAAmoBBkjMChSgAAUoQAEKUIACFKAABdQCDJCYFShAAQpQgAIUoAAFKEABCqgFGCAxK1CAAhSgAAUoQAEKUIACFFALMEBiVqAABShAAQpQgAIUoAAFKKAWYIDErEABClCAAhSgAAUoQAEKUEAtwACJWYECFKAABShAAQpQgAIUoIBagAESswIFKEABClCAAhSgAAUoQAG1AAMkZgUKUIACFKAABShAAQpQgAJqAQZIzAoUoAAFKEABClCAAhSgAAXUAgyQmBUoQAEKUIACFKAABShAAQqoBRggMStQgAIUoAAFKEABClCAAhRQCzBAYlagAAUoQAEKUIACFKAABSigFmCAxKxAAQpQgAIUoAAFKEABClBALcAAiVmBAhSgAAUoQAEKUIACFKCAWoABErMCBShAAQpQgAIUoAAFKEABtQADJGYFClCAAhSgAAUoQAEKUIACagEGSMwKFKAABShAAQpQgAIUoAAF1AIMkJgVKEABClCAAhSgAAUoQAEKqAUYIDErUIACFKAABShAAQpQgAIUUAswQGJWoAAFKEABClCAAhSgAAUooBZggMSsQAEKUIACFKAABShAAQpQQC3AAIlZgQIUoAAFKEABClCAAhSggFqAARKzAgUoQAEKUIACFKAABShAAbUAAyRmBQpQgAIUoAAFKEABClCAAmoBBkjMChSgAAUoQAEKUIACFKAABdQCDJCYFShAAQpQgAIUoAAFKEABCqgFGCAxK1CAAhSgAAUoQAEKUIACFFALMEBiVqAABShAAQpQgAIUoAAFKKAWYIDErEABClCAAhSgAAUoQAEKUEAtwACJWYECFKAABShAAQpQgAIUoIBagAESswIFKEABClCAAhSgAAUoQAG1AAMkZgUKUIACFKAABShAAQpQgAJqAQZIzAoUoAAFKEABClCAAhSgAAXUAgyQmBUoQAEKUIACFKAABShAAQqoBRggMStQgAIUoAAFKEABClCAAhRQCzBAYlagAAUoQAEKUIACFKAABSigFmCAxKxAAQpQgAIUoAAFKEABClBALcAAiVmBAhSgAAUoQAEKUIACFKCAWoABErMCBShAAQpQgAIUoAAFKEABtQADJGYFClCAAhSgAAUoQAEKUIACagEGSMwKFKAABShAAQpQgAIUoAAF1AIMkJgVKEABClCAAhSgAAUoQAEKqAUYIDErUIACFKAABShAAQpQgAIUUAswQGJWoAAFKEABClCAAhSgAAUooBZggMSsQAEKUIACFKAABShAAQpQQC3AAIlZgQIUoAAFKEABClCAAhSggFqAARKzAgUoQAEKUIACFKAABShAAbUAAyRmBQpQgAIUoAAFKEABClCA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AktvTt7O9WRHjx4d991337jwwgvP9Sj/03//1157bbzwwgvc5lA/ceLE2L179xzP7H7K888/P7Zv3z42bdrUDTFj+pMnT44zZ86M888/f8Znnt2H/7+/fLz88svjxRdfHLt27Tq7EAv2s09fG44fPz727NmzYMnObpw33nhjPPvss+Oiiy46u/+gBfzZn3vuubFz586xvOzr9rPUO31tmJpt3bp1lqfVP/b06dNj375944EHHhgrKyvRYyEG0qlTp8b0E68tW7bEkI5ZYPrJzSuvvDLW1tbyA1zXFZh+4sVtXZ51f2D68ba6uupFcF2h/APTT1inv16ndt7eusB0VL766qt+rb51sv88cvqJ/vR1ddu2bTM+08Onbj5Znf3jYPrasHnz5tmfWP6M6WvD0tLS2LBhQ7nEbPGnrw3TYfnfvni2EANpNhaPJkCAAAECBAgQIECAQBbwe5nZxZUAAQIECBAgQIAAgUIBA6mwdJEJECBAgAABAgQIEMgCBlJ2cSVAgAABAgQIECBAoFDAQCosXWQCBAgQIECAAAECBLKAgZRdXAkQIECAAAECBAgQKBQwkApLF5kAAQIECBAgQIAAgSxgIGUXVwIECBAgQIAAAQIECgUMpMLSRSZAgAABAgQIECBAIAsYSNnFlQABAgQIECBAgACBQgEDqbB0kQkQIECAAAECBAgQyAIGUnZxJUCAAAECBAgQIECgUMBAKixdZAIECBAgQIAAAQIEsoCBlF1cCRAgQIAAAQIECBAoFDCQCksXmQABAgQIECBAgACBLGAgZRdXAgQIECBAgAABAgQKBQykwtJFJkCAAAECBAgQIEAgCxhI2cWVAAECBAgQIECAAIFCAQOpsHSRCRAgQIAAAQIECBDIAgZSdnElQIAAAQIECBAgQKBQwEAqLF1kAgQIECBAgAABAgSygIGUXVwJECBAgAABAgQIECgUMJAKSxeZAAECBAgQIECAAIEsYCBlF1cCBAgQIECAAAECBAoFDKTC0kUmQIAAAQIECBAgQCALGEjZxZUAAQIECBAgQIAAgUIBA6mwdJEJECBAgAABAgQIEMgCBlJ2cSVAgAABAgQIECBAoFDAQCosXWQCBAgQIECAAAECBLKAgZRdXAkQIECAAAECBAgQKBQwkApLF5kAAQIECBAgQIAAgSxgIGUXVwIECBAgQIAAAQIECgUM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" alt="Current"></p>
<p>1 / 9</p>
<iframe src="https://leetcode.com/playground/w8UZ2q6u/shared" frameborder="0" name="w8UZ2q6u" width="100%" height="292" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). We traverse over the given A<em>A</em> array with n<em>n</em> elements once only.</li>
<li>Space complexity : O(n)<em>O</em>(<em>n</em>). 1-D dp<em>d**p</em> of size n<em>n</em> is used.</li>
</ul>
<hr>
<h4 id="Approach-5-Constant-Space-Dynamic-Programming-Accepted"><a href="#Approach-5-Constant-Space-Dynamic-Programming-Accepted" class="headerlink" title="Approach #5 Constant Space Dynamic Programming [Accepted]:"></a>Approach #5 Constant Space Dynamic Programming [Accepted]:</h4><p><strong>Algorithm</strong></p>
<p>In the last approach, we can observe that we only require the element dp[i−1]<em>d**p</em>[<em>i</em>−1] to determine the value to be entered at dp[i]<em>d**p</em>[<em>i</em>]. Thus, instead of making use of a 1-D array to store the required data, we can simply keep a track of just the last element.</p>
<iframe src="https://leetcode.com/playground/mGEcWWi3/shared" frameborder="0" name="mGEcWWi3" width="100%" height="292" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). We traverse over the given A<em>A</em> array with n<em>n</em> elements once only.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant extra space is used.</li>
</ul>
<hr>
<h4 id="Approach-6-Using-Formula-Accepted"><a href="#Approach-6-Using-Formula-Accepted" class="headerlink" title="Approach #6 Using Formula [Accepted]:"></a>Approach #6 Using Formula [Accepted]:</h4><p><strong>Algorithm</strong></p>
<p>From the dp<em>d**p</em> solution, we can observe that for k<em>k</em> consecutive elements sastisfying the common difference criteria, we update the sum<em>s<strong>u</strong>m</em> for each such element by 1,2,3,…,k1,2,3,…,<em>k</em> counts in that order. Thus, instead of updating the sum<em>s<strong>u</strong>m</em> at the same time, we can just keep a track of the number of consecutive elements satisfying the common differnce criteria in a count<em>c<strong>o</strong>u<strong>n</strong>t</em> variable and just update the sum<em>s<strong>u</strong>m</em> directly as count∗(count+1)/2<em>c<strong>o</strong>u<strong>n</strong>t<em>∗(</em>c<strong>o</strong>u<strong>n</strong>t</em>+1)/2 whenver an element not satisfying this criteria is found. At the same time, we also need to reset the count<em>c<strong>o</strong>u<strong>n</strong>t</em> value.</p>
<iframe src="https://leetcode.com/playground/fQULWrDF/shared" frameborder="0" name="fQULWrDF" width="100%" height="309" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). We iterate over A<em>A</em> with n<em>n</em> elements exactly once.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant extra space is used.</li>
</ul>
<h2 id="1039-多边形三角剖分的最低得分"><a href="#1039-多边形三角剖分的最低得分" class="headerlink" title="1039. 多边形三角剖分的最低得分"></a><a href="https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/" target="_blank" rel="noopener">1039. 多边形三角剖分的最低得分</a></h2><p>难度中等41收藏分享切换为英文关注反馈</p>
<p>给定 <code>N</code>，想象一个凸 <code>N</code> 边多边形，其顶点按顺时针顺序依次标记为 <code>A[0], A[i], ..., A[N-1]</code>。</p>
<p>假设您将多边形剖分为 <code>N-2</code> 个三角形。对于每个三角形，该三角形的值是顶点标记的<strong>乘积</strong>，三角剖分的分数是进行三角剖分后所有 <code>N-2</code> 个三角形的值之和。</p>
<p>返回多边形进行三角剖分后可以得到的最低分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：多边形已经三角化，唯一三角形的分数为 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/minimum-score-triangulation-of-polygon-1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,7,4,5]</span><br><span class="line">输出：144</span><br><span class="line">解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 &#x3D; 245，或 3*4*5 + 3*4*7 &#x3D; 144。最低分数为 144。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,3,1,4,1,5]</span><br><span class="line">输出：13</span><br><span class="line">解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 &#x3D; 13。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minScoreTriangulation</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=A.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[l][l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l-<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">2</span>;j&lt;l;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j]==<span class="number">0</span>)</span><br><span class="line">                        dp[i][j]=dp[i][k]+dp[k][j]+A[i]*A[j]*A[k];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=Math.min(dp[i][k]+dp[k][j]+A[i]*A[j]*A[k],dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][l-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解题思路</p>
<p>dp[i][j]表示从i到j序列的最低分。记底边为ij的三角形顶点为m，三角形imj将多边形分成三部分，总分即为三部分的分数和（如果m=i+1或m=j-1，则对应第一或第三部分分数为0）。<br>那么m在什么位置分数最低呢，将m从i+1到j-1遍历，分别计算dp[i][m]+A[i]<em>A[j]</em>A[m]+dp[m][j],取其中最小值即为dp[i][j]。<br>dp[i][j]=min(dp[i][m]+A[i]<em>A[j]</em>A[m]+dp[m][j]),for m in range [i+1,j-1]</p>
<p>dp table只用到右上半部分，初始化相邻两元素序列结果为0（两元素序列不能构成三角形）；采用自底向上、自左向右的方向计算dp table。最终输出dp[0][n-1]。</p>
<h2 id="1043-分隔数组以得到最大和"><a href="#1043-分隔数组以得到最大和" class="headerlink" title="1043. 分隔数组以得到最大和"></a><a href="https://leetcode-cn.com/problems/partition-array-for-maximum-sum/" target="_blank" rel="noopener">1043. 分隔数组以得到最大和</a></h2><p>难度中等48收藏分享切换为英文关注反馈</p>
<p>给出整数数组 <code>A</code>，将该数组分隔为长度最多为 K 的几个（连续）子数组。分隔完成后，每个子数组的中的值都会变为该子数组中的最大值。</p>
<p>返回给定数组完成分隔后的最大和。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [1,15,7,9,2,5,10], K &#x3D; 3</span><br><span class="line">输出：84</span><br><span class="line">解释：A 变为 [15,15,15,9,10,10,10]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= K &lt;= A.length &lt;= 500</code></li>
<li><code>0 &lt;= A[i] &lt;= 10^6</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=A.length;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">0</span>||A==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[l+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> max=dp[i];</span><br><span class="line">            <span class="keyword">while</span>((i-j)&lt;=K &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                max=Math.max(A[j],max);</span><br><span class="line">                dp[i]=Math.max(dp[i],dp[j]+max*(i-j));</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法1：DP"><a href="#方法1：DP" class="headerlink" title="方法1：DP"></a>方法1：DP</h5><p><img src="https://pic.leetcode-cn.com/ddf9ff236598ff79b00e7365354cdaf961463cc78dfed7505334ad2628a60d73-e7c5ca8d4c19bed3e8652951c6f37c6.jpg" alt="e7c5ca8d4c19bed3e8652951c6f37c6.jpg"></p>
<p><img src="https://pic.leetcode-cn.com/a49b3279d3d2e9b9d9617da384d72dbcfe395dc3a0f0d1fe6fc4e4587f2c6d12-image.png" alt="image.png"></p>
<h2 id="1218-最长定差子序列"><a href="#1218-最长定差子序列" class="headerlink" title="1218. 最长定差子序列"></a><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/" target="_blank" rel="noopener">1218. 最长定差子序列</a></h2><p>难度中等27收藏分享切换为英文关注反馈</p>
<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>difference</code>，请你找出 <code>arr</code> 中所有相邻元素之间的差等于给定 <code>difference</code> 的等差子序列，并返回其中最长的等差子序列的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,3,4], difference &#x3D; 1</span><br><span class="line">输出：4</span><br><span class="line">解释：最长的等差子序列是 [1,2,3,4]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,3,5,7], difference &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：最长的等差子序列是任意单个元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,5,7,8,5,3,4,2,1], difference &#x3D; -2</span><br><span class="line">输出：4</span><br><span class="line">解释：最长的等差子序列是 [7,5,3,1]。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= arr[i], difference &lt;= 10^4</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">1</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: arr)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=map.getOrDefault(i-difference, <span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">            map.put(i,tmp);</span><br><span class="line">            result=Math.max(result,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路<br>这道题思路比较简单，跟经典问题最长递增（减）子序列有点相似，而这道题称为最长等差子序列, 也就是说是固定公差的递增（减），相对还更简单一点。</p>
<p>可以用dp[i]来记录以数字i为结尾的最长等差子序列的长度，那么它应该只有两种情况：</p>
<p>dp[i] = 1 // 表示在 i 之前没有出现等差子序列<br>dp[i] = dp[i - difference] + 1 // 表示在 i 之前出现了等差子序列，长度为 dp[i - difference], 而 i 也是满足这个等差序列的，所以等差序列的长度在此基础上加 1 就可以了<br>考虑元素值会出现负数，所以用数组存放是不行的，那么可以用一个 map来维护以 i 结尾的最长等差序列的长度，所以也就不难得出如下代码：</p>
<p>可以为下标加一个偏置，解决出现负值的情况，这是很OK，因为这道题arr[i]、difference的数据范围已经给的很明确了，而且比较小。</p>
<h2 id="1269-停在原地的方案数"><a href="#1269-停在原地的方案数" class="headerlink" title="1269. 停在原地的方案数"></a><a href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/" target="_blank" rel="noopener">1269. 停在原地的方案数</a></h2><p>难度困难23收藏分享切换为英文关注反馈</p>
<p>有一个长度为 <code>arrLen</code> 的数组，开始有一个指针在索引 <code>0</code> 处。</p>
<p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p>
<p>给你两个整数 <code>steps</code> 和 <code>arrLen</code> ，请你计算并返回：在恰好执行 <code>steps</code> 次操作以后，指针仍然指向索引 <code>0</code> 处的方案数。</p>
<p>由于答案可能会很大，请返回方案数 <strong>模</strong> <code>10^9 + 7</code> 后的结果。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：steps &#x3D; 3, arrLen &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。</span><br><span class="line">向右，向左，不动</span><br><span class="line">不动，向右，向左</span><br><span class="line">向右，不动，向左</span><br><span class="line">不动，不动，不动</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：steps &#x3D; 2, arrLen &#x3D; 4</span><br><span class="line">输出：2</span><br><span class="line">解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。</span><br><span class="line">向右，向左</span><br><span class="line">不动，不动</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：steps &#x3D; 4, arrLen &#x3D; 2</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= steps &lt;= 500</code></p>
</li>
<li><p><code>1 &lt;= arrLen &lt;= 10^6</code></p>
<p>s: steps</p>
<pre><code>l：经过s步，停留的坐标
p[s][l]: 经过s步，停留在坐标l的总方案数
arrLen: 数组长度</code></pre></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MOD = <span class="number">1_000_000_007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> steps, <span class="keyword">int</span> arrLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p[][] = <span class="keyword">new</span> <span class="keyword">int</span>[steps+<span class="number">1</span>][steps+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        p[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">1</span>; s&lt;=steps; s++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">0</span>; l &lt; Math.min(steps+<span class="number">1</span>, arrLen); l++) &#123;                        </span><br><span class="line">                <span class="keyword">if</span> (s == l) &#123;</span><br><span class="line">                    p[s][l] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s &lt; l) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p[s][l] = p[s-<span class="number">1</span>][l];</span><br><span class="line">                <span class="keyword">if</span> (l-<span class="number">1</span> &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                    p[s][l] += p[s-<span class="number">1</span>][l-<span class="number">1</span>];</span><br><span class="line">                    p[s][l] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l+<span class="number">1</span> &lt; arrLen) &#123;</span><br><span class="line">                    p[s][l] += p[s-<span class="number">1</span>][l+<span class="number">1</span>];</span><br><span class="line">                    p[s][l] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[steps][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<pre><code>动态规划解法三要素：
1、最优子结构
指针可以向左、向右、停在原地，所有最后一步可以前面的基础上往这三个方向前进，即子结构为：
p[s-1][l], p[s-1][l-1] , p[s-1][l+1]   PS: 原地、向右、向左
2、状态转移方程
p[s][l] = p[s-1][l] + p[s-1][l-1] + p[s-1][l+1]
3、边界条件
p[0][0] = 1;
p[s][l] = 0 if s &lt; l  

问题求解：
p[s][0]
arrLen


注意点：
1、 中间结果数组，注意边界条件p[s][l] = 0 if s &lt; l  ，所以只需要定义int[steps+1][steps+1] 而不需要是int[steps+1][arrLen]，不然会超出内存限制；
2、 结果是返回模 10^9 + 7 后的结果，p[s][l] = p[s-1][l] + p[s-1][l-1] + p[s-1][l+1]  状态方程是两两相加就要求mod，而不是三个求和之后再求mod，之前结果总有用例不过
就是因为三个求和之后再求的mod。</code></pre><h2 id="1312-让字符串成为回文串的最少插入次数"><a href="#1312-让字符串成为回文串的最少插入次数" class="headerlink" title="1312. 让字符串成为回文串的最少插入次数"></a><a href="https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/" target="_blank" rel="noopener">1312. 让字符串成为回文串的最少插入次数</a></h2><p>难度困难34收藏分享切换为英文关注反馈</p>
<p>给你一个字符串 <code>s</code> ，每一次操作你都可以在字符串的任意位置插入任意字符。</p>
<p>请你返回让 <code>s</code> 成为回文串的 <strong>最少操作次数</strong> 。</p>
<p>「回文串」是正读和反读都相同的字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;zzazz&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：字符串 &quot;zzazz&quot; 已经是回文串了，所以不需要做任何插入操作。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;mbadm&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：字符串可变为 &quot;mbdadbm&quot; 或者 &quot;mdbabdm&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcode&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：插入 5 个字符后字符串变为 &quot;leetcodocteel&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;g&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;no&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 中所有字符都是小写字母。</li>
</ul>
<p>我们用 dp[i][j] 表示对于字符串 s 的子串 s[i:j]（这里的下标从 0 开始，并且 s[i:j] 包含 s 中的第 i 和第 j 个字符），最少添加的字符数量，使得 s[i:j] 变为回文串。</p>
<p>我们从外向内考虑 s[i:j]：</p>
<p>如果 s[i] == s[j]，那么最外层已经形成了回文，我们只需要继续考虑 s[i+1:j-1]；</p>
<p>如果 s[i] != s[j]，那么我们要么在 s[i:j] 的末尾添加字符 s[i]，要么在 s[i:j] 的开头添加字符 s[j]，才能使得最外层形成回文。如果我们选择前者，那么需要继续考虑 s[i+1:j]；如果我们选择后者，那么需要继续考虑 s[i:j-1]。</p>
<p>因此我们可以得到如下的状态转移方程：</p>
<p>dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1)                     if s[i] != s[j]<br>dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1, dp[i + 1][j - 1])   if s[i] == s[j]<br>边界条件为：</p>
<p>dp[i][j] = 0   if i &gt;= j<br>注意该动态规划为区间动态规划，需要注意 dp[i][j] 的计算顺序。一种可行的方法是，我们递增地枚举子串 s[i:j] 的长度 span = j - i + 1，再枚举起始位置 i，通过 j = i + span - 1 得到 j 的值并计算 dp[i][j]。这样的计算顺序可以保证在计算 dp[i][j] 时，状态转移方程中的状态 dp[i + 1][j]，dp[i][j - 1] 和 dp[i + 1][j - 1] 均已计算过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> span = <span class="number">2</span>; span &lt;= n; ++span) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - span; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + span - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></h2><p>难度简单118收藏分享切换为英文关注反馈</p>
<p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为<strong>斐波那契数列</strong>。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>

<p>给定 <code>N</code>，计算 <code>F(N)</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2.</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3.</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>0 ≤ <code>N</code> ≤ 30</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private Integer[] cache &#x3D; new Integer[31];</span><br><span class="line"></span><br><span class="line">    public int fib(int N) &#123;</span><br><span class="line">        if (N &lt;&#x3D; 1) &#123;</span><br><span class="line">            return N;</span><br><span class="line">        &#125;</span><br><span class="line">        cache[0] &#x3D; 0;</span><br><span class="line">        cache[1] &#x3D; 1;</span><br><span class="line">        return memoize(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int memoize(int N) &#123;</span><br><span class="line">      if (cache[N] !&#x3D; null) &#123;</span><br><span class="line">          return cache[N];</span><br><span class="line">      &#125;</span><br><span class="line">      cache[N] &#x3D; memoize(N-1) + memoize(N-2);</span><br><span class="line">      return memoize(N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Approach-1-Recursion"><a href="#Approach-1-Recursion" class="headerlink" title="Approach 1: Recursion"></a>Approach 1: Recursion</h4><p><strong>Intuition</strong></p>
<p>Use recursion to compute the Fibonacci number of a given integer.</p>
<p><img src="https://leetcode.com/problems/fibonacci-number/Figures/509/fibonacciRecursion5.png" alt="fib(5) Recursion diagram"></p>
<p><em>Figure 1. An example tree representing what <code>fib(5)</code> would look like</em></p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Check if the provided input value, N, is less than or equal to 1. If true, return N.</li>
<li>Otherwise, the function <code>fib(int N)</code> calls itself, with the result of the 2 previous numbers being added to each other, passed in as the argument. This is derived directly from the <code>recurrence relation</code>: Fn=Fn−1+Fn−2<em>F**n</em>=<em>F*</em>n<em>−1+</em>F*<em>n</em>−2</li>
<li>Do this until all numbers have been computed, then return the resulting answer.</li>
</ul>
<iframe src="https://leetcode.com/playground/uoCAvhCh/shared" frameborder="0" width="100%" height="191" name="uoCAvhCh" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(2N)<em>O</em>(2<em>N</em>). This is the slowest way to solve the <code>Fibonacci Sequence</code> because it takes exponential time. The amount of operations needed, for each level of recursion, grows exponentially as the depth approaches <code>N</code>.</li>
<li>Space complexity : O(N)<em>O</em>(<em>N</em>). We need space proportionate to <code>N</code> to account for the max size of the stack, in memory. This stack keeps track of the function calls to <code>fib(N)</code>. This has the potential to be bad in cases that there isn’t enough physical memory to handle the increasingly growing stack, leading to a <code>StackOverflowError</code>. The <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/StackOverflowError.html" target="_blank" rel="noopener">Java docs</a> have a good explanation of this, describing it as an error that occurs because an application recurses too deeply.</li>
</ul>
<hr>
<h4 id="Approach-2-Bottom-Up-Approach-using-Memoization"><a href="#Approach-2-Bottom-Up-Approach-using-Memoization" class="headerlink" title="Approach 2: Bottom-Up Approach using Memoization"></a>Approach 2: Bottom-Up Approach using Memoization</h4><p><strong>Intuition</strong></p>
<p>Improve upon the recursive option by using iteration, still solving for all of the sub-problems and returning the answer for N, using already computed Fibonacci values. In using a bottom-up approach, we can iteratively compute and store the values, only returning once we reach the result.</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>If <code>N</code> is less than or equal to 1, return <code>N</code></li>
<li>Otherwise, iterate through <code>N</code>, storing each computed answer in an array along the way.</li>
<li>Use this array as a reference to the 2 previous numbers to calculate the current Fibonacci number.</li>
<li>Once we’ve reached the last number, return it’s Fibonacci number.</li>
</ul>
<iframe src="https://leetcode.com/playground/uEUpwCPg/shared" frameborder="0" width="100%" height="361" name="uEUpwCPg" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(N)<em>O</em>(<em>N</em>). Each number, starting at 2 up to and including <code>N</code>, is visited, computed and then stored for O(1)<em>O</em>(1)access later on.</li>
<li>Space complexity : O(N)<em>O</em>(<em>N</em>). The size of the data structure is proportionate to <code>N</code>.</li>
</ul>
<hr>
<h4 id="Approach-3-Top-Down-Approach-using-Memoization"><a href="#Approach-3-Top-Down-Approach-using-Memoization" class="headerlink" title="Approach 3: Top-Down Approach using Memoization"></a>Approach 3: Top-Down Approach using Memoization</h4><p><strong>Intuition</strong></p>
<p>Solve for all of the sub-problems, use memoization to store the pre-computed answers, then return the answer for N. We will leverage recursion, but in a smarter way by not repeating the work to calculate existing values.</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Check if <code>N &lt;= 1</code>. If it is, return <code>N</code>.</li>
<li>Call and return <code>memoize(N)</code></li>
<li>If <code>N</code> exists in the map, return the cached value for <code>N</code></li>
<li>Otherwise set the value of <code>N</code>, in our mapping, to the value of <code>memoize(N-1) + memoize(N-2)</code></li>
</ul>
<iframe src="https://leetcode.com/playground/T6ZdXXX4/shared" frameborder="0" width="100%" height="395" name="T6ZdXXX4" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(N)<em>O</em>(<em>N</em>). Each number, starting at 2 up to and including <code>N</code>, is visited, computed and then stored for O(1)<em>O</em>(1)access later on.</li>
<li>Space complexity : O(N)<em>O</em>(<em>N</em>). The size of the stack in memory is proportionate to <code>N</code>.</li>
</ul>
<hr>
<h4 id="Approach-4-Iterative-Top-Down-Approach"><a href="#Approach-4-Iterative-Top-Down-Approach" class="headerlink" title="Approach 4: Iterative Top-Down Approach"></a>Approach 4: Iterative Top-Down Approach</h4><p><strong>Intuition</strong></p>
<p>Let’s get rid of the need to use all of that space and instead use the minimum amount of space required. We can achieve O(1)<em>O</em>(1)space complexity by only storing the value of the two previous numbers and updating them as we iterate to <code>N</code>.</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Check if <code>N &lt;= 1</code>, if it is then we should return <code>N</code>.</li>
<li>Check if <code>N == 2</code>, if it is then we should return <code>1</code> since <code>N</code> is 2 and <code>fib(2-1) + fib(2-2)</code> equals <code>1 + 0 = 1</code>.</li>
<li>To use an iterative approach, we need at least 3 variables to store each state <code>fib(N)</code>, <code>fib(N-1)</code> and <code>fib(N-2)</code>.</li>
<li>Preset the initial values:<ul>
<li>Initialize <code>current</code> with 0.</li>
<li>Initialize <code>prev1</code> with 1, since this will represent <code>fib(N-1)</code> when computing the current value.</li>
<li>Initialize <code>prev2</code> with 1, since this will represent <code>fib(N-2)</code> when computing the current value.</li>
</ul>
</li>
<li>Iterate, incrementally by 1, all the way up to and including <code>N</code>. Starting at 3, since <code>0</code>, <code>1</code> and <code>2</code> are pre-computed.</li>
<li>Set the <code>current</code> value to <code>fib(N-1) + fib(N-2)</code> because that is the value we are currently computing.</li>
<li>Set the <code>prev2</code> value to <code>fib(N-1)</code>.</li>
<li>Set the <code>prev1</code> value to <code>current_value</code>.</li>
<li>When we reach <code>N+1</code>, we will exit the loop and return the previously set <code>current</code> value.</li>
</ul>
<iframe src="https://leetcode.com/playground/pM6EDZh2/shared" frameborder="0" width="100%" height="412" name="pM6EDZh2" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(N)<em>O</em>(<em>N</em>). Each value from <code>2 to N</code> will be visited at least once. The time it takes to do this is directly proportionate to <code>N</code> where <code>N</code> is the <code>Fibonacci Number</code> we are looking to compute.</li>
<li>Space complexity : O(1)<em>O</em>(1). This requires 1 unit of Space for the integer <code>N</code> and 3 units of Space to store the computed values (<code>curr</code>, <code>prev1</code> and <code>prev2</code>) for every loop iteration. The amount of Space doesn’t change so this is constant Space complexity.</li>
</ul>
<hr>
<h4 id="Approach-5-Matrix-Exponentiation"><a href="#Approach-5-Matrix-Exponentiation" class="headerlink" title="Approach 5: Matrix Exponentiation"></a>Approach 5: Matrix Exponentiation</h4><p><strong>Intuition</strong></p>
<p>Use Matrix Exponentiation to get the Fibonacci number from the element at (0, 0) in the resultant matrix.</p>
<p>In order to do this we can rely on the matrix equation for the Fibonacci sequence, to find the <code>Nth</code> Fibonacci number: (1  11  0)n=( F(n+1)     F(n) F(n)     F(n−1))(1110)<em>n</em>=(<em>F</em>(<em>n</em>+1)<em>F</em>(<em>n</em>)<em>F</em>(<em>n</em>)<em>F</em>(<em>n</em>−1))</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Check if <code>N</code> is less than or equal to 1. If it is, return <code>N</code>.</li>
<li>Use a recursive function, <code>matrixPower</code>, to calculate the power of a given matrix <code>A</code>. The power will be <code>N-1</code>, where <code>N</code> is the <code>Nth Fibonacci number</code>.</li>
<li>The <code>matrixPower</code> function will be performed for <code>N/2</code> of the Fibonacci numbers.</li>
<li>Within <code>matrixPower</code>, call the <code>multiply</code> function to multiply 2 matrices.</li>
<li>Once we finish doing the calculations, return <code>A[0][0]</code> to get the <code>Nth</code> Fibonacci number.</li>
</ul>
<iframe src="https://leetcode.com/playground/y9EwghPh/shared" frameborder="0" width="100%" height="500" name="y9EwghPh" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(log⁡N)<em>O</em>(log<em>N</em>). By halving the <code>N</code> value in every <code>matrixPower</code>‘s call to itself, we are halving the work needed to be done.</li>
<li>Space complexity : O(log⁡N)<em>O</em>(log<em>N</em>). The size of the stack in memory is proportionate to the function calls to <code>matrixPower</code> plus the memory used to account for the matrices which takes up constant space.</li>
</ul>
<hr>
<h4 id="Approach-6-Math"><a href="#Approach-6-Math" class="headerlink" title="Approach 6: Math"></a>Approach 6: Math</h4><p><strong>Intuition</strong> Using the <code>golden ratio</code>, a.k.a <code>Binet&#39;s forumula</code>: φ=1+52≈1.6180339887….<em>φ</em>=21+5≈1.6180339887….</p>
<p>Here’s a <a href="http://demonstrations.wolfram.com/GeneralizedFibonacciSequenceAndTheGoldenRatio/" target="_blank" rel="noopener">link</a> to find out more about how the Fibonacci sequence and the golden ratio work.</p>
<p>We can derive the most efficient solution to this problem using only constant time and constant space!</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Use the <code>golden ratio</code> formula to calculate the <code>Nth</code> Fibonacci number.</li>
</ul>
<iframe src="https://leetcode.com/playground/vgmYRSh2/shared" frameborder="0" width="100%" height="157" name="vgmYRSh2" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(1)<em>O</em>(1). Constant time complexity since we are using no loops or recursion and the time is based on the result of performing the calculation using <code>Binet&#39;s formula</code>.</li>
<li>Space complexity : O(1)<em>O</em>(1). The space used is the space needed to create the variable to store the <code>golden ratio</code> formula.</li>
</ul>
<h4 id="面试题-17-16-按摩师"><a href="#面试题-17-16-按摩师" class="headerlink" title="面试题 17.16. 按摩师"></a><a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">面试题 17.16. 按摩师</a></h4><p>难度简单98收藏分享切换为英文关注反馈</p>
<p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p><strong>注意：</strong>本题相对原题稍作改动</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [1,2,3,1]</span><br><span class="line">输出： 4</span><br><span class="line">解释： 选择 1 号预约和 3 号预约，总时长 &#x3D; 1 + 3 &#x3D; 4。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [2,7,9,3,1]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 &#x3D; 2 + 9 + 1 &#x3D; 12。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [2,1,4,5,3,1,1,3]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 &#x3D; 2 + 4 + 3 + 3 &#x3D; 12。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> premax=<span class="number">0</span>;<span class="comment">//记录上一个max</span></span><br><span class="line">        <span class="keyword">int</span> curmax=<span class="number">0</span>;<span class="comment">//当前max</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=curmax;</span><br><span class="line">            curmax=Math.max(premax+i, curmax);<span class="comment">//取当时max还是之前max加上目前值</span></span><br><span class="line">            premax=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curmax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>《程序员面试金典（第 6 版）》独家授权<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/11/logo20190828-02.png" alt="img"></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/30/book_2.jpg" alt="img"></p>
<p>本书是原谷歌资深面试官的经验之作，帮助了许多想要加入脸书、苹果、谷歌等 IT 名企的求职者拿到 Dream offer。本专题的 100+ 编程面试题是在原书基础上精心挑选出来的，帮助你轻松应战 IT 名企技术面试。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%99%BA%E8%83%BD%E5%AD%98%E5%82%A8/" rel="prev" title="动态规划之智能存储">
      <i class="fa fa-chevron-left"></i> 动态规划之智能存储
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E9%81%8D%E5%8E%86/" rel="next" title="二叉树之遍历">
      二叉树之遍历 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#72-编辑距离"><span class="nav-number">1.</span> <span class="nav-text">72. 编辑距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#132-分割回文串-II"><span class="nav-number">2.</span> <span class="nav-text">132. 分割回文串 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-最长回文子串"><span class="nav-number">3.</span> <span class="nav-text">5. 最长回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#198-打家劫舍"><span class="nav-number">4.</span> <span class="nav-text">198. 打家劫舍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#213-打家劫舍-II"><span class="nav-number">5.</span> <span class="nav-text">213. 打家劫舍 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#221-最大正方形"><span class="nav-number">6.</span> <span class="nav-text">221. 最大正方形</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-1-Brute-Force-Accepted"><span class="nav-number">6.0.1.</span> <span class="nav-text">Approach #1 Brute Force [Accepted]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-2-Dynamic-Programming-Accepted"><span class="nav-number">6.0.2.</span> <span class="nav-text">Approach #2 (Dynamic Programming) [Accepted]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-3-Better-Dynamic-Programming-Accepted"><span class="nav-number">6.0.3.</span> <span class="nav-text">Approach #3 (Better Dynamic Programming) [Accepted]</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#309-最佳买卖股票时机含冷冻期"><span class="nav-number">7.</span> <span class="nav-text">309. 最佳买卖股票时机含冷冻期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-1-Dynamic-Programming-with-State-Machine"><span class="nav-number">7.0.1.</span> <span class="nav-text">Approach 1: Dynamic Programming with State Machine</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-2-Yet-Another-Dynamic-Programming"><span class="nav-number">7.0.2.</span> <span class="nav-text">Approach 2: Yet-Another Dynamic Programming</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#337-打家劫舍-III"><span class="nav-number">8.</span> <span class="nav-text">337. 打家劫舍 III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#413-等差数列划分"><span class="nav-number">9.</span> <span class="nav-text">413. 等差数列划分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-1-Brute-Force-Accepted-1"><span class="nav-number">9.0.1.</span> <span class="nav-text">Approach #1 Brute Force [Accepted]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-2-Better-Brute-Force-Accepted"><span class="nav-number">9.0.2.</span> <span class="nav-text">Approach #2 Better Brute Force [Accepted]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-3-Using-Recursion-Accepted"><span class="nav-number">9.0.3.</span> <span class="nav-text">Approach #3 Using Recursion [Accepted]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-5-Dynamic-Programming-Accepted"><span class="nav-number">9.0.4.</span> <span class="nav-text">Approach #5 Dynamic Programming [Accepted]:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-5-Constant-Space-Dynamic-Programming-Accepted"><span class="nav-number">9.0.5.</span> <span class="nav-text">Approach #5 Constant Space Dynamic Programming [Accepted]:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-6-Using-Formula-Accepted"><span class="nav-number">9.0.6.</span> <span class="nav-text">Approach #6 Using Formula [Accepted]:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1039-多边形三角剖分的最低得分"><span class="nav-number">10.</span> <span class="nav-text">1039. 多边形三角剖分的最低得分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1043-分隔数组以得到最大和"><span class="nav-number">11.</span> <span class="nav-text">1043. 分隔数组以得到最大和</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#方法1：DP"><span class="nav-number">11.0.0.1.</span> <span class="nav-text">方法1：DP</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1218-最长定差子序列"><span class="nav-number">12.</span> <span class="nav-text">1218. 最长定差子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1269-停在原地的方案数"><span class="nav-number">13.</span> <span class="nav-text">1269. 停在原地的方案数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1312-让字符串成为回文串的最少插入次数"><span class="nav-number">14.</span> <span class="nav-text">1312. 让字符串成为回文串的最少插入次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#509-斐波那契数"><span class="nav-number">15.</span> <span class="nav-text">509. 斐波那契数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-1-Recursion"><span class="nav-number">15.0.1.</span> <span class="nav-text">Approach 1: Recursion</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-2-Bottom-Up-Approach-using-Memoization"><span class="nav-number">15.0.2.</span> <span class="nav-text">Approach 2: Bottom-Up Approach using Memoization</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-3-Top-Down-Approach-using-Memoization"><span class="nav-number">15.0.3.</span> <span class="nav-text">Approach 3: Top-Down Approach using Memoization</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-4-Iterative-Top-Down-Approach"><span class="nav-number">15.0.4.</span> <span class="nav-text">Approach 4: Iterative Top-Down Approach</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-5-Matrix-Exponentiation"><span class="nav-number">15.0.5.</span> <span class="nav-text">Approach 5: Matrix Exponentiation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Approach-6-Math"><span class="nav-number">15.0.6.</span> <span class="nav-text">Approach 6: Math</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面试题-17-16-按摩师"><span class="nav-number">15.0.7.</span> <span class="nav-text">面试题 17.16. 按摩师</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jackson"
      src="/uploads/hacker.png">
  <p class="site-author-name" itemprop="name">Jackson</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jackson</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
