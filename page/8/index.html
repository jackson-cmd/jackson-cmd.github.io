<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jackson Blog">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="Jackson Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jackson">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jackson Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jackson Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday05/" class="post-title-link" itemprop="url">带你学c带你飞day05</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 21:06:21" itemprop="dateCreated datePublished" datetime="2020-04-20T21:06:21-05:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday04/" class="post-title-link" itemprop="url">带你学c带你飞day04</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 21:06:18" itemprop="dateCreated datePublished" datetime="2020-04-20T21:06:18-05:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday03/" class="post-title-link" itemprop="url">带你学c带你飞day03</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 21:06:14" itemprop="dateCreated datePublished" datetime="2020-04-20T21:06:14-05:00">2020-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-25 09:35:30" itemprop="dateModified" datetime="2020-04-25T09:35:30-05:00">2020-04-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P21"><a href="#P21" class="headerlink" title="P21"></a>P21</h2><p>内存地址存数据</p>
<p>在C语言中，指针的使用非常广泛，因为使用指针往往可以生成更高效、更紧凑的代码。总的来说，使用指针有如下好处：</p>
<p>1）指针的使用使得不同区域的代码可以轻易的共享内存数据，这样可以使程序更为快速高效；</p>
<p>2）C语言中一些复杂的数据结构往往需要使用指针来构建，如链表、二叉树等；</p>
<p>3）C语言是传值调用，而有些操作传值调用是无法完成的，如通过被调函数修改调用函数的对象，但是这种操作可以由指针来完成，而且并不违背传值调用。</p>
<p><strong>3.1 声明并初始化一个指针</strong></p>
<p>　　指针其实就是一个变量，指针的声明方式与一般的变量声明方式没太大区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int *p;        &#x2F;&#x2F; 声明一个 int 类型的指针 p</span><br><span class="line">char *p        &#x2F;&#x2F; 声明一个 char 类型的指针 p</span><br><span class="line">int *arr[10]   &#x2F;&#x2F; 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向 int 类型对象的指针</span><br><span class="line">int (*arr)[10] &#x2F;&#x2F; 声明一个数组指针，该指针指向一个 int 类型的一维数组</span><br><span class="line">int **p;       &#x2F;&#x2F; 声明一个指针 p ，该指针指向一个 int 类型的指针</span><br></pre></td></tr></table></figure>

<p>　　指针的声明比普通变量的声明多了一个一元运算符 “<em>”。运算符 “</em>” 是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。在上述的声明中： p 是一个指针，保存着一个地址，该地址指向内存中的一个变量； *p 则会访问这个地址所指向的变量。</p>
<p>　　声明一个指针变量并不会自动分配任何内存。在对指针进行间接访问之前，指针必须进行初始化：或是使他指向现有的内存，或者给他动态分配内存，否则我们并不知道指针指向哪儿，这将是一个很严重的问题，稍后会讨论这个问题。初始化操作如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 方法1：使指针指向现有的内存 *&#x2F;</span><br><span class="line">int x &#x3D; 1;</span><br><span class="line">int *p &#x3D; &amp;x;　　&#x2F;&#x2F; 指针 p 被初始化，指向变量 x ，其中取地址符 &amp; 用于产生操作数内存地址</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法2：动态分配内存给指针 *&#x2F;</span><br><span class="line">int *p;</span><br><span class="line">p &#x3D; (int *)malloc(sizeof(int) * 10);　　　　&#x2F;&#x2F; malloc 函数用于动态分配内存</span><br><span class="line">free(p);　　　　&#x2F;&#x2F; free 函数用于释放一块已经分配的内存，常与 malloc 函数一起使用，要使用这两个函数需要头文件 stdlib.h</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　指针的初始化实际上就是给指针一个合法的地址，让程序能够清楚地知道指针指向哪儿。</p>
<p><strong>3.2 未初始化和非法的指针</strong> </p>
<p>　　 如果一个指针没有被初始化，那么程序就不知道它指向哪里。它可能指向一个非法地址，这时，程序会报错，在 Linux 上，错误类型是 Segmentation fault（core dumped），提醒我们段违例或内存错误。它也可能指向一个合法地址，实际上，这种情况更严重，你的程序或许能正常运行，但是这个没有被初始化的指针所指向的那个位置的值将会被修改，而你并无意去修改它。用一个例子简单的演示一下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int *p;</span><br><span class="line">    *p &#x3D; 1;</span><br><span class="line">    printf(&quot;%d\n&quot;,*p);</span><br><span class="line"></span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　这个程序可以编译通过，但是运行的话会报错，报错信息如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180917175256031-967973584.png" alt="img"></p>
<p>　　要想使这个程序运行起来，需要先对指针 p 进行初始化：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int x &#x3D; 1;  </span><br><span class="line">    int *p &#x3D; &amp;x;</span><br><span class="line">    printf(&quot;%d\n&quot;,*p);</span><br><span class="line">　  *p &#x3D; 2;</span><br><span class="line">    printf(&quot;%d\n&quot;,*p);</span><br><span class="line"></span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　这段代码的输出结果如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180917212250007-280056505.png" alt="img"> </p>
<p>　　可以看到，对指针进行初始化后，便可以正常对指针进行赋值了。 </p>
<p><strong>3.3 NULL指针</strong></p>
<p>　　<strong>NULL 指针是一个特殊的指针变量，表示不指向任何东西</strong>。可以通过给一个指针赋一个零值来生成一个 NULL 指针。 </p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int *p &#x3D; NULL;</span><br><span class="line">    printf(&quot;p的地址为%d\n&quot;,p);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;***************</span><br><span class="line"> * 程序输出：</span><br><span class="line"> * p的地址为0</span><br><span class="line">***************&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　可以看到指针指向内存地址0。在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是为操作系统保留的。但是，内存地址 0 有一个特别重要的意义，它表明改指针不指向一个可访问的内存位置。</p>
<p><strong>四、指针的运算</strong></p>
<p>　　C 指针的算术运算只限于两种形式：</p>
<p>1） 指针 +/- 整数 ：</p>
<p>　　 可以对指针变量 p 进行 p++、p–、p + i 等操作，所得结果也是一个指针，只是指针所指向的内存地址相比于 p 所指的内存地址前进或者后退了 i 个操作数。用一张图来说明一下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180921154218407-1813012241.png" alt="img"></p>
<p>　　在上图中，10000000等是内存地址的十六进制表示（数值是假定的），p 是一个 int 类型的指针，指向内存地址 0x10000008 处。则 p++ 将指向与 p 相邻的下一个内存地址，由于 int 型数据占 4 个字节，因此 p++ 所指的内存地址为 1000000b。其余类推。不过要注意的是，这种运算并不会改变指针变量 p 自身的地址，只是改变了它所指向的地址。举个例子：</p>
<p>2）指针 - 指针</p>
<p>　　只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。两个指针相减的结果的类型是 ptrdiff_t，它是一种有符号整数类型。减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位），因为减法运算的结果将除以数组元素类型的长度。举个例子：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[10] &#x3D; &#123;1,2,3,4,5,6,7,8,9,0&#125;;</span><br><span class="line">    int sub;</span><br><span class="line">    int *p1 &#x3D; &amp;a[2];</span><br><span class="line">    int *p2 &#x3D; &amp;a[8];</span><br><span class="line"></span><br><span class="line">    sub &#x3D; p2-p1;                                                                            </span><br><span class="line">    printf(&quot;%d\n&quot;,sub);　　　　&#x2F;&#x2F; 输出结果为 6</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>五、指针与数组</strong></p>
<p>　　在C语言中，指针与数组之间的关系十分密切。实际上，许多可以用数组完成的工作都可以使用指针来完成。一般来说，用指针编写的程序比用数组编写的程序执行速度快，但另一方面，用指针实现的程序理解起来稍微困难一些。</p>
<p><strong>5.1 指针与数组的关系</strong></p>
<p>　　我们先声明一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[10];        &#x2F;&#x2F; 声明一个int类型的数组，这个数组有10个元素</span><br></pre></td></tr></table></figure>

<p>　　我们可以用 a[0]、a[1]、…、a[9] 来表示这个数组中的10个元素，这10个元素是存储在一段连续相邻的内存区域中的。</p>
<p>　　接下来，我们再声明一个指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p;           &#x2F;&#x2F; 声明一个int类型的指针变量</span><br></pre></td></tr></table></figure>

<p>　　 p 是一个指针变量，指向内存中的一个区域。如果我们对指针 p 做如下的初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; &amp;a[0];        &#x2F;&#x2F; 对指针进行初始化，p将指向数组 a 的第 1 个元素 a[0]</span><br></pre></td></tr></table></figure>

<p>　　我们知道，对指针进行自增操作会让指针指向与当前元素相邻的下一个元素，即 <em>(p + 1) 将指向 a[1] ；同样的， <em>(p + i) 将指向 a[i] 。因此，我们可以使用该指针来遍历数组 a[10] 的所有元素。可以看到，数组下标与指针运算之间的关系是一一对应的。而根据定义，</em></em>数组类型的变量或表达式的值是该数组第 1 个元素的地址**，且数组名所代表的的就是该数组第 1 个元素的地址，故，上述赋值语句可以直接写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; a;        &#x2F;&#x2F; a 为数组名，代表该数组最开始的一个元素的地址</span><br></pre></td></tr></table></figure>

<p>　　很显然，<strong>一个通过数组和下标实现的表达式可以等价地通过指针及其偏移量来实现</strong>，这就是数组和指针的互通之处。但有一点要明确的是，数组和指针并不是完全等价，<em>指针是一个变量，而数组名不是变量，它数组中第 1 个元素的地址</em>，数组可以看做是一个用于保存变量的容器。更直接的方法，我们可以直接看二者的地址，并不一样：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;                                                                          </span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    int x[10] &#x3D; &#123;1,2,3,4,5,6,7,8,9,0&#125;;</span><br><span class="line">    int *p &#x3D; x;</span><br><span class="line">    printf(&quot;x的地址为：%p\n&quot;,x);</span><br><span class="line">    printf(&quot;x[0]的地址为：%p\n&quot;,&amp;x[0]);</span><br><span class="line">    printf(&quot;p的地址为：%p\n&quot;,&amp;p);　　　　　　&#x2F;&#x2F; 打印指针 p 的地址，并不是指针所指向的地方的地址</span><br><span class="line"></span><br><span class="line">    p +&#x3D; 2;</span><br><span class="line">    printf(&quot;*(p+2)的值为：%d\n&quot;,*p);　　　　&#x2F;&#x2F; 输出结果为 3，*(p+2)指向了 x[2]</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　结果如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180918160417548-189120951.png" alt="img"></p>
<p>　　可以看到， x 的值与 x[0] 的地址是一样的，也就是说数组名即为数组中第 1 个元素的地址。实际上，打印 &amp;x 后发现，x 的地址也是这个值。而 x 的地址与指针变量 p 的地址是不一样的。故而数组和指针并不能完全等价。</p>
<p>（笔者注：上述输出结果是在 centos7 64bit 的环境下使用 gcc 编译器得到的，可以看到地址是一个12位的十六进制数，转换成二进制是48位，也就是说寻址空间有 256TB，但是笔者的电脑只有 8GB 内存，猜测是不是由于 linux 系统开启了内存分页机制，这里寻址的是虚拟地址？另外，在Windows下使用 vs2015 编译运行的话，则输出结果是一个 8位的十六进制数，也就是32位二进制，寻址空间为 4GB） </p>
<p><strong>5.2 指针数组</strong></p>
<p>　　指针是一个变量，而数组是用于存储变量的容器，因此，指针也可以像其他变量一样存储在数组中，也就是指针数组。 <strong>指针数组是一个数组，数组中的每一个元素都是指针</strong>。声明一个指针数组的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p[10];    &#x2F;&#x2F; 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向int类型的指针</span><br></pre></td></tr></table></figure>

<p>　　在上述声明中，由于 [] 的优先级比 * 高，故 p 先与 [] 结合，成为一个数组 p[]；再由 int * 指明这是一个 int 类型的指针数组，数组中的元素都是 int 类型的指针。数组的第 i 个元素是 <em>p[i]，而 *</em>p[i] 是一个指针**。由于指针数组中存放着多个指针，操作灵活，在一些需要操作大量数据的程序中使用，可以使程序更灵活快速。</p>
<p><strong>5.3 数组指针</strong></p>
<p>　　<strong>数组指针是一个指针，它指向一个数组</strong>。声明一个数组指针的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*p)[10];        &#x2F;&#x2F; 声明一个数组指针 p ，该指针指向一个数组</span><br></pre></td></tr></table></figure>

<p>　　由于 () 的优先级最高，所以 p 是一个指针，指向一个 int 类型的一维数组，这个一维数组的长度是 10，这也是指针 p 的步长。也就是说，执行 p+1 时，p 要跨过 n 个 int 型数据的长度。数组指针与二维数组联系密切，可以用数组指针来指向一个二维数组，如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int arr[2][3] &#x3D; &#123;1,2,3,4,5,6&#125;;               &#x2F;&#x2F; 定义一个二维数组并初始化</span><br><span class="line">    int (*p)[3];                                 &#x2F;&#x2F; 定义一个数组指针，指针指向一个含有3个元素的一维数组</span><br><span class="line"></span><br><span class="line">    p &#x3D; arr;                                     &#x2F;&#x2F; 将二维数组的首地址赋给 p，此时 p 指向 arr[0] 或 &amp;arr[0][0]</span><br><span class="line">    printf(&quot;%d\n&quot;,(*p)[0]);　　　　　　　　　　　　  &#x2F;&#x2F; 输出结果为 1</span><br><span class="line">    p++;　　　　　　　　　　　　　　　　　　　　　　　　 &#x2F;&#x2F; 对 p 进行算术运算，此时 p 将指向二维数组的下一行的首地址，即 &amp;arr[1][0]</span><br><span class="line">    printf(&quot;%d\n&quot;,(*p)[1]);                      &#x2F;&#x2F; 输出结果为5</span><br><span class="line"></span><br><span class="line">    return 0;                                                                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>六、指针与结构</strong></p>
<p><strong>6.1 简单介绍一下结构</strong></p>
<p>　　结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。由于结构将一组相关的变量看做一个单元而不是各自独立的实体，因此结构有助于组织复杂的数据，特别是在大型的程序中。声明一个结构的方式如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct message&#123;　　　　　　      &#x2F;&#x2F; 声明一个结构 message</span><br><span class="line">    char name[10];             &#x2F;&#x2F; 成员</span><br><span class="line">    int age;</span><br><span class="line">    int score;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct message s_message;　　　　 &#x2F;&#x2F; 类型定义符 typedef</span><br><span class="line"></span><br><span class="line">s_message mess &#x3D; &#123;&quot;tongye&quot;,23,83&#125;;　　　　&#x2F;&#x2F; 声明一个 struct message 类型的变量 mess,并对其进行初始化　</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line">&#x2F;* 另一种更简便的声明方法 *&#x2F;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">　　char name[10];</span><br><span class="line">　　int age;</span><br><span class="line">　　int score;</span><br><span class="line">&#125;message;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　可以使用 <strong>结构名.成员</strong> 的方式来访问结构中的成员，如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">　　printf(&quot;%s\n&quot;,mess.name);　　　　&#x2F;&#x2F; 输出结果：tongye</span><br><span class="line">　　printf(&quot;%d\n&quot;,mess.age);　　　　 &#x2F;&#x2F; 输出结果：23</span><br><span class="line"></span><br><span class="line">　　return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>6.2 结构指针</strong>　</p>
<p>　　结构指针是指向结构的指针，以上面的结构为例，可以这样定义一个结构指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s_message *p;        &#x2F;&#x2F; 声明一个结构指针 p ，该指针指向一个 s_message 类型的结构</span><br><span class="line">*p &#x3D; &amp;mess;　　　　　　&#x2F;&#x2F; 对结构指针的初始化与普通指针一样，也是使用取地址符 &amp;</span><br></pre></td></tr></table></figure>

<p>　　C语言中使用 -&gt; 操作符来访问结构指针的成员，举个例子：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char name[10];</span><br><span class="line">    int age;</span><br><span class="line">    int score;  </span><br><span class="line">&#125;message;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    message mess &#x3D; &#123;&quot;tongye&quot;,23,83&#125;;</span><br><span class="line">    message *p &#x3D; &amp;mess;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%s\n&quot;,p-&gt;name);　　　　　　&#x2F;&#x2F; 输出结果为：tongye</span><br><span class="line">    printf(&quot;%d\n&quot;,p-&gt;score);         &#x2F;&#x2F; 输出结果为：83</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>七、指针与函数</strong></p>
<p>　　<strong>C语言的所有参数均是以“传值调用”的方式进行传递的</strong>，这意味着函数将获得参数值的一份拷贝。这样，函数可以放心修改这个拷贝值，而不必担心会修改调用程序实际传递给它的参数。 </p>
<p><strong>7.1 指针作为函数的参数</strong></p>
<p>　　传值调用的好处是是被调函数不会改变调用函数传过来的值，可以放心修改。但是有时候需要被调函数回传一个值给调用函数，这样的话，传值调用就无法做到。为了解决这个问题，可以使用传指针调用。<strong>指针参数使得被调函数能够访问和修改主调函数中对象的值。</strong>用一个例子来说明：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">void swap1(int a,int b)　　　　　　  &#x2F;&#x2F; 参数为普通的 int 变量</span><br><span class="line">&#123;</span><br><span class="line">　　int temp;</span><br><span class="line">　　temp &#x3D; a;</span><br><span class="line">　　a &#x3D; b;</span><br><span class="line">　　b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap2(int *a,int *b)　　　　　　&#x2F;&#x2F; 参数为指针，接受调用函数传递过来的变量地址作为参数，对所指地址处的内容进行操作</span><br><span class="line">&#123;</span><br><span class="line">　　int temp;　　　　                &#x2F;&#x2F; 最终结果是，地址本身并没有改变，但是这一地址所对应的内存段中的内容发生了变化，即x,y的值发生了变化</span><br><span class="line">　　temp &#x3D; *a;</span><br><span class="line">　　*a &#x3D; *b;</span><br><span class="line">　　*b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">　　int x &#x3D; 1,y &#x3D; 2;</span><br><span class="line">　　swap1(x,y);                     &#x2F;&#x2F; 将 x,y 的值本身作为参数传递给了被调函数</span><br><span class="line">　　printf(&quot;%d %5d\n&quot;,x,y);         &#x2F;&#x2F; 输出结果为：1     2</span><br><span class="line"></span><br><span class="line">　　swap(&amp;x,&amp;y);                    &#x2F;&#x2F; 将 x,y 的地址作为参数传递给了被调函数，传递过去的也是一个值，与传值调用不冲突</span><br><span class="line">　　printf(&quot;%d %5d\n&quot;,x,y);         &#x2F;&#x2F; 输出结果为：2     1</span><br><span class="line">　　return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>7.2 指向函数的指针</strong></p>
<p>　　在C语言中，函数本身不是变量，但是可以定义指向函数的指针，也称作函数指针，函数指针指向函数的入口地址。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。 声明一个函数指针的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 （* 指针变量名）（[形参列表]）;</span><br><span class="line"></span><br><span class="line">int (*pointer)(int *,int *);        &#x2F;&#x2F; 声明一个函数指针</span><br></pre></td></tr></table></figure>

<p>　　上述代码声明了一个函数指针 pointer ，该指针指向一个函数，函数具有两个 int * 类型的参数，且返回值类型为 int。下面的代码演示了函数指针的用法：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line"></span><br><span class="line">int str_comp(const char *m,const char *n);                             &#x2F;&#x2F; 声明一个函数 str_comp，该函数有两个 const char 类型的指针，函数的返回值为 int 类型</span><br><span class="line">void comp(char *a,char *b,int (*prr)(const char *,const char*));       &#x2F;&#x2F; 声明一个函数 comp ,注意该函数的第三个参数，是一个函数指针</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char str1[20];      &#x2F;&#x2F; 声明一个字符数组</span><br><span class="line">    char str2[20];</span><br><span class="line">    int (*p)(const char *,const char *) &#x3D; str_comp;　　　　　　　　　　　 &#x2F;&#x2F; 声明并初始化一个函数指针，该指针所指向的函数有两个 const char 类型的指针，且返回值为 int 类型</span><br><span class="line">    gets(str1);         &#x2F;&#x2F; 使用 gets() 函数从 I&#x2F;O 读取一行字符串</span><br><span class="line">    gets(str2);</span><br><span class="line">    comp(str1,str2,p);  &#x2F;&#x2F; 函数指针 p 作为参数传给 comp 函数</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int str_comp(const char *m,const char *n)</span><br><span class="line">&#123;</span><br><span class="line">　　 &#x2F;&#x2F; 库函数 strcmp 用于比较两个字符串，其原型是： int strcmp(const char *s1,const char *s2);</span><br><span class="line">    if(strcmp(m,n) &#x3D;&#x3D; 0) </span><br><span class="line">        return 0;</span><br><span class="line">    else</span><br><span class="line">        return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 函数 comp 接受一个函数指针作为它的第三个参数 *&#x2F;</span><br><span class="line">void comp(char *a,char *b,int (*prr)(const char *,const char*))</span><br><span class="line">&#123;</span><br><span class="line">    if((*prr)(a,b) &#x3D;&#x3D; 0)</span><br><span class="line">        printf(&quot;str1 &#x3D; str2\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;str1 !&#x3D; str2\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　这段代码的功能是从键盘读取两行字符串（长度不超过20），判断二者是否相等。</p>
<p>　　注意，声明一个函数指针时，() 不能漏掉，否则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p(void *,void*);</span><br></pre></td></tr></table></figure>

<p>　　这表明 p 是一个函数，该函数返回一个指向 int 类型的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a=<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> *pa=&amp;a;</span><br></pre></td></tr></table></figure>

<p>指针长度：以前是16位地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就占8个字节。</p>
<p>避免访问未初始化指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a; *a=<span class="number">123</span>;<span class="comment">//野指针</span></span><br></pre></td></tr></table></figure>

<h2 id="P22"><a href="#P22" class="headerlink" title="P22"></a>P22</h2><p>&amp;取值操作符</p>
<p>数组名就是地址信息，也是第一个元素的地址。</p>
<p>当指针指向数组元素是，可以对指针变量进行加减运算。指针加一指向下一个元素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday02/" class="post-title-link" itemprop="url">带你学c带你飞day02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-20 21:06:09 / Modified: 22:35:12" itemprop="dateCreated datePublished" datetime="2020-04-20T21:06:09-05:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P11"><a href="#P11" class="headerlink" title="P11"></a>P11</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);<span class="comment">//地址</span></span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"true"</span>);<span class="comment">//这样缩进可以</span></span><br><span class="line"><span class="keyword">if</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P12"><a href="#P12" class="headerlink" title="P12"></a>P12</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量表达式<span class="number">1</span>：语句或代码块；</span><br><span class="line">	<span class="keyword">case</span> ...</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">	<span class="keyword">default</span>: 语句或代码块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line">  <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span>: <span class="built_in">printf</span>(<span class="string">"hi"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'B'</span>: <span class="built_in">printf</span>(<span class="string">"hey"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">"hello"</span>); </span><br><span class="line">    <span class="keyword">break</span>;<span class="comment">//不加break会导致所有case都输出了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(has = <span class="string">"a"</span>)&#123;&#125;<span class="comment">//永远对，所以应该 ==</span></span><br></pre></td></tr></table></figure>

<h2 id="P13"><a href="#P13" class="headerlink" title="P13"></a>P13</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">()</span></span>;<span class="comment">//读取下一个字符</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>()&#123;&#125;<span class="comment">//判断后循环</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>()；<span class="comment">//先循环在判断，while后面有语句</span></span><br></pre></td></tr></table></figure>

<h2 id="P14"><a href="#P14" class="headerlink" title="P14"></a>P14</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环初始;循环结束;循环条件)&#123;&#125;</span><br><span class="line"><span class="built_in">_Bool</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, <span class="keyword">int</span> j=<span class="number">0</span>;i&lt;j;i++,j++)&#123;&#125;<span class="comment">//也可以</span></span><br><span class="line">若想 <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">10</span>;<span class="comment">//则需 gcc -std=c99 test.c &amp;&amp; ./a.out</span></span><br></pre></td></tr></table></figure>

<h2 id="P15"><a href="#P15" class="headerlink" title="P15"></a>P15</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> 在<span class="built_in">printf</span>中是%lld</span><br><span class="line">  <span class="keyword">break</span>跳出当前循环，<span class="keyword">continue</span>直接进入下一次循环</span><br></pre></td></tr></table></figure>

<h2 id="P16"><a href="#P16" class="headerlink" title="P16"></a>P16</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">5</span>, j;</span><br><span class="line">j=++i;<span class="comment">//i=6=j</span></span><br><span class="line">i=<span class="number">5</span>;</span><br><span class="line">j=i++;<span class="comment">//i=6,j=5</span></span><br><span class="line"><span class="comment">//i++先把值给j，再加加</span></span><br><span class="line"><span class="comment">//多语句，逗号表达式</span></span><br><span class="line"><span class="comment">/* 语法：表达式1，...表达式n</span></span><br><span class="line"><span class="comment">表达式从左到右计算</span></span><br><span class="line"><span class="comment">	逗号表达式作为一个整体，值为最后一个表达式也就是n的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">a=(b=<span class="number">3</span>, (c=b+<span class="number">4</span>) +<span class="number">5</span>)<span class="comment">//a=12</span></span><br><span class="line">exp1 ? exp2:exp3  <span class="comment">//if exp1==true , exp2, else: exp3</span></span><br><span class="line"><span class="comment">//goto 跳到标签</span></span><br><span class="line">  <span class="keyword">goto</span> A;<span class="comment">//谨慎用goto</span></span><br><span class="line">  A: <span class="built_in">printf</span>(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="P17"><a href="#P17" class="headerlink" title="P17"></a>P17</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组 类型 数组名[元素个数]</span></span><br><span class="line"><span class="comment">/*数组不能动态定义</span></span><br><span class="line"><span class="comment">int 自动初始化为0，最好手动初始化，要不然栈内空间会错误赋值，可能。</span></span><br><span class="line"><span class="comment">int a[5]=&#123;[2]=2,[3]=3&#125;;//这样可以</span></span><br><span class="line"><span class="comment">sizeof(a);//计算数组内存大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="P18"><a href="#P18" class="headerlink" title="P18"></a>P18</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态数组</span></span><br><span class="line">c99, c支持可变长数组，数组长度在运行时才被决定</span><br><span class="line">  新编译， 在数组越界不会出现错误，好像</span><br></pre></td></tr></table></figure>

<h2 id="P19"><a href="#P19" class="headerlink" title="P19"></a>P19</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">字符串数组定义：</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[]=&#123;<span class="string">"ab"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[]=<span class="string">"ab"</span>;</span><br><span class="line">字符串处理函数：&lt;<span class="built_in">string</span>.h&gt;内</span><br><span class="line">  <span class="built_in">strcat</span>：连接字符串</span><br><span class="line">  <span class="built_in">strcmp</span>:比较字符串</span><br><span class="line">  <span class="built_in">strcpy</span>:拷贝字符串</span><br><span class="line">  <span class="built_in">strlen</span>:获取长度</span><br><span class="line">  <span class="built_in">strncat</span>(str1,str2,<span class="number">5</span>):（以下<span class="number">3</span>个受限，功能一样）<span class="comment">//str2拷贝5个字符到str1</span></span><br><span class="line">  <span class="built_in">strcmp</span>:</span><br><span class="line">  <span class="built_in">strncpy</span>:</span><br><span class="line"><span class="keyword">sizeof</span>(str);<span class="comment">//n</span></span><br><span class="line"><span class="built_in">strlen</span>(str);<span class="comment">//n-1, 因为strlen不包括那个\n，sizeof包括</span></span><br></pre></td></tr></table></figure>

<h3 id="1-字符串基础"><a href="#1-字符串基础" class="headerlink" title="1 字符串基础"></a>1 字符串基础</h3><p>字符串是一种重要的数据类型，有零个或多个字符组成的有限串行。</p>
<p>定义子串: 串中任意个连续的字符组成的子序列，并规定空串是任意串的子串，任意串也是其自身的子串，如字符串”adereegfb”中它本身、空串、诸如”ader”连续的字符串都是它的子串。子序列则不要求字符连续，但顺序要与主串保持一致，若有”abcd”与”ad”则两者的最长公共子序列为”ad”。在动态规划中计算最长公共子序列和最长公共子串中一定要能区分这两个概念!</p>
<p>在C语言中并没有显示的字符串类型，它有如下两种风格的字符串：</p>
<ul>
<li>字符串常量: 以双引号扩起来的字符序列，规定所有的字符串常量都由编译器自动在末尾添加一个空字符</li>
<li>字符数组: 末尾添加了’\0’的字符数组，一般需要显示在末尾添加空字符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char c1[]&#x3D;&#123;&#39;c&#39;,&#39;+&#39;,&#39;+&#39;&#125;; &#x2F;&#x2F;末尾没有空字符</span><br><span class="line">char c2[]&#x3D;&#123;&#39;c&#39;,&#39;+&#39;,&#39;+&#39;，&#39;\0&#39;&#125;; &#x2F;&#x2F;末尾显示添加空字符</span><br><span class="line">char c3&#x3D;&quot;c++&quot;; &#x2F;&#x2F;末尾自动添加空字符</span><br></pre></td></tr></table></figure>

<p>注意到通过字符数组初始化和字符串常量初始化并不完全相同的。因为字符串常量包含一个额外的空字符用于结束字符串，用它来初始化创建数组时，末尾会自动添加空字符。所以c1的长度是3，后两者的长度是4，并且字符数组c2和c3都被称为C风格字符串，而字符数组c1不是C风格字符串。</p>
<p>规定C风格的字符串都是以NULL空字符(‘\0’)作为终结符结尾。由于它是字符串的终止符，但它本身并不是字符串的一部分，所以字符串的长度并不包括NULL字节，如strlen函数。而且C标准库中提供的各种字符串处理函数都要求提供的字符串或字符数组必须以空字符结束，否则会出现不可预料的结果。如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char c[]&#x3D;&#123;&#39;c&#39;,&#39;+&#39;,&#39;+&#39;&#125;;</span><br><span class="line">printf(&quot;%d\n&quot;,strlen(c)); &#x2F;&#x2F;结果输出为6，这是不正确的</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-标准库中的字符串处理函数"><a href="#2-标准库中的字符串处理函数" class="headerlink" title="2 标准库中的字符串处理函数"></a>2 标准库中的字符串处理函数</h3><p>C标准库中头文件<code>定义了两组字符串函数(C++中用</code>表示)。</p>
<ul>
<li>第一组函数的名字以str开头，它主要处理以’\0’结尾的字符串，所以字符串内部不能包含任何’\0’字符。</li>
<li>第二组函数的名字以mem开头，主要考虑非字符串内部含有零值的情形，它能够处理任意的字节序列，操作与字符串函数类似</li>
<li>除了memmove函数外，其他函数都没定义重叠对象间的行为</li>
</ul>
<p>为了提高程序在不同机器上的移植性，利用typedef定义新类型名，即<code>typedef unsigned int size_t</code>。 程序员必须要保证目标字符数组的空间能够足以存放结果字符串(有可能存在字符数组溢出的危险)</p>
<ul>
<li>字符串处理类</li>
</ul>
<p>如下表为字符串处理函数说明，变量s,t的类型是<code>char *</code>, cs和ct的类型是<code>const char *</code>;n的类型为<code>size_t</code>,c的类型为<code>int</code>。</p>
<p><img src="https://images0.cnblogs.com/blog2015/678327/201507/311507392043956.png" alt="img"></p>
<ul>
<li>内存操作类</li>
</ul>
<p>按照字节数组的方式操作对象，提供一个高效的函数接口(提供字节流的访问)。其中s,t类型是<code>void *</code> ， cs，ct的类型是<code>const void *</code>; n类型为<code>size_t</code>，c类型为<code>int</code>。</p>
<p><img src="https://images0.cnblogs.com/blog2015/678327/201507/311507530171602.png" alt="img"></p>
<p>总结起来，头文件&lt; string.h&gt;实现了如下函数：</p>
<ul>
<li>长度计算、长度不受限和受限的复制、连接和比较版本的函数</li>
<li>基础字符串查找(查找一个字符、一组字符和匹配一个子串)、高级字符串查找（查找子串前缀位置、返回token标记）</li>
<li>处理任意字节序列的内存操作如复制、比较、查找和初始化等函数</li>
</ul>
<h2 id="P20"><a href="#P20" class="headerlink" title="P20"></a>P20</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组矩阵</span></span><br><span class="line">和一维数组一样</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9E/" class="post-title-link" itemprop="url">带你学c带你飞（day1）小甲鱼视频</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-20 15:59:53 / Modified: 17:23:04" itemprop="dateCreated datePublished" datetime="2020-04-20T15:59:53-05:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P1"><a href="#P1" class="headerlink" title="P1"></a>P1</h2><p>打广告</p>
<h2 id="P2"><a href="#P2" class="headerlink" title="P2"></a>P2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.所有的 C 语言程序都需要包含 main() 函数。 代码从 main() 函数开始执行。</span><br><span class="line"></span><br><span class="line">2.&#x2F;* ... *&#x2F; 用于注释说明。</span><br><span class="line"></span><br><span class="line">3.printf() 用于格式化输出到屏幕。printf() 函数在 &quot;stdio.h&quot; 头文件中声明。</span><br><span class="line"></span><br><span class="line">4.stdio.h 是一个头文件 (标准输入输出头文件) , #include 是一个预处理命令，用来引入头文件。 当编译器遇到 printf() 函数时，如果没有找到 stdio.h 头文件，会发生编译错误。</span><br><span class="line"></span><br><span class="line">5.return 0; 语句用于表示退出程序。</span><br></pre></td></tr></table></figure>

<h2 id="P3"><a href="#P3" class="headerlink" title="P3"></a>P3</h2><p>打印 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">print</span>\</span><br><span class="line">f(<span class="string">"hi"</span>&#125;)<span class="comment">//反斜杠表示读下一行开头，可以运行，换行符\n;</span></span><br></pre></td></tr></table></figure>

<h2 id="p4"><a href="#p4" class="headerlink" title="p4"></a>p4</h2><p>变量名：英文字母数字，下划线组成，开头必须是字母下划线。</p>
<p>c有32个关键字</p>
<p>第一类：数 据类型关键 字</p>
<p>A基本数据类 型（5个）：</p>
<p>void： 声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果。</p>
<p>char： 字符型类型数据，属于整型数据的一种。</p>
<p>int： 整型数据，通常为编译器指定的机器字长。</p>
<p>float： 单精度浮点型数据，属于浮点数据的一种，小数点后保存6位。</p>
<p>double： 双精度浮点型数据，属于浮点数据的一种，比float保存的精度高，小数点后保存15/16位。</p>
<p>B类型修饰关 键字（4个）：</p>
<p>short ：修饰int，短整型数据，可省略被修饰的int。 </p>
<p>long ：修饰int，长整形数据，可省略被修饰的int。 </p>
<p>signed ：修饰整型数据，有符号数据类型。 </p>
<p>unsigned： 修饰整型数据，无符号数据类型。</p>
<p>C复杂类型关 键字（5个）：</p>
<p>struct ：结构体声明。 </p>
<p>union ：共用体声明。 </p>
<p>enum ：枚举声明。 </p>
<p>typedef ：声明类型别名。 </p>
<p>sizeof ：得到特定类型或特定类型变量的大小。</p>
<p>D存储级别关 键字（6个）：</p>
<p>auto ：指定为自动变量，由编译器自动分配及释放。通常在栈上分配。 </p>
<p>static ：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部。 </p>
<p>register ：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通 过寄存器而不是堆栈传递参数。 </p>
<p>extern ：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的。 </p>
<p>const ：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改 </p>
<p>volatile ：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存 中取得该变量的值。</p>
<p>第二类：流 程控制关键 字</p>
<p>A跳转结构（4 个）：</p>
<p>return ：用在函数体中，返回特定值（或者是void值，即不返回值）。 </p>
<p>continue： 结束当前循环，开始下一轮循环。 </p>
<p>break ：跳出当前循环或switch结构。 </p>
<p>goto ：无条件跳转语句。</p>
<p>B分支结构（5 个）：</p>
<p>if ：条件语句。 </p>
<p>else： 条件语句否定分支（与if连用）。 </p>
<p>switch： 开关语句（多重分支语句）。 </p>
<p>case ：开关语句中的分支标记。 </p>
<p>default： 开关语句中的“其他”分治，可选。</p>
<p>C循环结构（3 个）：</p>
<p>for ：for循环结构，for(1;2;3)4;的执行顺序为1-&gt;2-&gt;4-&gt;3-&gt;2…循环，其中2为循环条件。 </p>
<p>do：do循环结构，do 1 while(2);的执行顺序是1-&gt;2-&gt;1…循环，2为循环条件。 </p>
<p>while： while循环结构，while(1) 2;的执行顺序是1-&gt;2-&gt;1…循环，1为循环条件， 以上循环语句，当循环条件 表达式为真则继续循环，为假则跳出循环。</p>
<p>c99新增5个关键字</p>
<p>1、<strong>inline</strong>关键字用来定义一个类的内联函数，引入它的主要原因是用它替代C中表达式形式的宏定义</p>
<p>引入原因：C语言是一个效率很高的语言，这种宏定义在形式及使用上像一个函数，但它使用预处理器实现，没有了<strong>参数压栈，代码生成</strong>等一系列的操作</p>
<p>2、<strong>restrict</strong>关键字只用于限定指针；该关键字用于告知编译器，所有修改该指针所指向内容的操作全部都是基于(base on)该指针的，即不存在其它进行修改操作的途径；这样的后果是帮助编译器进行更好的代码优化，生成更有效率的汇编代码。</p>
<p>3、<strong>_Bool</strong>关键字是用于表示布尔值。包含标准头文件 stdbool.h 后，我们可以用 bool 代替 _Bool ，true 代替 1 ，false 代替 0 。</p>
<p>4、<strong>_Complex</strong>and<strong>_Imaginary</strong>关键字</p>
<p>C99标准中定义的复数类型如下：float_Complex; float_Imaginary; double_Complex; double_Imaginary; long double_Complex; long double_Imaginary.</p>
<p>头文件中定义了complex和imaginary宏,并将它们扩展为_Complex和_Imaginary,因此在编写新的应用程序时,应该使用头文件中的complex和imaginary宏。</p>
<p><strong>C语言32个关键字（C99新增5个、C11新增7个）</strong></p>
<p>按年份起始：</p>
<p><strong>auto break case char const continue default do</strong> <strong>double else enum extern float for goto if</strong> <strong>int long register return short signed sizeof static</strong> <strong>struct switch typedef union unsigned void volatile while</strong>1999年12月16日，ISO推出了C99标准，该标准新增了5个C语言关键字：</p>
<p>inline restrict _Bool _Complex _Imaginary2011年12月8日，ISO发布C语言的新标准C11，该标准新增了7个C语言关键字：</p>
<p>_Alignas _Alignof _Atomic _Static_assert _Noreturn _Thread_local _Generic</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%d<span class="comment">//int</span></span><br><span class="line">%c<span class="comment">//char</span></span><br><span class="line">%<span class="number">11.9</span><span class="comment">//11位，小数点后9位</span></span><br><span class="line">gcc test.c -o test &amp;&amp; ./test <span class="comment">//这个-o可以改a.out为你想要的名字， 用&amp;&amp;可以合并编译运行两个阶段，而/ 的意思：目录级别分隔符</span></span><br><span class="line">. 的意思：当前目录</span><br><span class="line">./a 的意思就是：当前目录下文件名为“a”的文件。</span><br><span class="line">Linux中还有 .. 代表上抄级目录</span><br></pre></td></tr></table></figure>

<h2 id="P5"><a href="#P5" class="headerlink" title="P5"></a>P5</h2><p>字符常量单引号，字符串常量双引号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义, 标识符全大写，宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 标识符 常量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.1415926535</span></span><br></pre></td></tr></table></figure>

<p>C++ 语言可以用const 来定义常量，也可以用#define 来定义常量。但是前者比后者有更多的优点：<br>（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。<br>（2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。规则5-2-1：在C++ 程序中只使用const 常量而不使用宏常量，即const 常量完全取代宏常量。</p>
<p>2.实现机制</p>
<p>宏是预处理命令，即在预编译阶段进行字节替换。const常量是变量，在执行时const定义的只读变量在程序运行过程中只有一份拷贝（因为它是全局的只读变量，存放在静态存储区的只读数据区。根据c/c++语法，当你声明该量为常量，即告诉程序和编译器，你不希望此量被修改。 程序的实现，为了保护常量，特将常量都放在受保护的静态存储区内。凡是试图修改这个区域内的值，都将被视为非法，并报错。 这不能理解为凡是字符串都是放在静态存储区域的。这个跟数据类型没有关系，而是这个量是变量还是常量的问题。例如，一个字符串变量就是可以被修改的。 这种静态存储区域的保护机制是由编译器实现的，而非存储该值的内存的电器属性。换言之，实质上内存永远都可以被用户随意修改，只是编译器给用户的代码注入了一些自己的保护代码，通过软件手段将这段内存软保护起来。这种保护在汇编级别可以轻松突破，其保护也就无效了。）。</p>
<p>3.用法区别</p>
<p>define宏定义和const常变量区别：<br>1.define是宏定义，程序在预处理阶段将用define定义的内容进行了替换。因此程序运行时，常量表中并没有用define定义的常量，系统不为它分配内存。const定义的常量，在程序运行时在常量表中，系统为它分配内存。<br>2.define定义的常量，预处理时只是直接进行了替换。所以编译时不能进行数据类型检验。const定义的常量，在编译时进行严格的类型检验，可以避免出错。3.define定义表达式时要注意“边缘效应”，例如如下定义：<br>#define N 2+3 //我们预想的N值是5，我们这样使用N，int a = N/2; //我们预想的a的值是2.5，可实际上a的值是3.5原因在于在预处理阶段，编译器将 a = N/2处理成了 a = 2+3/2；这就是宏定义的字符串替换的“边缘效应”因此要如下定义：#define N (2+3)。const定义表达式没有上述问题。const定义的常量叫做常变量原因有二：const定义常量像变量一样检查类型；const可以在任何地方定义常量，编译器对它的处理过程与变量相似，只是分配内存的地方不同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串常量， <span class="string">'\0'</span>遇到这个会知道字符串结束了</span><br></pre></td></tr></table></figure>



<h2 id="P6"><a href="#P6" class="headerlink" title="P6"></a>P6</h2><p>C语言数据类型的分类方式如下：</p>
<ul>
<li>基本类型<ul>
<li>标准整数类型，以及扩充的整数类型</li>
<li>实数浮点类型，以及复数浮点类型</li>
</ul>
</li>
<li>枚举类型</li>
<li>void类型</li>
<li>派生类型<ul>
<li>指针类型</li>
<li>数组类型</li>
<li>结构类型</li>
</ul>
</li>
<li>联合类型</li>
<li>函数类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(a);<span class="comment">//return size of a</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span>);<span class="comment">//return 4单位是字节</span></span><br></pre></td></tr></table></figure>

<p>objective-c 中的BOOL 实际上是一种对带符号的字符类型（signed char）的类型定义（typedef），它使用8位的存储空间。通过#define指令把YES定义为1，NO定义为0。</p>
<p>C99标准定义了一个新的关键字_Bool，提供了布尔类内型。以前，C程序员总是使用自己的方法定义布尔类型。0表示false，非0表示true。</p>
<p>可能使用char类型表示一个布尔类型，也可能使用int类型表示一个布尔类型。</p>
<p>1、类型不同百 :  BOOL为int型 , bool为布尔型  </p>
<p>2、长度不同 : bool只有一个字节 , BOOL长度视实际环境来定，一般可认为是4个字节 </p>
<p>3、取值不同 :bool取值false和true，是0和1的区别； false可以代表0，但true有很多种，并非度只有1。  </p>
<p>4、bool表示布尔型变量，也就是逻辑型变量的定义符，以英国数学家、布尔代数的奠基人乔治·布尔（George Boole）命名。</p>
<p>总结bool是true，false，而_Bool is 0,1 但是都是1字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign <span class="keyword">unsigned</span><span class="comment">//带符号不带符号，如果不用会引发栈溢出栈泄露</span></span><br></pre></td></tr></table></figure>

<h2 id="P7"><a href="#P7" class="headerlink" title="P7"></a>P7</h2><p>printf是输出一个字符串，putchar输出一个char。</p>
<p>printf格式字符：</p>
<table>
<thead>
<tr>
<th>打印格式</th>
<th>对应数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>int</td>
<td>接受整数值并将它表示为有符号的十进制整数</td>
</tr>
<tr>
<td>%hd</td>
<td>short int</td>
<td>短整数</td>
</tr>
<tr>
<td>%hu</td>
<td>unsigned short</td>
<td>无符号短整数</td>
</tr>
<tr>
<td>%o</td>
<td>unsigned int</td>
<td>无符号8进制整数</td>
</tr>
<tr>
<td>%u</td>
<td>unsigned int</td>
<td>无符号10进制整数</td>
</tr>
<tr>
<td>%x,%X</td>
<td>unsigned int</td>
<td>无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF</td>
</tr>
<tr>
<td>%f</td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td>%lf</td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td>%e,%E</td>
<td>double</td>
<td>科学计数法表示的数，此处”e”的大小写代表在输出时用的”e”的大小写</td>
</tr>
<tr>
<td>%c</td>
<td>char</td>
<td>字符型。可以把输入的数字按照ASCII码相应转换’对应的字符</td>
</tr>
<tr>
<td>%s</td>
<td>char *</td>
<td>字符串。输出字符串中的字符直至字符串中的空字符（字符串以’\0‘结尾，这个’\0’即空字符）</td>
</tr>
<tr>
<td>%p</td>
<td>void *</td>
<td>以16进制形式输出指针</td>
</tr>
<tr>
<td>%%</td>
<td>%</td>
<td>输出一个百分号</td>
</tr>
</tbody></table>
<p> %d  整形 int</p>
<p> %f  浮点型 float</p>
<p> %c  字符型  char </p>
<p> %hd 短整型  short</p>
<p> %ld  长整形  long</p>
<p> %lld  长长整形  long long </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1b</span>it=<span class="number">8</span> bytes</span><br><span class="line"><span class="built_in">pow</span>(a,b)<span class="comment">//#include &lt;math.h&gt;,一般打印需要&lt;stdio.h&gt;, a的b次方</span></span><br><span class="line">gcc -lm test.c &amp;&amp; ./a.out<span class="comment">// warning:overflow in implicit constant conversion</span></span><br><span class="line">  unsign <span class="keyword">int</span> 用%u，sign <span class="keyword">int</span>用%d</span><br></pre></td></tr></table></figure>

<p>使用math.h中声明的库函数还有一点特殊之处，gcc命令行必须加-lm选项，因为数学函数位于libm.so库文件中（这些库文件通常位于/lib目录下），-lm选项告诉编译器，我们程序中用到的数学函数要到这个库文件里找。本书用到的大部分库函数（例如printf）位于libc.so库文件中，使用libc.so中的库函数在编译时不需要加-lc选项，当然加了也不算错，因为这个选项是gcc的默认选项。</p>
<p>  C标准主要由两部分组成，一部分描述C的语法，另一部分描述C标准库。C标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型 声明和宏定义。要在一个平台上支持C语言，不仅要实现C编译器，还要实现C标准库，这样的实现才算符合C标准。不符合C标准的实现也是存在的，例如很多单 片机的C语言开发工具中只有C编译器而没有完整的C标准库。</p>
<p>在Linux平台上最广泛使用的C函数库是glibc，其中包括C标准库的实现。几乎所有C程序都要调用glibc的库函数，所以glibc是Linux平台C程序运行的基础。glibc提供一组头文件和一组库文件，最基本、最常用的C标准库函数和系统函数在libc.so库文件中，几乎所有C程序的运行都依赖于libc.so，有些做数学计算的C程序依赖于libm.so，以后我们还会看到多线程的C程序依赖于libpthread.so。以后我说libc时专指libc.so这个库文件，而说glibc时指的是glibc提供的所有库文件。</p>
<h3 id="1-原码"><a href="#1-原码" class="headerlink" title="1. 原码"></a>1. 原码</h3><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p>
<blockquote>
<p>[+1]原 = 0000 0001</p>
<p>[-1]原 = 1000 0001</p>
</blockquote>
<p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p>
<blockquote>
<p>[1111 1111 , 0111 1111]</p>
</blockquote>
<p>即</p>
<blockquote>
<p>[-127 , 127]</p>
</blockquote>
<p>原码是人脑最容易理解和计算的表示方式.</p>
<h3 id="2-反码"><a href="#2-反码" class="headerlink" title="2. 反码"></a>2. 反码</h3><p>反码的表示方法是:</p>
<p>正数的反码是其本身</p>
<p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反</p>
<p>[-1] = [10000001]原 = [11111110]反</p>
</blockquote>
<p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p>
<h3 id="3-补码"><a href="#3-补码" class="headerlink" title="3. 补码"></a>3. 补码</h3><p>补码的表示方法是:</p>
<p>正数的补码就是其本身</p>
<p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p>
<h2 id="P8"><a href="#P8" class="headerlink" title="P8"></a>P8</h2><p>字符用ASCII字符表写的，常用的ascii: 空格的ASCII码值为32；数字0到9的ASCII码值分别为48到57；大写字母“A”到“Z”的ASCII码值分别为65到90；小写字母“a”到“z”的ASCII码值分别为97到到122。</p>
<p>字符类型是特殊的整型，ascii有0-255个字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="number">170</span>；<span class="comment">//这是正数，若不用unsigned，则是负数</span></span><br></pre></td></tr></table></figure>

<p>字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[length];<span class="comment">//0 to length-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经典问题</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">2</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hi\n"</span>);<span class="comment">//会出现错误，因为字符数组a没有\0,改法： char a[3]=&#123;'a','b'，'\0'&#125;;</span></span><br><span class="line"><span class="keyword">char</span> a[]=<span class="string">"hi"</span>;<span class="comment">//字符串常量</span></span><br></pre></td></tr></table></figure>

<h2 id="P9"><a href="#P9" class="headerlink" title="P9"></a>P9</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>/<span class="number">3</span>=<span class="number">1</span></span><br><span class="line"><span class="number">5</span>%<span class="number">3</span>=<span class="number">2</span></span><br><span class="line"><span class="number">5.0</span>%<span class="number">3.0</span><span class="comment">//出错</span></span><br><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line"> <span class="number">1</span>+<span class="number">2.0</span>;<span class="comment">//-&gt;1.0+2.0</span></span><br><span class="line"> <span class="number">1</span>+(<span class="keyword">int</span>)<span class="number">2.0</span>;<span class="comment">//-&gt;3 </span></span><br><span class="line"><span class="number">1</span>+(<span class="keyword">int</span>)<span class="number">1.8</span>;<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h2 id="P10"><a href="#P10" class="headerlink" title="P10"></a>P10</h2><p>关系表达式返回0，1</p>
<p>c语言中没有true，false，只有1，0</p>
<p>c和java一样采用短路与和短路或</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E4%B9%8Bc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E4%B9%8Bc/" class="post-title-link" itemprop="url">小甲鱼之c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-19 16:01:44 / Modified: 16:30:59" itemprop="dateCreated datePublished" datetime="2020-04-19T16:01:44-05:00">2020-04-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P1-C-和OO思想"><a href="#P1-C-和OO思想" class="headerlink" title="P1:C++和OO思想"></a>P1:C++和OO思想</h2><p>经典面向对象java 一样封装继承多态</p>
<h2 id="P2-P4-从小程序说起"><a href="#P2-P4-从小程序说起" class="headerlink" title="P2-P4:从小程序说起"></a>P2-P4:从小程序说起</h2><p>1.类，异常，对象都是c++特有的</p>
<ol start="2">
<li><p>整形数组求和：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">addArray</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n)</span></span>;<span class="comment">//在main用前需要声明</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> data[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">size</span>=<span class="keyword">sizeof</span>(data)/<span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"data size: %ld\n"</span>,<span class="keyword">sizeof</span>(data));<span class="comment">//不要用%d，c99报错</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"answer :%d\n"</span>,addArray(data,<span class="built_in">size</span>));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">addArray</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"data size: %ld\n"</span>,<span class="keyword">sizeof</span>(<span class="built_in">array</span>));</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">       sum+=<span class="built_in">array</span>[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/*data size: 40</span></span><br><span class="line"><span class="comment">   data size: 8</span></span><br><span class="line"><span class="comment">   answer :45</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++版本</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">二叉树之遍历</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-19 10:17:19" itemprop="dateCreated datePublished" datetime="2020-04-19T10:17:19-05:00">2020-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-25 12:40:58" itemprop="dateModified" datetime="2020-04-25T12:40:58-05:00">2020-04-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h2><p>难度中等477收藏分享切换为英文关注反馈</p>
<p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//recursion</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt;  res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.left, res);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.right !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.right,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//iterative</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        Stack&lt;TreeNode&gt; s= <span class="keyword">new</span> Stack();</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur=cur.left;    </span><br><span class="line">            &#125;</span><br><span class="line">            cur=s.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></h2><p>难度中等454收藏分享切换为英文关注反馈</p>
<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//recursion</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; levels= <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(level==levels.size())</span><br><span class="line">                levels.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">            levels.get(level).add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">                helper(root.left, level+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">                helper(root.right, level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> levels;</span><br><span class="line">            helper(root, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> levels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;&#x2F;&#x2F;iterative</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; levels&#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        if(root&#x3D;&#x3D;null) return levels;</span><br><span class="line">        Queue&lt;TreeNode&gt; q&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        int level&#x3D;0;</span><br><span class="line">        while(!q.isEmpty())&#123;</span><br><span class="line">            levels.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">            int level_l&#x3D; q.size();</span><br><span class="line">            for(int i&#x3D;0; i&lt;level_l;i++)&#123;</span><br><span class="line">                TreeNode n&#x3D;q.remove();</span><br><span class="line">                levels.get(level).add(n.val);</span><br><span class="line">                if(n.left !&#x3D;null) q.add(n.left);</span><br><span class="line">                if(n.right !&#x3D;null) q.add(n.right);</span><br><span class="line">            &#125;  </span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        return levels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103. 二叉树的锯齿形层次遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. 二叉树的锯齿形层次遍历</a></h2><p>难度中等183收藏分享切换为英文关注反馈</p>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回锯齿形层次遍历如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%85%B6%E4%BB%96%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%85%B6%E4%BB%96%E9%A2%98/" class="post-title-link" itemprop="url">动态规划之其他题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-19 10:16:32" itemprop="dateCreated datePublished" datetime="2020-04-19T10:16:32-05:00">2020-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-19 14:39:56" itemprop="dateModified" datetime="2020-05-19T14:39:56-05:00">2020-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></h2><p>难度困难804收藏分享切换为英文关注反馈</p>
<p>给你两个单词 <em>word1</em> 和 <em>word2*，请你计算出将 *word1</em> 转换成 <em>word2</em> 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (插入 &#39;u&#39;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">动态规划</span><br><span class="line"></span><br><span class="line">定义 dp[i][j]</span><br><span class="line">21. dp[i][j] 代表 word1 中前 i 个字符，变换到 word2 中前 j 个字符，最短需要操作的次数</span><br><span class="line">22. 需要考虑 word1 或 word2 一个字母都没有，即全增加&#x2F;删除的情况，所以预留 dp[0][j] 和 dp[i][0]</span><br><span class="line"></span><br><span class="line">状态转移</span><br><span class="line">31. 增，dp[i][j] &#x3D; dp[i][j - 1] + 1</span><br><span class="line">32. 删，dp[i][j] &#x3D; dp[i - 1][j] + 1</span><br><span class="line">33. 改，dp[i][j] &#x3D; dp[i - 1][j - 1] + 1</span><br><span class="line">34. 按顺序计算，当计算 dp[i][j] 时，dp[i - 1][j] ， dp[i][j - 1] ， dp[i - 1][j - 1] 均已经确定了</span><br><span class="line">35. 配合增删改这三种操作，需要对应的 dp 把操作次数加一，取三种的最小</span><br><span class="line">36. 如果刚好这两个字母相同 word1[i - 1] &#x3D; word2[j - 1] ，那么可以直接参考 dp[i - 1][j - 1] ，操作不用加一</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：ikaruga</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;edit-distance&#x2F;solution&#x2F;edit-distance-by-ikaruga&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=word1.length();</span><br><span class="line">        <span class="keyword">int</span> col=word2.length();</span><br><span class="line">        <span class="keyword">if</span>((row==<span class="number">0</span>) || (col==<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> row+col;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row+<span class="number">1</span>;i++)</span><br><span class="line">            dp[i][<span class="number">0</span>]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col+<span class="number">1</span>;j++)</span><br><span class="line">            dp[<span class="number">0</span>][j]=j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;col+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>)!=word2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                    dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+=<span class="number">1</span>;</span><br><span class="line">                dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,Math.min(dp[i][j-<span class="number">1</span>]+<span class="number">1</span>,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">132. 分割回文串 II</a></h2><p>难度困难130收藏分享切换为英文关注反馈</p>
<p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。</p>
<p>返回符合要求的最少分割次数。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 进行一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> n = c.length;</span><br><span class="line">    <span class="keyword">int</span>[] cut = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[j] == c[i] &amp;&amp; (j + <span class="number">1</span> &gt; i - <span class="number">1</span> || dp[j + <span class="number">1</span>][i - <span class="number">1</span>])) &#123;</span><br><span class="line">                dp[j][i] = <span class="keyword">true</span>;  </span><br><span class="line">                min = j == <span class="number">0</span> ? <span class="number">0</span> : Math.min(min, cut[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cut[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cut[n - <span class="number">1</span>];</span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h2><p>难度中等2038收藏分享切换为英文关注反馈</p>
<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> strLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> maxStart = <span class="number">0</span>;  <span class="comment">//最长回文串的起点</span></span><br><span class="line">        <span class="keyword">int</span> maxEnd = <span class="number">0</span>;    <span class="comment">//最长回文串的终点</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;  <span class="comment">//最长回文串的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[strLen][strLen];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; strLen; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; r; l++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(l) == s.charAt(r) &amp;&amp; (r - l &lt;= <span class="number">2</span> || dp[l + <span class="number">1</span>][r - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[l][r] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                        maxLen = r - l + <span class="number">1</span>;</span><br><span class="line">                        maxStart = l;</span><br><span class="line">                        maxEnd = r;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxStart, maxEnd + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> premax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curmax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=curmax;</span><br><span class="line">            curmax=Math.max(x+premax,curmax);</span><br><span class="line">            premax=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curmax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Algorithm</strong></p>
<p>It could be overwhelming thinking of all possibilities on which houses to rob.</p>
<p>A natural way to approach this problem is to work on the simplest case first.</p>
<p>Let us denote that:</p>
<blockquote>
<p><em>f</em>(<em>k</em>) = Largest amount that you can rob from the first <em>k</em> houses.<br>Ai = Amount of money at the ith house.</p>
</blockquote>
<p>Let us look at the case <code>n = 1</code>, clearly <em>f</em>(1) = A1.</p>
<p>Now, let us look at <code>n = 2</code>, which <em>f</em>(2) = max(A1, A2).</p>
<p>For <code>n = 3</code>, you have basically the following two options:</p>
<ol>
<li>Rob the third house, and add its amount to the first house’s amount.</li>
<li>Do not rob the third house, and stick with the maximum amount of the first two houses.</li>
</ol>
<p>Clearly, you would want to choose the larger of the two options at each step.</p>
<p>Therefore, we could summarize the formula as following:</p>
<blockquote>
<p><em>f</em>(<em>k</em>) = max(<em>f</em>(<em>k</em> – 2) + Ak, <em>f</em>(<em>k</em> – 1))</p>
</blockquote>
<p>We choose the base case as <em>f</em>(–1) = <em>f</em>(0) = 0, which will greatly simplify our code as you can see.</p>
<p>The answer will be calculated as <em>f</em>(<em>n</em>). We could use an array to store and calculate the result, but since at each step you only need the previous two maximum values, two variables are suffice.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prevMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : num) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = currMax;</span><br><span class="line">        currMax = Math.max(prevMax + x, currMax);</span><br><span class="line">        prevMax = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). Assume that n<em>n</em> is the number of houses, the time complexity is O(n)<em>O</em>(<em>n</em>).</li>
<li>Space complexity : O(1)<em>O</em>(1).</li>
</ul>
<h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h2><p>难度中等254收藏分享切换为英文关注反馈</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈，</strong>这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">2</span>)<span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob0(nums),rob1(nums));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob0</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;<span class="comment">//0~length-2</span></span><br><span class="line">        <span class="keyword">int</span> premax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curmax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] arr1=<span class="keyword">new</span> <span class="keyword">int</span>[l-<span class="number">1</span>];</span><br><span class="line">        System.arraycopy(nums,<span class="number">0</span>,arr1,<span class="number">0</span>,l-<span class="number">1</span>);<span class="comment">//copy array</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr1)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=curmax;</span><br><span class="line">            curmax=Math.max(x+premax,curmax);</span><br><span class="line">            premax=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curmax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;<span class="comment">//0~length-1</span></span><br><span class="line">        <span class="keyword">int</span> premax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curmax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] arr2=<span class="keyword">new</span> <span class="keyword">int</span>[l-<span class="number">1</span>];</span><br><span class="line">        System.arraycopy(nums,<span class="number">1</span>,arr2,<span class="number">0</span>,l-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr2)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=curmax;</span><br><span class="line">            curmax=Math.max(x+premax,curmax);</span><br><span class="line">            premax=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curmax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>), rob(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> include = <span class="number">0</span>, exclude = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lo; j &lt;= hi; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = include, e = exclude;</span><br><span class="line">            include = e + num[j];</span><br><span class="line">            exclude = Math.max(e, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(include, exclude);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Since this question is a follow-up to House Robber, we can assume we already have a way to solve the simpler question, i.e. given a 1 row of house, we know how to rob them. So we already have such a helper function. We modify it a bit to rob a given range of houses.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private int rob(int[] num, int lo, int hi) &#123;</span><br><span class="line">    int include &#x3D; 0, exclude &#x3D; 0;</span><br><span class="line">    for (int j &#x3D; lo; j &lt;&#x3D; hi; j++) &#123;</span><br><span class="line">        int i &#x3D; include, e &#x3D; exclude;</span><br><span class="line">        include &#x3D; e + num[j];</span><br><span class="line">        exclude &#x3D; Math.max(e, i);</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.max(include, exclude);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Now the question is how to rob a circular row of houses. It is a bit complicated to solve like the simpler question. It is because in the simpler question whether to rob <em>num[lo]</em> is entirely our choice. But, it is now constrained by whether <em>num[hi]</em> is robbed.</p>
<p>However, since we already have a nice solution to the simpler problem. We do not want to throw it away. Then, it becomes how can we reduce this problem to the simpler one. Actually, extending from the logic that if house i is not robbed, then you are free to choose whether to rob house i + 1, you can break the circle by assuming a house is not robbed.</p>
<p>For example, 1 -&gt; 2 -&gt; 3 -&gt; 1 becomes 2 -&gt; 3 if 1 is not robbed.</p>
<p>Since every house is either robbed or not robbed and at least half of the houses are not robbed, the solution is simply the larger of two cases with consecutive houses, i.e. house i not robbed, break the circle, solve it, or house i + 1 not robbed. Hence, the following solution. I chose i = n and i + 1 = 0 for simpler coding. But, you can choose whichever two consecutive ones.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int rob(int[] nums) &#123;</span><br><span class="line">    if (nums.length &#x3D;&#x3D; 1) return nums[0];</span><br><span class="line">    return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></h2><p>难度中等403收藏分享切换为英文关注反馈</p>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.length, col=row&gt;<span class="number">0</span>? matrix[<span class="number">0</span>].length:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;col+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j]=Math.min(Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]),dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">                    max=Math.max(max,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max*max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Approach-1-Brute-Force-Accepted"><a href="#Approach-1-Brute-Force-Accepted" class="headerlink" title="Approach #1 Brute Force [Accepted]"></a>Approach #1 Brute Force [Accepted]</h4><p>The simplest approach consists of trying to find out every possible square of 1’s that can be formed from within the matrix. The question now is – how to go for it?</p>
<p>We use a variable to contain the size of the largest square found so far and another variable to store the size of the current, both initialized to 0. Starting from the left uppermost point in the matrix, we search for a 1. No operation needs to be done for a 0. Whenever a 1 is found, we try to find out the largest square that can be formed including that 1. For this, we move diagonally (right and downwards), i.e. we increment the row index and column index temporarily and then check whether all the elements of that row and column are 1 or not. If all the elements happen to be 1, we move diagonally further as previously. If even one element turns out to be 0, we stop this diagonal movement and update the size of the largest square. Now we, continue the traversal of the matrix from the element next to the initial 1 found, till all the elements of the matrix have been traversed.</p>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = rows &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxsqlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sqlen = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">while</span> (sqlen + i &lt; rows &amp;&amp; sqlen + j &lt; cols &amp;&amp; flag) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= sqlen + j; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[i + sqlen][k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                                flag = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= sqlen + i; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[k][j + sqlen] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                                flag = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag)</span><br><span class="line">                            sqlen++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (maxsqlen &lt; sqlen) &#123;</span><br><span class="line">                        maxsqlen = sqlen;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsqlen * maxsqlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O((mn))<em>O</em>((<em>m**n</em>)2). In worst case, we need to traverse the complete matrix for every 1.</li>
<li>Space complexity : O(1)<em>O</em>(1). No extra space is used.</li>
</ul>
<hr>
<h4 id="Approach-2-Dynamic-Programming-Accepted"><a href="#Approach-2-Dynamic-Programming-Accepted" class="headerlink" title="Approach #2 (Dynamic Programming) [Accepted]"></a>Approach #2 (Dynamic Programming) [Accepted]</h4><p><strong>Algorithm</strong></p>
<p>We will explain this approach with the help of an example.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 1 0</span><br><span class="line">1 1 1 1 1</span><br><span class="line">0 1 1 1 1</span><br><span class="line">0 1 1 1 1</span><br><span class="line">0 0 1 1 1</span><br></pre></td></tr></table></figure>

<p>We initialize another matrix (dp) with the same dimensions as the original one initialized with all 0’s.</p>
<p>dp(i,j) represents the side length of the maximum square whose bottom right corner is the cell with index (i,j) in the original matrix.</p>
<p>Starting from index (0,0), for every 1 found in the original matrix, we update the value of the current element as</p>
<p>dp(i,j)=min⁡(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1.dp(<em>i</em>,<em>j</em>)=min(dp(<em>i</em>−1,<em>j</em>),dp(<em>i</em>−1,<em>j</em>−1),dp(<em>i</em>,<em>j</em>−1))+1.</p>
<p>We also remember the size of the largest square found so far. In this way, we traverse the original matrix once and find out the required maximum size. This gives the side length of the square (say maxsqlen<em>m<strong>a</strong>x<strong>s</strong>q<strong>l</strong>e**n</em>). The required result is the area maxsqlen2<em>m*</em>a<strong>x</strong>s<strong>q</strong>l<strong>e</strong>n*2.</p>
<p>To understand how this solution works, see the figure below.</p>
<p><img src="https://leetcode.com/media/original_images/221_Maximal_Square.PNG?raw=true" alt="Max Square"></p>
<p>An entry 2 at (1,3)(1,3) implies that we have a square of side 2 up to that index in the original matrix. Similarly, a 2 at (1,2)(1,2) and (2,2)(2,2)implies that a square of side 2 exists up to that index in the original matrix. Now to make a square of side 3, only a single entry of 1 is pending at (2,3)(2,3). So, we enter a 3 corresponding to that position in the dp array.</p>
<p>Now consider the case for the index (3,4)(3,4). Here, the entries at index (3,3)(3,3) and (2,3)(2,3) imply that a square of side 3 is possible up to their indices. But, the entry 1 at index (2,4)(2,4) indicates that a square of side 1 only can be formed up to its index. Therefore, while making an entry at the index (3,4)(3,4), this element obstructs the formation of a square having a side larger than 2. Thus, the maximum sized square that can be formed up to this index is of size 2×22×2.</p>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = rows &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows + <span class="number">1</span>][cols + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> maxsqlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    maxsqlen = Math.max(maxsqlen, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsqlen * maxsqlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(mn)<em>O</em>(<em>m**n</em>). Single pass.</li>
<li>Space complexity : O(mn)<em>O</em>(<em>m**n</em>). Another matrix of same size is used for dp.</li>
</ul>
<hr>
<h4 id="Approach-3-Better-Dynamic-Programming-Accepted"><a href="#Approach-3-Better-Dynamic-Programming-Accepted" class="headerlink" title="Approach #3 (Better Dynamic Programming) [Accepted]"></a>Approach #3 (Better Dynamic Programming) [Accepted]</h4><p><strong>Algorithm</strong></p>
<p>In the previous approach for calculating dp of ith<em>i<strong>t</strong>h</em> row we are using only the previous element and the (i−1)(<em>i</em>−1)<em>t**h</em> row. Therefore, we don’t need 2D dp matrix as 1D dp array will be sufficient for this.</p>
<p>Initially the dp array contains all 0’s. As we scan the elements of the original matrix across a row, we keep on updating the dp array as per the equation dp[j]=min(dp[j−1],dp[j],prev)<em>d**p</em>[<em>j</em>]=<em>m<strong>i</strong>n</em>(<em>d**p</em>[<em>j</em>−1],<em>d**p</em>[<em>j</em>],<em>p<strong>r</strong>e**v</em>), where prev refers to the old dp[j−1]<em>d**p</em>[<em>j</em>−1]. For every row, we repeat the same process and update in the same dp array.</p>
<p><img src="https://leetcode.com/media/original_images/221_Maximal_Square1.png?raw=true" alt=" Max Square "></p>
<p><strong>java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = rows &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[cols + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> maxsqlen = <span class="number">0</span>, prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cols; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = dp[j];</span><br><span class="line">                <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    dp[j] = Math.min(Math.min(dp[j - <span class="number">1</span>], prev), dp[j]) + <span class="number">1</span>;</span><br><span class="line">                    maxsqlen = Math.max(maxsqlen, dp[j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsqlen * maxsqlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(mn)<em>O</em>(<em>m**n</em>). Single pass.</li>
<li>Space complexity : O(n)<em>O</em>(<em>n</em>). Another array which stores elements in a row is used for dp.</li>
</ul>
<h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></h2><p>给定一个整数数组，其中第 <em>i</em> 个元素代表了第 <em>i</em> 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sold=Integer.MIN_VALUE, held=Integer.MIN_VALUE, reset=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price: prices)&#123;</span><br><span class="line">            <span class="keyword">int</span> presold=sold;</span><br><span class="line">            sold=held+price;</span><br><span class="line">            held=Math.max(held,reset-price);</span><br><span class="line">            reset=Math.max(reset, presold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(sold, reset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Approach-1-Dynamic-Programming-with-State-Machine"><a href="#Approach-1-Dynamic-Programming-with-State-Machine" class="headerlink" title="Approach 1: Dynamic Programming with State Machine"></a>Approach 1: Dynamic Programming with State Machine</h4><p><strong>Intuition</strong></p>
<p>First of all, let us take a different perspective to look at the problem, unlike the other algorithmic problems.</p>
<p>Here, we will treat the problem as a game, and the trader as an agent in the game. The agent can take actions that lead to gain or lose of game points (<em>i.e.</em> profits). And the goal of the game for the agent is to gain the maximal points.</p>
<p>In addition, we will introduce a tool called <a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="noopener">state machine</a>, which is a mathematical model of computation. Later one will see how the state machine coupled with the dynamic programming technique can help us solve the problem easily.</p>
<p>In the following sections, we will first define a <strong><em>state machine</em></strong> that is used to model the behaviors and states of the game agent.</p>
<p>Then, we will demonstrate how to apply the state machine to solve the problem.</p>
<p><strong>Definition</strong></p>
<p>Let us define a <strong><em>state machine\</em></strong> to model our agent. The state machine consists of three states, which we define as follows:</p>
<ul>
<li>state <code>held</code>: in this state, the agent holds a stock that it bought at some point before. </li>
<li>state <code>sold</code>: in this state, the agent has just sold a stock right before entering this state. And the agent holds no stock at hand. </li>
<li>state <code>reset</code>: first of all, one can consider this state as the starting point, where the agent holds no stock and did not sell a stock before. More importantly, it is also the <em>transient</em> state before the <code>held</code> and <code>sold</code>. Due to the <strong><em>cooldown\</em></strong> rule, after the <code>sold</code> state, the agent can not immediately acquire any stock, but is <em>forced</em> into the <code>reset</code> state. One can consider this state as a “reset” button for the cycles of buy and sell transactions.</li>
</ul>
<p>At any moment, the agent can only be in <strong><em>one\</em></strong> state. The agent would transition to another state by performing some actions, namely:</p>
<ul>
<li>action <code>sell</code>: the agent sells a stock at the current moment. After this action, the agent would transition to the <code>sold</code> state.</li>
<li>action <code>buy</code>: the agent acquires a stock at the current moment. After this action, the agent would transition to the <code>held</code>state.</li>
<li>action <code>rest</code>: this is the action that the agent does no transaction, neither buy or sell. For instance, while holding a stock at the <code>held</code> state, the agent might simply do nothing, and at the next moment the agent would remain in the <code>held</code> state.</li>
</ul>
<p>Now, we can assemble the above states and actions into a <strong>state machine</strong>, which we show in the following graph where each node represents a state, and each edge represents a transition between two states. On top of each edge, we indicate the action that triggers the transition.</p>
<p><img src="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_state_machine.png" alt="state machine"></p>
<p>Notice that, in all states except the <code>sold</code> state, by doing nothing, we would remain in the same state, which is why there is a self-looped transition on these states.</p>
<p><strong>Deduction</strong></p>
<p>Now, one might wonder how exactly the state machine that we defined can help to solve the problem.</p>
<p>As we mentioned before, we model the problem as a <strong><em>game\</em></strong>, and the trader as an <strong><em>agent\</em></strong> in the game. And this is where our state machine comes into the picture. The behaviors and the states of the game agent can be modeled by our state machine.</p>
<p><img src="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_game.png" alt="mario game"></p>
<p>Given a list stock prices (<em>i.e.</em> <code>price[0...n]</code>), our agent would walk through each price point one by one. At each point, the agent would be in one of three states (<em>i.e.</em> <code>held</code>, <code>sold</code> and <code>reset</code>) that we defined before. And at each point, the agent would take one of the three actions (<em>i.e.</em> <code>buy</code>, <code>sell</code> and <code>rest</code>), which then would lead to the next state at the next price point.</p>
<blockquote>
<p>Now if we chain up each state at each price point, it would form a <strong><em>graph\</em></strong> where each <strong><em>path\</em></strong> that starts from the initial price point and ends at the last price point represents a combination of transactions that the agent could perform through out the game.</p>
</blockquote>
<p><img src="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_graph.png" alt="graph of state transition"></p>
<p>The above graph shows all possible paths that our game agent agent walks through the list, which corresponds to all possible combinations of transactions that the trader can perform with the given price sequence.</p>
<blockquote>
<p>In order to solve the problem, the goal is to find such a path in the above graph that maximizes the profits.</p>
</blockquote>
<p>In each node of graph, we also indicate the maximal profits that the agent has gained so far in each state of each step. And we highlight the path that generates the maximal profits. Don’t worry about them for the moment. We will explain in detail how to calculate in the next section.</p>
<p><strong>Algorithm</strong></p>
<p>In order to implement the above state machine, we could define three arrays (<em>i.e.</em> <code>held[i]</code>, <code>sold[i]</code> and <code>reset[i]</code>) which correspond to the three states that we defined before.</p>
<blockquote>
<p>Each element in each array represents the maximal profits that we could gain at the specific price point <code>i</code> with the specific state. For instance, the element <code>sold[2]</code> represents the maximal profits we gain if we sell the stock at the price point <code>price[2]</code>.</p>
</blockquote>
<p>According to the state machine we defined before, we can then deduce the formulas to calculate the values for the state arrays, as follows:</p>
<p>sold[i]=hold[i−1]+price[i]held[i]=max⁡(held[i−1],reset[i−1]−price[i])reset[i]=max⁡(reset[i−1],sold[i−1])sold[<em>i</em>]=hold[<em>i</em>−1]+price[<em>i</em>]held[<em>i</em>]=max(held[<em>i</em>−1],reset[<em>i</em>−1]−price[<em>i</em>])reset[<em>i</em>]=max(reset[<em>i</em>−1],sold[<em>i</em>−1])</p>
<p>Here is how we interpret each formulas:</p>
<ul>
<li>sold[i]sold[<em>i</em>]: the previous state of <code>sold</code> can only be <code>held</code>. Therefore, the maximal profits of this state is the maximal profits of the previous state plus the revenue by selling the stock at the current price. </li>
<li>held[i]held[<em>i</em>]: the previous state of <code>held</code> could also be <code>held</code>, <em>i.e.</em> one does no transaction. Or its previous state could be <code>reset</code>, from which state, one can acquire a stock at the current price point. </li>
<li>reset[i]reset[<em>i</em>]: the previous state of <code>reset</code> could either be <code>reset</code> or <code>sold</code>. Both transitions do not involve any transaction with the stock.</li>
</ul>
<blockquote>
<p>Finally, the maximal profits that we can gain from this game would be max⁡(sold[n],reset[n])max(sold[<em>n</em>],reset[<em>n</em>]), <em>i.e.</em> at the last price point, either we sell the stock or we simply do no transaction, to have the maximal profits. It makes no sense to acquire the stock at the last price point, which only leads to the reduction of profits.</p>
</blockquote>
<p>In particular, as a base case, the game should be kicked off from the state <code>reset</code>, since initially we don’t hold any stock and we don’t have any stock to sell neither. Therefore, we assign the initial values of <code>sold[-1]</code> and <code>held[-1]</code> to be <code>Integer.MIN_VALUE</code>, which are intended to <em>render</em> the paths that start from these two states impossible.</p>
<p>As one might notice in the above formulas, in order to calculate the value for each array, we reuse the intermediate values, and this is where the paradigm of <strong><em>dynamic programming</em></strong> comes into play.</p>
<p>More specifically, we only need the intermediate values at exactly one step before the current step. As a result, rather than keeping all the values in the three arrays, we could use a <strong><em>sliding window\</em></strong> of size <code>1</code> to calculate the value for max⁡(sold[n],reset[n])max(sold[<em>n</em>],reset[<em>n</em>]).</p>
<p>In the following animation, we demonstrate the process on how the three arrays are calculated step by step.</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAAEgCAYAAACO31PFAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAADSKADAAQAAAABAAABIAAAAAAYqXSkAABAAElEQVR4Ae3dB2BV1f3A8V/2HoQkhBAg7L03IrgrCoo4qlalrXW31hatrf/iqhu0Slu1rmrdE7FuERUVRPaUFfYKAbL3+t/fCTckYYWQ9959731PG997d51zPuclvN874wZUW0lICCCAAAIIIIAAAggggAACEogBAggggAACCCCAAAIIIIBAjQABEu8EBBBAAAEEEEAAAQQQQOCAAAESbwUEEEAAAQQQQAABBBBA4IAAARJvBQQQQAABBBBAAAEEEEDggAABEm8FBBBAAAEEEEAAAQQQQOCAAAESbwUEEEAAAQQQQAABBBBA4IAAARJvBQQQQAABBBBAAAEEEEDggAABEm8FBBBAAAEEEEAAAQQQQOCAAAESbwUEEEAAAQQQQAABBBBA4IAAARJvBQQQQAABBBBAAAEEEEDggECwJyQCAgI8ka1P5Tl58mSZNm2aT9WJyhwU4HfkoAXPEEAAAQQQQAABVwhUV1cf9rIeCZC0JEcq0GFLycZ6AlOnTpXMzMx623jhewL8jvhem9o1+umnn+SCCy6QNWvW2Jt49DEB/ZKD32Efa9QG1aGNG4D42MtzzjlHbrzxRhk3bpyP1Yzq2AJH+zKaIXa2Eo8IIIAAAggggAACCCDg9wIESH7/FgAAAQQQQAABBBBAAAEEbAECJFuCRwQQQAABBBBAAAEEEPB7AQIkv38LAIAAAggggAACCCCAAAK2AAGSLcEjAggggAACCCCAAAII+L0AAZLfvwUAQAABBBBAAAEEEEAAAVuAAMmW4BEBBBBAAAEEEEAAAQT8XoAAye/fAgAggAACCCCAAAIIIICALUCAZEvwiAACCCCAAAIIIIAAAn4vQIDk928BABBAAAEEEEAAAQQQQMAWIECyJXhEAAEEEEAAAQQQQAABvxcgQPL7twAACCCAAAIIIIAAAgggYAsQINkSBx4XL14sU6dOlfLy8gZ7eIkAAq4QKCoqkrPOOksiIiIkPz/fFVlwTQ8J6N/Ru+++W372s5/JmDFjZOLEiTJ//nwPlYZsm1ugqqpK3njjDbnoootk3Lhxcumll4r+G0ryHYHt27fLBRdcIB07dpTk5GQZOnSoPPzww75TQWoi+/btk8svv1xOO+00OfXUU+VXv/qV2ebvNMH+DtCw/ueff77oHwR9owwaNKjhbl4jgEAzCvz0009y5plnyo4dO8xV9QMXyTcE1q1bZ9p269at9So0Y8YMmT59uvzud7+rt50X3iWQnZ0to0ePlpUrV9Yr+Jtvvim33367PPTQQ/W288L7BLRtR4wYIQUFBbWFz8rKkgULFsimTZvk6aefrt3OE+8UeO+99+TCCy88pPCvv/66rFixQrp06XLIPn/ZQA9Sg5a++eab5ZJLLpH09PQGe3iJAALNKaAfsIYNG1YbHDXntbmWZwX0A9VJJ50kGhzpl01Lly41Xzz95S9/MQW79dZb6S30bBOdcO5r1qwxwZF+gNIPWRkZGfLSSy9JdHS0PProo+YD9AlnwgU8JlBSUmJ6jvR3edKkSbJ3716pqKiQr7/+2pTpueeekx9//NFj5SPjExdYuHBhbXD05z//2fy91i8tzz33XCktLZWzzz77xDPx4ivQg9Sg8W677bYGW3iJAAKuEAgKCpLg4GD505/+JM8//zxd+q5A9tA1q6urpVu3bnLTTTfJHXfcIaGhoaYkDzzwgHzwwQeyatUqKSwslJiYGA+VkGxPVEC/3FiyZIl07dpVIiMjzeV0GJYOk/3tb38rW7ZskQ4dOpxoNpzvIYHZs2fLhg0bpF+/fvKf//xHAgICTEl0qOz7778vEyZMMD2FX331lYdKSLYnKhASEiIDBw4U/eJKh8na6cUXX5SkpCS//xLL6wMk/YdYx0zqP7ba7bt+/Xrz07p1axkwYIDd3ubxrbfeMmPh4+LiZPny5fLMM8+Ifkvy4IMPmjeDHqTnR0VFSWpqar1z9YWOu9V/2PUf+2uuucaMxbX/aNgHa0SufzD0m5ZRo0bJyJEjRT8IkhBAoL5AbGysCYr0d0i783UcNMk3BDTw+e677w6pjA6l1J6GsLAw09NwyAFs8BqBwMBA6d+/f73y6r/HzEGqR+K1L15++WVTdv3c0/Bzzsknn2z2rV27VrTNG+732kr7WcE1+F20aNEhtba36Wdlf05eHyDpnIVvvvnG/IJqoGR3/2qj6jcd+i2I/iEvKyuTX/ziFyaY0n+8dUiAnVavXi3ff/+9uYYGNHrNPXv21AtsdHKxjp23k37jPX78ePNNil6/srJSdP7SRx99ZB9iHvVb1Dlz5pjJjfV28AIBBGr/YdXfn/j4eAkPD0fFRwVyc3Nl7Nix5kspncyvQ7FI3i+gv7v6b5x+yaFfEGqvkn7BqJP5Sd4poG2qw+cSEhLMZ6aGtdAvt9q0aWOGYREgNdTx7tc670x7BzVpj78/J5+Zg6S/pBocaUQ8efJkExRp4GQHQhr06DFffPGF2aarKv33v/8132TqZGLdp0n/MDRMf/vb30xw1Lt3b/nhhx/kww8/NH8c9Ll93nXXXWeCI+2ufO2110zgpAGafsPSMGhqeH1eI+DPAtqLqx+etbuf3lbffCd8++235m+zTvpNS0uTRx55xDcr6oe1+vvf/27mmT377LNmZIauRqlfTNrD7vyQxCeqrJ+F9Asr/bvcMOmXwtoLrPOTdK4KyfsF9DPyP//5T+nTp4/5Eks7HC6++GLvr9gJ1MDrAyS7a1cfdaicTgaeNm2aaK+QbtNFF+wgxnZ64okn5JNPPpErr7yy3reY+gZpGCDpMrWPP/64OVXP0XHXOoFt48aNZoy1fqDTD3f67Vm7du3M8LrLLrtMWrZsaSY16on2+Hs7fx4RQOCggA6t0yGyffv2NXOSDu7hmbcL6N/ev/71r2a1M52Tor0K+sVS27Ztvb1qlP+AgC5qdO+995oRFfrvp47WuPrqq80wc5C8W6DhZ6eGtdFeYA2USN4toPMGtXffXllU547OmjXLuyvVDKX3+iF2dQMknextJx3apsHLrl276gVIGh1r49vn3XnnndKjRw/T46TfZOu3IXqufkOiSe/xsH//frnnnnvMN5/29esGPR9//LHovVy0p0kDtPvvv18+//xzc+h5551n7v1hn8cjAggcXqBnz56H38FWrxTQv6f690977XUxDl3a+ze/+c1hv5H2ygpSaCOgXwxOmTLFPNfg95xzzjFD1nWO74033oiSlwroF8Ya7GrQq7+/dZN+TtL5hCyyUlfFO5/rcu06p0zbUxdmePvtt830FO+sTfOW2ut7kI7GYQdB+otuJx2CV3cYj/Yw6X1YNNnH1+1F+t///mf26U20jpR0vpKmu+66y7yxNDg644wzTG+SrvaiQw5ICCBwdIG6v6dHP5K93iDwhz/8wQRHusqZzku54YYbCI68oeFOoIzDhw+vHT45d+7cE7gSp3pSQD8j6XQBvRXD5s2bDylKZmam+TJZ5yjZXyYfchAbHC+gAbDejkGDI51Dr738OjWEVCPg9QGSBjXaK3S4ZHcP1/0F1pucHSvpBMSGwZJuO1LSPyKa9A+JjtnUiar6rekpp5xSe50jnct2BBCoEaj7xQUm3i2gq3jai9roo87fJPmWwM6dO83KsQ1rpSMwNNX9d7fhMbx2voB+yatfWukS3w3TzJkzzSYNokjeK6Ariuooq5SUFDM3ny/z67el1wdIdatjB0S6Te/irf9I6x9rO9ipe+zRntftTtYJxZr03h11U05OTu0/Dr169TK7NDjSBRoGDRpUe6hOStYATlfJIyGAwKEC9uIMusQ+yTcEdF6ZfsusE331RqL693L37t3mRoR681j920zybgFdDEnnlNWdq6BzdvUmsZrsQMm7a+m/pT/rrLNM5Z988klz+xNbQm8kesstt5gAmPtG2ire+agBkiaddqK9Sfp3W7/40J4k/Xvt76n+wFIv1tBvOvT+RTr+Wce+64IKmt59991GB0h2gKVvGr2efgOmNznUO0brfY/mzZtnxtTrOOt//etf5iZa+mbSrsn27dubsZv6j7/2HOm34dptqXOYdLyuTkInIYDAQQGd26e/r/pBWoe16u+s3r9MV8MaN27cwQN55rUCek+4uvM17YroMtDz58+vN6/T3sejdwiMHj3a/Pumv8N6C43ExEQz91bvMaiLcOjwdZL3CujQWP3grJ919H5XuhiHfkZ66aWXTKU0gKIHyXvbt27JdQ6hPY+w7nYdblf31jl19/nDc58JkLSxNBCxh3Xoa73Rmd27Ywc/Rxsqp6uxaJClPUD28IBWrVrJCy+8INdee6151Od20jH2OqlNe5y+/PJLs3KPLi2u//DbSe8sfvfdd9fOc7K384iAvwvo6o96z4W6Xx7ot1b6LTTJuwV08naHDh1EJwB3797dfGDW4Ru6Xb9U0g/Rded6endt/bP0emsL/TJRe4xefPHFWgRdjVInejOBv5bEa5/oisDFxcXms0/dNr7iiitE7wVJ8m4B/RutST/DDhgwwNz3Sj8D64/OG9Uv/P05BViBQ80NgNyooEPemjNb/YOsH7T0m2gdT6mBko55bzieUpeb1W9B9PgjJf1HW4OjhsPydBnEV155xfzjrqv26I20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" alt="Current"></p>
<p>1 / 7</p>
<blockquote>
<p>As a <strong><em>byproduct\</em></strong> of this algorithm, not only would we obtain the maximal profits at the end, but also we could recover each action that we should perform along the path, although this is not required by the problem.</p>
</blockquote>
<p>In the above graph, by starting from the final state, and walking backward following the path, we could obtain a sequence of actions that leads to the maximal profits at the end, <em>i.e.</em> [<code>buy</code>, <code>sell</code>, <code>cooldown</code>, <code>buy</code>, <code>sell</code>].</p>
<iframe src="https://leetcode.com/playground/G3tLgwPY/shared" frameborder="0" width="100%" height="378" name="G3tLgwPY" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li><p>Time Complexity: O(N)O(<em>N</em>) where N<em>N</em> is the length of the input price list.</p>
<ul>
<li>We have one loop over the input list, and the operation within one iteration takes constant time. </li>
</ul>
</li>
<li><p>Space Complexity: O(1)O(1), constant memory is used regardless the size of the input. </p>
</li>
</ul>
<hr>
<h4 id="Approach-2-Yet-Another-Dynamic-Programming"><a href="#Approach-2-Yet-Another-Dynamic-Programming" class="headerlink" title="Approach 2: Yet-Another Dynamic Programming"></a>Approach 2: Yet-Another Dynamic Programming</h4><p><strong>Intuition</strong></p>
<p>Most of the times, there are more than one approaches to decompose the problem, so that we could apply the technique of dynamic programming.</p>
<p>Here we would like to propose a different perspective on how to model the problem purely with mathematical formulas.</p>
<p>Again, this would be a journey loaded with mathematical notations, which might be complicated, but it showcases how the mathematics could help one with the dynamic <em>programming</em> (pun intended).</p>
<p><strong>Definition</strong></p>
<p>For a sequence of prices, denoted as price[0,1,…,n]price[0,1,…,<em>n</em>], let us first define our <strong>target</strong> function called MP(i)MP(<em>i</em>). The function MP(i)MP(<em>i</em>)gives the maximal profits that we can gain for the price <em>subsequence</em> starting from the index i<em>i</em>, <em>i.e.</em> price[i,i+1,…,n]price[<em>i</em>,<em>i</em>+1,…,<em>n</em>].</p>
<p>Given the definition of the MP(i)MP(<em>i</em>) function, one can see that when i=0<em>i</em>=0 the output of the function, <em>i.e.</em> MP(0)MP(0), is exactly the result that we need to solve the problem, which is the maximal profits that one can gain for the price subsequence of price[0,1,…,n]price[0,1,…,<em>n</em>].</p>
<p>Suppose that we know all the values for MP(i)MP(<em>i</em>) onwards until MP(n)MP(<em>n</em>), <em>i.e.</em> we know the maximal profits that we can gain for any subsequence of price[k…n]k∈[i,n]price[<em>k</em>…<em>n</em>]<em>k</em>∈[<em>i</em>,<em>n</em>].</p>
<p>Now, let us add a new price point price[i−1]price[<em>i</em>−1] into the subsequence price[i…n]price[<em>i</em>…<em>n</em>], all we need to do is to deduce the value for the <strong>unknown</strong> MP(i−1)MP(<em>i</em>−1).</p>
<blockquote>
<p>Up to this point, we have just modeled the problem with our <strong>target</strong> function MP(i)MP(<em>i</em>), along with a series of definitions. The problem now is boiled down to deducing the formula for MP(i−1)MP(<em>i</em>−1).</p>
</blockquote>
<p>In the following section, we will demonstrate how to deduce the formula for MP(i−1)MP(<em>i</em>−1).</p>
<p><strong>Deduction</strong></p>
<p>With the newly-added price point price[i−1]price[<em>i</em>−1], we need to consider <strong>all</strong> possible transactions that we can do to the stock at this price point, which can be broken down into two cases:</p>
<ul>
<li>Case 1): we buy this stock with price[i−1]price[<em>i</em>−1] and then sell it at some point in the following price sequence of price[i…n]price[<em>i</em>…<em>n</em>]. Note that, once we sell the stock at a certain point, we need to cool down for a day, then we can reengage with further transactions. Suppose that we sell the stock right after we bought it, at the next price point price[i]price[<em>i</em>], the maximal profits we would gain from this choice would be the profit of this transaction (<em>i.e.</em> price[i]−price[i−1]price[<em>i</em>]−price[<em>i</em>−1]) <strong>plus</strong> the maximal profits from the rest of the price sequence, as we show in the following:</li>
</ul>
<p><img src="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/Figures/309/309_formula.png" alt="example of profit calculation"></p>
<p>In addition, we need to <strong>enumerate</strong> all possible points to sell this stock, and take the maximum among them. The maximal profits that we could gain from this case can be represented by the following:</p>
<p>C1=max⁡{k∈[i,n]}(price[k]−p[i−1]+MP(k+2))<em>C</em>1=max{<em>k</em>∈[<em>i</em>,<em>n</em>]}(price[<em>k</em>]−p[<em>i</em>−1]+MP(<em>k</em>+2))</p>
<ul>
<li>Case 2): we simply do nothing with this stock. Then the maximal profits that we can gain from this case would be MP(i)MP(<em>i</em>), which are also the maximal profits that we can gain from the rest of the price sequence.</li>
</ul>
<p>C2=MP(i)<em>C</em>2=MP(<em>i</em>)</p>
<p>By combining the above two cases, <em>i.e.</em> selecting the max value among them, we can obtain the value for MP(i−1)MP(<em>i</em>−1), as follows:</p>
<p>MP(i−1)=max⁡(C1,C2)MP(<em>i</em>−1)=max(<em>C</em>1,<em>C</em>2)</p>
<p>MP(i−1)=max⁡(max⁡{k∈[i,n]}(price[k]−price[i−1]+MP(k+2)),MP(i))MP(<em>i</em>−1)=max(max{<em>k</em>∈[<em>i</em>,<em>n</em>]}(price[<em>k</em>]−price[<em>i</em>−1]+MP(<em>k</em>+2)),MP(<em>i</em>))</p>
<p>By the way, the base case for our recursive function MP(i)MP(<em>i</em>) would be MP(n)MP(<em>n</em>) which is the maximal profits that we can gain from the sequence with a single price point price[n]price[<em>n</em>]. And the best thing we should do with a single price point is to do no transaction, hence we would neither lose money nor gain any profit, <em>i.e.</em> MP(n)=0MP(<em>n</em>)=0.</p>
<p>The above formulas do model the problem soundly. In addition, one should be able to translate them directly into code.</p>
<p><strong>Algorithm</strong></p>
<p>With the final formula we derived for our target function MP(i)MP(<em>i</em>), we can now go ahead and translate it into any programming language.</p>
<ul>
<li>Since the formula deals with subsequences of price that start from the last price point, we then could do an <strong>iteration</strong> over the price list in the reversed order. </li>
<li>We define an array <code>MP[i]</code> to hold the values for our target function MP(i)MP(<em>i</em>). We initialize the array with zeros, which correspond to the base case where the minimal profits that we can gain is zero. Note that, here we did a trick to pad the array with two additional elements, which is intended to simplify the branching conditions, as one will see later. </li>
<li>To calculate the value for each element <code>MP[i]</code>, we need to look into two cases as we discussed in the previous section, namely:<ul>
<li>Case 1). we buy the stock at the price point <code>price[i]</code>, then we sell it at a later point. As one might notice, the initial padding on the <code>MP[i]</code> array saves us from getting out of boundary in the array.</li>
<li>Case 2). we do no transaction with the stock at the price point <code>price[i]</code>.</li>
</ul>
</li>
<li>At the end of each iteration, we then pick the largest value from the above two cases as the final value for <code>MP[i]</code>.</li>
<li>At the end of the loop, the <code>MP[i]</code> array will be populated. We then return the value of <code>MP[0]</code>, which is the desired solution for the problem.</li>
</ul>
<iframe src="https://leetcode.com/playground/MM2cVbSW/shared" frameborder="0" width="100%" height="463" name="MM2cVbSW" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time Complexity: O(N2)O(<em>N</em>2) where N<em>N</em> is the length of the price list.<ul>
<li>As one can see, we have nested loops over the price list. The number of iterations in the outer loop is N<em>N</em>. The number of iterations in the inner loop varies from 11 to N<em>N</em>. Therefore, the total number of iterations that we perform is ∑i=1Ni=N⋅(N+1)2∑<em>i</em>=1<em>N**i</em>=2<em>N</em>⋅(<em>N</em>+1).</li>
<li>As a result, the overall time complexity of the algorithm is O(N2)O(<em>N</em>2). </li>
</ul>
</li>
<li>Space Complexity: O(N)O(<em>N</em>) where N<em>N</em> is the length of the price list.<ul>
<li>We allocated an array to hold all the values for our target function MP(i)MP(<em>i</em>). </li>
</ul>
</li>
</ul>
<h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 3 + 3 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \   \ </span><br><span class="line"> 1   3   1</span><br><span class="line"></span><br><span class="line">输出: 9</span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 4 + 5 &#x3D; 9.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result=helper(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(result[<span class="number">0</span>],result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] helper(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];<span class="comment">//0 is not steal, 1 is steal</span></span><br><span class="line">        <span class="keyword">int</span>[] left=helper(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] right=helper(root.right);</span><br><span class="line">        result[<span class="number">0</span>]=Math.max(left[<span class="number">0</span>],left[<span class="number">1</span>])+Math.max(right[<span class="number">0</span>],right[<span class="number">1</span>]);</span><br><span class="line">        result[<span class="number">1</span>]=left[<span class="number">0</span>]+right[<span class="number">0</span>]+root.val;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明</p>
<p>本题目本身就是动态规划的树形版本，通过此题解，可以了解一下树形问题在动态规划问题解法<br>我们通过三个方法不断递进解决问题</p>
<p>解法一通过递归实现，虽然解决了问题，但是复杂度太高<br>解法二通过解决方法一中的重复子问题，实现了性能的百倍提升<br>解法三直接省去了重复子问题，性能又提升了一步<br>解法一、暴力递归 - 最优子结构</p>
<p>在解法一和解法二中，我们使用爷爷、两个孩子、4 个孙子来说明问题<br>首先来定义这个问题的状态<br>爷爷节点获取到最大的偷取的钱数呢</p>
<p>首先要明确相邻的节点不能偷，也就是爷爷选择偷，儿子就不能偷了，但是孙子可以偷<br>二叉树只有左右两个孩子，一个爷爷最多 2 个儿子，4 个孙子<br>根据以上条件，我们可以得出单个节点的钱该怎么算<br>4 个孙子偷的钱 + 爷爷的钱 VS 两个儿子偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数。这就是动态规划里面的最优子结构</p>
<p>由于是二叉树，这里可以选择计算所有子节点</p>
<p>4 个孙子投的钱加上爷爷的钱如下<br>int method1 = root.val + rob(root.left.left) + rob(root.left.right) + rob(root.right.left) + rob(root.right.right)<br>两个儿子偷的钱如下<br>int method2 = rob(root.left) + rob(root.right);<br>挑选一个钱数多的方案则<br>int result = Math.max(method1, method2);<br>将上述方案写成代码如下</p>
<p>Java<br>public int rob(TreeNode root) {<br>    if (root == null) return 0;</p>
<pre><code>int money = root.val;
if (root.left != null) {
    money += (rob(root.left.left) + rob(root.left.right));
}

if (root.right != null) {
    money += (rob(root.right.left) + rob(root.right.right));
}

return Math.max(money, rob(root.left) + rob(root.right));</code></pre><p>}<br>信心满满的提交，一次通过，然而 执行用时:837 ms,在所有 java 提交中击败了24.49%的用户 这个结果太没面子了，下个解法进行优化</p>
<p>解法二、记忆化 - 解决重复子问题</p>
<p>针对解法一种速度太慢的问题，经过分析其实现，我们发现爷爷在计算自己能偷多少钱的时候，同时计算了 4 个孙子能偷多少钱，也计算了 2 个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。</p>
<p>于是乎我们发现了一个动态规划的关键优化点</p>
<p>重复子问题</p>
<p>我们这一步针对重复子问题进行优化，我们在做斐波那契数列时，使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。<br>由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，TreeNode 当做 key，能偷的钱当做 value</p>
<p>解法一加上记忆化优化后代码如下：</p>
<p>Java<br>public int rob(TreeNode root) {<br>    HashMap&lt;TreeNode, Integer&gt; memo = new HashMap&lt;&gt;();<br>    return robInternal(root, memo);<br>}</p>
<p>public int robInternal(TreeNode root, HashMap&lt;TreeNode, Integer&gt; memo) {<br>    if (root == null) return 0;<br>    if (memo.containsKey(root)) return memo.get(root);<br>    int money = root.val;</p>
<pre><code>if (root.left != null) {
    money += (robInternal(root.left.left, memo) + robInternal(root.left.right, memo));
}
if (root.right != null) {
    money += (robInternal(root.right.left, memo) + robInternal(root.right.right, memo));
}
int result = Math.max(money, robInternal(root.left, memo) + robInternal(root.right, memo));
memo.put(root, result);
return result;</code></pre><p>}<br>提交代码，执行用时：4 ms, 在所有 java 提交中击败了 54.92% 的用户，速度提高了 200 倍。太开心了。别着急，还有一个终极方案呢，连记忆化消耗的时间都省了，能省则省么。</p>
<p>解法三、终极解法</p>
<p>上面两种解法用到了孙子节点，计算爷爷节点能偷的钱还要同时去计算孙子节点投的钱，虽然有了记忆化，但是还是有性能损耗。</p>
<p>我们换一种办法来定义此问题</p>
<p>每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷</p>
<p>当前节点选择偷时，那么两个孩子节点就不能选择偷了<br>当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系)<br>我们使用一个大小为 2 的数组来表示 int[] res = new int[2] 0 代表不偷，1 代表偷<br>任何一个节点能偷到的最大钱的状态可以定义为</p>
<p>当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱<br>当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数<br>表示为公式如下</p>
<p>root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) + Math.max(rob(root.right)[0], rob(root.right)[1])<br>root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;<br>将公式做个变换就是代码啦</p>
<p>Java<br>public int rob(TreeNode root) {<br>    int[] result = robInternal(root);<br>    return Math.max(result[0], result[1]);<br>}</p>
<p>public int[] robInternal(TreeNode root) {<br>    if (root == null) return new int[2];<br>    int[] result = new int[2];</p>
<pre><code>int[] left = robInternal(root.left);
int[] right = robInternal(root.right);

result[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
result[1] = left[0] + right[0] + root.val;

return result;</code></pre><p>}<br>再提交一次：<br>执行用时 1 ms, 在所有 java 提交中击败了 99.87% 的用户，这样的结果，我觉得可以了。</p>
<h2 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413. 等差数列划分"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices/" target="_blank" rel="noopener">413. 等差数列划分</a></h2><p>难度中等122收藏分享切换为英文关注反馈</p>
<p>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<p>例如，以下数列为等差数列:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br></pre></td></tr></table></figure>

<p>以下数列不是等差数列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 5, 7</span><br></pre></td></tr></table></figure>



<p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。</p>
<p>如果满足以下条件，则称子数组(P, Q)为等差数组：</p>
<p>元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。</p>
<p>函数要返回数组 A 中所有为等差数组的子数组个数。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=A.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;l;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]-A[i-<span class="number">1</span>]==A[i-<span class="number">1</span>]-A[i-<span class="number">2</span>])&#123;</span><br><span class="line">                dp[i]=<span class="number">1</span>+dp[i-<span class="number">1</span>];</span><br><span class="line">                result+=dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Approach-1-Brute-Force-Accepted-1"><a href="#Approach-1-Brute-Force-Accepted-1" class="headerlink" title="Approach #1 Brute Force [Accepted]"></a>Approach #1 Brute Force [Accepted]</h4><p>The most naive solution is to consider every pair of elements(with atleast 1 element between them), so that the range of elements lying between these two elements acts as a slice. Then, we can iterate over every such slice(range) to check if all the consecutive elements within this range have the same difference. For every such range found, we can increment the count<em>c<strong>o</strong>u<strong>n</strong>t</em> that is used to keep a track of the required result.</p>
<iframe src="https://leetcode.com/playground/HT3WjgGf/shared" frameborder="0" name="HT3WjgGf" width="100%" height="343" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n3)<em>O</em>(<em>n</em>3). We iterate over the range formed by every pair of elements. Here, n<em>n</em> refers to the number of elements in the given array A<em>A</em>.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant extra space is used.</li>
</ul>
<hr>
<h4 id="Approach-2-Better-Brute-Force-Accepted"><a href="#Approach-2-Better-Brute-Force-Accepted" class="headerlink" title="Approach #2 Better Brute Force [Accepted]"></a>Approach #2 Better Brute Force [Accepted]</h4><p><strong>Algorithm</strong></p>
<p>In the last approach, we considered every possible range and then iterated over the range to check if the difference between every consercutive element in this range is the same. We can optimize this approach to some extent, by making a small observation.</p>
<p>We can see, that if we are currently considering the range bound by the elements, let’s say, A[s]<em>A</em><a href="start"><em>s</em></a> and A[e]<em>A</em><a href="end"><em>e</em></a>, we have checked the consecutive elements in this range to have the same difference. Now, when we move on to the next range between the indices s<em>s</em> and e+1<em>e</em>+1, we again perform a check on all the elements in the range s:e<em>s</em>:<em>e</em>, along with one additional pair A[e+1]<em>A</em>[<em>e</em>+1]and A[e]<em>A</em>[<em>e</em>]. We can remove this redundant check in the range s:e<em>s</em>:<em>e</em> and just check the last pair to have the same difference as the one used for the previous range(same s<em>s</em>, incremented e<em>e</em>).</p>
<p>Note that if the last range didn’t constitute an arithmetic slice, the same elements will be a part of the updated range as well. Thus, we can omit the rest of the ranges consisting of the same starting index. The rest of the process remains the same as in the last approach.</p>
<iframe src="https://leetcode.com/playground/NPDEAgTz/shared" frameborder="0" name="NPDEAgTz" width="100%" height="309" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n2)<em>O</em>(<em>n</em>2). Two for loops are used.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant extra space is used.</li>
</ul>
<hr>
<h4 id="Approach-3-Using-Recursion-Accepted"><a href="#Approach-3-Using-Recursion-Accepted" class="headerlink" title="Approach #3 Using Recursion [Accepted]"></a>Approach #3 Using Recursion [Accepted]</h4><p><strong>Algorithm</strong></p>
<p>By making use of the observation discussed in the last approach, we know, that if a range of elements between the indices (i,j)(<em>i</em>,<em>j</em>)constitute an Arithmetic Slice, and another element A[j+1]<em>A</em>[<em>j</em>+1] is included such that A[j+1]<em>A</em>[<em>j</em>+1] and A[j]<em>A</em>[<em>j</em>] have the same difference as that of the previous common difference, the ranges between (i,j+1)(<em>i</em>,<em>j</em>+1) will constitutes an arithmetic slice. Further, if the original range (i,j)(<em>i</em>,<em>j</em>) doesn’t form an arithmetic slice, adding new elements to this range won’t do us any good. Thus, no more arithmetic slices can be obtained by adding new elements to it.</p>
<p>By making use of this observation, we can develop a recursive solution for the given problem as well. Assume that a sum<em>s<strong>u</strong>m</em> variable is used to store the total number of arithmetic slices in the given array A<em>A</em>. We make use of a recursive function <code>slices(A,i)</code>which returns the number of Arithmetic Slices in the range (k,i)(<em>k</em>,<em>i</em>), but which are not a part of any range (k,j)(<em>k</em>,<em>j</em>) such that j&lt;i<em>j</em>&lt;<em>i</em>. It also updates sum<em>s<strong>u</strong>m</em> with the number of arithmetic slices(total) in the current range. Thus, k<em>k</em> refers to the minimum index such that the range (k,i)(<em>k</em>,<em>i</em>) constitutes a valid arithmetic slice.</p>
<p>Now, suppose we know the number of arithmetic slices in the range (0,i−1)(0,<em>i</em>−1) constituted by the elements [a0,a1,a2,…a(i−1)][<em>a</em>0,<em>a</em>1,<em>a</em>2,…<em>a</em>(<em>i</em>−1)], to be say x<em>x</em>. If this range itself is an arithmetic slice, all the consecutive elements have the same difference(equal to say, a(i−1)−a(i−2)<em>a</em>(<em>i</em>−1)−<em>a</em>(<em>i</em>−2)). Now, adding a new element ai<em>a**i</em> to it to extend the range to (0,i)(0,<em>i</em>) will constitute an arithmetic slice only if this new element satisfies ai−a(i−1)=a(i−1)−a(i−2)<em>a*<em>i</em>−*a</em>(<em>i</em>−1)=<em>a</em>(<em>i</em>−1)−<em>a</em>(<em>i</em>−2). Thus, now, the addition of this new element, will lead to an addition of ap<em>a**p</em> number of arithmetic slices to the ones obtained in the range (0,i−1)(0,<em>i</em>−1). The new arithmetic slices will be the ones constituting the ranges (0,i),(1,i),…(i−2,i)(0,<em>i</em>),(1,<em>i</em>),…(<em>i</em>−2,<em>i</em>), which are a total of x+1<em>x</em>+1 additional arithmetic slices. This is because, apart from the range (0,i)(0,<em>i</em>) the rest of the ranges (1,i),(2,i),…(i−2,i)(1,<em>i</em>),(2,<em>i</em>),…(<em>i</em>−2,<em>i</em>) can be mapped to (0,i−1),(1,i−1),…(i−3,i−1)(0,<em>i</em>−1),(1,<em>i</em>−1),…(<em>i</em>−3,<em>i</em>−1), with count equal to x<em>x</em>.</p>
<p>Thus, in every call to <code>slices</code>, if the ith<em>i<strong>t</strong>h</em> element has the same common difference with the last element as the previous common difference, we can find the number of new arithmetic slices added by the use of this element, ap<em>a**p</em> and also update the sum<em>s<strong>u</strong>m</em> to include this ap<em>a**p</em> into it, apart from the count obtained by the smaller ranges. But, if the new element doesn’t have the same common difference, extra arithmetic slices can’t be contributed by it and hence, no addition is done to sum<em>s<strong>u</strong>m</em> for the current element. But, of course sum<em>s<strong>u</strong>m</em> will be updated as per the count obtained from the smaller ranges.</p>
<iframe src="https://leetcode.com/playground/WGzuREMw/shared" frameborder="0" name="WGzuREMw" width="100%" height="360" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). The recursive function is called at most n−2<em>n</em>−2 times.</li>
<li>Space complexity : O(n)<em>O</em>(<em>n</em>). The depth of the recursion tree goes upto n−2<em>n</em>−2.</li>
</ul>
<hr>
<h4 id="Approach-5-Dynamic-Programming-Accepted"><a href="#Approach-5-Dynamic-Programming-Accepted" class="headerlink" title="Approach #5 Dynamic Programming [Accepted]:"></a>Approach #5 Dynamic Programming [Accepted]:</h4><p><strong>Algorithm</strong></p>
<p>In the last approach, we start with the full range (0,n−1)(0,<em>n</em>−1), where n<em>n</em> is the number of elements in the given A<em>A</em> array. We can observe that the result for the range (0,i)(0,<em>i</em>) only depends on the elements in the range (0,i)(0,<em>i</em>) and not on any element beyond this range. Thus, we can make use of Dynamic Programming to solve the given problem.</p>
<p>We can make use of a 1-D dp<em>d**p</em> with number of elements equal to n<em>n</em>. dp[i]<em>d**p</em>[<em>i</em>] is used to store the number of arithmetic slices possible in the range (k,i)(<em>k</em>,<em>i</em>) and not in any range (k,j)(<em>k</em>,<em>j</em>) such that j&lt;i<em>j</em>&lt;<em>i</em>. Again, k<em>k</em> refers to the minimum index possible such that (k,j)(<em>k</em>,<em>j</em>)constitutes a valid Arithmetic Slice.</p>
<p>Instead of going in the reverse order as in the recursive approach, we can start filling the dp<em>d**p</em> in a forward manner. The intuition remains the same as in the last approach. For the ith<em>i<strong>t</strong>h</em> element being considered, we check if this element satsfies the common difference criteria with the previous element. If so, we know the number of new arithmetic slices added will be 1+dp[i−1]1+<em>d**p</em>[<em>i</em>−1] as discussed in the last approach. The sum<em>s<strong>u</strong>m</em> is also updated by the same count to reflect the new arithmetic slices added.</p>
<p>The following animation illustrates the dp<em>d**p</em> filling process.</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAAHZCAYAAAC8QhsUAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAADSKADAAQAAAABAAAB2QAAAABdjUaIAABAAElEQVR4AezdB3wURRsG8Ody6b2RkJCQhNB770WkShOkgyJNBAFFqqh0UERB9KOLIL0K0hHpvfcaSAiBJKSH9Ha331w4ILm7hNCTu2f9RW77zn9nd+ednd2VSaIDOwpQgAIUoAAFKEABClCAAhSAEQ0oQAEKUIACFKAABShAAQpQ4LEAAyTmBApQgAIUoAAFKEABClCAAmoBBkjMChSgAAUoQAEKUIACFKAABdQCDJCYFShAAQpQgAIUoAAFKEABCqgFGCAxK1CAAhSgAAUoQAEKUIACFFALMEBiVqAABShAAQpQgAIUoAAFKKAWYIDErEABClCAAhSgAAUoQAEKUEAtwACJWYECFKAABShAAQpQgAIUoIBagAESswIFKEABClCAAhSgAAUoQAG1AAMkZgUKUIACFKAABShAAQpQgAJqAQZIzAoUoAAFKEABClCAAhSgAAXUAgyQmBUoQAEKUIACFKAABShAAQqoBRggMStQgAIUoAAFKEABClCAAhRQCzBAYlagAAUoQAEKUIACFKAABSigFmCAxKxAAQpQgAIUoAAFKEABClBALcAAiVmBAhSgAAUoQAEKUIACFKCAWoABErMCBShAAQpQgAIUoAAFKEABtQADJGYFClCAAhSgAAUoQAEKUIACagEGSMwKFKAABShAAQpQgAIUoAAF1AIMkJgVKEABClCAAhSgAAUoQAEKqAUYIDErUIACFKAABShAAQpQgAIUUAswQGJWoAAFKEABClCAAhSgAAUooBZggMSsQAEKUIACFKAABShAAQpQQC3AAIlZgQIUoAAFKEABClCAAhSggFqAARKzAgUoQAEKUIACFKAABShAAbUAAyRmBQpQgAIUoAAFKEABClCAAmoBBkjMChSgAAUoQAEKUIACFKAABdQCDJCYFShAAQpQgAIUoAAFKEABCqgFGCAxK1CAAhSgAAUoQAEKUIACFFALMEBiVqAABShAAQpQgAIUoAAFKKAWYIDErEABClCAAhSgAAUoQAEKUEAtwACJWYECFKAABShAAQpQgAIUoIBagAESswIFKEABClCAAhSgAAUoQAG1AAMkZgUKUIACFKAABShAAQpQgAJqAQZIzAoUoAAFKEABClCAAhSgAAXUAgyQmBUoQAEKUIACFKAABShAAQqoBRggMStQgAIUoAAFKEABClCAAhRQCzBAYlagAAUoQAEKUIACFKAABSigFmCAxKxAAQpQgAIUoAAFKEABClBALcAAiVmBAhSgAAUoQAEKUIACFKCAWoABErMCBShAAQpQgAIUoAAFKEABtQADJGYFClCAAhSgAAUoQAEKUIACagEGSMwKFKAABShAAQpQgAIUoAAF1AIMkJgVKEABClCAAhSgAAUoQAEKqAUYIDErUIACFKAABShAAQpQgAIUUAswQGJWoAAFKEABClCAAhSgAAUooBZggMSsQAEKUIACFKAABShAAQpQQC3AAIlZgQIUoAAFKEABClCAAhSggFqAARKzAgUoQAEKUIACFKAABShAAbUAAyRmBQpQgAIUoAAFKEABClCAAmoBBkjMChSgAAUoQAEKUIACFKAABdQCDJCYFShAAQpQgAIUoAAFKEABCqgFGCAxK1CAAhSgAAUoQAEKUIACFFALMEBiVqAABShAAQpQgAIUoAAFKKAWYIDErEABClCAAhSgAAUoQAEKUEAtwACJWYECFKAABShAAQpQgAIUoIBagAESswIFKEABClCAAhSgAAUoQAG1AAMkZgUKUIACFKAABShAAQpQgAJqAQZIzAoUoAAFKEABClCAAhSgAAXUAgyQmBUoQAEKUIACFKAABShAAQqoBRggMStQgAIUoAAFKEABClCAAhRQCzBAYlagAAUoQAEKUIACFKAABSigFmCAxKxAAQpQgAIUoAAFKEABClBALcAAiVmBAhSgAAUoQAEKUIACFKCAWoABErMCBShAAQpQgAIUoAAFKEABtQADJGYFClCAAhSgAAUoQAEKUIACagEGSMwKFKAABShAAQpQgAIUoAAF1AIMkJgVKEABClCAAhSgAAUoQAEKqAUYIDErUIACFKAABShAAQpQgAIUUAswQGJWoAAFKEABClCAAhSgAAUooBZggMSsQAEKUIACFKAABShAAQpQQC3AAIlZgQIUoAAFKEABClCAAhSggFqAARKzAgUoQAEKUIACFKAABShAAbUAAyRmBQpQgAIUoAAFKEABClCA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AktvTt7O9WRHjx4d991337jwwgvP9Sj/03//1157bbzwwgvc5lA/ceLE2L179xzP7H7K888/P7Zv3z42bdrUDTFj+pMnT44zZ86M888/f8Znnt2H/7+/fLz88svjxRdfHLt27Tq7EAv2s09fG44fPz727NmzYMnObpw33nhjPPvss+Oiiy46u/+gBfzZn3vuubFz586xvOzr9rPUO31tmJpt3bp1lqfVP/b06dNj375944EHHhgrKyvRYyEG0qlTp8b0E68tW7bEkI5ZYPrJzSuvvDLW1tbyA1zXFZh+4sVtXZ51f2D68ba6uupFcF2h/APTT1inv16ndt7eusB0VL766qt+rb51sv88cvqJ/vR1ddu2bTM+08Onbj5Znf3jYPrasHnz5tmfWP6M6WvD0tLS2LBhQ7nEbPGnrw3TYfnfvni2EANpNhaPJkCAAAECBAgQIECAQBbwe5nZxZUAAQIECBAgQIAAgUIBA6mwdJEJECBAgAABAgQIEMgCBlJ2cSVAgAABAgQIECBAoFDAQCosXWQCBAgQIECAAAECBLKAgZRdXAkQIECAAAECBAgQKBQwkApLF5kAAQIECBAgQIAAgSxgIGUXVwIECBAgQIAAAQIECgUMpMLSRSZAgAABAgQIECBAIAsYSNnFlQABAgQIECBAgACBQgEDqbB0kQkQIECAAAECBAgQyAIGUnZxJUCAAAECBAgQIECgUMBAKixdZAIECBAgQIAAAQIEsoCBlF1cCRAgQIAAAQIECBAoFDCQCksXmQABAgQIECBAgACBLGAgZRdXAgQIECBAgAABAgQKBQykwtJFJkCAAAECBAgQIEAgCxhI2cWVAAECBAgQIECAAIFCAQOpsHSRCRAgQIAAAQIECBDIAgZSdnElQIAAAQIECBAgQKBQwEAqLF1kAgQIECBAgAABAgSygIGUXVwJECBAgAABAgQIECgUMJAKSxeZAAECBAgQIECAAIEsYCBlF1cCBAgQIECAAAECBAoFDKTC0kUmQIAAAQIECBAgQCALGEjZxZUAAQIECBAgQIAAgUIBA6mwdJEJECBAgAABAgQIEMgCBlJ2cSVAgAABAgQIECBAoFDAQCosXWQCBAgQIECAAAECBLKAgZRdXAkQIECAAAECBAgQKBQwkApLF5kAAQIECBAgQIAAgSxgIGUXVwIECBAgQIAAAQIECgUM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" alt="Current"></p>
<p>1 / 9</p>
<iframe src="https://leetcode.com/playground/w8UZ2q6u/shared" frameborder="0" name="w8UZ2q6u" width="100%" height="292" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). We traverse over the given A<em>A</em> array with n<em>n</em> elements once only.</li>
<li>Space complexity : O(n)<em>O</em>(<em>n</em>). 1-D dp<em>d**p</em> of size n<em>n</em> is used.</li>
</ul>
<hr>
<h4 id="Approach-5-Constant-Space-Dynamic-Programming-Accepted"><a href="#Approach-5-Constant-Space-Dynamic-Programming-Accepted" class="headerlink" title="Approach #5 Constant Space Dynamic Programming [Accepted]:"></a>Approach #5 Constant Space Dynamic Programming [Accepted]:</h4><p><strong>Algorithm</strong></p>
<p>In the last approach, we can observe that we only require the element dp[i−1]<em>d**p</em>[<em>i</em>−1] to determine the value to be entered at dp[i]<em>d**p</em>[<em>i</em>]. Thus, instead of making use of a 1-D array to store the required data, we can simply keep a track of just the last element.</p>
<iframe src="https://leetcode.com/playground/mGEcWWi3/shared" frameborder="0" name="mGEcWWi3" width="100%" height="292" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). We traverse over the given A<em>A</em> array with n<em>n</em> elements once only.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant extra space is used.</li>
</ul>
<hr>
<h4 id="Approach-6-Using-Formula-Accepted"><a href="#Approach-6-Using-Formula-Accepted" class="headerlink" title="Approach #6 Using Formula [Accepted]:"></a>Approach #6 Using Formula [Accepted]:</h4><p><strong>Algorithm</strong></p>
<p>From the dp<em>d**p</em> solution, we can observe that for k<em>k</em> consecutive elements sastisfying the common difference criteria, we update the sum<em>s<strong>u</strong>m</em> for each such element by 1,2,3,…,k1,2,3,…,<em>k</em> counts in that order. Thus, instead of updating the sum<em>s<strong>u</strong>m</em> at the same time, we can just keep a track of the number of consecutive elements satisfying the common differnce criteria in a count<em>c<strong>o</strong>u<strong>n</strong>t</em> variable and just update the sum<em>s<strong>u</strong>m</em> directly as count∗(count+1)/2<em>c<strong>o</strong>u<strong>n</strong>t<em>∗(</em>c<strong>o</strong>u<strong>n</strong>t</em>+1)/2 whenver an element not satisfying this criteria is found. At the same time, we also need to reset the count<em>c<strong>o</strong>u<strong>n</strong>t</em> value.</p>
<iframe src="https://leetcode.com/playground/fQULWrDF/shared" frameborder="0" name="fQULWrDF" width="100%" height="309" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). We iterate over A<em>A</em> with n<em>n</em> elements exactly once.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant extra space is used.</li>
</ul>
<h2 id="1039-多边形三角剖分的最低得分"><a href="#1039-多边形三角剖分的最低得分" class="headerlink" title="1039. 多边形三角剖分的最低得分"></a><a href="https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/" target="_blank" rel="noopener">1039. 多边形三角剖分的最低得分</a></h2><p>难度中等41收藏分享切换为英文关注反馈</p>
<p>给定 <code>N</code>，想象一个凸 <code>N</code> 边多边形，其顶点按顺时针顺序依次标记为 <code>A[0], A[i], ..., A[N-1]</code>。</p>
<p>假设您将多边形剖分为 <code>N-2</code> 个三角形。对于每个三角形，该三角形的值是顶点标记的<strong>乘积</strong>，三角剖分的分数是进行三角剖分后所有 <code>N-2</code> 个三角形的值之和。</p>
<p>返回多边形进行三角剖分后可以得到的最低分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：多边形已经三角化，唯一三角形的分数为 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/minimum-score-triangulation-of-polygon-1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,7,4,5]</span><br><span class="line">输出：144</span><br><span class="line">解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 &#x3D; 245，或 3*4*5 + 3*4*7 &#x3D; 144。最低分数为 144。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,3,1,4,1,5]</span><br><span class="line">输出：13</span><br><span class="line">解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 &#x3D; 13。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minScoreTriangulation</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=A.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[l][l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l-<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">2</span>;j&lt;l;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j]==<span class="number">0</span>)</span><br><span class="line">                        dp[i][j]=dp[i][k]+dp[k][j]+A[i]*A[j]*A[k];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=Math.min(dp[i][k]+dp[k][j]+A[i]*A[j]*A[k],dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][l-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解题思路</p>
<p>dp[i][j]表示从i到j序列的最低分。记底边为ij的三角形顶点为m，三角形imj将多边形分成三部分，总分即为三部分的分数和（如果m=i+1或m=j-1，则对应第一或第三部分分数为0）。<br>那么m在什么位置分数最低呢，将m从i+1到j-1遍历，分别计算dp[i][m]+A[i]<em>A[j]</em>A[m]+dp[m][j],取其中最小值即为dp[i][j]。<br>dp[i][j]=min(dp[i][m]+A[i]<em>A[j]</em>A[m]+dp[m][j]),for m in range [i+1,j-1]</p>
<p>dp table只用到右上半部分，初始化相邻两元素序列结果为0（两元素序列不能构成三角形）；采用自底向上、自左向右的方向计算dp table。最终输出dp[0][n-1]。</p>
<h2 id="1043-分隔数组以得到最大和"><a href="#1043-分隔数组以得到最大和" class="headerlink" title="1043. 分隔数组以得到最大和"></a><a href="https://leetcode-cn.com/problems/partition-array-for-maximum-sum/" target="_blank" rel="noopener">1043. 分隔数组以得到最大和</a></h2><p>难度中等48收藏分享切换为英文关注反馈</p>
<p>给出整数数组 <code>A</code>，将该数组分隔为长度最多为 K 的几个（连续）子数组。分隔完成后，每个子数组的中的值都会变为该子数组中的最大值。</p>
<p>返回给定数组完成分隔后的最大和。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [1,15,7,9,2,5,10], K &#x3D; 3</span><br><span class="line">输出：84</span><br><span class="line">解释：A 变为 [15,15,15,9,10,10,10]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= K &lt;= A.length &lt;= 500</code></li>
<li><code>0 &lt;= A[i] &lt;= 10^6</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=A.length;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">0</span>||A==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[l+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> max=dp[i];</span><br><span class="line">            <span class="keyword">while</span>((i-j)&lt;=K &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                max=Math.max(A[j],max);</span><br><span class="line">                dp[i]=Math.max(dp[i],dp[j]+max*(i-j));</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法1：DP"><a href="#方法1：DP" class="headerlink" title="方法1：DP"></a>方法1：DP</h5><p><img src="https://pic.leetcode-cn.com/ddf9ff236598ff79b00e7365354cdaf961463cc78dfed7505334ad2628a60d73-e7c5ca8d4c19bed3e8652951c6f37c6.jpg" alt="e7c5ca8d4c19bed3e8652951c6f37c6.jpg"></p>
<p><img src="https://pic.leetcode-cn.com/a49b3279d3d2e9b9d9617da384d72dbcfe395dc3a0f0d1fe6fc4e4587f2c6d12-image.png" alt="image.png"></p>
<h2 id="1218-最长定差子序列"><a href="#1218-最长定差子序列" class="headerlink" title="1218. 最长定差子序列"></a><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/" target="_blank" rel="noopener">1218. 最长定差子序列</a></h2><p>难度中等27收藏分享切换为英文关注反馈</p>
<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>difference</code>，请你找出 <code>arr</code> 中所有相邻元素之间的差等于给定 <code>difference</code> 的等差子序列，并返回其中最长的等差子序列的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,3,4], difference &#x3D; 1</span><br><span class="line">输出：4</span><br><span class="line">解释：最长的等差子序列是 [1,2,3,4]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,3,5,7], difference &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：最长的等差子序列是任意单个元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,5,7,8,5,3,4,2,1], difference &#x3D; -2</span><br><span class="line">输出：4</span><br><span class="line">解释：最长的等差子序列是 [7,5,3,1]。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= arr[i], difference &lt;= 10^4</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">1</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: arr)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=map.getOrDefault(i-difference, <span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">            map.put(i,tmp);</span><br><span class="line">            result=Math.max(result,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路<br>这道题思路比较简单，跟经典问题最长递增（减）子序列有点相似，而这道题称为最长等差子序列, 也就是说是固定公差的递增（减），相对还更简单一点。</p>
<p>可以用dp[i]来记录以数字i为结尾的最长等差子序列的长度，那么它应该只有两种情况：</p>
<p>dp[i] = 1 // 表示在 i 之前没有出现等差子序列<br>dp[i] = dp[i - difference] + 1 // 表示在 i 之前出现了等差子序列，长度为 dp[i - difference], 而 i 也是满足这个等差序列的，所以等差序列的长度在此基础上加 1 就可以了<br>考虑元素值会出现负数，所以用数组存放是不行的，那么可以用一个 map来维护以 i 结尾的最长等差序列的长度，所以也就不难得出如下代码：</p>
<p>可以为下标加一个偏置，解决出现负值的情况，这是很OK，因为这道题arr[i]、difference的数据范围已经给的很明确了，而且比较小。</p>
<h2 id="1269-停在原地的方案数"><a href="#1269-停在原地的方案数" class="headerlink" title="1269. 停在原地的方案数"></a><a href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/" target="_blank" rel="noopener">1269. 停在原地的方案数</a></h2><p>难度困难23收藏分享切换为英文关注反馈</p>
<p>有一个长度为 <code>arrLen</code> 的数组，开始有一个指针在索引 <code>0</code> 处。</p>
<p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p>
<p>给你两个整数 <code>steps</code> 和 <code>arrLen</code> ，请你计算并返回：在恰好执行 <code>steps</code> 次操作以后，指针仍然指向索引 <code>0</code> 处的方案数。</p>
<p>由于答案可能会很大，请返回方案数 <strong>模</strong> <code>10^9 + 7</code> 后的结果。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：steps &#x3D; 3, arrLen &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。</span><br><span class="line">向右，向左，不动</span><br><span class="line">不动，向右，向左</span><br><span class="line">向右，不动，向左</span><br><span class="line">不动，不动，不动</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：steps &#x3D; 2, arrLen &#x3D; 4</span><br><span class="line">输出：2</span><br><span class="line">解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。</span><br><span class="line">向右，向左</span><br><span class="line">不动，不动</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：steps &#x3D; 4, arrLen &#x3D; 2</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= steps &lt;= 500</code></p>
</li>
<li><p><code>1 &lt;= arrLen &lt;= 10^6</code></p>
<p>s: steps</p>
<pre><code>l：经过s步，停留的坐标
p[s][l]: 经过s步，停留在坐标l的总方案数
arrLen: 数组长度</code></pre></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MOD = <span class="number">1_000_000_007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> steps, <span class="keyword">int</span> arrLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p[][] = <span class="keyword">new</span> <span class="keyword">int</span>[steps+<span class="number">1</span>][steps+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        p[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">1</span>; s&lt;=steps; s++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">0</span>; l &lt; Math.min(steps+<span class="number">1</span>, arrLen); l++) &#123;                        </span><br><span class="line">                <span class="keyword">if</span> (s == l) &#123;</span><br><span class="line">                    p[s][l] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s &lt; l) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p[s][l] = p[s-<span class="number">1</span>][l];</span><br><span class="line">                <span class="keyword">if</span> (l-<span class="number">1</span> &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                    p[s][l] += p[s-<span class="number">1</span>][l-<span class="number">1</span>];</span><br><span class="line">                    p[s][l] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l+<span class="number">1</span> &lt; arrLen) &#123;</span><br><span class="line">                    p[s][l] += p[s-<span class="number">1</span>][l+<span class="number">1</span>];</span><br><span class="line">                    p[s][l] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[steps][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<pre><code>动态规划解法三要素：
1、最优子结构
指针可以向左、向右、停在原地，所有最后一步可以前面的基础上往这三个方向前进，即子结构为：
p[s-1][l], p[s-1][l-1] , p[s-1][l+1]   PS: 原地、向右、向左
2、状态转移方程
p[s][l] = p[s-1][l] + p[s-1][l-1] + p[s-1][l+1]
3、边界条件
p[0][0] = 1;
p[s][l] = 0 if s &lt; l  

问题求解：
p[s][0]
arrLen


注意点：
1、 中间结果数组，注意边界条件p[s][l] = 0 if s &lt; l  ，所以只需要定义int[steps+1][steps+1] 而不需要是int[steps+1][arrLen]，不然会超出内存限制；
2、 结果是返回模 10^9 + 7 后的结果，p[s][l] = p[s-1][l] + p[s-1][l-1] + p[s-1][l+1]  状态方程是两两相加就要求mod，而不是三个求和之后再求mod，之前结果总有用例不过
就是因为三个求和之后再求的mod。</code></pre><h2 id="1312-让字符串成为回文串的最少插入次数"><a href="#1312-让字符串成为回文串的最少插入次数" class="headerlink" title="1312. 让字符串成为回文串的最少插入次数"></a><a href="https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/" target="_blank" rel="noopener">1312. 让字符串成为回文串的最少插入次数</a></h2><p>难度困难34收藏分享切换为英文关注反馈</p>
<p>给你一个字符串 <code>s</code> ，每一次操作你都可以在字符串的任意位置插入任意字符。</p>
<p>请你返回让 <code>s</code> 成为回文串的 <strong>最少操作次数</strong> 。</p>
<p>「回文串」是正读和反读都相同的字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;zzazz&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：字符串 &quot;zzazz&quot; 已经是回文串了，所以不需要做任何插入操作。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;mbadm&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：字符串可变为 &quot;mbdadbm&quot; 或者 &quot;mdbabdm&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcode&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：插入 5 个字符后字符串变为 &quot;leetcodocteel&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;g&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;no&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 中所有字符都是小写字母。</li>
</ul>
<p>我们用 dp[i][j] 表示对于字符串 s 的子串 s[i:j]（这里的下标从 0 开始，并且 s[i:j] 包含 s 中的第 i 和第 j 个字符），最少添加的字符数量，使得 s[i:j] 变为回文串。</p>
<p>我们从外向内考虑 s[i:j]：</p>
<p>如果 s[i] == s[j]，那么最外层已经形成了回文，我们只需要继续考虑 s[i+1:j-1]；</p>
<p>如果 s[i] != s[j]，那么我们要么在 s[i:j] 的末尾添加字符 s[i]，要么在 s[i:j] 的开头添加字符 s[j]，才能使得最外层形成回文。如果我们选择前者，那么需要继续考虑 s[i+1:j]；如果我们选择后者，那么需要继续考虑 s[i:j-1]。</p>
<p>因此我们可以得到如下的状态转移方程：</p>
<p>dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1)                     if s[i] != s[j]<br>dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1, dp[i + 1][j - 1])   if s[i] == s[j]<br>边界条件为：</p>
<p>dp[i][j] = 0   if i &gt;= j<br>注意该动态规划为区间动态规划，需要注意 dp[i][j] 的计算顺序。一种可行的方法是，我们递增地枚举子串 s[i:j] 的长度 span = j - i + 1，再枚举起始位置 i，通过 j = i + span - 1 得到 j 的值并计算 dp[i][j]。这样的计算顺序可以保证在计算 dp[i][j] 时，状态转移方程中的状态 dp[i + 1][j]，dp[i][j - 1] 和 dp[i + 1][j - 1] 均已计算过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> span = <span class="number">2</span>; span &lt;= n; ++span) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - span; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + span - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></h2><p>难度简单118收藏分享切换为英文关注反馈</p>
<p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为<strong>斐波那契数列</strong>。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>

<p>给定 <code>N</code>，计算 <code>F(N)</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2.</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3.</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>0 ≤ <code>N</code> ≤ 30</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private Integer[] cache &#x3D; new Integer[31];</span><br><span class="line"></span><br><span class="line">    public int fib(int N) &#123;</span><br><span class="line">        if (N &lt;&#x3D; 1) &#123;</span><br><span class="line">            return N;</span><br><span class="line">        &#125;</span><br><span class="line">        cache[0] &#x3D; 0;</span><br><span class="line">        cache[1] &#x3D; 1;</span><br><span class="line">        return memoize(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int memoize(int N) &#123;</span><br><span class="line">      if (cache[N] !&#x3D; null) &#123;</span><br><span class="line">          return cache[N];</span><br><span class="line">      &#125;</span><br><span class="line">      cache[N] &#x3D; memoize(N-1) + memoize(N-2);</span><br><span class="line">      return memoize(N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Approach-1-Recursion"><a href="#Approach-1-Recursion" class="headerlink" title="Approach 1: Recursion"></a>Approach 1: Recursion</h4><p><strong>Intuition</strong></p>
<p>Use recursion to compute the Fibonacci number of a given integer.</p>
<p><img src="https://leetcode.com/problems/fibonacci-number/Figures/509/fibonacciRecursion5.png" alt="fib(5) Recursion diagram"></p>
<p><em>Figure 1. An example tree representing what <code>fib(5)</code> would look like</em></p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Check if the provided input value, N, is less than or equal to 1. If true, return N.</li>
<li>Otherwise, the function <code>fib(int N)</code> calls itself, with the result of the 2 previous numbers being added to each other, passed in as the argument. This is derived directly from the <code>recurrence relation</code>: Fn=Fn−1+Fn−2<em>F**n</em>=<em>F*</em>n<em>−1+</em>F*<em>n</em>−2</li>
<li>Do this until all numbers have been computed, then return the resulting answer.</li>
</ul>
<iframe src="https://leetcode.com/playground/uoCAvhCh/shared" frameborder="0" width="100%" height="191" name="uoCAvhCh" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(2N)<em>O</em>(2<em>N</em>). This is the slowest way to solve the <code>Fibonacci Sequence</code> because it takes exponential time. The amount of operations needed, for each level of recursion, grows exponentially as the depth approaches <code>N</code>.</li>
<li>Space complexity : O(N)<em>O</em>(<em>N</em>). We need space proportionate to <code>N</code> to account for the max size of the stack, in memory. This stack keeps track of the function calls to <code>fib(N)</code>. This has the potential to be bad in cases that there isn’t enough physical memory to handle the increasingly growing stack, leading to a <code>StackOverflowError</code>. The <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/StackOverflowError.html" target="_blank" rel="noopener">Java docs</a> have a good explanation of this, describing it as an error that occurs because an application recurses too deeply.</li>
</ul>
<hr>
<h4 id="Approach-2-Bottom-Up-Approach-using-Memoization"><a href="#Approach-2-Bottom-Up-Approach-using-Memoization" class="headerlink" title="Approach 2: Bottom-Up Approach using Memoization"></a>Approach 2: Bottom-Up Approach using Memoization</h4><p><strong>Intuition</strong></p>
<p>Improve upon the recursive option by using iteration, still solving for all of the sub-problems and returning the answer for N, using already computed Fibonacci values. In using a bottom-up approach, we can iteratively compute and store the values, only returning once we reach the result.</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>If <code>N</code> is less than or equal to 1, return <code>N</code></li>
<li>Otherwise, iterate through <code>N</code>, storing each computed answer in an array along the way.</li>
<li>Use this array as a reference to the 2 previous numbers to calculate the current Fibonacci number.</li>
<li>Once we’ve reached the last number, return it’s Fibonacci number.</li>
</ul>
<iframe src="https://leetcode.com/playground/uEUpwCPg/shared" frameborder="0" width="100%" height="361" name="uEUpwCPg" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(N)<em>O</em>(<em>N</em>). Each number, starting at 2 up to and including <code>N</code>, is visited, computed and then stored for O(1)<em>O</em>(1)access later on.</li>
<li>Space complexity : O(N)<em>O</em>(<em>N</em>). The size of the data structure is proportionate to <code>N</code>.</li>
</ul>
<hr>
<h4 id="Approach-3-Top-Down-Approach-using-Memoization"><a href="#Approach-3-Top-Down-Approach-using-Memoization" class="headerlink" title="Approach 3: Top-Down Approach using Memoization"></a>Approach 3: Top-Down Approach using Memoization</h4><p><strong>Intuition</strong></p>
<p>Solve for all of the sub-problems, use memoization to store the pre-computed answers, then return the answer for N. We will leverage recursion, but in a smarter way by not repeating the work to calculate existing values.</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Check if <code>N &lt;= 1</code>. If it is, return <code>N</code>.</li>
<li>Call and return <code>memoize(N)</code></li>
<li>If <code>N</code> exists in the map, return the cached value for <code>N</code></li>
<li>Otherwise set the value of <code>N</code>, in our mapping, to the value of <code>memoize(N-1) + memoize(N-2)</code></li>
</ul>
<iframe src="https://leetcode.com/playground/T6ZdXXX4/shared" frameborder="0" width="100%" height="395" name="T6ZdXXX4" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(N)<em>O</em>(<em>N</em>). Each number, starting at 2 up to and including <code>N</code>, is visited, computed and then stored for O(1)<em>O</em>(1)access later on.</li>
<li>Space complexity : O(N)<em>O</em>(<em>N</em>). The size of the stack in memory is proportionate to <code>N</code>.</li>
</ul>
<hr>
<h4 id="Approach-4-Iterative-Top-Down-Approach"><a href="#Approach-4-Iterative-Top-Down-Approach" class="headerlink" title="Approach 4: Iterative Top-Down Approach"></a>Approach 4: Iterative Top-Down Approach</h4><p><strong>Intuition</strong></p>
<p>Let’s get rid of the need to use all of that space and instead use the minimum amount of space required. We can achieve O(1)<em>O</em>(1)space complexity by only storing the value of the two previous numbers and updating them as we iterate to <code>N</code>.</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Check if <code>N &lt;= 1</code>, if it is then we should return <code>N</code>.</li>
<li>Check if <code>N == 2</code>, if it is then we should return <code>1</code> since <code>N</code> is 2 and <code>fib(2-1) + fib(2-2)</code> equals <code>1 + 0 = 1</code>.</li>
<li>To use an iterative approach, we need at least 3 variables to store each state <code>fib(N)</code>, <code>fib(N-1)</code> and <code>fib(N-2)</code>.</li>
<li>Preset the initial values:<ul>
<li>Initialize <code>current</code> with 0.</li>
<li>Initialize <code>prev1</code> with 1, since this will represent <code>fib(N-1)</code> when computing the current value.</li>
<li>Initialize <code>prev2</code> with 1, since this will represent <code>fib(N-2)</code> when computing the current value.</li>
</ul>
</li>
<li>Iterate, incrementally by 1, all the way up to and including <code>N</code>. Starting at 3, since <code>0</code>, <code>1</code> and <code>2</code> are pre-computed.</li>
<li>Set the <code>current</code> value to <code>fib(N-1) + fib(N-2)</code> because that is the value we are currently computing.</li>
<li>Set the <code>prev2</code> value to <code>fib(N-1)</code>.</li>
<li>Set the <code>prev1</code> value to <code>current_value</code>.</li>
<li>When we reach <code>N+1</code>, we will exit the loop and return the previously set <code>current</code> value.</li>
</ul>
<iframe src="https://leetcode.com/playground/pM6EDZh2/shared" frameborder="0" width="100%" height="412" name="pM6EDZh2" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(N)<em>O</em>(<em>N</em>). Each value from <code>2 to N</code> will be visited at least once. The time it takes to do this is directly proportionate to <code>N</code> where <code>N</code> is the <code>Fibonacci Number</code> we are looking to compute.</li>
<li>Space complexity : O(1)<em>O</em>(1). This requires 1 unit of Space for the integer <code>N</code> and 3 units of Space to store the computed values (<code>curr</code>, <code>prev1</code> and <code>prev2</code>) for every loop iteration. The amount of Space doesn’t change so this is constant Space complexity.</li>
</ul>
<hr>
<h4 id="Approach-5-Matrix-Exponentiation"><a href="#Approach-5-Matrix-Exponentiation" class="headerlink" title="Approach 5: Matrix Exponentiation"></a>Approach 5: Matrix Exponentiation</h4><p><strong>Intuition</strong></p>
<p>Use Matrix Exponentiation to get the Fibonacci number from the element at (0, 0) in the resultant matrix.</p>
<p>In order to do this we can rely on the matrix equation for the Fibonacci sequence, to find the <code>Nth</code> Fibonacci number: (1  11  0)n=( F(n+1)     F(n) F(n)     F(n−1))(1110)<em>n</em>=(<em>F</em>(<em>n</em>+1)<em>F</em>(<em>n</em>)<em>F</em>(<em>n</em>)<em>F</em>(<em>n</em>−1))</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Check if <code>N</code> is less than or equal to 1. If it is, return <code>N</code>.</li>
<li>Use a recursive function, <code>matrixPower</code>, to calculate the power of a given matrix <code>A</code>. The power will be <code>N-1</code>, where <code>N</code> is the <code>Nth Fibonacci number</code>.</li>
<li>The <code>matrixPower</code> function will be performed for <code>N/2</code> of the Fibonacci numbers.</li>
<li>Within <code>matrixPower</code>, call the <code>multiply</code> function to multiply 2 matrices.</li>
<li>Once we finish doing the calculations, return <code>A[0][0]</code> to get the <code>Nth</code> Fibonacci number.</li>
</ul>
<iframe src="https://leetcode.com/playground/y9EwghPh/shared" frameborder="0" width="100%" height="500" name="y9EwghPh" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(log⁡N)<em>O</em>(log<em>N</em>). By halving the <code>N</code> value in every <code>matrixPower</code>‘s call to itself, we are halving the work needed to be done.</li>
<li>Space complexity : O(log⁡N)<em>O</em>(log<em>N</em>). The size of the stack in memory is proportionate to the function calls to <code>matrixPower</code> plus the memory used to account for the matrices which takes up constant space.</li>
</ul>
<hr>
<h4 id="Approach-6-Math"><a href="#Approach-6-Math" class="headerlink" title="Approach 6: Math"></a>Approach 6: Math</h4><p><strong>Intuition</strong> Using the <code>golden ratio</code>, a.k.a <code>Binet&#39;s forumula</code>: φ=1+52≈1.6180339887….<em>φ</em>=21+5≈1.6180339887….</p>
<p>Here’s a <a href="http://demonstrations.wolfram.com/GeneralizedFibonacciSequenceAndTheGoldenRatio/" target="_blank" rel="noopener">link</a> to find out more about how the Fibonacci sequence and the golden ratio work.</p>
<p>We can derive the most efficient solution to this problem using only constant time and constant space!</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Use the <code>golden ratio</code> formula to calculate the <code>Nth</code> Fibonacci number.</li>
</ul>
<iframe src="https://leetcode.com/playground/vgmYRSh2/shared" frameborder="0" width="100%" height="157" name="vgmYRSh2" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(1)<em>O</em>(1). Constant time complexity since we are using no loops or recursion and the time is based on the result of performing the calculation using <code>Binet&#39;s formula</code>.</li>
<li>Space complexity : O(1)<em>O</em>(1). The space used is the space needed to create the variable to store the <code>golden ratio</code> formula.</li>
</ul>
<h4 id="面试题-17-16-按摩师"><a href="#面试题-17-16-按摩师" class="headerlink" title="面试题 17.16. 按摩师"></a><a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">面试题 17.16. 按摩师</a></h4><p>难度简单98收藏分享切换为英文关注反馈</p>
<p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p><strong>注意：</strong>本题相对原题稍作改动</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [1,2,3,1]</span><br><span class="line">输出： 4</span><br><span class="line">解释： 选择 1 号预约和 3 号预约，总时长 &#x3D; 1 + 3 &#x3D; 4。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [2,7,9,3,1]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 &#x3D; 2 + 9 + 1 &#x3D; 12。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [2,1,4,5,3,1,1,3]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 &#x3D; 2 + 4 + 3 + 3 &#x3D; 12。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> premax=<span class="number">0</span>;<span class="comment">//记录上一个max</span></span><br><span class="line">        <span class="keyword">int</span> curmax=<span class="number">0</span>;<span class="comment">//当前max</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=curmax;</span><br><span class="line">            curmax=Math.max(premax+i, curmax);<span class="comment">//取当时max还是之前max加上目前值</span></span><br><span class="line">            premax=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curmax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>《程序员面试金典（第 6 版）》独家授权<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/11/logo20190828-02.png" alt="img"></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/30/book_2.jpg" alt="img"></p>
<p>本书是原谷歌资深面试官的经验之作，帮助了许多想要加入脸书、苹果、谷歌等 IT 名企的求职者拿到 Dream offer。本专题的 100+ 编程面试题是在原书基础上精心挑选出来的，帮助你轻松应战 IT 名企技术面试。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%99%BA%E8%83%BD%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%99%BA%E8%83%BD%E5%AD%98%E5%82%A8/" class="post-title-link" itemprop="url">动态规划之智能存储</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-19 09:37:02 / Modified: 10:16:05" itemprop="dateCreated datePublished" datetime="2020-04-19T09:37:02-05:00">2020-04-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304. 二维区域和检索 - 矩阵不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">304. 二维区域和检索 - 矩阵不可变</a></h2><p>难度中等79收藏分享切换为英文关注反馈</p>
<p>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (<em>row</em>1, <em>col</em>1) ，右下角为 (<em>row</em>2, <em>col</em>2)。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/images/304.png" alt="Range Sum Query 2D"><br>上图子矩阵左上角 (row1, col1) = <strong>(2, 1)</strong> ，右下角(row2, col2) = <strong>(4, 3)，</strong>该子矩形内元素的总和为 8。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix &#x3D; [</span><br><span class="line">  [3, 0, 1, 4, 2],</span><br><span class="line">  [5, 6, 3, 2, 1],</span><br><span class="line">  [1, 2, 0, 1, 5],</span><br><span class="line">  [4, 1, 0, 1, 7],</span><br><span class="line">  [1, 0, 3, 0, 5]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sumRegion(2, 1, 4, 3) -&gt; 8</span><br><span class="line">sumRegion(1, 1, 2, 2) -&gt; 11</span><br><span class="line">sumRegion(1, 2, 2, 4) -&gt; 12</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li><p>你可以假设矩阵不可变。</p>
</li>
<li><p>会多次调用 <em>sumRegion</em> 方法<em>。</em></p>
</li>
<li><p>你可以假设 <em>row</em>1 ≤ <em>row</em>2 且 <em>col</em>1 ≤ <em>col</em>2。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> r=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> c=matrix[<span class="number">0</span>].length;</span><br><span class="line">        dp=<span class="keyword">new</span> <span class="keyword">int</span>[r+<span class="number">1</span>][c+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j+<span class="number">1</span>]+dp[i+<span class="number">1</span>][j]+matrix[i][j]-dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[row2+<span class="number">1</span>][col2+<span class="number">1</span>]-dp[row1][col2+<span class="number">1</span>]-dp[row2+<span class="number">1</span>][col1]+dp[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">动态规划之最长公共子序列问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-19 09:16:34 / Modified: 09:37:13" itemprop="dateCreated datePublished" datetime="2020-04-19T09:16:34-05:00">2020-04-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></h2><p>难度中等101收藏分享切换为英文关注反馈</p>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长公共子序列。</p>
<p>一个字符串的 <em>子序列</em> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0。</span><br></pre></td></tr></table></figure>



<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= text1.length &lt;= 1000</code></li>
<li><code>1 &lt;= text2.length &lt;= 1000</code></li>
<li>输入的字符串只含有小写英文字符。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c1=text1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] c2=text2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[c1.length+<span class="number">1</span>][c2.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=c1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=c2.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c1[i-<span class="number">1</span>]==c2[j-<span class="number">1</span>])</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=Math.max(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[c1.length][c2.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jackson"
      src="/uploads/hacker.png">
  <p class="site-author-name" itemprop="name">Jackson</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jackson</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
