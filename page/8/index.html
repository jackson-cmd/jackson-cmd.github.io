<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jackson Blog">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="Jackson Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jackson">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jackson Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jackson Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/25/linux%E5%9F%BA%E7%A1%802/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/25/linux%E5%9F%BA%E7%A1%802/" class="post-title-link" itemprop="url">linux基础（19-41集）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-25 16:41:07" itemprop="dateCreated datePublished" datetime="2020-04-25T16:41:07-05:00">2020-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-26 00:02:49" itemprop="dateModified" datetime="2020-04-26T00:02:49-05:00">2020-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="linux-100集"><a href="#linux-100集" class="headerlink" title="linux 100集"></a>linux 100集</h1><h2 id="P19-22-文件和目录（ls常用选项）"><a href="#P19-22-文件和目录（ls常用选项）" class="headerlink" title="P19-22 文件和目录（ls常用选项）"></a>P19-22 文件和目录（ls常用选项）</h2><p>Linux中“./”在系统文件中表示绝对路径的意思。</p>
<p>linux系统中，所有的文件与目录都是由根目录/开始，不是以/开头的就是相对路径；</p>
<p>1、“.”表示当前目录，也可以用“./”表示；</p>
<p>2、“..”表示上一级目录，也可以用“../”表示；</p>
<p>3、“~” 代表用户自己的宿主目录；</p>
<p>4、“/”处于Linux文件系统树形结构的最顶端，我们称它为Linux文件系统的root，它是Linux文件系统的入口。</p>
<p>所有的目录、文件、设备都在/之下，它是Linux文件系统最顶层的唯一的目录；</p>
<p>自动不全：tab键</p>
<p>查看曾经用过命令：上下光标键，退出选择用ctrl+c</p>
<p>ls命令扩展：</p>
<p>最常用，.开头的文件为隐藏文件，需要-a才可以打开， ls -a才可以显示出来</p>
<p>.表示当前目录 </p>
<p>..表示上级目录， cd ..返回上一个目录</p>
<p>ls -l以列表方式显示文件详细信息</p>
<p>ls -h配合-l以人性化方式显示文件大小（文件大小用k，m表示，而不是byte，人易读）：ls -l -h或者 ls -lh</p>
<p>所以可以ls -alh</p>
<p>drw… 这里d是目录</p>
<h2 id="P23-文件和目录（ls常用通配符）"><a href="#P23-文件和目录（ls常用通配符）" class="headerlink" title="P23 文件和目录（ls常用通配符）"></a>P23 文件和目录（ls常用通配符）</h2><p>*：任意个数字符(0或多个)</p>
<p>？：任意一个字符，至少一个（只一个，不可为0）</p>
<p>[]:可匹配字符组任意一个</p>
<p>ls功能： 列出非目录的文件项，然后是每一个目录中的“可显示”文件（可理解为ls命令将本目录向下展开两级）</p>
<p>ls用法：ls  [参数]  [目录名]</p>
<p>​    （如过要显示当前目录的文件可不加目录名）</p>
<p>ls常用参数</p>
<p>   -a 显示所有文件，包含隐藏文件</p>
<p>   -A 显示所有文件，包含隐藏文件，但不包含.及..</p>
<p> -l  显示为long format（长格式），列出文件的类型、权限、链接数、owner、group、大 小，时间，名字</p>
<p>   -R  </p>
<p>   -d 不展开目录，只显示目录自身，一般与-l配合使用以显示目录自身的属性信息（只显示当前目录的内容）</p>
<p>   -1 数字1，成列显示内容</p>
<p>   -S 以文件大小排序显示，默认从大到小 -r后，从小到大</p>
<p>   -U 按存放顺序排序显示</p>
<p>   -X 按扩展名的首字母来排序</p>
<p>   -t  按mtime排序（先显示时间最近的）</p>
<p>   -ul  按atime排序（先显示时间最近的）</p>
<p>   -ct  按ctime排序（先显示时间最近的）</p>
<p>​     补充：</p>
<p>关于时间戳：</p>
<p>​     atime  访问时间</p>
<p>​     mtime 数据修改时间 （写入，修改数据mtime改变，mtime改变ctime必改变）</p>
<p>​     ctime  元数据修改时间 （修改权限的时候只有ctime改变）</p>
<p>​     可过“stat 文件路径”查看全部时间戳</p>
<p><strong>扩展**</strong>: 如何通过ls只显示指定格式的文件**</p>
<p>首先我们要了解什么是文件名通配符</p>
<p>Shell提供了一套完整的字符串模式匹配规则，或者称之为元字符，当s h e l l遇到上述字符时，就会把它们当作特殊字符，而不是文件名中的普通字符，这样用户就可以用它们来匹配相应的文件名，我理解这可以称为通配符。</p>
<p>常用通配符：</p>
<p>* 匹配0或多个任意字符</p>
<p>? 匹配任意1个字符</p>
<p>[  ]  当中括号内为几个确定字符时，表示匹配括号内任意一个字符，当中括号内为一个范围时表示匹配这个范围中的任意一个字符（中括号表示的是一个范围，匹配的是一个字符）</p>
<p>例：</p>
<p> [ab46e] 表示是a,b,4,6,e中的任意一个字符</p>
<p> [a-z] 表示aAbBcC……z（Linux中的默认编码顺序是一个小写字母一个大写字母即aAbBcC…..Z）</p>
<p>​     [A-Z] 表示AbBcC……Z</p>
<p>​    [a- Z] 表示所有大小写字母</p>
<p>​    [^ae] 表示即不是a也不是e的其他任意单一字符</p>
<p>[:lower:] 表示一个小写字母 </p>
<p>[:upper:] 表示一个大写字母</p>
<p>[:alpha:] 表示一个大小写字母 等同于[a-Z]</p>
<p>[:digit:]  表示任意一个数字 等同于[0-9]</p>
<p>[:alnum:] 表示任意一个字母或数字 等于[a-Z0-9]或[[:digit:][:alpha:]]</p>
<p>[:blank:]：一个水平空白字符</p>
<p>[:space:]：一个水平或垂直空白字符（文件名不可能包含回车，故此处使用与[:blank:]：效果相同）</p>
<p>通过ls命令和通配符查找指定格式的文件：</p>
<p> 格式：ls  [参数]  [目录名][通配符]</p>
<p>以下是一些例子：</p>
<p>\1. 查找/usr/share/man 目录下以m开头且以一个数字加x结尾的文件</p>
<p>命令：ls  -d  /usr/share/man/m*[0-9]x</p>
<p>运行结果：</p>
<p> <img src="https://images2018.cnblogs.com/blog/1440488/201807/1440488-20180714174106974-1962045890.png" alt="img"></p>
<p>解释：-d 只展开一级目录</p>
<p>   /usr/share/man/  目录路径</p>
<p> m*[0-9]x  m表示以m开头，[0-9]x表示以数字加x结尾,因为对文件的中间没</p>
<p>有加以限制所以用<em>代替中间部分，</em>表示任意个数的任意字符</p>
<p>\2. 查找root下的隐藏文件和目录</p>
<p>   命令： ls  -d  /root/.*</p>
<p>   运行结果：</p>
<p><img src="https://images2018.cnblogs.com/blog/1440488/201807/1440488-20180714174309686-515187362.png" alt="img"></p>
<p>解释：-d 只展开一级目录</p>
<p>   /root 目录路径</p>
<p>   因为Linux下以“.”开头的文件是隐藏文件，所以用“.”加上“*”来表示隐藏文件</p>
<p>\3. 查找/etc下所有以k开头，以一个小写字母结尾，且中间出现至少一位数字的文件</p>
<p>​    命令：ls  -d  /etc/k<em>[0-9]</em>[[:lower:]]</p>
<p>​    运行结果：</p>
<p> <img src="https://images2018.cnblogs.com/blog/1440488/201807/1440488-20180714174409329-147595255.png" alt="img"></p>
<p>解释：-d 只展开一级目录 </p>
<p>   /etc 目录路径</p>
<p>​    k表示以k开头，[0-9]表示一个数字，[[:lower:]]表示一个小写字母，因为[:lower:]表示为小写字母，也就是abcdefg…z，所以在[:lower:]外面加</p>
<p>   上[ ]以表示在这写子母中取任意一个，因为只规定了开头和结尾，对中间只要求至少出现一位数字，所以中间用*[0-9]*来表示</p>
<h2 id="P25-文件和目录（cd常用选项）"><a href="#P25-文件和目录（cd常用选项）" class="headerlink" title="P25 文件和目录（cd常用选项）"></a>P25 文件和目录（cd常用选项）</h2><p>cd </p>
<p>跳入test目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com]#cd testDir&#x2F;</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#ls</span><br><span class="line">file1  file2  file3</span><br></pre></td></tr></table></figure>

<p>跳至上层目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#cd ..</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com]#ls</span><br><span class="line">testDir</span><br></pre></td></tr></table></figure>

<p>跳至上上层目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#cd ..&#x2F;..&#x2F;</span><br><span class="line">[root@&#x2F;root]#ls</span><br></pre></td></tr></table></figure>

<p>跳入用户主目录: cd ~或者cd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#ls</span><br><span class="line">file1  file2  file3</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#cd ~&#x2F;</span><br><span class="line">[root@&#x2F;root]#pwd</span><br><span class="line">&#x2F;root</span><br></pre></td></tr></table></figure>

<p>使用绝对路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@&#x2F;root]#cd &#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#ls</span><br><span class="line">file1  file2  file3</span><br></pre></td></tr></table></figure>

<p>使用环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@&#x2F;root]#cd $TEST_PATH</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#ls</span><br><span class="line">file1  file2  file3</span><br></pre></td></tr></table></figure>

<p>跳入上次使用目录: cd -, 可以在最近两次工作目录间切换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@&#x2F;root]#pwd</span><br><span class="line">&#x2F;root</span><br><span class="line">[root@&#x2F;root]#cd -</span><br><span class="line">&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir</span><br><span class="line">[root@&#x2F;root&#x2F;linuxdaxue.com&#x2F;testDir]#</span><br></pre></td></tr></table></figure>

<h2 id="P26-文件和目录（相对路径绝对路径）"><a href="#P26-文件和目录（相对路径绝对路径）" class="headerlink" title="P26 文件和目录（相对路径绝对路径）"></a>P26 文件和目录（相对路径绝对路径）</h2><ul>
<li>绝对路径：路径的写法一定是由根目录 / 写起的，例如 /usr/local/mysql</li>
<li>相对路径：路径的写法不是由根目录 / 写起的，例如 首先用户进入到 /home，然后再进入到test，执行的命令为 “#cd /home,#cd test”。此时用户所在的路径为 /home/test。第一个cd命令后紧跟/home，前面有斜杠；而第二个cd命令后紧跟test，前面没有斜杠。<strong>这个test是相对于/home目录来讲的，所以称为相对路径</strong>。</li>
</ul>
<h2 id="P27-文件和目录（mkdir和touch）"><a href="#P27-文件和目录（mkdir和touch）" class="headerlink" title="P27 文件和目录（mkdir和touch）"></a>P27 文件和目录（mkdir和touch）</h2><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p>
<p>ls -l 可以显示档案的时间记录。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数说明</strong>：</li>
<li>a 改变档案的读取时间记录。</li>
<li>m 改变档案的修改时间记录。</li>
<li>c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。</li>
<li>f 不使用，是为了与其他 unix 系统的相容性而保留。</li>
<li>r 使用参考档的时间记录，与 –file 的效果一样。</li>
<li>d 设定时间与日期，可以使用各种不同的格式。</li>
<li>t 设定档案的时间记录，格式与 date 指令相同。</li>
<li>–no-create 不会建立新档案。</li>
<li>–help 列出指令格式。</li>
<li>–version 列出版本讯息。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用指令”touch”修改文件”testfile”的时间属性为当前系统时间，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch testfile                #修改文件的时间属性</span><br></pre></td></tr></table></figure>

<p>首先，使用ls命令查看testfile文件的属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#原来文件的修改时间为16:09  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile</span><br></pre></td></tr></table></figure>

<p>执行指令”touch”修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch testfile                #修改文件时间属性为当前系统时间  </span><br><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#修改后文件的时间属性为当前系统时间  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile</span><br></pre></td></tr></table></figure>

<p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch file            #创建一个名为“file”的新的空白文件</span><br></pre></td></tr></table></figure>

<p>Linux mkdir命令用于建立名称为 dirName 之子目录。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-p] dirName</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-p 确保目录名称存在，不存在的就建一个。</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>在工作目录下，建立一个名为 AAA 的子目录 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir AAA</span><br></pre></td></tr></table></figure>

<p>在工作目录下的 BBB 目录中，建立一个名为 Test 的子目录。 若 BBB 目录原本不存在，则建立一个。（注：本例若不加 -p，且原本 BBB目录不存在，则产生错误。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p BBB&#x2F;Test</span><br></pre></td></tr></table></figure>

<p>linux中文件目录不可以重名</p>
<h2 id="P28-文件和目录（rm）"><a href="#P28-文件和目录（rm）" class="headerlink" title="P28 文件和目录（rm）"></a>P28 文件和目录（rm）</h2><p>rm删除的不能恢复。Linux rm命令用于删除一个文件或者目录。</p>
<p>rm也可以使用通配符。</p>
<p>格式化电脑：rm -rf *</p>
<p>所有数据全部删除。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [options] name...</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-i 删除前逐一询问确认。</li>
<li>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。（没有此文件也可以删除，不会报错）</li>
<li>-r 将目录及以下之档案亦逐一删除。（不加无法删目录）（用递归方法）</li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>删除文件可以直接使用rm命令，若删除目录则必须配合选项”-r”，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># rm  test.txt </span><br><span class="line">rm：是否删除 一般文件 &quot;test.txt&quot;? y  </span><br><span class="line"># rm  homework  </span><br><span class="line">rm: 无法删除目录&quot;homework&quot;: 是一个目录  </span><br><span class="line"># rm  -r  homework  </span><br><span class="line">rm：是否删除 目录 &quot;homework&quot;? y</span><br></pre></td></tr></table></figure>

<p>删除当前目录下的所有文件及目录，命令行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm  -r  *</span><br></pre></td></tr></table></figure>

<p>文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。</p>
<h2 id="P29-35拷贝和移动文件"><a href="#P29-35拷贝和移动文件" class="headerlink" title="P29-35拷贝和移动文件"></a>P29-35拷贝和移动文件</h2><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>Linux tree命令用于以树状图列出目录的内容。</p>
<p>需要此指令安装：sudo snap install tree</p>
<p>tree <del>，家目录（</del>），全部显示出来。</p>
<p>执行tree指令，它会列出指定目录下的所有文件，包括子目录里的文件。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree [-aACdDfFgilnNpqstux][-I &lt;范本样式&gt;][-P &lt;范本样式&gt;][目录...]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-a 显示所有文件和目录。</li>
<li>-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。</li>
<li>-C 在文件和目录清单加上色彩，便于区分各种类型。</li>
<li>-d 显示目录名称而非内容。（常用）</li>
<li>-D 列出文件或目录的更改时间。</li>
<li>-f 在每个文件或目录之前，显示完整的相对路径名称。</li>
<li>-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”/“,”=”,”@”,”|”号。</li>
<li>-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</li>
<li>-i 不以阶梯状列出文件或目录名称。</li>
<li>-L level 限制目录显示层级。</li>
<li>-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</li>
<li>-n 不在文件和目录清单加上色彩。</li>
<li>-N 直接列出文件和目录名称，包括控制字符。</li>
<li>-p 列出权限标示。</li>
<li>-P&lt;范本样式&gt; 只显示符合范本样式的文件或目录名称。</li>
<li>-q 用”?”号取代控制字符，列出文件和目录名称。</li>
<li>-s 列出文件或目录大小。</li>
<li>-t 用文件和目录的更改时间排序。</li>
<li>-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</li>
<li>-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</li>
</ul>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [options] source dest</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [options] source... directory</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</li>
<li>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</li>
<li>-f：覆盖已经存在的目标文件而不给出提示。</li>
<li>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。（常用）</li>
<li>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li>
<li>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。（常用）</li>
<li>-l：不复制文件，只是生成链接文件。</li>
</ul>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>使用指令”cp”将当前目录”test/“下的所有文件复制到新目录”newtest”下，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp –r test&#x2F; newtest</span><br></pre></td></tr></table></figure>

<p>注意：用户使用该指令复制目录时，必须使用参数”-r”或者”-R”。</p>
<p>例 cp ~/Desktop/a.txt .       当前文件夹下</p>
<p>Linux mv 命令用来为文件或目录改名、或将文件或目录移入其它位置。</p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv [options] source dest</span><br><span class="line">mv [options] source... directory</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;（常用）</li>
<li>-f: 在 mv 操作要覆盖某已有的目标文件时不给任何指示;</li>
</ul>
<p>mv参数设置与运行结果</p>
<table>
<thead>
<tr>
<th align="left">命令格式</th>
<th align="left">运行结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mv 文件名 文件名</td>
<td align="left">将源文件名改为目标文件名</td>
</tr>
<tr>
<td align="left">mv 文件名 目录名</td>
<td align="left">将文件移动到目标目录</td>
</tr>
<tr>
<td align="left">mv 目录名 目录名</td>
<td align="left">目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名</td>
</tr>
<tr>
<td align="left">mv 目录名 文件名</td>
<td align="left">出错</td>
</tr>
</tbody></table>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>将文件 aaa 更名为 bbb :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv aaa bbb</span><br></pre></td></tr></table></figure>

<p>将info目录放入logs目录中。注意，如果logs目录不存在，则该命令将info改名为logs。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv info&#x2F; logs</span><br></pre></td></tr></table></figure>

<p>再如将/usr/student下的所有文件和目录移到当前目录下，命令行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv &#x2F;usr&#x2F;student&#x2F;*  .</span><br></pre></td></tr></table></figure>



<h2 id="P36-39查看文件内容命令"><a href="#P36-39查看文件内容命令" class="headerlink" title="P36-39查看文件内容命令"></a>P36-39查看文件内容命令</h2><p>cat， more， grep</p>
<h3 id="cat："><a href="#cat：" class="headerlink" title="cat："></a>cat：</h3><h4 id="concatenate-查看文件，创建文件，文件合并，追加文件内容等功能"><a href="#concatenate-查看文件，创建文件，文件合并，追加文件内容等功能" class="headerlink" title="concatenate: 查看文件，创建文件，文件合并，追加文件内容等功能"></a>concatenate: 查看文件，创建文件，文件合并，追加文件内容等功能</h4><p>cat 命令用于连接文件并打印到标准输出设备上。（适合内容少的文本内容）</p>
<h3 id="使用权限"><a href="#使用权限" class="headerlink" title="使用权限"></a>使用权限</h3><p>所有使用者</p>
<h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [-AbeEnstTuv] [--help] [--version] fileName</span><br></pre></td></tr></table></figure>

<h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><p><strong>-n 或 –number</strong>：由 1 开始对所有输出的行数编号。（常用）</p>
<p><strong>-b 或 –number-nonblank</strong>：和 -n 相似，只不过对于空白行不编号。（常用）</p>
<p><strong>-s 或 –squeeze-blank</strong>：当遇到有连续两行以上的空白行，就代换为一行的空白行。</p>
<p><strong>-v 或 –show-nonprinting</strong>：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。</p>
<p><strong>-E 或 –show-ends</strong> : 在每行结束处显示 $。</p>
<p><strong>-T 或 –show-tabs</strong>: 将 TAB 字符显示为 ^I。</p>
<p><strong>-A, –show-all</strong>：等价于 -vET。</p>
<p><strong>-e：</strong>等价于”-vE”选项；</p>
<p><strong>-t：</strong>等价于”-vT”选项；</p>
<h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure>

<p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure>

<p>清空 /etc/test.txt 文档内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;dev&#x2F;null &gt; &#x2F;etc&#x2F;test.txt</span><br></pre></td></tr></table></figure>

<p>cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;dev&#x2F;fd0 &gt; OUTFILE</span><br></pre></td></tr></table></figure>

<p>相反的，如果想把 image file 写到软盘，输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat IMG_FILE &gt; &#x2F;dev&#x2F;fd0</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：</p>
<ul>
<li><p>\1. OUTFILE 指输出的镜像文件名。</p>
</li>
<li><p>\2. IMG_FILE 指镜像文件。</p>
</li>
<li><p>\3. 若从镜像文件写回 device 时，device 容量需与相当。</p>
</li>
<li><p>\4. 通常用制作开机磁片。</p>
</li>
</ul>
<h3 id="more："><a href="#more：" class="headerlink" title="more："></a>more：</h3><p>Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。Enter键：一次滚动手册页的一行，f前滚一页，q退出，/word搜索word字符串</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [-dlfpcsu] [-num] [+&#x2F;pattern] [+linenum] [fileNames..]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-num 一次显示的行数</li>
<li>-d 提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声</li>
<li>-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能</li>
<li>-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）</li>
<li>-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容</li>
<li>-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料</li>
<li>-s 当遇到有连续两行以上的空白行，就代换为一行的空白行</li>
<li>-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）</li>
<li>+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示</li>
<li>+num 从第 num 行开始显示</li>
<li>fileNames 欲显示内容的文档，可为复数个数</li>
</ul>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>逐页显示 testfile 文档内容，如有连续两行以上空白行则以一行空白行显示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more -s testfile</span><br></pre></td></tr></table></figure>

<p>从第 20 行开始显示 testfile 之文档内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more +20 testfile</span><br></pre></td></tr></table></figure>

<h3 id="常用操作命令"><a href="#常用操作命令" class="headerlink" title="常用操作命令"></a>常用操作命令</h3><ul>
<li>Enter 向下n行，需要定义。默认为1行</li>
<li>Ctrl+F 向下滚动一屏</li>
<li>空格键 向下滚动一屏</li>
<li>Ctrl+B 返回上一屏</li>
<li>= 输出当前行的行号</li>
<li>：f 输出文件名和当前行的行号</li>
<li>V 调用vi编辑器</li>
<li>!命令 调用Shell，并执行命令 </li>
<li>q 退出more</li>
</ul>
<h3 id="grep：文本搜索工具"><a href="#grep：文本搜索工具" class="headerlink" title="grep：文本搜索工具"></a>grep：文本搜索工具</h3><p>Linux grep 命令用于查找文件里符合条件的字符串。</p>
<p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p>
<h3 id="常用2种模式查找："><a href="#常用2种模式查找：" class="headerlink" title="常用2种模式查找："></a>常用2种模式查找：</h3><p>^a: 行首，以a开头的行</p>
<p>ke$：行尾，以ke结尾的行</p>
<p> 例：gref ^f a.txt</p>
<h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><strong>-a 或 –text</strong> : 不要忽略二进制的数据。 </li>
<li><strong>-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt;</strong> : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。 </li>
<li><strong>-b 或 –byte-offset</strong> : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。 </li>
<li><strong>-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前的内容。 </li>
<li><strong>-c 或 –count</strong> : 计算符合样式的列数。 </li>
<li><strong>-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前后的内容。 </li>
<li><strong>-d &lt;动作&gt; 或 –directories=&lt;动作&gt;</strong> : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li>
<li><strong>-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt;</strong> : 指定字符串做为查找文件内容的样式。 </li>
<li><strong>-E 或 –extended-regexp</strong> : 将样式为延伸的正则表达式来使用。 </li>
<li><strong>-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt;</strong> : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 </li>
<li><strong>-F 或 –fixed-regexp</strong> : 将样式视为固定字符串的列表。 </li>
<li><strong>-G 或 –basic-regexp</strong> : 将样式视为普通的表示法来使用。 </li>
<li><strong>-h 或 –no-filename</strong> : 在显示符合样式的那一行之前，不标示该行所属的文件名称。 </li>
<li><strong>-H 或 –with-filename</strong> : 在显示符合样式的那一行之前，表示该行所属的文件名称。 </li>
<li><strong>-i 或 –ignore-case</strong> : 忽略字符大小写的差别。 （常用）</li>
<li><strong>-l 或 –file-with-matches</strong> : 列出文件内容符合指定的样式的文件名称。 </li>
<li><strong>-L 或 –files-without-match</strong> : 列出文件内容不符合指定的样式的文件名称。 </li>
<li><strong>-n 或 –line-number</strong> : 在显示符合样式的那一行之前，标示出该行的列数编号。 （显示匹配行及行号，常用）</li>
<li><strong>-o 或 –only-matching</strong> : 只显示匹配PATTERN 部分。 </li>
<li><strong>-q 或 –quiet或–silent</strong> : 不显示任何信息。 </li>
<li><strong>-r 或 –recursive</strong> : 此参数的效果和指定”-d recurse”参数相同。 </li>
<li><strong>-s 或 –no-messages</strong> : 不显示错误信息。 </li>
<li><strong>-v 或 –revert-match</strong> : 显示不包含匹配文本的所有行。 （求反，常用）</li>
<li><strong>-V 或 –version</strong> : 显示版本信息。 </li>
<li><strong>-w 或 –word-regexp</strong> : 只显示全字符合的列。 </li>
<li><strong>-x –line-regexp</strong> : 只显示全列符合的列。 </li>
<li><strong>-y</strong> : 此参数的效果和指定”-i”参数相同。</li>
</ul>
<p><a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener"><img src="https://www.runoob.com/images/up.gif" alt="Linux 命令大全"> Linux 命令大全</a></p>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>1、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep test *file</span><br></pre></td></tr></table></figure>

<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep test test* #查找前缀有“test”的文件包含“test”字符串的文件  </span><br><span class="line">testfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行  </span><br><span class="line">testfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行  </span><br><span class="line">testfile_2:Linux test #列出testfile_2 文件中包含test字符的行</span><br></pre></td></tr></table></figure>

<p>2、以递归的方式查找符合条件的文件。例如，查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串”update”的文件，并打印出该字符串所在行的内容，使用的命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r update &#x2F;etc&#x2F;acpi</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r update &#x2F;etc&#x2F;acpi #以递归的方式查找“etc&#x2F;acpi”  </span><br><span class="line">#下包含“update”的文件  </span><br><span class="line">&#x2F;etc&#x2F;acpi&#x2F;ac.d&#x2F;85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.)  </span><br><span class="line">Rather than  </span><br><span class="line">&#x2F;etc&#x2F;acpi&#x2F;resume.d&#x2F;85-anacron.sh:# (Things like the slocate updatedb cause a lot of  </span><br><span class="line">IO.) Rather than  </span><br><span class="line">&#x2F;etc&#x2F;acpi&#x2F;events&#x2F;thinkpad-cmos:action&#x3D;&#x2F;usr&#x2F;sbin&#x2F;thinkpad-keys--update</span><br></pre></td></tr></table></figure>

<p>3、反向查找。前面各个例子是查找并打印出符合条件的行，通过”-v”参数可以打印出不符合条件行的内容。</p>
<p>查找文件名中包含 test 的文件中不包含test 的行，此时，使用的命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v test *test*</span><br></pre></td></tr></table></figure>

<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ grep-v test* #查找文件名中包含test 的文件中不包含test 的行  </span><br><span class="line">testfile1:helLinux!  </span><br><span class="line">testfile1:Linis a free Unix-type operating system.  </span><br><span class="line">testfile1:Lin  </span><br><span class="line">testfile_1:HELLO LINUX!  </span><br><span class="line">testfile_1:LINUX IS A FREE UNIX-TYPE OPTERATING SYSTEM.  </span><br><span class="line">testfile_1:THIS IS A LINUX TESTFILE!  </span><br><span class="line">testfile_2:HELLO LINUX!  </span><br><span class="line">testfile_2:Linux is a free unix-type opterating system.</span><br></pre></td></tr></table></figure>

<h2 id="P40-41-echo"><a href="#P40-41-echo" class="headerlink" title="P40-41 echo"></a>P40-41 echo</h2><h3 id="用于字符串的输出"><a href="#用于字符串的输出" class="headerlink" title="用于字符串的输出"></a>用于字符串的输出</h3><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul>
<li>echo string</li>
</ul>
<h3 id="使用echo实现更复杂的输出格式控制"><a href="#使用echo实现更复杂的输出格式控制" class="headerlink" title="使用echo实现更复杂的输出格式控制"></a>使用echo实现更复杂的输出格式控制</h3><h3 id="1-显示普通字符串"><a href="#1-显示普通字符串" class="headerlink" title="1.显示普通字符串:"></a>1.显示普通字符串:</h3><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;It is a test&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这里的双引号完全可以省略，以下命令与上面实例效果一致：</span><br><span class="line"></span><br><span class="line">echo It is a test</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<h3 id="2-显示转义字符"><a href="#2-显示转义字符" class="headerlink" title="2.显示转义字符"></a>2.显示转义字符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;\&quot;It is a test\&quot;&quot;</span><br><span class="line">结果将是:</span><br><span class="line">&quot;It is a test&quot;</span><br><span class="line">同样，双引号也可以省略</span><br></pre></td></tr></table></figure>



<h3 id="3-显示变量"><a href="#3-显示变量" class="headerlink" title="3.显示变量"></a>3.显示变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</span><br><span class="line"></span><br><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">read name </span><br><span class="line">echo &quot;$name It is a test&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:</span><br><span class="line"></span><br><span class="line">[root@www ~]# sh test.sh</span><br><span class="line">OK                     #标准输入</span><br><span class="line">OK It is a test        #输出</span><br></pre></td></tr></table></figure>



<h3 id="4-显示换行"><a href="#4-显示换行" class="headerlink" title="4.显示换行"></a>4.显示换行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;OK! \n&quot; # -e 开启转义</span><br><span class="line">echo &quot;It it a test&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">OK!</span><br><span class="line"></span><br><span class="line">It it a test</span><br></pre></td></tr></table></figure>



<h3 id="5-显示不换行"><a href="#5-显示不换行" class="headerlink" title="5.显示不换行"></a>5.显示不换行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行</span><br><span class="line">echo &quot;It is a test&quot;</span><br><span class="line">输出结果：OK! It is a test</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<ul>
<li>转义</li>
</ul>
<p>　　　　\a 发出警告声； </p>
<p>　　　　\b 删除前一个字符； </p>
<p>　　　　\c 最后不加上换行符号； </p>
<p>　　　　\f 换行但光标仍旧停留在原来的位置； </p>
<p>　　　　\n 换行且光标移至行首； </p>
<p>　　　　\r 光标移至行首，但不换行； </p>
<p>　　　　\t 插入tab； </p>
<p>　　　　\v 与\f相同； </p>
<p>　　　　\ 插入\字符； </p>
<p>　　　　\nnn 插入nnn（八进制）所代表的ASCII字符；</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="6-显示结果定向至文件"><a href="#6-显示结果定向至文件" class="headerlink" title="6.显示结果定向至文件"></a>6.显示结果定向至文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;It is a test&quot; &gt; myfile</span><br></pre></td></tr></table></figure>



<h3 id="7-原样输出字符串，不进行转义或取变量-用单引号"><a href="#7-原样输出字符串，不进行转义或取变量-用单引号" class="headerlink" title="7.原样输出字符串，不进行转义或取变量(用单引号)"></a>7.原样输出字符串，不进行转义或取变量(用单引号)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &#39;$name\&quot;&#39;</span><br><span class="line">输出结果：</span><br><span class="line">$name\&quot;</span><br></pre></td></tr></table></figure>



<h3 id="8-显示命令执行结果"><a href="#8-显示命令执行结果" class="headerlink" title="8.显示命令执行结果"></a>8.显示命令执行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  echo &#96;date&#96;</span><br><span class="line">结果将显示当前日期</span><br><span class="line"></span><br><span class="line">Thu Jul 24 10:08:46 CST 2014</span><br></pre></td></tr></table></figure>

<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h1 id="Shell-输入-输出重定向"><a href="#Shell-输入-输出重定向" class="headerlink" title="Shell 输入/输出重定向"></a>Shell 输入/输出重定向</h1><p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p>
<p>重定向命令列表如下：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">command &gt; file</td>
<td align="left">将输出重定向到 file。</td>
</tr>
<tr>
<td align="left">command &lt; file</td>
<td align="left">将输入重定向到 file。</td>
</tr>
<tr>
<td align="left">command &gt;&gt; file</td>
<td align="left">将输出以追加的方式重定向到 file。</td>
</tr>
<tr>
<td align="left">n &gt; file</td>
<td align="left">将文件描述符为 n 的文件重定向到 file。（会覆盖）</td>
</tr>
<tr>
<td align="left">n &gt;&gt; file</td>
<td align="left">将文件描述符为 n 的文件以追加的方式重定向到 file。（不会覆盖）</td>
</tr>
<tr>
<td align="left">n &gt;&amp; m</td>
<td align="left">将输出文件 m 和 n 合并。</td>
</tr>
<tr>
<td align="left">n &lt;&amp; m</td>
<td align="left">将输入文件 m 和 n 合并。</td>
</tr>
<tr>
<td align="left">&lt;&lt; tag</td>
<td align="left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
</blockquote>
<hr>
<h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &gt; file1</span><br></pre></td></tr></table></figure>

<p>上面这个命令执行command1然后将输出的内容存入file1。</p>
<p>注意任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用&gt;&gt;操作符。</p>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>执行下面的 who 命令，它将命令的完整的输出重定向在用户文件中(users):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ who &gt; users</span><br></pre></td></tr></table></figure>

<p>执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。</p>
<p>你可以使用 cat 命令查看文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat users</span><br><span class="line">_mbsetupuser console  Oct 31 17:35 </span><br><span class="line">tianqixin    console  Oct 31 17:35 </span><br><span class="line">tianqixin    ttys000  Dec  1 11:33</span><br></pre></td></tr></table></figure>

<p>输出重定向会覆盖文件内容，请看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;菜鸟教程：www.runoob.com&quot; &gt; users</span><br><span class="line">$ cat users</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;菜鸟教程：www.runoob.com&quot; &gt;&gt; users</span><br><span class="line">$ cat users</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &lt; file1</span><br></pre></td></tr></table></figure>

<p>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</p>
<p>注意：输出重定向是大于号(&gt;)，输入重定向是小于号(&lt;)。</p>
<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>接着以上实例，我们需要统计 users 文件的行数,执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wc -l users</span><br><span class="line">       2 users</span><br></pre></td></tr></table></figure>

<p>也可以将输入重定向到 users 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  wc -l &lt; users</span><br><span class="line">       2</span><br></pre></td></tr></table></figure>

<p>注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &lt; infile &gt; outfile</span><br></pre></td></tr></table></figure>

<p>同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。</p>
<h3 id="重定向深入讲解"><a href="#重定向深入讲解" class="headerlink" title="重定向深入讲解"></a>重定向深入讲解</h3><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>
<ul>
<li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li>
<li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li>
<li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li>
</ul>
<p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
<p>如果希望 stderr 重定向到 file，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ command 2 &gt; file</span><br></pre></td></tr></table></figure>

<p>如果希望 stderr 追加到 file 文件末尾，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ command 2 &gt;&gt; file</span><br></pre></td></tr></table></figure>

<p><strong>2</strong> 表示标准错误文件(stderr)。</p>
<p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ command &gt; file 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">$ command &gt;&gt; file 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>如果希望对 stdin 和 stdout 都重定向，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ command &lt; file1 &gt;file2</span><br></pre></td></tr></table></figure>

<p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。 </p>
<hr>
<h2 id="Here-Document"><a href="#Here-Document" class="headerlink" title="Here Document"></a>Here Document</h2><p>Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。 </p>
<p>它的基本的形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command &lt;&lt; delimiter</span><br><span class="line">    document</span><br><span class="line">delimiter</span><br></pre></td></tr></table></figure>

<p>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p>
<blockquote>
<p>注意：</p>
<ul>
<li>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</li>
<li>开始的delimiter前后的空格会被忽略掉。</li>
</ul>
</blockquote>
<h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><p>在命令行中通过 wc -l 命令计算 Here Document 的行数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ wc -l &lt;&lt; EOF</span><br><span class="line">    欢迎来到</span><br><span class="line">    菜鸟教程</span><br><span class="line">    www.runoob.com</span><br><span class="line">EOF</span><br><span class="line">3          # 输出结果为 3 行</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>我们也可以将 Here Document 用在脚本中，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF</span><br><span class="line">欢迎来到</span><br><span class="line">菜鸟教程</span><br><span class="line">www.runoob.com</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>执行以上脚本，输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">欢迎来到</span><br><span class="line">菜鸟教程</span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="dev-null-文件"><a href="#dev-null-文件" class="headerlink" title="/dev/null 文件"></a>/dev/null 文件</h2><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ command &gt; &#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>

<p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。</p>
<p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ command &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
</blockquote>
<h2 id="P41"><a href="#P41" class="headerlink" title="P41"></a>P41</h2><p>echo和重定向一起用，例：echo hello &gt; a， 想hello输入a文件中</p>
<p>例 ls -lh &gt; a,   ls结果放入a内。&gt;&gt; 是追加。&gt;是覆盖</p>
<h3 id="管道："><a href="#管道：" class="headerlink" title="管道："></a>管道：</h3><p>Shell 还有一种功能，就是可以将两个或者多个命令（程序或者进程）连接到一起，把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了<strong>管道（pipe）</strong>。</p>
<p>Linux 管道使用竖线<code>|</code>连接多个命令，这被称为管道符。Linux 管道的具体语法格式如下：</p>
<p>command1 | command2<br>command1 | command2 [ | commandN… ]</p>
<p>当在两个命令之间设置管道时，管道符<code>|</code>左边命令的输出就变成了右边命令的输入。只要第一个命令向标准输出写入，而第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道。大部分的 Linux 命令都可以用来形成管道。</p>
<blockquote>
<p>这里需要注意，command1 必须有正确输出，而 command2 必须可以处理 command2 的输出结果；而且 command2 只能处理 command1 的正确输出结果，不能处理 command1 的错误信息。</p>
</blockquote>
<h2 id="为什么使用管道？"><a href="#为什么使用管道？" class="headerlink" title="为什么使用管道？"></a>为什么使用管道？</h2><p>我们先看下面一组命令，使用 mysqldump（一个数据库备份程序）来备份一个叫做 wiki 的数据库：</p>
<p>mysqldump -u root -p ‘123456’ wiki &gt; /tmp/wikidb.backup<br>gzip -9 /tmp/wikidb.backup<br>scp /tmp/wikidb.backup username@remote_ip:/backup/mysql/</p>
<p>上述这组命令主要做了如下任务：</p>
<ul>
<li>mysqldump 命令用于将名为 wike 的数据库备份到文件 /tmp/wikidb.backup；其中<code>-u</code>和<code>-p</code>选项分别指出数据库的用户名和密码。</li>
<li>gzip 命令用于压缩较大的数据库文件以节省磁盘空间；其中<code>-9</code>表示最慢的压缩速度最好的压缩效果。</li>
<li>scp 命令（secure copy，安全拷贝）用于将数据库备份文件复制到 IP 地址为 remote_ip 的备份服务器的 /backup/mysql/ 目录下。其中<code>username</code>是登录远程服务器的用户名，命令执行后需要输入密码。</li>
</ul>
<p>上述三个命令依次执行。然而，如果使用管道的话，你就可以将 mysqldump、gzip、ssh 命令相连接，这样就避免了创建临时文件 /tmp/wikidb.backup，而且可以同时执行这些命令并达到相同的效果。</p>
<p>使用管道后的命令如下所示：</p>
<p>mysqldump -u root -p ‘123456’ wiki | gzip -9 | ssh username@remote_ip “cat &gt; /backup/wikidb.gz”</p>
<p>这些使用了管道的命令有如下特点：</p>
<ul>
<li>命令的语法紧凑并且使用简单。</li>
<li>通过使用管道，将三个命令串联到一起就完成了远程 mysql 备份的复杂任务。</li>
<li>从管道输出的标准错误会混合到一起。</li>
</ul>
<p>上述命令的数据流如下图所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190416/1-1Z4161052294c.gif" alt="Linux Shell管道演示图"></p>
<h2 id="重定向和管道的区别"><a href="#重定向和管道的区别" class="headerlink" title="重定向和管道的区别"></a>重定向和管道的区别</h2><p>乍看起来，管道也有重定向的作用，它也改变了数据输入输出的方向，那么，管道和重定向之间到底有什么不同呢？</p>
<p>简单地说，重定向操作符&gt;将命令与文件连接起来，用文件来接收命令的输出；而管道符|将命令与命令连接起来，用第二个命令来接收第一个命令的输出。如下所示：</p>
<p>command &gt; file<br>command1 | command1</p>
<p>有些读者在学习管道时会尝试如下的命令，我们来看一下会发生什么：</p>
<p>command1 &gt; command2</p>
<p>答案是，有时尝试的结果将会很糟糕。这是一个实际的例子，一个 Linux 系统管理员以超级用户（root 用户）的身份执行了如下命令：</p>
<p>cd /usr/bin<br>ls &gt; less</p>
<p>第一条命令将当前目录切换到了大多数程序所存放的目录，第二条命令是告诉 Shell 用 ls 命令的输出重写文件 less。因为 /usr/bin 目录已经包含了名称为 less（less 程序）的文件，第二条命令用 ls 输出的文本重写了 less 程序，因此破坏了文件系统中的 less 程序。</p>
<p>这是使用重定向操作符错误重写文件的一个教训，所以在使用它时要谨慎。</p>
<h2 id="Linux管道实例"><a href="#Linux管道实例" class="headerlink" title="Linux管道实例"></a>Linux管道实例</h2><p>【实例1】将 ls 命令的输出发送到 grep 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ls | grep log.txt</span><br><span class="line">log.txt</span><br></pre></td></tr></table></figure>

<p>上述命令是查看文件 log.txt 是否存在于当前目录下。</p>
<p>我们可以在命令的后面使用选项，例如使用<code>-al</code>选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ls -al | grep log.txt</span><br><span class="line">-rw-rw-r--.  1 mozhiyan mozhiyan    0 4月  15 17:26 log.txt</span><br></pre></td></tr></table></figure>

<p>管道符<code>|</code>与两侧的命令之间也可以不存在空格，例如将上述命令写作<code>ls -al|grep log.txt</code>；然而我还是推荐在管道符<code>|</code>和两侧的命令之间使用空格，以增加代码的可读性。</p>
<p>我们也可以重定向管道的输出到一个文件，比如将上述管道命令的输出结果发送到文件 output.txt 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ls -al | grep log.txt &gt;output.txt</span><br><span class="line">[c.biancheng.net]$ cat output.txt</span><br><span class="line">-rw-rw-r--.  1 mozhiyan mozhiyan    0 4月  15 17:26 log.txt</span><br></pre></td></tr></table></figure>


<p>【实例2】使用管道将 cat 命令的输出作为 less 命令的输入，这样就可以将 cat 命令的输出每次按照一个屏幕的长度显示，这对于查看长度大于一个屏幕的文件内容很有帮助。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;var&#x2F;log&#x2F;message | less</span><br></pre></td></tr></table></figure>


<p>【实例3】查看指定程序的进程运行状态，并将输出重定向到文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ps aux | grep httpd &gt; &#x2F;tmp&#x2F;ps.output</span><br><span class="line">[c.biancheng.net]$ cat &#x2F;tem&#x2F;ps.output</span><br><span class="line">mozhiyan  4101     13776  0   10:11 pts&#x2F;3  00:00:00 grep httpd</span><br><span class="line">root      4578     1      0   Dec09 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19984    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19985    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19986    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19987    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19988    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19989    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19990    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br><span class="line">apache    19991    4578   0   Dec29 ?      00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd</span><br></pre></td></tr></table></figure>


<p>【实例4】显示按用户名排序后的当前登录系统的用户的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ who | sort</span><br><span class="line">mozhiyan :0           2019-04-16 12:55 (:0)</span><br><span class="line">mozhiyan pts&#x2F;0        2019-04-16 13:16 (:0)</span><br></pre></td></tr></table></figure>

<p>who 命令的输出将作为 sort 命令的输入，所以这两个命令通过管道连接后会显示按照用户名排序的已登录用户的信息。</p>
<p>【实例5】统计系统中当前登录的用户数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ who | wc -l</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h2 id="管道与输入重定向"><a href="#管道与输入重定向" class="headerlink" title="管道与输入重定向"></a>管道与输入重定向</h2><p>输入重定向操作符&lt;可以在管道中使用，以用来从文件中获取输入，其语法类似下面这样：</p>
<p>command1 &lt; input.txt | command2<br>command1 &lt; input.txt | command2 -option | command3</p>
<p>例如，使用 tr 命令从 os.txt 文件中获取输入，然后通过管道将输出发送给 sort 或 uniq 等命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ cat os.txt</span><br><span class="line">redhat</span><br><span class="line">suse</span><br><span class="line">centos</span><br><span class="line">ubuntu</span><br><span class="line">solaris</span><br><span class="line">hp-ux</span><br><span class="line">fedora</span><br><span class="line">centos</span><br><span class="line">redhat</span><br><span class="line">hp-ux</span><br><span class="line">[c.biancheng.net]$ tr a-z A-Z &lt;os.txt | sort</span><br><span class="line">CENTOS</span><br><span class="line">CENTOS</span><br><span class="line">FEDORA</span><br><span class="line">HP-UX</span><br><span class="line">HP-UX</span><br><span class="line">REDHAT</span><br><span class="line">REDHAT</span><br><span class="line">SOLARIS</span><br><span class="line">SUSE</span><br><span class="line">UBUNTU</span><br><span class="line">[c.biancheng.net]$ tr a-z A-Z &lt;os.txt | sort | uniq</span><br><span class="line">CENTOS</span><br><span class="line">FEDORA</span><br><span class="line">HP-UX</span><br><span class="line">REDHAT</span><br><span class="line">SOLARIS</span><br><span class="line">SUSE</span><br><span class="line">UBUNTU</span><br></pre></td></tr></table></figure>

<h2 id="管道与输出重定向"><a href="#管道与输出重定向" class="headerlink" title="管道与输出重定向"></a>管道与输出重定向</h2><p>你也可以使用重定向操作符&gt;或&gt;&gt;将管道中的最后一个命令的标准输出进行重定向，其语法如下所示：</p>
<p>command1 | command2 | … | commandN &gt; output.txt<br>command1 &lt; input.txt | command2 | … | commandN &gt; output.txt</p>
<p>【实例1】使用 mount 命令显示当前挂载的文件系统的信息，并使用 column 命令格式化列的输出，最后将输出结果保存到一个文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ mount | column -t &gt;mounted.txt</span><br><span class="line">[c.biancheng.net]$ cat mounted.txt</span><br><span class="line">proc         on  &#x2F;proc                  type  proc        (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">sysfs        on  &#x2F;sys                   type  sysfs       (rw,nosuid,nodev,noexec,relatime,seclabel)</span><br><span class="line">devtmpfs     on  &#x2F;dev                   type  devtmpfs    (rw,nosuid,seclabel,size&#x3D;496136k,nr_inodes&#x3D;124034,mode&#x3D;755)</span><br><span class="line">securityfs   on  &#x2F;sys&#x2F;kernel&#x2F;security   type  securityfs  (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">tmpfs        on  &#x2F;dev&#x2F;shm               type  tmpfs       (rw,nosuid,nodev,seclabel)</span><br><span class="line">devpts       on  &#x2F;dev&#x2F;pts               type  devpts      (rw,nosuid,noexec,relatime,seclabel,gid&#x3D;5,mode&#x3D;620,ptmxmode&#x3D;000)</span><br><span class="line">tmpfs        on  &#x2F;run                   type  tmpfs       (rw,nosuid,nodev,seclabel,mode&#x3D;755)</span><br><span class="line">tmpfs        on  &#x2F;sys&#x2F;fs&#x2F;cgroup         type  tmpfs       (rw,nosuid,nodev,noexec,seclabel,mode&#x3D;755)</span><br><span class="line">#####此处省略部分内容#####</span><br></pre></td></tr></table></figure>


<p>【实例2】使用 tr 命令将 os.txt 文件中的内容转化为大写，并使用 sort 命令将内容排序，使用 uniq 命令去除重复的行，最后将输出重定向到文件 ox.txt.new。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ cat os.txt</span><br><span class="line">redhat</span><br><span class="line">suse</span><br><span class="line">centos</span><br><span class="line">ubuntu</span><br><span class="line">solaris</span><br><span class="line">hp-ux</span><br><span class="line">fedora</span><br><span class="line">centos</span><br><span class="line">redhat</span><br><span class="line">hp-ux</span><br><span class="line">[c.biancheng.net]$ tr a-z A-Z &lt;os.txt | sort | uniq &gt;os.txt.new</span><br><span class="line">[c.biancheng.net]$ cat os.txt.new</span><br><span class="line">CENTOS</span><br><span class="line">FEDORA</span><br><span class="line">HP-UX</span><br><span class="line">REDHAT</span><br><span class="line">SOLARIS</span><br><span class="line">SUSE</span><br><span class="line">UBUNTU</span><br></pre></td></tr></table></figure>



<h3 id="管道"><a href="#管道" class="headerlink" title="管道 |"></a>管道 |</h3><p>linux允许讲一个命令的输出可以通过管道作为另一个命令的输入。（有用）</p>
<p>例： ls -lha ~| more: 用more查看</p>
<p>例： ls -lha ~| grep vi: 把match vi的输出，找出来。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/25/linux%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/25/linux%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">linux基础（1-18集）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-25 14:07:36 / Modified: 16:52:52" itemprop="dateCreated datePublished" datetime="2020-04-25T14:07:36-05:00">2020-04-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="linux-100集"><a href="#linux-100集" class="headerlink" title="linux 100集"></a>linux 100集</h1><h2 id="P3：操作系统作用"><a href="#P3：操作系统作用" class="headerlink" title="P3：操作系统作用"></a>P3：操作系统作用</h2><p>操作系统作用：1. 直接操作硬件 2把操作硬件的代码封装成一个个系统调用，供其他使用。</p>
<p>操作系统，与硬件交互。操作系统作用：操作系统位于底层硬件与用户之间，是两者沟通的桥梁。用户可以通过操作系统的用户界面，输入命令。操作系统则对命令进行解释，驱动硬件设备，实现用户要求。以现代标准而言，一个标准PC的操作系统应该提供以下的功能：</p>
<p>1、进程管理。又称处理器管理，其主要任务是对处理器的时间进行合理分配、对处理器的运行实施有效的管理。</p>
<p>2、存储器管理。由于多道程序共享内存资源，所以存储器管理的主要任务是对存储器进行分配、保护和扩充。</p>
<p>3、设备管理。根据确定的设备分配原则对设备进行分配，使设备与主机能够并行工作，为用户提供良好的设备使用界面。</p>
<p>4、文件管理。有效地管理文件的存储空间，合理地组织和管理文件系统，为文件访问和文件保护提供更有效的方法及手段。</p>
<p>5、用户接口。用户操作计算机的界面称为用户接口（或用户界面），通过用户接口，用户只需进行简单操作，就能实现复杂的应用处理。</p>
<p>例：听音乐，把硬盘中文件加载内存，然后声卡对音频数据解码，然后解码后数据给音响。这些都是操作系统做的。</p>
<h2 id="P4-10：历史简介"><a href="#P4-10：历史简介" class="headerlink" title="P4-10：历史简介"></a>P4-10：历史简介</h2><p>桌面操作系统：Windows（用户多，安全性较差，稳定性较差），Linux（应用软件少）， macOS（开发人员用）</p>
<p>服务器操作系统：Linux（安全，稳定，免费，占有率高，一般公司服务器都是Linux）（维护机房计算机，在远程维护），Windows Server（微软付费的，占有率低）</p>
<p>嵌入式操作系统：Linux（）</p>
<p>系统设备操作系统：iOS，Android</p>
<p>虚拟机：通过软件模拟具有完整硬件系统功能的，运行在一个完全隔离环境中的完整计算机系统。</p>
<p>Ken Thompson, 1969运行space travel，用汇编写了Unix原型，老爷子后来用B语言写了Unix</p>
<p>Dennis M.Ritchie发明了c语言，然后两个人一起重写了Unix。</p>
<p>unix version7 后unix不在开源源代码，因为ken老爷子喜欢走后门，让贝尔实验室很不爽。</p>
<p>Linux出现了，Linus老爷子来了，用GNU的bash当开发环境，gcc做compiler，编写了linux内核。</p>
<p>Linux两个版本：内核版本和发行版本。</p>
<p><u>终端命令</u>调系统调用，<u>系统调用</u>与硬件交互。</p>
<p>内核版本：kernel，Linux内核：内核只有一个<br>        linux内核是一种开放源码的操作系统，由Linux Torvalds负责维护，提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。</p>
<p>Linux发行版：<br>        linux发行版基于linux内核源码，将Linux系统的内核与外围实用程序(Utilities)软件和文档包装起来，并提供一些系统安装界面和系统配置、设定与管理工具，就构成了一种发行版本(distribution)，Linux的发行版本其实就是Linux核心再加上外围的实用程序组成的一个大软件包。</p>
<p>linux主要发行版：</p>
<p>Fedora Core、Debian、Mandrake、Ubuntu、Red Hat Linux、SuSE、Linux Mint、Gentoo、CentOS、</p>
<h2 id="P11：Linux文件目录"><a href="#P11：Linux文件目录" class="headerlink" title="P11：Linux文件目录"></a>P11：Linux文件目录</h2><p>windows每个驱动器都有根目录，前身是单用户操作系统</p>
<p>unix/linux是多用户操作系统，ubuntu目录：</p>
<p>/是根目录：/bin, /etc, /home, /lib, /usr</p>
<p>在/home中有/python, /laowang, 在这两个用户中都有/Desktop, /Documents, /Downloads, 各人各家，不会干扰别人。linux没有盘符概念</p>
<p>/bin: /usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。</p>
<p>/boot：放置linux系统启动时用到的一些文件。/boot/vmlinuz 为 linux 的内核文件，以及 /boot/gurb。建议单独分区，分区大小100M即可</p>
<p>/dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。</p>
<p>/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d修改配置文件之前记得备份。</p>
<p>注：/etc/X11 存放与 x windows 有关的设置。</p>
<p>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，<del>表示当前用户的家目录，</del>edu 表示用户 edu 的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据</p>
<p>/lib: /usr/lib: /usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为 /lib/modules。</p>
<p>/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。如加载硬盘于 /disk 中，此目录下就会自动产生目录 /disk/lost+found</p>
<p>/mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。</p>
<p>/opt：给主机额外安装软件所摆放的目录。如：FC4使用的Fedora 社群开发软件，如果想要自行安装新的 KDE 桌面软件，可以将该软件安装在该目录下。以前的 Linux 系统中，习惯放置在 /usr/local 目录下</p>
<p>/proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。</p>
<p>/root：系统管理员root的家目录，系统第一个启动的分区为 /，所以最好将 /root和 /放置在一个分区下。</p>
<p>/sbin: /usr/sbin: /usr/local/sbin：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能”查看”而不能设置和使用。</p>
<p>/tmp：一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下</p>
<p>/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。</p>
<p>/usr：应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录，使用 man ls 时会查询 /usr/share/man/man1/ls.1.gz 的内容建议单独分区，设置较大的磁盘空间</p>
<p>/var：放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。建议单独分区，设置较大的磁盘空间</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h3><p>Linux 对数据文件(<em>.mp3、</em>.bmp)，程序文件(<em>.c、</em>.h、*.o)，设备文件（LCD、触摸屏、鼠标），网络文件( socket ) 等的管理都抽象为文件，使用统一的方式方法管理。</p>
<p>文件分类：</p>
<p>1）普通文件( 数据文件 )</p>
<p>普通文件是用于存放数据、程序等信息的文件，一般都长期地存放在外存储器（磁盘）中。普通文件又分为文本文件和二进制文件。</p>
<p>2）目录文件</p>
<p>目录文件是文件系统中一个目录所包含的目录项所组成的文件。</p>
<p>3）设备文件</p>
<p>设备文件是用于为操作系统与设备提供连接的一种文件。在Linux系统中将设备作为文件来处理，操作设备就像是操作普通文件一样。每一个设备对应一个设备文件，存放在 /dev 目录中。</p>
<p>5）链接文件</p>
<p>似于 windows 下的快捷方式，链接又可以分为软链接（符号链接）和硬链接。</p>
<p>6）管道文件</p>
<p>管道文件主要用于在进程间传递数据的一种特殊文件。</p>
<p>7）套接口文件</p>
<p>主要用于不同计算机间网络通信的一种特殊文件。</p>
<p><strong>【常见目录说明】</strong></p>
<table>
<thead>
<tr>
<th>目录</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>/bin</td>
<td>存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里。</td>
</tr>
<tr>
<td>/etc</td>
<td>存放系统管理和配置文件</td>
</tr>
<tr>
<td>/home</td>
<td>存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示</td>
</tr>
<tr>
<td>/usr</td>
<td>用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。/usr/x11r6 存放x window的目录/usr/bin 众多的应用程序  /usr/sbin 超级用户的一些管理程序  /usr/doc linux文档  /usr/include linux下开发和编译应用程序所需要的头文件  /usr/lib 常用的动态链接库和软件包的配置文件  /usr/man 帮助文档  /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里  /usr/local/bin 本地增加的命令  /usr/local/lib 本地增加的库</td>
</tr>
<tr>
<td>/opt</td>
<td>额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。</td>
</tr>
<tr>
<td>/proc</td>
<td>虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。</td>
</tr>
<tr>
<td>/root</td>
<td>超级用户（系统管理员）的主目录（特权阶级^o^）</td>
</tr>
<tr>
<td>/sbin</td>
<td>存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。</td>
</tr>
<tr>
<td>/dev</td>
<td>用于存放设备文件。</td>
</tr>
<tr>
<td>/mnt</td>
<td>系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。</td>
</tr>
<tr>
<td>/boot</td>
<td>存放用于系统引导时使用的各种文件</td>
</tr>
<tr>
<td>/lib</td>
<td>存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。</td>
</tr>
<tr>
<td>/tmp</td>
<td>用于存放各种临时文件，是公用的临时文件存储点。</td>
</tr>
<tr>
<td>/var</td>
<td>用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。</td>
</tr>
<tr>
<td>/lost+found</td>
<td>这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里</td>
</tr>
</tbody></table>
<h2 id="P13-17-LInux终端命令"><a href="#P13-17-LInux终端命令" class="headerlink" title="P13-17.LInux终端命令"></a>P13-17.LInux终端命令</h2><p>terminal放大字体：ctrl + shift + =；缩小字体： ctrl + -</p>
<p>linux常用命令：ls, pwd, cd, touch, mkdir, rm, clear.</p>
<p>对应：list, print work directory, change directory, touch(创建文件，例如java，txt文件), mkdir(创建目录)马克directory，clear（清屏), rmdir(删除目录)</p>
<p>终端命令格式：command [options] [parameter]</p>
<p>Linux中的rm －r 和rm －R区别为：用途不同道、范围不同、数量不同。</p>
<p>一、用途不同</p>
<p>1、rm －r ：rm －r 只能用于删除文件，不能用于删除文件夹。</p>
<p>2、rm －R：rm －R既能用于删除文件，也能用于删除文件夹。</p>
<p>二、范围不同内</p>
<p>1、rm －容r ：rm －r的删除范围是删除当前输入位置的文件。</p>
<p>2、rm －R：rm －R的删除范围是删除当前输入的目录文件夹里文件及其子目录里的文件。</p>
<p><strong>系统信息</strong><br>arch 显示机器的处理器架构<br>uname -m 显示机器的处理器架构<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS </p>
<p><strong>关机 (系统的关机、重启以及登出 )</strong><br>shutdown -h now 关闭系统<br>init 0 关闭系统<br>telinit 0 关闭系统<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启<br>reboot 重启<br>logout 注销 </p>
<p><strong>文件和目录</strong><br>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构<br>lstree 显示文件和目录由根目录开始的树形结构<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录 </p>
<p>cp -r dir1 dir2 复制一个目录及子目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) </p>
<p><strong>文件搜索</strong><br>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径 </p>
<p><strong>挂载一个文件系统</strong><br>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 </p>
<p><strong>磁盘空间</strong><br>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </p>
<p><strong>用户和群组</strong><br>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 </p>
<p><strong>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong><br>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位 </p>
<p><strong>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong><br>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性 </p>
<p><strong>打包和压缩文件</strong><br>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包 </p>
<p><strong>RPM 包 - （Fedora, Redhat及类似系统）</strong><br>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 </p>
<p><strong>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</strong><br>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件 </p>
<p><strong>DEB 包 (Debian, Ubuntu 以及类似系统)</strong><br>dpkg -i package.deb 安装/更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 </p>
<p><strong>APT 软件工具 (Debian, Ubuntu 以及类似系统)</strong><br>apt-get install package_name 安装/更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 </p>
<p><strong>查看文件内容</strong><br>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容 </p>
<p><strong>文本处理</strong><br>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行<br>sed ‘/ <em>#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ *$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 </p>
<p><strong>字符设置和文件格式转换</strong><br>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>recode -l | more 显示所有允许的转换格式 </p>
<p><strong>文件系统分析</strong><br>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 </p>
<p><strong>初始化一个文件系统</strong><br>mkfs /dev/hda1 在hda1分区创建一个文件系统<br>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>fdformat -n /dev/fd0 格式化一个软盘<br>mkswap /dev/hda3 创建一个swap文件系统 </p>
<p><strong>SWAP文件系统</strong><br>mkswap /dev/hda3 创建一个swap文件系统<br>swapon /dev/hda3 启用一个新的swap文件系统<br>swapon /dev/hda2 /dev/hdb3 启用两个swap分区 </p>
<p><strong>备份</strong><br>dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份<br>dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份<br>restore -if /tmp/home0.bak 还原一个交互式备份<br>rsync -rogpav –delete /home /tmp 同步两边的目录<br>rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync<br>rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作<br>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>find /home/user1 -name ‘<em>.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>find /var/log -name ‘</em>.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 </p>
<p><strong>光盘</strong><br>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>cdrecord –scanbus 扫描总线以识别scsi通道<br>dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD </p>
<p><strong>网络 - （以太网和WIFI无线</strong>）<br>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>dhclient eth0 以dhcp模式启用 ‘eth0’<br>route -n show routing table<br>route add -net 0/0 gw IP_Gateway configura default gateway<br>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’<br>route del 0/0 gw IP_gateway remove static route<br>echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing<br>hostname show hostname of system<br>host <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>ip link show show link status of all interfaces<br>mii-tool eth0 show link status of ‘eth0’<br>ethtool eth0 show statistics of network card ‘eth0’<br>netstat -tup show all active network connections and their PID<br>netstat -tupl show all network services listening on the system and their PID<br>tcpdump tcp port 80 show all HTTP traffic<br>iwlist scan show wireless networks<br>iwconfig eth1 show configuration of a wireless network card<br>hostname show hostname<br>host <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>whois <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup on Whois database </p>
<p><strong>JPS工具</strong></p>
<p>jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。</p>
<p>  我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。</p>
<p>   <strong>使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。</strong></p>
<p><strong>jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path.</strong></p>
<p>$&gt; <strong>jps</strong><br>23991 Jps<br>23789 BossMain<br>23651 Resin</p>
<p>比较常用的参数：</p>
<p><strong>-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数</strong><br>$&gt; <strong>jps -q</strong><br>28680<br>23789<br>23651</p>
<p><strong>-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null</strong></p>
<p>$&gt; <strong>jps -m</strong><br>28715 Jps -m<br>23789 BossMain<br>23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log</p>
<p><strong>-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名</strong></p>
<p>$&gt; <strong>jps -l</strong><br>28729 sun.tools.jps.Jps<br>23789 com.asiainfo.aimc.bossbi.BossMain<br>23651 com.caucho.server.resin.Resin</p>
<p><strong>-v 输出传递给JVM的参数</strong></p>
<p>$&gt; <strong>jps -v</strong><br>23789 BossMain<br>28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd</p>
<p>k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m<br>23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -</p>
<p>Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl</p>
<p><strong>sudo jps看到的进程数量最全</strong></p>
<p><strong>jps 192.168.0.77</strong></p>
<p><strong>列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099</strong></p>
<p><strong>（前提是远程服务器提供jstatd服务）</strong></p>
<p><strong>注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。</strong></p>
<h2 id="P18"><a href="#P18" class="headerlink" title="P18"></a>P18</h2><p>查阅命令帮助信息，command –help, man command.</p>
<p>系统中会有单独的man文件，命令百<br>man term<br>等同于<br>less [manpath]/term.X[.gz] // X为1-8中的数，视term而定<br>就是说，如果系统没有安装对度应man文件，哪怕term命令完全正常，知man term都没结果（同样，只要安装了man文件，哪怕没term命令，也可以得到道一大堆东西）。内<br>而–help参数将会显示可执行程序自带的信息，这些信容息是嵌入到程序本身的（所以–help信息较简短）。man是在系统安装的时候安装了狠制多的文档，可以在系统的目录doc下找到，如果软件有配套的页面，就可以使用man来查找，<br>而 help是软件编写百人员在编写的时候提供了内置的查询参数，查询的参数在程序里度面。也就是说man查询的结果是在程序外面，而help 查询出来的内容在程序里面。</p>
<p>man是一个详细的介绍，help是一个命令选项的简单介绍</p>
<p>man的用法：man    -&gt;&gt;manual    ###man是手册缩写<br>man man            #####查看man命令的帮助<br>man passwd        ###查看passwd命令的帮助</p>
<p>man的级别<br>1    系统命令<br>2    系统接口<br>3    函数库<br>4    特殊文件，比如设备文件<br>5    文件<br>6    游戏<br>7    系统的软件包<br>8    系统管理命令<br>9    内核</p>
<p>man 5 passwd    ##查看/etc/passwd文件的帮助<br>man 1 passwd    ##查看passwd命令的帮助，1可以省略</p>
<p>man页面的快捷方式<br>上下键            ##向上或向下一行<br>pageup|pagedown        ##向下一个屏幕或者向上一个屏幕<br>d|u            ##向下或者向上半个屏幕<br>G|gg            ##跳转页面到man最下面或最上面<br>/关键字            ##搜索关键字，关键字会高亮显示，n向下匹配，N向上<br>q            ##退出帮助页面</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday06/" class="post-title-link" itemprop="url">带你学c带你飞day06</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 21:06:25" itemprop="dateCreated datePublished" datetime="2020-04-20T21:06:25-05:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday05/" class="post-title-link" itemprop="url">带你学c带你飞day05</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 21:06:21" itemprop="dateCreated datePublished" datetime="2020-04-20T21:06:21-05:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday04/" class="post-title-link" itemprop="url">带你学c带你飞day04</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 21:06:18" itemprop="dateCreated datePublished" datetime="2020-04-20T21:06:18-05:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday03/" class="post-title-link" itemprop="url">带你学c带你飞day03</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 21:06:14" itemprop="dateCreated datePublished" datetime="2020-04-20T21:06:14-05:00">2020-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-25 09:35:30" itemprop="dateModified" datetime="2020-04-25T09:35:30-05:00">2020-04-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P21"><a href="#P21" class="headerlink" title="P21"></a>P21</h2><p>内存地址存数据</p>
<p>在C语言中，指针的使用非常广泛，因为使用指针往往可以生成更高效、更紧凑的代码。总的来说，使用指针有如下好处：</p>
<p>1）指针的使用使得不同区域的代码可以轻易的共享内存数据，这样可以使程序更为快速高效；</p>
<p>2）C语言中一些复杂的数据结构往往需要使用指针来构建，如链表、二叉树等；</p>
<p>3）C语言是传值调用，而有些操作传值调用是无法完成的，如通过被调函数修改调用函数的对象，但是这种操作可以由指针来完成，而且并不违背传值调用。</p>
<p><strong>3.1 声明并初始化一个指针</strong></p>
<p>　　指针其实就是一个变量，指针的声明方式与一般的变量声明方式没太大区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int *p;        &#x2F;&#x2F; 声明一个 int 类型的指针 p</span><br><span class="line">char *p        &#x2F;&#x2F; 声明一个 char 类型的指针 p</span><br><span class="line">int *arr[10]   &#x2F;&#x2F; 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向 int 类型对象的指针</span><br><span class="line">int (*arr)[10] &#x2F;&#x2F; 声明一个数组指针，该指针指向一个 int 类型的一维数组</span><br><span class="line">int **p;       &#x2F;&#x2F; 声明一个指针 p ，该指针指向一个 int 类型的指针</span><br></pre></td></tr></table></figure>

<p>　　指针的声明比普通变量的声明多了一个一元运算符 “<em>”。运算符 “</em>” 是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。在上述的声明中： p 是一个指针，保存着一个地址，该地址指向内存中的一个变量； *p 则会访问这个地址所指向的变量。</p>
<p>　　声明一个指针变量并不会自动分配任何内存。在对指针进行间接访问之前，指针必须进行初始化：或是使他指向现有的内存，或者给他动态分配内存，否则我们并不知道指针指向哪儿，这将是一个很严重的问题，稍后会讨论这个问题。初始化操作如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 方法1：使指针指向现有的内存 *&#x2F;</span><br><span class="line">int x &#x3D; 1;</span><br><span class="line">int *p &#x3D; &amp;x;　　&#x2F;&#x2F; 指针 p 被初始化，指向变量 x ，其中取地址符 &amp; 用于产生操作数内存地址</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法2：动态分配内存给指针 *&#x2F;</span><br><span class="line">int *p;</span><br><span class="line">p &#x3D; (int *)malloc(sizeof(int) * 10);　　　　&#x2F;&#x2F; malloc 函数用于动态分配内存</span><br><span class="line">free(p);　　　　&#x2F;&#x2F; free 函数用于释放一块已经分配的内存，常与 malloc 函数一起使用，要使用这两个函数需要头文件 stdlib.h</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　指针的初始化实际上就是给指针一个合法的地址，让程序能够清楚地知道指针指向哪儿。</p>
<p><strong>3.2 未初始化和非法的指针</strong> </p>
<p>　　 如果一个指针没有被初始化，那么程序就不知道它指向哪里。它可能指向一个非法地址，这时，程序会报错，在 Linux 上，错误类型是 Segmentation fault（core dumped），提醒我们段违例或内存错误。它也可能指向一个合法地址，实际上，这种情况更严重，你的程序或许能正常运行，但是这个没有被初始化的指针所指向的那个位置的值将会被修改，而你并无意去修改它。用一个例子简单的演示一下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int *p;</span><br><span class="line">    *p &#x3D; 1;</span><br><span class="line">    printf(&quot;%d\n&quot;,*p);</span><br><span class="line"></span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　这个程序可以编译通过，但是运行的话会报错，报错信息如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180917175256031-967973584.png" alt="img"></p>
<p>　　要想使这个程序运行起来，需要先对指针 p 进行初始化：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int x &#x3D; 1;  </span><br><span class="line">    int *p &#x3D; &amp;x;</span><br><span class="line">    printf(&quot;%d\n&quot;,*p);</span><br><span class="line">　  *p &#x3D; 2;</span><br><span class="line">    printf(&quot;%d\n&quot;,*p);</span><br><span class="line"></span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　这段代码的输出结果如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180917212250007-280056505.png" alt="img"> </p>
<p>　　可以看到，对指针进行初始化后，便可以正常对指针进行赋值了。 </p>
<p><strong>3.3 NULL指针</strong></p>
<p>　　<strong>NULL 指针是一个特殊的指针变量，表示不指向任何东西</strong>。可以通过给一个指针赋一个零值来生成一个 NULL 指针。 </p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int *p &#x3D; NULL;</span><br><span class="line">    printf(&quot;p的地址为%d\n&quot;,p);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;***************</span><br><span class="line"> * 程序输出：</span><br><span class="line"> * p的地址为0</span><br><span class="line">***************&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　可以看到指针指向内存地址0。在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是为操作系统保留的。但是，内存地址 0 有一个特别重要的意义，它表明改指针不指向一个可访问的内存位置。</p>
<p><strong>四、指针的运算</strong></p>
<p>　　C 指针的算术运算只限于两种形式：</p>
<p>1） 指针 +/- 整数 ：</p>
<p>　　 可以对指针变量 p 进行 p++、p–、p + i 等操作，所得结果也是一个指针，只是指针所指向的内存地址相比于 p 所指的内存地址前进或者后退了 i 个操作数。用一张图来说明一下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180921154218407-1813012241.png" alt="img"></p>
<p>　　在上图中，10000000等是内存地址的十六进制表示（数值是假定的），p 是一个 int 类型的指针，指向内存地址 0x10000008 处。则 p++ 将指向与 p 相邻的下一个内存地址，由于 int 型数据占 4 个字节，因此 p++ 所指的内存地址为 1000000b。其余类推。不过要注意的是，这种运算并不会改变指针变量 p 自身的地址，只是改变了它所指向的地址。举个例子：</p>
<p>2）指针 - 指针</p>
<p>　　只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。两个指针相减的结果的类型是 ptrdiff_t，它是一种有符号整数类型。减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位），因为减法运算的结果将除以数组元素类型的长度。举个例子：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[10] &#x3D; &#123;1,2,3,4,5,6,7,8,9,0&#125;;</span><br><span class="line">    int sub;</span><br><span class="line">    int *p1 &#x3D; &amp;a[2];</span><br><span class="line">    int *p2 &#x3D; &amp;a[8];</span><br><span class="line"></span><br><span class="line">    sub &#x3D; p2-p1;                                                                            </span><br><span class="line">    printf(&quot;%d\n&quot;,sub);　　　　&#x2F;&#x2F; 输出结果为 6</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>五、指针与数组</strong></p>
<p>　　在C语言中，指针与数组之间的关系十分密切。实际上，许多可以用数组完成的工作都可以使用指针来完成。一般来说，用指针编写的程序比用数组编写的程序执行速度快，但另一方面，用指针实现的程序理解起来稍微困难一些。</p>
<p><strong>5.1 指针与数组的关系</strong></p>
<p>　　我们先声明一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[10];        &#x2F;&#x2F; 声明一个int类型的数组，这个数组有10个元素</span><br></pre></td></tr></table></figure>

<p>　　我们可以用 a[0]、a[1]、…、a[9] 来表示这个数组中的10个元素，这10个元素是存储在一段连续相邻的内存区域中的。</p>
<p>　　接下来，我们再声明一个指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p;           &#x2F;&#x2F; 声明一个int类型的指针变量</span><br></pre></td></tr></table></figure>

<p>　　 p 是一个指针变量，指向内存中的一个区域。如果我们对指针 p 做如下的初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; &amp;a[0];        &#x2F;&#x2F; 对指针进行初始化，p将指向数组 a 的第 1 个元素 a[0]</span><br></pre></td></tr></table></figure>

<p>　　我们知道，对指针进行自增操作会让指针指向与当前元素相邻的下一个元素，即 <em>(p + 1) 将指向 a[1] ；同样的， <em>(p + i) 将指向 a[i] 。因此，我们可以使用该指针来遍历数组 a[10] 的所有元素。可以看到，数组下标与指针运算之间的关系是一一对应的。而根据定义，</em></em>数组类型的变量或表达式的值是该数组第 1 个元素的地址**，且数组名所代表的的就是该数组第 1 个元素的地址，故，上述赋值语句可以直接写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; a;        &#x2F;&#x2F; a 为数组名，代表该数组最开始的一个元素的地址</span><br></pre></td></tr></table></figure>

<p>　　很显然，<strong>一个通过数组和下标实现的表达式可以等价地通过指针及其偏移量来实现</strong>，这就是数组和指针的互通之处。但有一点要明确的是，数组和指针并不是完全等价，<em>指针是一个变量，而数组名不是变量，它数组中第 1 个元素的地址</em>，数组可以看做是一个用于保存变量的容器。更直接的方法，我们可以直接看二者的地址，并不一样：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;                                                                          </span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    int x[10] &#x3D; &#123;1,2,3,4,5,6,7,8,9,0&#125;;</span><br><span class="line">    int *p &#x3D; x;</span><br><span class="line">    printf(&quot;x的地址为：%p\n&quot;,x);</span><br><span class="line">    printf(&quot;x[0]的地址为：%p\n&quot;,&amp;x[0]);</span><br><span class="line">    printf(&quot;p的地址为：%p\n&quot;,&amp;p);　　　　　　&#x2F;&#x2F; 打印指针 p 的地址，并不是指针所指向的地方的地址</span><br><span class="line"></span><br><span class="line">    p +&#x3D; 2;</span><br><span class="line">    printf(&quot;*(p+2)的值为：%d\n&quot;,*p);　　　　&#x2F;&#x2F; 输出结果为 3，*(p+2)指向了 x[2]</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　结果如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180918160417548-189120951.png" alt="img"></p>
<p>　　可以看到， x 的值与 x[0] 的地址是一样的，也就是说数组名即为数组中第 1 个元素的地址。实际上，打印 &amp;x 后发现，x 的地址也是这个值。而 x 的地址与指针变量 p 的地址是不一样的。故而数组和指针并不能完全等价。</p>
<p>（笔者注：上述输出结果是在 centos7 64bit 的环境下使用 gcc 编译器得到的，可以看到地址是一个12位的十六进制数，转换成二进制是48位，也就是说寻址空间有 256TB，但是笔者的电脑只有 8GB 内存，猜测是不是由于 linux 系统开启了内存分页机制，这里寻址的是虚拟地址？另外，在Windows下使用 vs2015 编译运行的话，则输出结果是一个 8位的十六进制数，也就是32位二进制，寻址空间为 4GB） </p>
<p><strong>5.2 指针数组</strong></p>
<p>　　指针是一个变量，而数组是用于存储变量的容器，因此，指针也可以像其他变量一样存储在数组中，也就是指针数组。 <strong>指针数组是一个数组，数组中的每一个元素都是指针</strong>。声明一个指针数组的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p[10];    &#x2F;&#x2F; 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向int类型的指针</span><br></pre></td></tr></table></figure>

<p>　　在上述声明中，由于 [] 的优先级比 * 高，故 p 先与 [] 结合，成为一个数组 p[]；再由 int * 指明这是一个 int 类型的指针数组，数组中的元素都是 int 类型的指针。数组的第 i 个元素是 <em>p[i]，而 *</em>p[i] 是一个指针**。由于指针数组中存放着多个指针，操作灵活，在一些需要操作大量数据的程序中使用，可以使程序更灵活快速。</p>
<p><strong>5.3 数组指针</strong></p>
<p>　　<strong>数组指针是一个指针，它指向一个数组</strong>。声明一个数组指针的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*p)[10];        &#x2F;&#x2F; 声明一个数组指针 p ，该指针指向一个数组</span><br></pre></td></tr></table></figure>

<p>　　由于 () 的优先级最高，所以 p 是一个指针，指向一个 int 类型的一维数组，这个一维数组的长度是 10，这也是指针 p 的步长。也就是说，执行 p+1 时，p 要跨过 n 个 int 型数据的长度。数组指针与二维数组联系密切，可以用数组指针来指向一个二维数组，如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int arr[2][3] &#x3D; &#123;1,2,3,4,5,6&#125;;               &#x2F;&#x2F; 定义一个二维数组并初始化</span><br><span class="line">    int (*p)[3];                                 &#x2F;&#x2F; 定义一个数组指针，指针指向一个含有3个元素的一维数组</span><br><span class="line"></span><br><span class="line">    p &#x3D; arr;                                     &#x2F;&#x2F; 将二维数组的首地址赋给 p，此时 p 指向 arr[0] 或 &amp;arr[0][0]</span><br><span class="line">    printf(&quot;%d\n&quot;,(*p)[0]);　　　　　　　　　　　　  &#x2F;&#x2F; 输出结果为 1</span><br><span class="line">    p++;　　　　　　　　　　　　　　　　　　　　　　　　 &#x2F;&#x2F; 对 p 进行算术运算，此时 p 将指向二维数组的下一行的首地址，即 &amp;arr[1][0]</span><br><span class="line">    printf(&quot;%d\n&quot;,(*p)[1]);                      &#x2F;&#x2F; 输出结果为5</span><br><span class="line"></span><br><span class="line">    return 0;                                                                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>六、指针与结构</strong></p>
<p><strong>6.1 简单介绍一下结构</strong></p>
<p>　　结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。由于结构将一组相关的变量看做一个单元而不是各自独立的实体，因此结构有助于组织复杂的数据，特别是在大型的程序中。声明一个结构的方式如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct message&#123;　　　　　　      &#x2F;&#x2F; 声明一个结构 message</span><br><span class="line">    char name[10];             &#x2F;&#x2F; 成员</span><br><span class="line">    int age;</span><br><span class="line">    int score;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct message s_message;　　　　 &#x2F;&#x2F; 类型定义符 typedef</span><br><span class="line"></span><br><span class="line">s_message mess &#x3D; &#123;&quot;tongye&quot;,23,83&#125;;　　　　&#x2F;&#x2F; 声明一个 struct message 类型的变量 mess,并对其进行初始化　</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line">&#x2F;* 另一种更简便的声明方法 *&#x2F;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">　　char name[10];</span><br><span class="line">　　int age;</span><br><span class="line">　　int score;</span><br><span class="line">&#125;message;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　可以使用 <strong>结构名.成员</strong> 的方式来访问结构中的成员，如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">　　printf(&quot;%s\n&quot;,mess.name);　　　　&#x2F;&#x2F; 输出结果：tongye</span><br><span class="line">　　printf(&quot;%d\n&quot;,mess.age);　　　　 &#x2F;&#x2F; 输出结果：23</span><br><span class="line"></span><br><span class="line">　　return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>6.2 结构指针</strong>　</p>
<p>　　结构指针是指向结构的指针，以上面的结构为例，可以这样定义一个结构指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s_message *p;        &#x2F;&#x2F; 声明一个结构指针 p ，该指针指向一个 s_message 类型的结构</span><br><span class="line">*p &#x3D; &amp;mess;　　　　　　&#x2F;&#x2F; 对结构指针的初始化与普通指针一样，也是使用取地址符 &amp;</span><br></pre></td></tr></table></figure>

<p>　　C语言中使用 -&gt; 操作符来访问结构指针的成员，举个例子：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char name[10];</span><br><span class="line">    int age;</span><br><span class="line">    int score;  </span><br><span class="line">&#125;message;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    message mess &#x3D; &#123;&quot;tongye&quot;,23,83&#125;;</span><br><span class="line">    message *p &#x3D; &amp;mess;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%s\n&quot;,p-&gt;name);　　　　　　&#x2F;&#x2F; 输出结果为：tongye</span><br><span class="line">    printf(&quot;%d\n&quot;,p-&gt;score);         &#x2F;&#x2F; 输出结果为：83</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>七、指针与函数</strong></p>
<p>　　<strong>C语言的所有参数均是以“传值调用”的方式进行传递的</strong>，这意味着函数将获得参数值的一份拷贝。这样，函数可以放心修改这个拷贝值，而不必担心会修改调用程序实际传递给它的参数。 </p>
<p><strong>7.1 指针作为函数的参数</strong></p>
<p>　　传值调用的好处是是被调函数不会改变调用函数传过来的值，可以放心修改。但是有时候需要被调函数回传一个值给调用函数，这样的话，传值调用就无法做到。为了解决这个问题，可以使用传指针调用。<strong>指针参数使得被调函数能够访问和修改主调函数中对象的值。</strong>用一个例子来说明：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">void swap1(int a,int b)　　　　　　  &#x2F;&#x2F; 参数为普通的 int 变量</span><br><span class="line">&#123;</span><br><span class="line">　　int temp;</span><br><span class="line">　　temp &#x3D; a;</span><br><span class="line">　　a &#x3D; b;</span><br><span class="line">　　b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap2(int *a,int *b)　　　　　　&#x2F;&#x2F; 参数为指针，接受调用函数传递过来的变量地址作为参数，对所指地址处的内容进行操作</span><br><span class="line">&#123;</span><br><span class="line">　　int temp;　　　　                &#x2F;&#x2F; 最终结果是，地址本身并没有改变，但是这一地址所对应的内存段中的内容发生了变化，即x,y的值发生了变化</span><br><span class="line">　　temp &#x3D; *a;</span><br><span class="line">　　*a &#x3D; *b;</span><br><span class="line">　　*b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">　　int x &#x3D; 1,y &#x3D; 2;</span><br><span class="line">　　swap1(x,y);                     &#x2F;&#x2F; 将 x,y 的值本身作为参数传递给了被调函数</span><br><span class="line">　　printf(&quot;%d %5d\n&quot;,x,y);         &#x2F;&#x2F; 输出结果为：1     2</span><br><span class="line"></span><br><span class="line">　　swap(&amp;x,&amp;y);                    &#x2F;&#x2F; 将 x,y 的地址作为参数传递给了被调函数，传递过去的也是一个值，与传值调用不冲突</span><br><span class="line">　　printf(&quot;%d %5d\n&quot;,x,y);         &#x2F;&#x2F; 输出结果为：2     1</span><br><span class="line">　　return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>7.2 指向函数的指针</strong></p>
<p>　　在C语言中，函数本身不是变量，但是可以定义指向函数的指针，也称作函数指针，函数指针指向函数的入口地址。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。 声明一个函数指针的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 （* 指针变量名）（[形参列表]）;</span><br><span class="line"></span><br><span class="line">int (*pointer)(int *,int *);        &#x2F;&#x2F; 声明一个函数指针</span><br></pre></td></tr></table></figure>

<p>　　上述代码声明了一个函数指针 pointer ，该指针指向一个函数，函数具有两个 int * 类型的参数，且返回值类型为 int。下面的代码演示了函数指针的用法：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line"></span><br><span class="line">int str_comp(const char *m,const char *n);                             &#x2F;&#x2F; 声明一个函数 str_comp，该函数有两个 const char 类型的指针，函数的返回值为 int 类型</span><br><span class="line">void comp(char *a,char *b,int (*prr)(const char *,const char*));       &#x2F;&#x2F; 声明一个函数 comp ,注意该函数的第三个参数，是一个函数指针</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char str1[20];      &#x2F;&#x2F; 声明一个字符数组</span><br><span class="line">    char str2[20];</span><br><span class="line">    int (*p)(const char *,const char *) &#x3D; str_comp;　　　　　　　　　　　 &#x2F;&#x2F; 声明并初始化一个函数指针，该指针所指向的函数有两个 const char 类型的指针，且返回值为 int 类型</span><br><span class="line">    gets(str1);         &#x2F;&#x2F; 使用 gets() 函数从 I&#x2F;O 读取一行字符串</span><br><span class="line">    gets(str2);</span><br><span class="line">    comp(str1,str2,p);  &#x2F;&#x2F; 函数指针 p 作为参数传给 comp 函数</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int str_comp(const char *m,const char *n)</span><br><span class="line">&#123;</span><br><span class="line">　　 &#x2F;&#x2F; 库函数 strcmp 用于比较两个字符串，其原型是： int strcmp(const char *s1,const char *s2);</span><br><span class="line">    if(strcmp(m,n) &#x3D;&#x3D; 0) </span><br><span class="line">        return 0;</span><br><span class="line">    else</span><br><span class="line">        return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 函数 comp 接受一个函数指针作为它的第三个参数 *&#x2F;</span><br><span class="line">void comp(char *a,char *b,int (*prr)(const char *,const char*))</span><br><span class="line">&#123;</span><br><span class="line">    if((*prr)(a,b) &#x3D;&#x3D; 0)</span><br><span class="line">        printf(&quot;str1 &#x3D; str2\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;str1 !&#x3D; str2\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>　　这段代码的功能是从键盘读取两行字符串（长度不超过20），判断二者是否相等。</p>
<p>　　注意，声明一个函数指针时，() 不能漏掉，否则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p(void *,void*);</span><br></pre></td></tr></table></figure>

<p>　　这表明 p 是一个函数，该函数返回一个指向 int 类型的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a=<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> *pa=&amp;a;</span><br></pre></td></tr></table></figure>

<p>指针长度：以前是16位地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就占8个字节。</p>
<p>避免访问未初始化指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a; *a=<span class="number">123</span>;<span class="comment">//野指针</span></span><br></pre></td></tr></table></figure>

<h2 id="P22"><a href="#P22" class="headerlink" title="P22"></a>P22</h2><p>&amp;取值操作符</p>
<p>数组名就是地址信息，也是第一个元素的地址。</p>
<p>当指针指向数组元素是，可以对指针变量进行加减运算。指针加一指向下一个元素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9Eday02/" class="post-title-link" itemprop="url">带你学c带你飞day02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-20 21:06:09 / Modified: 22:35:12" itemprop="dateCreated datePublished" datetime="2020-04-20T21:06:09-05:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P11"><a href="#P11" class="headerlink" title="P11"></a>P11</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);<span class="comment">//地址</span></span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"true"</span>);<span class="comment">//这样缩进可以</span></span><br><span class="line"><span class="keyword">if</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P12"><a href="#P12" class="headerlink" title="P12"></a>P12</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量表达式<span class="number">1</span>：语句或代码块；</span><br><span class="line">	<span class="keyword">case</span> ...</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">	<span class="keyword">default</span>: 语句或代码块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line">  <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span>: <span class="built_in">printf</span>(<span class="string">"hi"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'B'</span>: <span class="built_in">printf</span>(<span class="string">"hey"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">"hello"</span>); </span><br><span class="line">    <span class="keyword">break</span>;<span class="comment">//不加break会导致所有case都输出了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(has = <span class="string">"a"</span>)&#123;&#125;<span class="comment">//永远对，所以应该 ==</span></span><br></pre></td></tr></table></figure>

<h2 id="P13"><a href="#P13" class="headerlink" title="P13"></a>P13</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">()</span></span>;<span class="comment">//读取下一个字符</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>()&#123;&#125;<span class="comment">//判断后循环</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>()；<span class="comment">//先循环在判断，while后面有语句</span></span><br></pre></td></tr></table></figure>

<h2 id="P14"><a href="#P14" class="headerlink" title="P14"></a>P14</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环初始;循环结束;循环条件)&#123;&#125;</span><br><span class="line"><span class="built_in">_Bool</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, <span class="keyword">int</span> j=<span class="number">0</span>;i&lt;j;i++,j++)&#123;&#125;<span class="comment">//也可以</span></span><br><span class="line">若想 <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">10</span>;<span class="comment">//则需 gcc -std=c99 test.c &amp;&amp; ./a.out</span></span><br></pre></td></tr></table></figure>

<h2 id="P15"><a href="#P15" class="headerlink" title="P15"></a>P15</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> 在<span class="built_in">printf</span>中是%lld</span><br><span class="line">  <span class="keyword">break</span>跳出当前循环，<span class="keyword">continue</span>直接进入下一次循环</span><br></pre></td></tr></table></figure>

<h2 id="P16"><a href="#P16" class="headerlink" title="P16"></a>P16</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">5</span>, j;</span><br><span class="line">j=++i;<span class="comment">//i=6=j</span></span><br><span class="line">i=<span class="number">5</span>;</span><br><span class="line">j=i++;<span class="comment">//i=6,j=5</span></span><br><span class="line"><span class="comment">//i++先把值给j，再加加</span></span><br><span class="line"><span class="comment">//多语句，逗号表达式</span></span><br><span class="line"><span class="comment">/* 语法：表达式1，...表达式n</span></span><br><span class="line"><span class="comment">表达式从左到右计算</span></span><br><span class="line"><span class="comment">	逗号表达式作为一个整体，值为最后一个表达式也就是n的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">a=(b=<span class="number">3</span>, (c=b+<span class="number">4</span>) +<span class="number">5</span>)<span class="comment">//a=12</span></span><br><span class="line">exp1 ? exp2:exp3  <span class="comment">//if exp1==true , exp2, else: exp3</span></span><br><span class="line"><span class="comment">//goto 跳到标签</span></span><br><span class="line">  <span class="keyword">goto</span> A;<span class="comment">//谨慎用goto</span></span><br><span class="line">  A: <span class="built_in">printf</span>(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="P17"><a href="#P17" class="headerlink" title="P17"></a>P17</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组 类型 数组名[元素个数]</span></span><br><span class="line"><span class="comment">/*数组不能动态定义</span></span><br><span class="line"><span class="comment">int 自动初始化为0，最好手动初始化，要不然栈内空间会错误赋值，可能。</span></span><br><span class="line"><span class="comment">int a[5]=&#123;[2]=2,[3]=3&#125;;//这样可以</span></span><br><span class="line"><span class="comment">sizeof(a);//计算数组内存大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="P18"><a href="#P18" class="headerlink" title="P18"></a>P18</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态数组</span></span><br><span class="line">c99, c支持可变长数组，数组长度在运行时才被决定</span><br><span class="line">  新编译， 在数组越界不会出现错误，好像</span><br></pre></td></tr></table></figure>

<h2 id="P19"><a href="#P19" class="headerlink" title="P19"></a>P19</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">字符串数组定义：</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[]=&#123;<span class="string">"ab"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[]=<span class="string">"ab"</span>;</span><br><span class="line">字符串处理函数：&lt;<span class="built_in">string</span>.h&gt;内</span><br><span class="line">  <span class="built_in">strcat</span>：连接字符串</span><br><span class="line">  <span class="built_in">strcmp</span>:比较字符串</span><br><span class="line">  <span class="built_in">strcpy</span>:拷贝字符串</span><br><span class="line">  <span class="built_in">strlen</span>:获取长度</span><br><span class="line">  <span class="built_in">strncat</span>(str1,str2,<span class="number">5</span>):（以下<span class="number">3</span>个受限，功能一样）<span class="comment">//str2拷贝5个字符到str1</span></span><br><span class="line">  <span class="built_in">strcmp</span>:</span><br><span class="line">  <span class="built_in">strncpy</span>:</span><br><span class="line"><span class="keyword">sizeof</span>(str);<span class="comment">//n</span></span><br><span class="line"><span class="built_in">strlen</span>(str);<span class="comment">//n-1, 因为strlen不包括那个\n，sizeof包括</span></span><br></pre></td></tr></table></figure>

<h3 id="1-字符串基础"><a href="#1-字符串基础" class="headerlink" title="1 字符串基础"></a>1 字符串基础</h3><p>字符串是一种重要的数据类型，有零个或多个字符组成的有限串行。</p>
<p>定义子串: 串中任意个连续的字符组成的子序列，并规定空串是任意串的子串，任意串也是其自身的子串，如字符串”adereegfb”中它本身、空串、诸如”ader”连续的字符串都是它的子串。子序列则不要求字符连续，但顺序要与主串保持一致，若有”abcd”与”ad”则两者的最长公共子序列为”ad”。在动态规划中计算最长公共子序列和最长公共子串中一定要能区分这两个概念!</p>
<p>在C语言中并没有显示的字符串类型，它有如下两种风格的字符串：</p>
<ul>
<li>字符串常量: 以双引号扩起来的字符序列，规定所有的字符串常量都由编译器自动在末尾添加一个空字符</li>
<li>字符数组: 末尾添加了’\0’的字符数组，一般需要显示在末尾添加空字符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char c1[]&#x3D;&#123;&#39;c&#39;,&#39;+&#39;,&#39;+&#39;&#125;; &#x2F;&#x2F;末尾没有空字符</span><br><span class="line">char c2[]&#x3D;&#123;&#39;c&#39;,&#39;+&#39;,&#39;+&#39;，&#39;\0&#39;&#125;; &#x2F;&#x2F;末尾显示添加空字符</span><br><span class="line">char c3&#x3D;&quot;c++&quot;; &#x2F;&#x2F;末尾自动添加空字符</span><br></pre></td></tr></table></figure>

<p>注意到通过字符数组初始化和字符串常量初始化并不完全相同的。因为字符串常量包含一个额外的空字符用于结束字符串，用它来初始化创建数组时，末尾会自动添加空字符。所以c1的长度是3，后两者的长度是4，并且字符数组c2和c3都被称为C风格字符串，而字符数组c1不是C风格字符串。</p>
<p>规定C风格的字符串都是以NULL空字符(‘\0’)作为终结符结尾。由于它是字符串的终止符，但它本身并不是字符串的一部分，所以字符串的长度并不包括NULL字节，如strlen函数。而且C标准库中提供的各种字符串处理函数都要求提供的字符串或字符数组必须以空字符结束，否则会出现不可预料的结果。如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char c[]&#x3D;&#123;&#39;c&#39;,&#39;+&#39;,&#39;+&#39;&#125;;</span><br><span class="line">printf(&quot;%d\n&quot;,strlen(c)); &#x2F;&#x2F;结果输出为6，这是不正确的</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-标准库中的字符串处理函数"><a href="#2-标准库中的字符串处理函数" class="headerlink" title="2 标准库中的字符串处理函数"></a>2 标准库中的字符串处理函数</h3><p>C标准库中头文件<code>定义了两组字符串函数(C++中用</code>表示)。</p>
<ul>
<li>第一组函数的名字以str开头，它主要处理以’\0’结尾的字符串，所以字符串内部不能包含任何’\0’字符。</li>
<li>第二组函数的名字以mem开头，主要考虑非字符串内部含有零值的情形，它能够处理任意的字节序列，操作与字符串函数类似</li>
<li>除了memmove函数外，其他函数都没定义重叠对象间的行为</li>
</ul>
<p>为了提高程序在不同机器上的移植性，利用typedef定义新类型名，即<code>typedef unsigned int size_t</code>。 程序员必须要保证目标字符数组的空间能够足以存放结果字符串(有可能存在字符数组溢出的危险)</p>
<ul>
<li>字符串处理类</li>
</ul>
<p>如下表为字符串处理函数说明，变量s,t的类型是<code>char *</code>, cs和ct的类型是<code>const char *</code>;n的类型为<code>size_t</code>,c的类型为<code>int</code>。</p>
<p><img src="https://images0.cnblogs.com/blog2015/678327/201507/311507392043956.png" alt="img"></p>
<ul>
<li>内存操作类</li>
</ul>
<p>按照字节数组的方式操作对象，提供一个高效的函数接口(提供字节流的访问)。其中s,t类型是<code>void *</code> ， cs，ct的类型是<code>const void *</code>; n类型为<code>size_t</code>，c类型为<code>int</code>。</p>
<p><img src="https://images0.cnblogs.com/blog2015/678327/201507/311507530171602.png" alt="img"></p>
<p>总结起来，头文件&lt; string.h&gt;实现了如下函数：</p>
<ul>
<li>长度计算、长度不受限和受限的复制、连接和比较版本的函数</li>
<li>基础字符串查找(查找一个字符、一组字符和匹配一个子串)、高级字符串查找（查找子串前缀位置、返回token标记）</li>
<li>处理任意字节序列的内存操作如复制、比较、查找和初始化等函数</li>
</ul>
<h2 id="P20"><a href="#P20" class="headerlink" title="P20"></a>P20</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组矩阵</span></span><br><span class="line">和一维数组一样</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6c%E5%B8%A6%E4%BD%A0%E9%A3%9E/" class="post-title-link" itemprop="url">带你学c带你飞（day1）小甲鱼视频</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-20 15:59:53 / Modified: 17:23:04" itemprop="dateCreated datePublished" datetime="2020-04-20T15:59:53-05:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P1"><a href="#P1" class="headerlink" title="P1"></a>P1</h2><p>打广告</p>
<h2 id="P2"><a href="#P2" class="headerlink" title="P2"></a>P2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.所有的 C 语言程序都需要包含 main() 函数。 代码从 main() 函数开始执行。</span><br><span class="line"></span><br><span class="line">2.&#x2F;* ... *&#x2F; 用于注释说明。</span><br><span class="line"></span><br><span class="line">3.printf() 用于格式化输出到屏幕。printf() 函数在 &quot;stdio.h&quot; 头文件中声明。</span><br><span class="line"></span><br><span class="line">4.stdio.h 是一个头文件 (标准输入输出头文件) , #include 是一个预处理命令，用来引入头文件。 当编译器遇到 printf() 函数时，如果没有找到 stdio.h 头文件，会发生编译错误。</span><br><span class="line"></span><br><span class="line">5.return 0; 语句用于表示退出程序。</span><br></pre></td></tr></table></figure>

<h2 id="P3"><a href="#P3" class="headerlink" title="P3"></a>P3</h2><p>打印 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">print</span>\</span><br><span class="line">f(<span class="string">"hi"</span>&#125;)<span class="comment">//反斜杠表示读下一行开头，可以运行，换行符\n;</span></span><br></pre></td></tr></table></figure>

<h2 id="p4"><a href="#p4" class="headerlink" title="p4"></a>p4</h2><p>变量名：英文字母数字，下划线组成，开头必须是字母下划线。</p>
<p>c有32个关键字</p>
<p>第一类：数 据类型关键 字</p>
<p>A基本数据类 型（5个）：</p>
<p>void： 声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果。</p>
<p>char： 字符型类型数据，属于整型数据的一种。</p>
<p>int： 整型数据，通常为编译器指定的机器字长。</p>
<p>float： 单精度浮点型数据，属于浮点数据的一种，小数点后保存6位。</p>
<p>double： 双精度浮点型数据，属于浮点数据的一种，比float保存的精度高，小数点后保存15/16位。</p>
<p>B类型修饰关 键字（4个）：</p>
<p>short ：修饰int，短整型数据，可省略被修饰的int。 </p>
<p>long ：修饰int，长整形数据，可省略被修饰的int。 </p>
<p>signed ：修饰整型数据，有符号数据类型。 </p>
<p>unsigned： 修饰整型数据，无符号数据类型。</p>
<p>C复杂类型关 键字（5个）：</p>
<p>struct ：结构体声明。 </p>
<p>union ：共用体声明。 </p>
<p>enum ：枚举声明。 </p>
<p>typedef ：声明类型别名。 </p>
<p>sizeof ：得到特定类型或特定类型变量的大小。</p>
<p>D存储级别关 键字（6个）：</p>
<p>auto ：指定为自动变量，由编译器自动分配及释放。通常在栈上分配。 </p>
<p>static ：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部。 </p>
<p>register ：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通 过寄存器而不是堆栈传递参数。 </p>
<p>extern ：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的。 </p>
<p>const ：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改 </p>
<p>volatile ：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存 中取得该变量的值。</p>
<p>第二类：流 程控制关键 字</p>
<p>A跳转结构（4 个）：</p>
<p>return ：用在函数体中，返回特定值（或者是void值，即不返回值）。 </p>
<p>continue： 结束当前循环，开始下一轮循环。 </p>
<p>break ：跳出当前循环或switch结构。 </p>
<p>goto ：无条件跳转语句。</p>
<p>B分支结构（5 个）：</p>
<p>if ：条件语句。 </p>
<p>else： 条件语句否定分支（与if连用）。 </p>
<p>switch： 开关语句（多重分支语句）。 </p>
<p>case ：开关语句中的分支标记。 </p>
<p>default： 开关语句中的“其他”分治，可选。</p>
<p>C循环结构（3 个）：</p>
<p>for ：for循环结构，for(1;2;3)4;的执行顺序为1-&gt;2-&gt;4-&gt;3-&gt;2…循环，其中2为循环条件。 </p>
<p>do：do循环结构，do 1 while(2);的执行顺序是1-&gt;2-&gt;1…循环，2为循环条件。 </p>
<p>while： while循环结构，while(1) 2;的执行顺序是1-&gt;2-&gt;1…循环，1为循环条件， 以上循环语句，当循环条件 表达式为真则继续循环，为假则跳出循环。</p>
<p>c99新增5个关键字</p>
<p>1、<strong>inline</strong>关键字用来定义一个类的内联函数，引入它的主要原因是用它替代C中表达式形式的宏定义</p>
<p>引入原因：C语言是一个效率很高的语言，这种宏定义在形式及使用上像一个函数，但它使用预处理器实现，没有了<strong>参数压栈，代码生成</strong>等一系列的操作</p>
<p>2、<strong>restrict</strong>关键字只用于限定指针；该关键字用于告知编译器，所有修改该指针所指向内容的操作全部都是基于(base on)该指针的，即不存在其它进行修改操作的途径；这样的后果是帮助编译器进行更好的代码优化，生成更有效率的汇编代码。</p>
<p>3、<strong>_Bool</strong>关键字是用于表示布尔值。包含标准头文件 stdbool.h 后，我们可以用 bool 代替 _Bool ，true 代替 1 ，false 代替 0 。</p>
<p>4、<strong>_Complex</strong>and<strong>_Imaginary</strong>关键字</p>
<p>C99标准中定义的复数类型如下：float_Complex; float_Imaginary; double_Complex; double_Imaginary; long double_Complex; long double_Imaginary.</p>
<p>头文件中定义了complex和imaginary宏,并将它们扩展为_Complex和_Imaginary,因此在编写新的应用程序时,应该使用头文件中的complex和imaginary宏。</p>
<p><strong>C语言32个关键字（C99新增5个、C11新增7个）</strong></p>
<p>按年份起始：</p>
<p><strong>auto break case char const continue default do</strong> <strong>double else enum extern float for goto if</strong> <strong>int long register return short signed sizeof static</strong> <strong>struct switch typedef union unsigned void volatile while</strong>1999年12月16日，ISO推出了C99标准，该标准新增了5个C语言关键字：</p>
<p>inline restrict _Bool _Complex _Imaginary2011年12月8日，ISO发布C语言的新标准C11，该标准新增了7个C语言关键字：</p>
<p>_Alignas _Alignof _Atomic _Static_assert _Noreturn _Thread_local _Generic</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%d<span class="comment">//int</span></span><br><span class="line">%c<span class="comment">//char</span></span><br><span class="line">%<span class="number">11.9</span><span class="comment">//11位，小数点后9位</span></span><br><span class="line">gcc test.c -o test &amp;&amp; ./test <span class="comment">//这个-o可以改a.out为你想要的名字， 用&amp;&amp;可以合并编译运行两个阶段，而/ 的意思：目录级别分隔符</span></span><br><span class="line">. 的意思：当前目录</span><br><span class="line">./a 的意思就是：当前目录下文件名为“a”的文件。</span><br><span class="line">Linux中还有 .. 代表上抄级目录</span><br></pre></td></tr></table></figure>

<h2 id="P5"><a href="#P5" class="headerlink" title="P5"></a>P5</h2><p>字符常量单引号，字符串常量双引号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义, 标识符全大写，宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 标识符 常量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.1415926535</span></span><br></pre></td></tr></table></figure>

<p>C++ 语言可以用const 来定义常量，也可以用#define 来定义常量。但是前者比后者有更多的优点：<br>（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。<br>（2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。规则5-2-1：在C++ 程序中只使用const 常量而不使用宏常量，即const 常量完全取代宏常量。</p>
<p>2.实现机制</p>
<p>宏是预处理命令，即在预编译阶段进行字节替换。const常量是变量，在执行时const定义的只读变量在程序运行过程中只有一份拷贝（因为它是全局的只读变量，存放在静态存储区的只读数据区。根据c/c++语法，当你声明该量为常量，即告诉程序和编译器，你不希望此量被修改。 程序的实现，为了保护常量，特将常量都放在受保护的静态存储区内。凡是试图修改这个区域内的值，都将被视为非法，并报错。 这不能理解为凡是字符串都是放在静态存储区域的。这个跟数据类型没有关系，而是这个量是变量还是常量的问题。例如，一个字符串变量就是可以被修改的。 这种静态存储区域的保护机制是由编译器实现的，而非存储该值的内存的电器属性。换言之，实质上内存永远都可以被用户随意修改，只是编译器给用户的代码注入了一些自己的保护代码，通过软件手段将这段内存软保护起来。这种保护在汇编级别可以轻松突破，其保护也就无效了。）。</p>
<p>3.用法区别</p>
<p>define宏定义和const常变量区别：<br>1.define是宏定义，程序在预处理阶段将用define定义的内容进行了替换。因此程序运行时，常量表中并没有用define定义的常量，系统不为它分配内存。const定义的常量，在程序运行时在常量表中，系统为它分配内存。<br>2.define定义的常量，预处理时只是直接进行了替换。所以编译时不能进行数据类型检验。const定义的常量，在编译时进行严格的类型检验，可以避免出错。3.define定义表达式时要注意“边缘效应”，例如如下定义：<br>#define N 2+3 //我们预想的N值是5，我们这样使用N，int a = N/2; //我们预想的a的值是2.5，可实际上a的值是3.5原因在于在预处理阶段，编译器将 a = N/2处理成了 a = 2+3/2；这就是宏定义的字符串替换的“边缘效应”因此要如下定义：#define N (2+3)。const定义表达式没有上述问题。const定义的常量叫做常变量原因有二：const定义常量像变量一样检查类型；const可以在任何地方定义常量，编译器对它的处理过程与变量相似，只是分配内存的地方不同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串常量， <span class="string">'\0'</span>遇到这个会知道字符串结束了</span><br></pre></td></tr></table></figure>



<h2 id="P6"><a href="#P6" class="headerlink" title="P6"></a>P6</h2><p>C语言数据类型的分类方式如下：</p>
<ul>
<li>基本类型<ul>
<li>标准整数类型，以及扩充的整数类型</li>
<li>实数浮点类型，以及复数浮点类型</li>
</ul>
</li>
<li>枚举类型</li>
<li>void类型</li>
<li>派生类型<ul>
<li>指针类型</li>
<li>数组类型</li>
<li>结构类型</li>
</ul>
</li>
<li>联合类型</li>
<li>函数类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(a);<span class="comment">//return size of a</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span>);<span class="comment">//return 4单位是字节</span></span><br></pre></td></tr></table></figure>

<p>objective-c 中的BOOL 实际上是一种对带符号的字符类型（signed char）的类型定义（typedef），它使用8位的存储空间。通过#define指令把YES定义为1，NO定义为0。</p>
<p>C99标准定义了一个新的关键字_Bool，提供了布尔类内型。以前，C程序员总是使用自己的方法定义布尔类型。0表示false，非0表示true。</p>
<p>可能使用char类型表示一个布尔类型，也可能使用int类型表示一个布尔类型。</p>
<p>1、类型不同百 :  BOOL为int型 , bool为布尔型  </p>
<p>2、长度不同 : bool只有一个字节 , BOOL长度视实际环境来定，一般可认为是4个字节 </p>
<p>3、取值不同 :bool取值false和true，是0和1的区别； false可以代表0，但true有很多种，并非度只有1。  </p>
<p>4、bool表示布尔型变量，也就是逻辑型变量的定义符，以英国数学家、布尔代数的奠基人乔治·布尔（George Boole）命名。</p>
<p>总结bool是true，false，而_Bool is 0,1 但是都是1字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign <span class="keyword">unsigned</span><span class="comment">//带符号不带符号，如果不用会引发栈溢出栈泄露</span></span><br></pre></td></tr></table></figure>

<h2 id="P7"><a href="#P7" class="headerlink" title="P7"></a>P7</h2><p>printf是输出一个字符串，putchar输出一个char。</p>
<p>printf格式字符：</p>
<table>
<thead>
<tr>
<th>打印格式</th>
<th>对应数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>int</td>
<td>接受整数值并将它表示为有符号的十进制整数</td>
</tr>
<tr>
<td>%hd</td>
<td>short int</td>
<td>短整数</td>
</tr>
<tr>
<td>%hu</td>
<td>unsigned short</td>
<td>无符号短整数</td>
</tr>
<tr>
<td>%o</td>
<td>unsigned int</td>
<td>无符号8进制整数</td>
</tr>
<tr>
<td>%u</td>
<td>unsigned int</td>
<td>无符号10进制整数</td>
</tr>
<tr>
<td>%x,%X</td>
<td>unsigned int</td>
<td>无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF</td>
</tr>
<tr>
<td>%f</td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td>%lf</td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td>%e,%E</td>
<td>double</td>
<td>科学计数法表示的数，此处”e”的大小写代表在输出时用的”e”的大小写</td>
</tr>
<tr>
<td>%c</td>
<td>char</td>
<td>字符型。可以把输入的数字按照ASCII码相应转换’对应的字符</td>
</tr>
<tr>
<td>%s</td>
<td>char *</td>
<td>字符串。输出字符串中的字符直至字符串中的空字符（字符串以’\0‘结尾，这个’\0’即空字符）</td>
</tr>
<tr>
<td>%p</td>
<td>void *</td>
<td>以16进制形式输出指针</td>
</tr>
<tr>
<td>%%</td>
<td>%</td>
<td>输出一个百分号</td>
</tr>
</tbody></table>
<p> %d  整形 int</p>
<p> %f  浮点型 float</p>
<p> %c  字符型  char </p>
<p> %hd 短整型  short</p>
<p> %ld  长整形  long</p>
<p> %lld  长长整形  long long </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1b</span>it=<span class="number">8</span> bytes</span><br><span class="line"><span class="built_in">pow</span>(a,b)<span class="comment">//#include &lt;math.h&gt;,一般打印需要&lt;stdio.h&gt;, a的b次方</span></span><br><span class="line">gcc -lm test.c &amp;&amp; ./a.out<span class="comment">// warning:overflow in implicit constant conversion</span></span><br><span class="line">  unsign <span class="keyword">int</span> 用%u，sign <span class="keyword">int</span>用%d</span><br></pre></td></tr></table></figure>

<p>使用math.h中声明的库函数还有一点特殊之处，gcc命令行必须加-lm选项，因为数学函数位于libm.so库文件中（这些库文件通常位于/lib目录下），-lm选项告诉编译器，我们程序中用到的数学函数要到这个库文件里找。本书用到的大部分库函数（例如printf）位于libc.so库文件中，使用libc.so中的库函数在编译时不需要加-lc选项，当然加了也不算错，因为这个选项是gcc的默认选项。</p>
<p>  C标准主要由两部分组成，一部分描述C的语法，另一部分描述C标准库。C标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型 声明和宏定义。要在一个平台上支持C语言，不仅要实现C编译器，还要实现C标准库，这样的实现才算符合C标准。不符合C标准的实现也是存在的，例如很多单 片机的C语言开发工具中只有C编译器而没有完整的C标准库。</p>
<p>在Linux平台上最广泛使用的C函数库是glibc，其中包括C标准库的实现。几乎所有C程序都要调用glibc的库函数，所以glibc是Linux平台C程序运行的基础。glibc提供一组头文件和一组库文件，最基本、最常用的C标准库函数和系统函数在libc.so库文件中，几乎所有C程序的运行都依赖于libc.so，有些做数学计算的C程序依赖于libm.so，以后我们还会看到多线程的C程序依赖于libpthread.so。以后我说libc时专指libc.so这个库文件，而说glibc时指的是glibc提供的所有库文件。</p>
<h3 id="1-原码"><a href="#1-原码" class="headerlink" title="1. 原码"></a>1. 原码</h3><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p>
<blockquote>
<p>[+1]原 = 0000 0001</p>
<p>[-1]原 = 1000 0001</p>
</blockquote>
<p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p>
<blockquote>
<p>[1111 1111 , 0111 1111]</p>
</blockquote>
<p>即</p>
<blockquote>
<p>[-127 , 127]</p>
</blockquote>
<p>原码是人脑最容易理解和计算的表示方式.</p>
<h3 id="2-反码"><a href="#2-反码" class="headerlink" title="2. 反码"></a>2. 反码</h3><p>反码的表示方法是:</p>
<p>正数的反码是其本身</p>
<p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反</p>
<p>[-1] = [10000001]原 = [11111110]反</p>
</blockquote>
<p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p>
<h3 id="3-补码"><a href="#3-补码" class="headerlink" title="3. 补码"></a>3. 补码</h3><p>补码的表示方法是:</p>
<p>正数的补码就是其本身</p>
<p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p>
<h2 id="P8"><a href="#P8" class="headerlink" title="P8"></a>P8</h2><p>字符用ASCII字符表写的，常用的ascii: 空格的ASCII码值为32；数字0到9的ASCII码值分别为48到57；大写字母“A”到“Z”的ASCII码值分别为65到90；小写字母“a”到“z”的ASCII码值分别为97到到122。</p>
<p>字符类型是特殊的整型，ascii有0-255个字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="number">170</span>；<span class="comment">//这是正数，若不用unsigned，则是负数</span></span><br></pre></td></tr></table></figure>

<p>字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[length];<span class="comment">//0 to length-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经典问题</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">2</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hi\n"</span>);<span class="comment">//会出现错误，因为字符数组a没有\0,改法： char a[3]=&#123;'a','b'，'\0'&#125;;</span></span><br><span class="line"><span class="keyword">char</span> a[]=<span class="string">"hi"</span>;<span class="comment">//字符串常量</span></span><br></pre></td></tr></table></figure>

<h2 id="P9"><a href="#P9" class="headerlink" title="P9"></a>P9</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>/<span class="number">3</span>=<span class="number">1</span></span><br><span class="line"><span class="number">5</span>%<span class="number">3</span>=<span class="number">2</span></span><br><span class="line"><span class="number">5.0</span>%<span class="number">3.0</span><span class="comment">//出错</span></span><br><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line"> <span class="number">1</span>+<span class="number">2.0</span>;<span class="comment">//-&gt;1.0+2.0</span></span><br><span class="line"> <span class="number">1</span>+(<span class="keyword">int</span>)<span class="number">2.0</span>;<span class="comment">//-&gt;3 </span></span><br><span class="line"><span class="number">1</span>+(<span class="keyword">int</span>)<span class="number">1.8</span>;<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h2 id="P10"><a href="#P10" class="headerlink" title="P10"></a>P10</h2><p>关系表达式返回0，1</p>
<p>c语言中没有true，false，只有1，0</p>
<p>c和java一样采用短路与和短路或</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E4%B9%8Bc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E4%B9%8Bc/" class="post-title-link" itemprop="url">小甲鱼之c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-19 16:01:44 / Modified: 16:30:59" itemprop="dateCreated datePublished" datetime="2020-04-19T16:01:44-05:00">2020-04-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P1-C-和OO思想"><a href="#P1-C-和OO思想" class="headerlink" title="P1:C++和OO思想"></a>P1:C++和OO思想</h2><p>经典面向对象java 一样封装继承多态</p>
<h2 id="P2-P4-从小程序说起"><a href="#P2-P4-从小程序说起" class="headerlink" title="P2-P4:从小程序说起"></a>P2-P4:从小程序说起</h2><p>1.类，异常，对象都是c++特有的</p>
<ol start="2">
<li><p>整形数组求和：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">addArray</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n)</span></span>;<span class="comment">//在main用前需要声明</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> data[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">size</span>=<span class="keyword">sizeof</span>(data)/<span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"data size: %ld\n"</span>,<span class="keyword">sizeof</span>(data));<span class="comment">//不要用%d，c99报错</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"answer :%d\n"</span>,addArray(data,<span class="built_in">size</span>));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">addArray</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"data size: %ld\n"</span>,<span class="keyword">sizeof</span>(<span class="built_in">array</span>));</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">       sum+=<span class="built_in">array</span>[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/*data size: 40</span></span><br><span class="line"><span class="comment">   data size: 8</span></span><br><span class="line"><span class="comment">   answer :45</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++版本</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">二叉树之遍历</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-19 10:17:19" itemprop="dateCreated datePublished" datetime="2020-04-19T10:17:19-05:00">2020-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-10 16:11:40" itemprop="dateModified" datetime="2020-06-10T16:11:40-05:00">2020-06-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h2><p>难度中等477收藏分享切换为英文关注反馈</p>
<p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//recursion</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt;  res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.left, res);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.right !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.right,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//iterative</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        Stack&lt;TreeNode&gt; s= <span class="keyword">new</span> Stack();</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur=cur.left;    </span><br><span class="line">            &#125;</span><br><span class="line">            cur=s.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></h2><p>难度中等454收藏分享切换为英文关注反馈</p>
<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//recursion</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; levels= <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(level==levels.size())</span><br><span class="line">                levels.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">            levels.get(level).add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">                helper(root.left, level+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">                helper(root.right, level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> levels;</span><br><span class="line">            helper(root, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> levels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;&#x2F;&#x2F;iterative</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; levels&#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        if(root&#x3D;&#x3D;null) return levels;</span><br><span class="line">        Queue&lt;TreeNode&gt; q&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        int level&#x3D;0;</span><br><span class="line">        while(!q.isEmpty())&#123;</span><br><span class="line">            levels.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">            int level_l&#x3D; q.size();</span><br><span class="line">            for(int i&#x3D;0; i&lt;level_l;i++)&#123;</span><br><span class="line">                TreeNode n&#x3D;q.remove();</span><br><span class="line">                levels.get(level).add(n.val);</span><br><span class="line">                if(n.left !&#x3D;null) q.add(n.left);</span><br><span class="line">                if(n.right !&#x3D;null) q.add(n.right);</span><br><span class="line">            &#125;  </span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        return levels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103. 二叉树的锯齿形层次遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. 二叉树的锯齿形层次遍历</a></h2><p>难度中等183收藏分享切换为英文关注反馈</p>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回锯齿形层次遍历如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode node, <span class="keyword">int</span> level, List&lt;List&lt;Integer&gt;&gt; results)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level &gt;= results.size()) &#123;</span><br><span class="line">      LinkedList&lt;Integer&gt; newLevel = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">      newLevel.add(node.val);</span><br><span class="line">      results.add(newLevel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        results.get(level).add(node.val);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        results.get(level).add(<span class="number">0</span>, node.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) DFS(node.left, level + <span class="number">1</span>, results);</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) DFS(node.right, level + <span class="number">1</span>, results);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    DFS(root, <span class="number">0</span>, results);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Approach-1-BFS-Breadth-First-Search"><a href="#Approach-1-BFS-Breadth-First-Search" class="headerlink" title="Approach 1: BFS (Breadth-First Search)"></a>Approach 1: BFS (Breadth-First Search)</h4><p><strong>Intuition</strong></p>
<p>Following the description of the problem, the most intuitive solution would be the <em>BFS</em> (Breadth-First Search) approach through which we traverse the tree level-by-level.</p>
<p>The default ordering of BFS within a single level is from left to right. As a result, we should adjust the BFS algorithm a bit to generate the desired zigzag ordering.</p>
<blockquote>
<p>One of the keys here is to store the values that are of the same level with the <code>deque</code> (double-ended queue) data structure, where we could add new values on either end of a queue.</p>
</blockquote>
<p>So if we want to have the ordering of <strong>FIFO</strong> (first-in-first-out), we simply append the new elements to the <em>tail</em> of the queue, <em>i.e.</em> the late comers stand last in the queue. While if we want to have the ordering of <strong>FILO</strong> (first-in-last-out), we insert the new elements to the <em>head</em> of the queue, <em>i.e.</em> the late comers jump the queue.</p>
<p><img src="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/Figures/103/103_BFS.png" alt="pic"></p>
<p><strong>Algorithm</strong></p>
<p>There are several ways to implement the BFS algorithm.</p>
<ul>
<li>One way would be that we run a two-level nested loop, with the <em>outer loop</em> iterating each level on the tree, and with the <em>inner loop</em> iterating each node within a single level. </li>
<li>We could also implement BFS with a single loop though. The trick is that we append the nodes to be visited into a queue and we separate nodes of different levels with a sort of <strong>delimiter</strong> (<em>e.g.</em> an empty node). The delimiter marks the end of a level, as well as the beginning of a new level.</li>
</ul>
<p>Here we adopt the <em>second</em> approach above. One can start with the normal BFS algorithm, upon which we add a touch of <em>zigzag*order with the help of <code>deque</code>. For each level, we start from an empty deque container to hold all the values of the same level. Depending on the ordering of each level, *i.e.</em> either from-left-to-right or from-right-to-left, we decide at which end of the deque to add the new element:</p>
<p><img src="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/Figures/103/103_deque.png" alt="pic"></p>
<ul>
<li>For the ordering of from-left-to-right (FIFO), we <em>append</em> the new element to the <strong><em>tail\</em></strong> of the queue, so that the element that comes late would get out late as well. As we can see from the above graph, given an input sequence of <code>[1, 2, 3, 4, 5]</code>, with FIFO ordering, we would have an output sequence of <code>[1, 2, 3, 4, 5]</code>.</li>
<li>For the ordering of from-right-to-left (FILO), we <em>insert</em> the new element to the <strong><em>head\</em></strong> of the queue, so that the element that comes late would get out first. With the same input sequence of <code>[1, 2, 3, 4, 5]</code>, with FILO ordering, we would obtain an output sequence of <code>[5, 4, 3, 2, 1]</code>.</li>
</ul>
<iframe src="https://leetcode.com/playground/CuzksuMQ/shared" frameborder="0" width="100%" height="500" name="CuzksuMQ" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p>Note: as an alternative approach, one can also implement the normal BFS algorithm first, which would generate the ordering of from-left-to-right for each of the levels. Then, at the end of the algorithm, we can simply <strong><em>reverse\</em></strong> the ordering of certain levels, following the zigzag steps.</p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li><p>Time Complexity: O(N)O(<em>N</em>), where N<em>N</em> is the number of nodes in the tree.</p>
<ul>
<li>We visit each node once and only once.</li>
<li>In addition, the insertion operation on either end of the deque takes a constant time, rather than using the array/list data structure where the inserting at the head could take the O(K)O(<em>K</em>) time where K<em>K</em> is the length of the list.</li>
</ul>
</li>
<li><p>Space Complexity: O(N)O(<em>N</em>) where N<em>N</em> is the number of nodes in the tree.</p>
<ul>
<li><p>The main memory consumption of the algorithm is the <code>node_queue</code> that we use for the loop, apart from the array that we use to keep the final output.</p>
</li>
<li><p>As one can see, at any given moment, the <code>node_queue</code> would hold the nodes that are <em>at most</em> across two levels. Therefore, at most, the size of the queue would be no more than 2⋅L2⋅<em>L</em>, assuming L<em>L</em> is the maximum number of nodes that might reside on the same level. Since we have a binary tree, the level that contains the most nodes could occur to consist all the leave nodes in a full binary tree, which is roughly L=N2<em>L</em>=2<em>N</em>. As a result, we have the space complexity of 2⋅N2=N2⋅2<em>N</em>=<em>N</em> in the worst case.</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Approach-2-DFS-Depth-First-Search"><a href="#Approach-2-DFS-Depth-First-Search" class="headerlink" title="Approach 2: DFS (Depth-First Search)"></a>Approach 2: DFS (Depth-First Search)</h4><p><strong>Intuition</strong></p>
<p>Though not intuitive, we could also obtain the <em>BFS</em> traversal ordering via the <em>DFS</em> (Depth-First Search) traversal in the tree.</p>
<blockquote>
<p>The trick is that during the DFS traversal, we maintain the results in a <em>global</em> array that is indexed by the level, <em>i.e.</em> the element <code>array[level]</code> would contain all the nodes that are at the same level. The global array would then be referred and updated at each step of DFS.</p>
</blockquote>
<p><img src="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/Figures/103/103_DFS.png" alt="pic"></p>
<p>Similar with the above modified BFS algorithm, we employ the <code>deque</code> data structure to hold the nodes that are of the same level, and we alternate the insertion direction (<em>i.e.</em> either to the head or to the tail) to generate the desired output ordering.</p>
<p><strong>Algorithm</strong></p>
<p>Here we implement the DFS algorithm via <em>recursion</em>. We define a recursive function called <code>DFS(node, level)</code> which only takes care of the current <code>node</code> which is located at the specified <code>level</code>. Within the function, here are three steps that we would perform:</p>
<ul>
<li>If this is the first time that we visit any node at the <code>level</code>, <em>i.e.</em> the deque for the level does not exist, then we simply create the deque with the current node value as the initial element.</li>
<li>If the deque for this level exists, then depending on the ordering, we insert the current node value either to the head or to the tail of the queue.</li>
<li>At the end, we <em>recursively</em> call the function for each of its child nodes.</li>
</ul>
<iframe src="https://leetcode.com/playground/5kZDYMsP/shared" frameborder="0" width="100%" height="500" name="5kZDYMsP" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p>It might go without saying that, one can also implement the DFS traversal via <strong><em>iteration\</em></strong> rather than recursion, which could be one of the followup questions by an interviewer.</p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time Complexity: O(N)O(<em>N</em>), where N<em>N</em> is the number of nodes in the tree.<ul>
<li>Same as the previous BFS approach, we visit each node once and only once.</li>
</ul>
</li>
<li>Space Complexity: O(H)O(<em>H</em>), where H<em>H</em> is the height of the tree, <em>i.e.</em> the number of levels in the tree, which would be roughly log⁡2Nlog2<em>N</em>.<ul>
<li>Unlike the BFS approach, in the DFS approach, we do not need to maintain the <code>node_queue</code> data structure for the traversal.</li>
<li>However, the function recursion would incur additional memory consumption on the <em>function call stack</em>. As we can see, the size of the call stack for any invocation of <code>DFS(node, level)</code> would be exactly the number of <code>level</code> that the current node resides on. Therefore, the space complexity of our DFS algorithm is O(log⁡2N)O(log2<em>N</em>) which is much better than the BFS approach. </li>
</ul>
</li>
</ul>
<h2 id="107-二叉树的层次遍历-II"><a href="#107-二叉树的层次遍历-II" class="headerlink" title="107. 二叉树的层次遍历 II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. 二叉树的层次遍历 II</a></h2><p>难度简单235收藏分享切换为英文关注反馈</p>
<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其自底向上的层次遍历为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; levels= <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(levels.size()==level) </span><br><span class="line">            levels.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        levels.get(level).add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">            helper(node.left,level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">            helper(node.right,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> levels;</span><br><span class="line">        helper(root,<span class="number">0</span>);</span><br><span class="line">        Collections.reverse(levels);</span><br><span class="line">        <span class="keyword">return</span> levels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="How-to-traverse-the-tree"><a href="#How-to-traverse-the-tree" class="headerlink" title="How to traverse the tree"></a>How to traverse the tree</h4><p>There are two general strategies to traverse a tree:</p>
<ul>
<li><p><em>Depth First Search</em> (<code>DFS</code>)</p>
<p>In this strategy, we adopt the <code>depth</code> as the priority, so that one would start from a root and reach all the way down to a certain leaf, and then back to root to reach another branch.</p>
<p>The DFS strategy can further be distinguished as <code>preorder</code>, <code>inorder</code>, and <code>postorder</code> depending on the relative order among the root node, left node, and right node.</p>
</li>
<li><p><em>Breadth First Search</em> (<code>BFS</code>)</p>
<p>We scan through the tree level by level, following the order of height, from top to bottom. The nodes on a higher level would be visited before the ones on lower levels.</p>
</li>
</ul>
<p>In the following figure the nodes are enumerated in the order you visit them, please follow <code>1-2-3-4-5</code> to compare different strategies.</p>
<p><img src="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/Figures/107/ddfs.png" alt="postorder"></p>
<p>Here the problem is to implement split-level BFS traversal : <code>[[4, 5], [2, 3], [1]]</code>. That means we could use one of the <code>Node-&gt;Left-&gt;Right</code> techniques: BFS or DFS Preorder.</p>
<p>We already discussed <a href="https://leetcode.com/articles/binary-tree-right-side-view/" target="_blank" rel="noopener">three different ways</a> to implement iterative BFS traversal with the queue, and compared <a href="https://leetcode.com/problems/deepest-leaves-sum/solution/" target="_blank" rel="noopener">iterative BFS vs. iterative DFS</a>. Let’s use this article to discuss the two most simple and fast techniques:</p>
<ul>
<li>Recursive DFS.</li>
<li>Iterative BFS with two queues.</li>
</ul>
<blockquote>
<p>Note, that both approaches are root-to-bottom traversals, and we’re asked to provide bottom-up output. To achieve that, the final result should be reversed.</p>
</blockquote>
<hr>
<h4 id="Approach-1-Recursion-DFS-Preorder-Traversal"><a href="#Approach-1-Recursion-DFS-Preorder-Traversal" class="headerlink" title="Approach 1: Recursion: DFS Preorder Traversal"></a>Approach 1: Recursion: DFS Preorder Traversal</h4><p><strong>Intuition</strong></p>
<p>The first step is to ensure that the tree is not empty. The second step is to implement the recursive function <code>helper(node, level)</code>, which takes the current node and its level as the arguments.</p>
<p><strong>Algorithm for the Recursive Function</strong></p>
<p>Here is its implementation:</p>
<ul>
<li>Initialize the output list <code>levels</code>. The length of this list determines which level is currently updated. You should compare this level <code>len(levels)</code> with a node level <code>level</code>, to ensure that you add the node on the correct level. If you’re still on the previous level - add the new level by adding a new list into <code>levels</code>.</li>
<li>Append the node value to the last level in <code>levels</code>.</li>
<li>Process recursively child nodes if they are not <code>None</code>: <code>helper(node.left / node.right, level + 1)</code>.</li>
</ul>
<p><strong>Implementation</strong></p>
<p><img src="data:image/png;base64,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jlznaOwodY7UNbKyOo1DL805+qk4Qm8RBFIRkaROEkQSghsckbRYGsRBJHVgT1J9+QPifZAACZAACZAACZBAgAhQIAUILIctm0BR58gRRxrIoOIIJXW+iqOio0NIYSsukhwnyUTSQjhJFElFmfFnEiABEiABEiABEiCB0glQIJXOhZ8GiEAx56h3bwtkGDtqrImjEwhkgHOkcedY6DUyKlyjup2eo6LOUWmXVq5I0nK7ha5IakAnqTR+/IwESIAESIAESIAESMAhQIHEv4QaI1BMHCGQQdPqxo4sRRxpIAOEEdY5QiBDReLIvYGSIilfgxsaNHB7ko4XEUlxLLdzofGdBEiABEiABEiABEigGAEKpGI4+EugCKxcubIwkKGn6xxVozhyr7t8kVQkuKFUJ8npY3LH4jsJkAAJkAAJkAAJkMCpR4AC6dR75jV+xxBHCGR47733BOIIUd5jyhNHXnWO1EXy1TkqeUMViqSCcruY2Dhp377kOkkUSSV58ncSIAESIAESIAESOJUIUCCdSk+7Fu7VnKMKxFEoeo4Kyuq8Ko7wc2XFkXuLZYmkzp2dCHD0JC1dulhiEQHevmS6HUWSy5HvJEACJEACJEACJHCqEaBAOtWeeA3er+scTVTnqFdBWR2coxMnNK0us0ggg9tzVOAcOYvAhlrMd1Uut0yRpBHgJ05kaE/SPBVJ36tI0p6k9h1LRIBTJFWFPY8lARIgARIgARIggbpKgAKprj65IL9ut+fILau7//4HZfTIMeWKI48KpeoSRy6eMkVS564FIsl1kiiSXGZ8JwESIAESIAESIIFTmQAF0qn89AN074XO0cSJjnNUS+LIvb1yRVJGhiwq1pNEJ8nlxncSIAESIAESIAESOBUJUCCdik89gPdcKI6KBDI4zlHWybI6XdHV1jlClLeW1QXCOSp5i+WJpOPHVSQtUidJF5NluV1JcvydBEiABEiABEiABE4tAhRIp9bzDujdQhw99thj8v7770vPPn1snaPRo9yyumxnEdgi4giBDEirq+6yurJusjyRhL6ohQvmyRINboiJQbodnaSyOPJzEiABEiABEiABEqjPBCiQ6vPTrcF7W7FihUV5QxxZIIOV1Y0u6DkqIo4QyBClSXU1LI5cFOWKpAwVSRbcsFiioxtI+w4USS43vpMACZAACZAACZDAqUKAAulUedIB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" alt="Current"></p>
<p>1 / 16</p>
<iframe src="https://leetcode.com/playground/H8Jue6Az/shared" frameborder="0" width="100%" height="480" name="H8Jue6Az" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li><p>Time complexity: O(N)O(<em>N</em>) since each node is processed exactly once.</p>
</li>
<li><p>Space complexity: O(N)O(<em>N</em>) to keep the output structure which contains N<em>N</em> node values. </p>
</li>
</ul>
<hr>
<h4 id="Approach-2-Iteration-BFS-Traversal"><a href="#Approach-2-Iteration-BFS-Traversal" class="headerlink" title="Approach 2: Iteration: BFS Traversal"></a>Approach 2: Iteration: BFS Traversal</h4><p><strong>Algorithm</strong></p>
<p>The recursion above could be rewritten in the iteration form.</p>
<p>Let’s keep each tree level in the <em>queue</em> structure, which typically orders elements in a FIFO (first-in-first-out) manner. In Java one could use <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html" target="_blank" rel="noopener"><code>ArrayDeque</code> implementation of the <code>Queue</code> interface</a>. In Python using <a href="https://docs.python.org/3/library/queue.html" target="_blank" rel="noopener"><code>Queue</code> structure</a> would be an overkill since it’s designed for a safe exchange between multiple threads and hence requires locking which leads to a performance downgrade. In Python the queue implementation with a fast atomic <code>append()</code> and <code>popleft()</code> is <a href="https://docs.python.org/3/library/collections.html#collections.deque" target="_blank" rel="noopener"><code>deque</code></a>.</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>Initialize two queues: one for the current level, and one for the next. Add root into <code>nextLevel</code> queue.</li>
<li>While <code>nextLevel</code> queue is not empty:<ul>
<li>Initialize the current level <code>currLevel = nextLevel</code>, and empty the next level <code>nextLevel</code>.</li>
<li>Iterate over the current level queue:<ul>
<li>Append the node value to the last level in <code>levels</code>.</li>
<li>Add first <em>left</em> and then <em>right</em> child node into <code>nextLevel</code> queue.</li>
</ul>
</li>
</ul>
</li>
<li>Return reversed <code>levels</code>.</li>
</ul>
<p><strong>Implementation</strong></p>
<iframe src="https://leetcode.com/playground/H5xJuMYH/shared" frameborder="0" width="100%" height="500" name="H5xJuMYH" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity: O(N)O(<em>N</em>) since each node is processed exactly once.</li>
<li>Space complexity: O(N)O(<em>N</em>) to keep the output structure which contains N<em>N</em> node values.</li>
</ul>
<h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">230. 二叉搜索树中第K小的元素</a></h2><p>难度中等216收藏分享切换为英文关注反馈</p>
<p>给定一个二叉搜索树，编写一个函数 <code>kthSmallest</code> 来查找其中第 <strong>k</strong> 个最小的元素。</p>
<p><strong>说明：</strong><br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong><br>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 <code>kthSmallest</code> 函数？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;recursion</span><br><span class="line">class Solution &#123;</span><br><span class="line">    private ArrayList&lt;Integer&gt; helper(TreeNode root, ArrayList&lt;Integer&gt; ans)&#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return ans;</span><br><span class="line">        helper(root.left, ans);</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        helper(root.right,ans);</span><br><span class="line">        return ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public int kthSmallest(TreeNode root, int k) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; num&#x3D; helper(root, new ArrayList&lt;Integer&gt;());</span><br><span class="line">        return num.get(k-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;iterative</span><br><span class="line">class Solution &#123;</span><br><span class="line">  public int kthSmallest(TreeNode root, int k) &#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack &#x3D; new LinkedList&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">      while (root !&#x3D; null) &#123;</span><br><span class="line">        stack.add(root);</span><br><span class="line">        root &#x3D; root.left;</span><br><span class="line">      &#125;</span><br><span class="line">      root &#x3D; stack.removeLast();</span><br><span class="line">      if (--k &#x3D;&#x3D; 0) return root.val;</span><br><span class="line">      root &#x3D; root.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="How-to-traverse-the-tree-1"><a href="#How-to-traverse-the-tree-1" class="headerlink" title="How to traverse the tree"></a>How to traverse the tree</h4><p>There are two general strategies to traverse a tree:</p>
<ul>
<li><p><em>Depth First Search</em> (<code>DFS</code>)</p>
<p>In this strategy, we adopt the <code>depth</code> as the priority, so that one would start from a root and reach all the way down to certain leaf, and then back to root to reach another branch.</p>
<p>The DFS strategy can further be distinguished as <code>preorder</code>, <code>inorder</code>, and <code>postorder</code> depending on the relative order among the root node, left node and right node.</p>
</li>
<li><p><em>Breadth First Search</em> (<code>BFS</code>)</p>
<p>We scan through the tree level by level, following the order of height, from top to bottom. The nodes on higher level would be visited before the ones with lower levels.</p>
</li>
</ul>
<p>On the following figure the nodes are numerated in the order you visit them, please follow <code>1-2-3-4-5</code> to compare different strategies.</p>
<p><img src="https://leetcode.com/problems/kth-smallest-element-in-a-bst/Figures/230/bfs_dfs.png" alt="postorder"></p>
<blockquote>
<p>To solve the problem, one could use the property of BST : inorder traversal of BST is an array sorted in the ascending order.</p>
</blockquote>
<hr>
<h4 id="Approach-1-Recursion"><a href="#Approach-1-Recursion" class="headerlink" title="Approach 1: Recursion"></a>Approach 1: Recursion</h4><p>It’s a very straightforward approach with O(N)O(<em>N</em>) time complexity. The idea is to build an inorder traversal of BST which is an array sorted in the ascending order. Now the answer is the <code>k - 1</code>th element of this array.</p>
<p><img src="https://leetcode.com/problems/kth-smallest-element-in-a-bst/Figures/230/inorder.png" alt="bla"></p>
<iframe src="https://leetcode.com/playground/7SGJHL4u/shared" frameborder="0" width="100%" height="293" name="7SGJHL4u" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li><p>Time complexity : O(N)O(<em>N</em>) to build a traversal.</p>
</li>
<li><p>Space complexity : O(N)O(<em>N</em>) to keep an inorder traversal. </p>
</li>
</ul>
<hr>
<h4 id="Approach-2-Iteration"><a href="#Approach-2-Iteration" class="headerlink" title="Approach 2: Iteration"></a>Approach 2: Iteration</h4><p>The above recursion could be converted into iteration, with the help of stack. This way one could speed up the solution because there is no need to build the entire inorder traversal, and one could stop after the kth element.</p>
<p><img src="https://leetcode.com/problems/kth-smallest-element-in-a-bst/Figures/230/iteration.png" alt="bla"></p>
<iframe src="https://leetcode.com/playground/NFRsiKKu/shared" frameborder="0" width="100%" height="361" name="NFRsiKKu" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li><p>Time complexity : O(H+k)O(<em>H</em>+<em>k</em>), where H<em>H</em> is a tree height. This complexity is defined by the stack, which contains at least H+k<em>H</em>+<em>k</em> elements, since before starting to pop out one has to go down to a leaf. This results in O(log⁡N+k)O(log<em>N</em>+<em>k</em>) for the balanced tree and O(N+k)O(<em>N</em>+<em>k</em>) for completely unbalanced tree with all the nodes in the left subtree.</p>
</li>
<li><p>Space complexity : O(H+k)O(<em>H</em>+<em>k</em>), the same as for time complexity, O(N+k)O(<em>N</em>+<em>k</em>) in the worst case, and O(log⁡N+k)O(log<em>N</em>+<em>k</em>) in the average case. </p>
</li>
</ul>
<hr>
<h4 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up"></a>Follow up</h4><blockquote>
<p>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
</blockquote>
<p><a href="https://leetcode.com/articles/insert-into-a-bst/" target="_blank" rel="noopener">Insert</a> and <a href="https://leetcode.com/articles/delete-node-in-a-bst/" target="_blank" rel="noopener">delete</a> in a BST were discussed last week, the time complexity of these operations is O(H)O(<em>H</em>), where H<em>H</em> is a height of binary tree, and H=log⁡N<em>H</em>=log<em>N</em> for the balanced tree.</p>
<p>Hence without any optimisation insert/delete + search of kth element has O(2H+k)O(2<em>H</em>+<em>k</em>) complexity. How to optimise that?</p>
<p>That’s a design question, basically we’re asked to implement a structure which contains a BST inside and optimises the following operations :</p>
<ul>
<li>Insert</li>
<li>Delete</li>
<li>Find kth smallest</li>
</ul>
<p>Seems like a database description, isn’t it? Let’s use here the same logic as for <a href="https://leetcode.com/articles/lru-cache/" target="_blank" rel="noopener">LRU cache</a> design, and combine an indexing structure (we could keep BST here) with a double linked list.</p>
<p>Such a structure would provide:</p>
<ul>
<li>O(H)O(<em>H</em>) time for the insert and delete.</li>
<li>O(k)O(<em>k</em>) for the search of kth smallest.</li>
</ul>
<p><img src="https://leetcode.com/problems/kth-smallest-element-in-a-bst/Figures/230/linked_list2.png" alt="bla"></p>
<p>The overall time complexity for insert/delete + search of kth smallest is O(H+k)O(<em>H</em>+<em>k</em>) instead of O(2H+k)O(2<em>H</em>+<em>k</em>).</p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity for insert/delete + search of kth smallest: O(H+k)O(<em>H</em>+<em>k</em>), where H<em>H</em> is a tree height. O(log⁡N+k)O(log<em>N</em>+<em>k</em>) in the average case, O(N+k)O(<em>N</em>+<em>k</em>) in the worst case.</li>
<li>Space complexity : O(N)O(<em>N</em>) to keep the linked list.</li>
</ul>
<h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener">501. 二叉搜索树中的众数</a></h2><p>难度简单109收藏分享切换为英文关注反馈</p>
<p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<ul>
<li>结点左子树中所含结点的值小于等于当前结点的值</li>
<li>结点右子树中所含结点的值大于等于当前结点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ul>
<p>例如：<br>给定 BST <code>[1,null,2,2]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><code>返回[2]</code>.</p>
<p><strong>提示</strong>：如果众数超过1个，不需考虑输出顺序</p>
<p><strong>进阶：</strong>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val &#x3D; val;</span><br><span class="line"> *         this.left &#x3D; left;</span><br><span class="line"> *         this.right &#x3D; right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    private List&lt;Integer&gt; items;</span><br><span class="line">    private int maxCount;</span><br><span class="line">    private int curCount;</span><br><span class="line">    private TreeNode pre;</span><br><span class="line"></span><br><span class="line">    public int[] findMode(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null)</span><br><span class="line">            return new int[0];</span><br><span class="line">        items &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F; 这里设置为1是因为 在递归中 BST中最左边的结点被跳过了，作为初状态 该结点值出现一次，记录的出现最多次数一开始也为1</span><br><span class="line">        maxCount &#x3D; 1;</span><br><span class="line">        curCount &#x3D; 1;</span><br><span class="line">        midTraversal(root);</span><br><span class="line">        &#x2F;&#x2F; 最右端结点的处理，从递归中看，最后一个结点与前一个结点相等只更新了curCount的值；不相等则只考虑到倒数第二个结点。</span><br><span class="line">        if(curCount &gt; maxCount)</span><br><span class="line">            return new int[]&#123;pre.val&#125;;</span><br><span class="line">        if(curCount &#x3D;&#x3D; maxCount)</span><br><span class="line">            items.add(pre.val);</span><br><span class="line">        int[] res &#x3D; new int[items.size()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; res.length; i++)</span><br><span class="line">            res[i] &#x3D; items.get(i);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void midTraversal(TreeNode x) &#123;</span><br><span class="line">        if (x &#x3D;&#x3D; null) return;</span><br><span class="line">        midTraversal(x.left);</span><br><span class="line">        if(pre !&#x3D; null)&#123;</span><br><span class="line">            if(x.val !&#x3D; pre.val)&#123; &#x2F;&#x2F; 说明上一个值的结点数量已经统计完成 要看出现次数的情况</span><br><span class="line">                if(curCount &gt; maxCount)&#123; &#x2F;&#x2F; 出现次数更多，清空之前的出现少的数，更新最大出现次数</span><br><span class="line">                    maxCount &#x3D; curCount;</span><br><span class="line">                    items.clear();</span><br><span class="line">                    items.add(pre.val);</span><br><span class="line">                &#125;</span><br><span class="line">                else if(curCount &#x3D;&#x3D; maxCount)&#123; &#x2F;&#x2F; 不止一个众数</span><br><span class="line">                    items.add(pre.val);</span><br><span class="line">                &#125;</span><br><span class="line">                curCount &#x3D; 1; &#x2F;&#x2F; 当前值与上一个结点值不同，重置计数</span><br><span class="line">            &#125;</span><br><span class="line">            else curCount++; &#x2F;&#x2F; 当前值与上一个结点值相同，当前值的出现次数增加。</span><br><span class="line">        &#125;</span><br><span class="line">        pre &#x3D; x;</span><br><span class="line">        midTraversal(x.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用List即时存放出现最多的数</p>
<pre><code>private List&lt;Integer&gt; items;
private int maxCount;
private int curCount;
private TreeNode pre;

public int[] findMode(TreeNode root) {
    if (root == null)
        return new int[0];
    items = new ArrayList&lt;&gt;();
    // 这里设置为1是因为 在递归中 BST中最左边的结点被跳过了，作为初状态 该结点值出现一次，记录的出现最多次数一开始也为1
    maxCount = 1;
    curCount = 1;
    midTraversal(root);
    // 最右端结点的处理，从递归中看，最后一个结点与前一个结点相等只更新了curCount的值；不相等则只考虑到倒数第二个结点。
    if(curCount &gt; maxCount)
        return new int[]{pre.val};
    if(curCount == maxCount)
        items.add(pre.val);
    int[] res = new int[items.size()];
    for (int i = 0; i &lt; res.length; i++)
        res[i] = items.get(i);
    return res;
}

private void midTraversal(TreeNode x) {
    if (x == null) return;
    midTraversal(x.left);
    if(pre != null){
        if(x.val != pre.val){ // 说明上一个值的结点数量已经统计完成 要看出现次数的情况
            if(curCount &gt; maxCount){ // 出现次数更多，清空之前的出现少的数，更新最大出现次数
                maxCount = curCount;
                items.clear();
                items.add(pre.val);
            }
            else if(curCount == maxCount){ // 不止一个众数
                items.add(pre.val);
            }
            curCount = 1; // 当前值与上一个结点值不同，重置计数
        }
        else curCount++; // 当前值与上一个结点值相同，当前值的出现次数增加。
    }
    pre = x;
    midTraversal(x.right);
}</code></pre><p>思路分析：</p>
<p>找众数，说明要统计出现次数，一般会直接想到搞个哈希表来计数（就像后面的方法二）。但是如果一个有序数组中统计出现次数，使用双指针就能很好解决，类似的这里给我们的树不是一般的树，而是BST，中序遍历相当于遍历有序数组。</p>
<p>利用BST这个特性，我们不需要使用哈希表来计数。如同双指针的做法，这里也需要记录上一个结点TreeNode pre;这样才能知道当前结点值与谁比较；另外还需要记录某个值的出现次数curCount，以及出现次数的最大值maxCount（否则你咋知道谁出现最多次）。并且这里遍历过程中的众数信息需要记录（List存放众数）及更新。</p>
<p>在中序遍历中：</p>
<p>如果pre == null，说明这是遍历的第一个结点，不需要处理（第一个结点的初条件在主函数中设定）。</p>
<p>如果当前结点值与上一个结点值相等，那么这个数字的出现次数+1。</p>
<p>否则，我们先去判断，上一个数字的出现次数curCount与之前的最大出现次数maxCount谁更大：</p>
<p>如果上一个数字出现次数最大，需要更新众数信息。首先更新最大出现次数maxCount = curCount;。然后将之前记录的众数清空，再将上一个数字放入items.clear(); items.add(pre.val);<br>如果一个数字出现次数等于最大出现次数，那么目前来看，它也是可能的众数，加入列表items.add(pre.val);<br>否则，上一个数字一定不是众数，不管它，继续保留List中的数字。<br>最后，重置计数curCount = 1;，表示当前数字出现一次了。<br>然后更新pre = x;</p>
<p>回到主函数：</p>
<p>特殊情况处理，root == null直接返回new int[0]。<br>然后上文提到的初始化，因为最左边结点在中序的递归中不处理，所以，我们要首先将maxCount = 1，因为树非空总会有数字出现一次，然后curCount = 1，代表最左边结点被我们在主函数计数了。<br>调用辅助函数后，还需要处理最后一个结点的值，因为在递归中不会有再下一个结点值与之不相等然后来判断它的值是否为众数。<br>所以如果curCount &gt; maxCount，说明最后一个结点才是唯一众数，return new int[]{pre.val};<br>如果curCount == maxCount，说明最后一个结点也是众数，items.add(pre.val);<br>最后，将List转成数组返回。<br>这个题要注意边界的考虑！</p>
<p>时间复杂度为<br>O<br>(<br>n<br>)<br>O(n)， 不考虑递归调用栈的话，空间复杂度可以认为是常数，中间状态List的元素并不会很多。</p>
<h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">543. 二叉树的直径</a></h2><p>难度简单372收藏分享切换为英文关注反馈</p>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p><strong>示例 :</strong><br>给定二叉树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>

<p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=depth(node.left);</span><br><span class="line">        <span class="keyword">int</span> r=depth(node.right);</span><br><span class="line">        ans=Math.max(l+r+<span class="number">1</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l,r)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> ans-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Approach-1-Depth-First-Search-Accepted"><a href="#Approach-1-Depth-First-Search-Accepted" class="headerlink" title="Approach #1: Depth-First Search [Accepted]"></a>Approach #1: Depth-First Search [Accepted]</h4><p><strong>Intuition</strong></p>
<p>Any path can be written as two <em>arrows</em> (in different directions) from some node, where an arrow is a path that starts at some node and only travels down to child nodes.</p>
<p>If we knew the maximum length arrows <code>L, R</code> for each child, then the best path touches <code>L + R + 1</code> nodes.</p>
<p><strong>Algorithm</strong></p>
<p>Let’s calculate the depth of a node in the usual way: max(depth of node.left, depth of node.right) + 1. While we do, a path “through” this node uses 1 + (depth of node.left) + (depth of node.right) nodes. Let’s search each node and remember the highest number of nodes used in some path. The desired length is 1 minus this number.</p>
<iframe src="https://leetcode.com/playground/6X2NvWFQ/shared" frameborder="0" width="100%" height="310" name="6X2NvWFQ" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time Complexity: O(N)<em>O</em>(<em>N</em>). We visit every node once.</li>
<li>Space Complexity: O(N)<em>O</em>(<em>N</em>), the size of our implicit call stack during our depth-first search.</li>
</ul>
<h2 id="663-Equal-Tree-Partition"><a href="#663-Equal-Tree-Partition" class="headerlink" title="663. Equal Tree Partition"></a>663. Equal Tree Partition</h2><p>Given a binary tree with <code>n</code> nodes, your task is to check if it’s possible to partition the tree to two trees which have the equal sum of values after removing <strong>exactly</strong> one edge on the original tree.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Input:     </span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  10 10</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   2   3</span><br><span class="line"></span><br><span class="line">Output: True</span><br><span class="line">Explanation: </span><br><span class="line">    5</span><br><span class="line">   &#x2F; </span><br><span class="line">  10</span><br><span class="line">      </span><br><span class="line">Sum: 15</span><br><span class="line"></span><br><span class="line">   10</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 2    3</span><br><span class="line"></span><br><span class="line">Sum: 15</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:     </span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2  10</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   2   20</span><br><span class="line"></span><br><span class="line">Output: False</span><br><span class="line">Explanation: You can&#39;t split the tree into two trees with equal sum after removing exactly one edge on the tree.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>The range of tree node value is in the range of [-100000, 100000].</li>
<li>1 &lt;= n &lt;= 10000</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack &lt;Integer&gt; seen;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        seen.push(sum(node.left)+sum(node.right)+node.val);</span><br><span class="line">        <span class="keyword">return</span> seen.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkEqualTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        seen=<span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">int</span> total=sum(root);</span><br><span class="line">        seen.pop();</span><br><span class="line">        <span class="keyword">if</span>(total%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i: seen)</span><br><span class="line">                <span class="keyword">if</span>(i==total/<span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Approach-1-Depth-First-Search-Accepted-1"><a href="#Approach-1-Depth-First-Search-Accepted-1" class="headerlink" title="Approach #1: Depth-First Search [Accepted]"></a>Approach #1: Depth-First Search [Accepted]</h4><p><strong>Intuition and Algorithm</strong></p>
<p>After removing some edge from <code>parent</code> to <code>child</code>, (where the <code>child</code> cannot be the original <code>root</code>) the subtree rooted at <code>child</code> must be half the sum of the entire tree.</p>
<p>Let’s record the sum of every subtree. We can do this recursively using depth-first search. After, we should check that half the sum of the entire tree occurs somewhere in our recording (and not from the total of the entire tree.)</p>
<p>Our careful treatment and analysis above prevented errors in the case of these trees:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">-1</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line"> <span class="number">0</span></span><br><span class="line">  \</span><br><span class="line">   <span class="number">0</span></span><br></pre></td></tr></table></figure>

<iframe src="https://leetcode.com/playground/bY5XPeuF/shared" frameborder="0" width="100%" height="378" name="bY5XPeuF" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time Complexity: O(N)<em>O</em>(<em>N</em>) where N<em>N</em> is the number of nodes in the input tree. We traverse every node.</li>
<li>Space Complexity: O(N)<em>O</em>(<em>N</em>), the size of <code>seen</code> and the implicit call stack in our DFS.</li>
</ul>
<h2 id="1339-分裂二叉树的最大乘积"><a href="#1339-分裂二叉树的最大乘积" class="headerlink" title="1339. 分裂二叉树的最大乘积"></a><a href="https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree/" target="_blank" rel="noopener">1339. 分裂二叉树的最大乘积</a></h2><p>难度中等26收藏分享切换为英文关注反馈</p>
<p>给你一棵二叉树，它的根为 <code>root</code> 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。</p>
<p>由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/sample_1_1699.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4,5,6]</span><br><span class="line">输出：110</span><br><span class="line">解释：删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10）</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/sample_2_1699.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3,4,null,null,5,6]</span><br><span class="line">输出：90</span><br><span class="line">解释：移除红色的边，得到 2 棵子树，和分别是 15 和 6 。它们的乘积为 90 （15*6）</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [2,3,9,10,7,8,6,5,4,11,1]</span><br><span class="line">输出：1025</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>每棵树最多有 <code>50000</code> 个节点，且至少有 <code>2</code> 个节点。</li>
<li>每个节点的值在 <code>[1, 10000]</code> 之间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;Integer&gt; all&#x3D;new ArrayList();</span><br><span class="line">    private int sum(TreeNode subroot)&#123;</span><br><span class="line">        if(subroot&#x3D;&#x3D;null) return 0;</span><br><span class="line">        int l&#x3D;sum(subroot.left);</span><br><span class="line">        int r&#x3D;sum(subroot.right);</span><br><span class="line">        int total&#x3D;l+r+subroot.val;</span><br><span class="line">        all.add(total);</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">    public int maxProduct(TreeNode root) &#123;</span><br><span class="line">        long total&#x3D;sum(root);</span><br><span class="line">        long ans&#x3D;0;</span><br><span class="line">        for(long i:all)</span><br><span class="line">            ans&#x3D;Math.max(ans,i*(total-i));</span><br><span class="line">        return (int)(ans%1000000007);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Approach-1-One-Pass-DFS"><a href="#Approach-1-One-Pass-DFS" class="headerlink" title="Approach 1: One-Pass DFS"></a>Approach 1: One-Pass DFS</h4><p><strong>Intuition</strong></p>
<p>To get started, we’re just going to pretend that integers can be infinitely large.</p>
<p>We’ll use the following tree example.</p>
<p><img src="https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/Figures/1339/tree.png" alt="The tree example."></p>
<p>There are <code>n - 1</code> edges in a tree with <code>n</code> nodes, and so for this question there are <code>n - 1</code> different possible ways of splitting the tree into a pair of subtrees. Here are 4 out of the 10 possible ways.</p>
<p><img src="https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/Figures/1339/4_trees.png" alt="4 possible ways of splitting the original tree."></p>
<p>Of these 4 possible ways, the best is the third one, which has a product of <code>651</code>.</p>
<p>To make it easier to discuss the solution, we’ll name each of the subtrees in a pair.</p>
<ol>
<li>One of the new subtrees is rooted at the node below the removed edge. We’ll call it <code>Subtree 1</code>.</li>
<li>The other is rooted at the root node of the original tree, and is missing the subtree below the removed edge. We’ll call it <code>Subtree 2</code>.</li>
</ol>
<p><img src="https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/Figures/1339/subtree_pair.png" alt="Diagram of Subtree 1 and Subtree 2."></p>
<p>Remember that we’re required to find the pair of subtrees that have the maximum product. This is done by calculating the sum of each subtree and then multiplying them together. The sum of a subtree is the sum of all the nodes in it.</p>
<p>Calculating the sum of <code>Subtree 1</code> can be done using the following recursive tree algorithm. The root of <code>Subtree 1</code> is passed into the function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree_sum</span><span class="params">(subroot)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> subroot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left_sum = tree_sum(subroot.left)</span><br><span class="line">    right_sum = tree_sum(subroot.right)</span><br><span class="line">    <span class="keyword">return</span> subroot.val + left_sum + right_sum</span><br><span class="line"></span><br><span class="line">print(tree_sum(sub_tree_1_root))</span><br></pre></td></tr></table></figure>

<p>This algorithm calculates the sum of a subtree by calculating the sum of its left subtree, sum of its right subtree, and then adding these to the root value. The sum of the left and right subtrees is done in the same way by the recursion.</p>
<p><img src="https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/Figures/1339/sum_recursive.png" alt="Diagram illustrating how sums are calculated."></p>
<p>If you’re confused by this recursive summing algorithm, it might help you to <a href="https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/534/" target="_blank" rel="noopener">read this article</a> on solving tree problems with recursive (top down) algorithms.</p>
<p>We still need a way to calculate the sum of <code>Subtree 2</code>. Recall that <code>Subtree 2</code> is the tree we get by removing <code>Subtree 1</code>. The only way we could directly use the above summing algorithm to calculate the sum of <code>Subtree 2</code> is to actually <em>remove</em> the edge above <code>Subtree 1</code> first. Otherwise, <code>Subtree 1</code> would be automatically traversed too.</p>
<p>A simpler way is to recognise that <code>Sum(Subtree 2) = Sum(Entire Tree) - Sum(Sub Tree 1)</code>.</p>
<p><img src="https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/Figures/1339/sum_rearranging.png" alt="Diagram showing the relationship between subtree sums."></p>
<p>Another benefit of this approach is that we only need to calculate <code>Sum(Entire Tree)</code> once. Then, for each <code>Sum(Subtree 1)</code> we calculate, we can immediately calculate <code>Sum(Subtree 2)</code> as an O(1)<em>O</em>(1) operation.</p>
<p>Recall how the summing algorithm above worked. The recursive function is called once for every node in the tree (i.e. subtree rooted at that node), and returns the sum of that subtree.</p>
<p><img src="https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/Figures/1339/sum_full_recursion.png" alt="Diagram of the recursive calls of part of the tree."></p>
<p>Therefore we can simply gather up all the possible <code>Subtree 1</code> sums with a list as follows:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">subtree_1_sums = [] <span class="comment"># All Subtree 1 sums will go here.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree_sum</span><span class="params">(subroot)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> subroot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left_sum = tree_sum(subroot.left)</span><br><span class="line">    right_sum = tree_sum(subroot.right)</span><br><span class="line">    subtree_sum = left_sum + right_sum + subroot.val</span><br><span class="line">    subtree_1_sums.append(subtree_sum) <span class="comment"># Add this subtree sum to the list.</span></span><br><span class="line">    <span class="keyword">return</span> subtree_sum</span><br><span class="line"></span><br><span class="line">total_sum = tree_sum(root) <span class="comment"># Call with the root of the entire tree.</span></span><br><span class="line">print(subtree_1_sums) <span class="comment"># This is all the subree sums.</span></span><br></pre></td></tr></table></figure>

<p>Now that we have a list of the sums for all possible <code>Subtree 1</code>‘s, we can calculate what the corresponding <code>Subtree 2</code> would be for each of them, and then calculate the product, keeping track of the best seen so far.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Call the function.</span></span><br><span class="line">subtree_1_sums = [] <span class="comment"># Populate by function call.</span></span><br><span class="line">total_sum = tree_sum(root)</span><br><span class="line"></span><br><span class="line">best_product = <span class="number">0</span></span><br><span class="line"><span class="comment"># Find the best product.</span></span><br><span class="line"><span class="keyword">for</span> subtree_1_sum <span class="keyword">in</span> subtree_1_sums:</span><br><span class="line">    subtree_2_sum = total_sum - subtree_1_sum</span><br><span class="line">    product = subtree_1_sum * subtree_2_sum</span><br><span class="line">    best_product = max(best_product, product)</span><br><span class="line"></span><br><span class="line">print(best_product)</span><br></pre></td></tr></table></figure>

<p>The question also says we need to take the answer modulo <code>10 ^ 9 + 7</code>. Expanded out, this number is <code>1,000,000,007</code>. So when we return the product, we’ll do:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">best_product % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>

<p>Only take the <em>final product</em> modulo <code>10 ^ 9 + 7</code>. Otherwise, you might not be correctly comparing the products.</p>
<hr>
<p>Up until now, we’ve assumed that integers can be of an infinite size. This is a safe assumption for Python, but not for Java. For Java (and other languages that use a 32-bit integer by default), we’ll need to think carefully about where integer overflows could occur.</p>
<p>The problem statement states that there can be up to <code>50000</code> nodes, each with a value of up to <code>10000</code>. Therefore, the maximum possible subtree sum would be <code>50,000 * 10,000 = 500,000,000</code>. This is well below the size of a 32-bit integer (<code>2,147,483,647</code>). Therefore, it is impossible for an integer overflow to occur during the summing phase with these constraints.</p>
<p>However, multiplying the subtrees could be a problem. For example, if we had subtrees of <code>100,000,000</code> and <code>400,000,000</code>, then we’d get a total product of <code>400,000,000,000,000,000</code> which is definitely larger than a 32-bit integer, and therefore and overflow would occur!</p>
<p>The easiest solution is to instead use 64-bit integers. In Java, this is the <code>long</code> primitive type. The largest possible product would be <code>250,000,000 * 250,000,000 = 62,500,000,000,000,000‬</code>, which is below the maximum a 64-bit integer can hold.</p>
<p>In Approach #3, we discuss other ways of solving the problem <em>if you only had access to 32-bit integers</em>.</p>
<p><strong>Algorithm</strong></p>
<iframe src="https://leetcode.com/playground/beQ6Fss6/shared" frameborder="0" width="100%" height="480" name="beQ6Fss6" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<p>n<em>n</em> is the number of nodes in the tree.</p>
<ul>
<li><p>Time Complexity : O(n)<em>O</em>(<em>n</em>).</p>
<p>The recursive function visits each of the n<em>n</em> nodes in the tree exactly once, performing an O(1)<em>O</em>(1) recursive operation on each. This gives a total of O(n)<em>O</em>(<em>n</em>)</p>
<p>There are n−1<em>n</em>−1 numbers in the list. Each of these is processed with an O(1)<em>O</em>(1) operation, giving a total of O(n)<em>O</em>(<em>n</em>) time for this phase too.</p>
<p>In total, we have O(n)<em>O</em>(<em>n</em>).</p>
</li>
<li><p>Space Complexity O(n)<em>O</em>(<em>n</em>).</p>
<p>There are two places that extra space is used.</p>
<p>Firstly, the recursion is putting frames on the stack. The maximum number of frames at any one time is the maximum depth of the tree. For a balanced tree, this is around O(log⁡ n)<em>O</em>(log<em>n</em>), and in the worst case (a long skinny tree) it is O(n)<em>O</em>(<em>n</em>).</p>
<p>Secondly, the list takes up space. It contains n−1<em>n</em>−1 numbers at the end, so it too is O(n)<em>O</em>(<em>n</em>).</p>
<p>In both the average case and worst case, we have a total of O(n)<em>O</em>(<em>n</em>) space used by this approach.</p>
</li>
</ul>
<p>Something you might have realised is that the subtree pair that leads to the largest product is the pair with the smallest difference between them. Interestingly, this fact doesn’t help us much with optimizing the algorithm. This is because subtree sums are <em>not<em>obtained in sorted order, and so any attempt to sort them (and thus find the nearest to middle directly) will cost at least O(n log⁡ n)</em>O</em>(<em>n</em>log<em>n</em>) to do. With the overall algorithm, even with the linear search, only being O(n)<em>O</em>(<em>n</em>), this is strictly worse. The only situation this insight becomes useful is if you <em>have</em> to solve the problem using only 32-bit integers. The reason for this is discussed in Approach #3.</p>
<hr>
<h4 id="Approach-2-Two-Pass-DFS"><a href="#Approach-2-Two-Pass-DFS" class="headerlink" title="Approach 2: Two-Pass DFS"></a>Approach 2: Two-Pass DFS</h4><p><strong>Intuition</strong></p>
<p>Instead of putting the <code>Subtree 1</code> sums into a separate list, we can do 2 separate tree summing traversals.</p>
<ol>
<li>Calculate the sum of the entire tree.</li>
<li>Check the product we’d get for each subtree.</li>
</ol>
<p>Calculating the total sum is done in the same way as before.</p>
<p>Finding the maximum product is similar, except requires a variable outside of the function to keep track of the maximum product seen so far.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximum_product</span><span class="params">(subroot, total)</span>:</span></span><br><span class="line">    best = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recursive_helper</span><span class="params">(subroot)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> best</span><br><span class="line">        <span class="keyword">if</span> subroot <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_sum = recursive_helper(subroot.left)</span><br><span class="line">        right_sum = recursive_helper(subroot.right)</span><br><span class="line">        total_sum = left_sum + right_sum + subroot.val</span><br><span class="line">        product = total_sum * (tree_total_sum - total_sum)</span><br><span class="line">        best = max(best, product)</span><br><span class="line">        <span class="keyword">return</span> total_sum</span><br><span class="line">    recursive_helper(subroot)</span><br><span class="line">    <span class="keyword">return</span> best</span><br></pre></td></tr></table></figure>

<p><strong>Algorithm</strong></p>
<p>It is possible to combine the 2 recursive functions into a single one that is called twice, however the side effects of the functions (changing of class variables) hurt code readability and can be confusing. For this reason, the code below uses 2 separate functions.</p>
<iframe src="https://leetcode.com/playground/NyJCwW9Q/shared" frameborder="0" width="100%" height="500" name="NyJCwW9Q" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<p>n<em>n</em> is the number of nodes in the tree.</p>
<ul>
<li><p>Time Complexity : O(n)<em>O</em>(<em>n</em>).</p>
<p>Each recursive function visits each of the n<em>n</em> nodes in the tree exactly once, performing an O(1)<em>O</em>(1) recursive operation on each. This gives a total of O(n)<em>O</em>(<em>n</em>).</p>
</li>
<li><p>Space Complexity O(n)<em>O</em>(<em>n</em>).</p>
<p>The recursion is putting frames on the stack. The maximum number of frames at any one time is the maximum depth of the tree. For a balanced tree, this is around O(log⁡ n)<em>O</em>(log<em>n</em>), and in the worst case (a long skinny tree) it is O(n)<em>O</em>(<em>n</em>).</p>
<p>Because we use worst case for complexity analysis, we say this algorithm uses O(n)<em>O</em>(<em>n</em>) space. However, it’s worth noting that as long as the tree is fairly balanced, the space usage will be a lot nearer to O(log⁡ n)<em>O</em>(log<em>n</em>).</p>
</li>
</ul>
<hr>
<h4 id="Approach-3-Advanced-Strategies-for-Dealing-with-32-Bit-Integers"><a href="#Approach-3-Advanced-Strategies-for-Dealing-with-32-Bit-Integers" class="headerlink" title="Approach 3: Advanced Strategies for Dealing with 32-Bit Integers"></a>Approach 3: Advanced Strategies for Dealing with 32-Bit Integers</h4><p><strong>Intuition</strong></p>
<p><em>This is an advanced bonus section that discusses ways of solving the problem using only 32-bit integers. It’s not essential for an interview, although could be useful depending on your choice of programming language. Some of the ideas might also help with potential follow up questions. This section assumes prior experience with introductory modular arithmetic.</em></p>
<p>We’ll additionally assume that the 32-bit integer we’re working with is <em>signed</em>, so has a <strong>maximum</strong> value of <code>2,147,483,647</code>.</p>
<p>What if your chosen programming language only supported 32-bit integers, and you had no access to a Big Integer library? Could we still solve this problem? What are the problems we’d need to address?</p>
<p>The solutions above relied on being able to multiply 2 numbers of up to 30 (signed) bits each without overflow. Because the number of bits in the product add, we would expect the product to require ~60 bits to represent. Using a 64-bit integer was therefore enough. Additionally, with a modulus of <code>1,000,000,007</code>, the <em>final</em> product, after taken to the modulus, will always fit within a <em>32-bit</em> integer.</p>
<p>However, we’re now assuming that we only have 32-bit integers. When working with 32-bit integers, we must <em>always</em> keep the total below <code>2,147,483,647</code>, even during intermediate calculations. Therefore, we’ll need a way of doing the math within this restriction. One way to do the multiplication safely is to write an algorithm using the same underlying idea as <a href="https://en.wikipedia.org/wiki/Modular_exponentiation" target="_blank" rel="noopener">modular exponentiation</a>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">modularMultiplication</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> product = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currentSum = a;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit = b % <span class="number">2</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit == <span class="number">1</span>) &#123;</span><br><span class="line">            product += currentSum;</span><br><span class="line">            product %= m;</span><br><span class="line">        &#125;</span><br><span class="line">        currentSum &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        currentSum %= m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There is one possible pitfall with this though. We are supposed to return the calculation for the <em>largest</em> product, determined <strong>before</strong> the modulus is taken.</p>
<p>For example, consider the following 2 products:</p>
<ol>
<li><code>34,000 * 30,000 = 1,020,000,000</code> becomes <code>1,020,000,000 % 1,000,000,007 = 19,999,993</code>.</li>
<li><code>30,000 * 30,000 = 900,000,000</code> doesn’t change because <code>900,000,000 % 1,000,000,007 = 900,000,000</code>.</li>
</ol>
<p>So if we were to compare them <em>before</em> taking the modulus, product 1 would be larger, which is correct. But if we compared them after, then product 2 is larger, which is incorrect.</p>
<p>Therefore, we need a way to determine which product will be the biggest, without actually calculating them. Then once we know which is biggest, we can use our method for calculating a product modulo <code>1,000,000,007</code> without going over <code>2,147,483,647</code>.</p>
<p>The trick is to realise that <code>Sum(Subtree 1) + Sum(Subtree 2)</code> is constant, but <code>Sum(Subtree 1) * Sum(Subtree 2)</code> increases as <code>Sum(Subtree 1) - Sum(Subtree 2)</code> gets nearer to 0, i.e. as the sum of the subtrees is more balanced. A good way of visualising this is to imagine you have <code>X</code> meters of fence and need to make a <em>rectangular</em> enclosure for some sheep. You want to maximise the area. It turns out that the optimal solution is to make a square. The nearer to a square the enclosure is, the nearer to the optimal area it will be. For example, where <code>H + W = 11</code>, the best (integer) solution is <code>5 x 6 = 30</code>.</p>
<p><img src="https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/Figures/1339/area_fences.png" alt="Different ways of building a fence."></p>
<p>A simple way to do this in code is to loop over the list of all the sums and find the <code>(sum, total - sum)</code> pair that has the minimal difference. This approach ensures we do <em>not</em> need to use floating point numbers.</p>
<p><strong>Algorithm</strong></p>
<p>We’ll use Approach #1 as a basis for the code, as it’s simpler and easier to understand. The same ideas can be used in Approach #2 though.</p>
<iframe src="https://leetcode.com/playground/vj739xxH/shared" frameborder="0" width="100%" height="500" name="vj739xxH" style="box-sizing: border-box; margin: 20px 0px;"></iframe>

<p><strong>Complexity Analysis</strong></p>
<p>n<em>n</em> is the number of nodes in the tree.</p>
<ul>
<li><p>Time Complexity : O(n)<em>O</em>(<em>n</em>).</p>
<p>Same as above approaches.</p>
</li>
<li><p>Space Complexity : O(n)<em>O</em>(<em>n</em>).</p>
<p>Same as above approaches.</p>
</li>
</ul>
<p>The <code>modularMultiplication</code> function has a time complexity of O(log⁡ b)<em>O</em>(log<em>b</em>) because the loop removes one bit from b<em>b</em> each iteration, until there are none left. This <em>doesn’t</em> bring up the total time complexity to O(n log⁡ b)<em>O</em>(<em>n</em>log<em>b</em>) though, because b<em>b</em> has a fixed upper limit of 32, and is therefore treated as a constant.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jackson"
      src="/uploads/hacker.png">
  <p class="site-author-name" itemprop="name">Jackson</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jackson</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
