<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jackson Blog">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Jackson Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jackson">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jackson Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jackson Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/03/python400%E9%9B%867/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/03/python400%E9%9B%867/" class="post-title-link" itemprop="url">python400集7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-03 19:13:54" itemprop="dateCreated datePublished" datetime="2020-05-03T19:13:54-05:00">2020-05-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/03/python400%E9%9B%866/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/03/python400%E9%9B%866/" class="post-title-link" itemprop="url">python400集6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-03 19:13:51" itemprop="dateCreated datePublished" datetime="2020-05-03T19:13:51-05:00">2020-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-07 00:09:16" itemprop="dateModified" datetime="2020-05-07T00:09:16-05:00">2020-05-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>module：一个 .py 文件就是个 module</p>
<p>lib：抽象概念，和另外两个不zhidao是一类，只要你喜欢，什么都是 lib，就算只有个 hello world</p>
<p>package：就是个带 <strong>init</strong>.py 的文件夹，并不在乎里内面有什么，不过一般来讲会包含一些 packages/modules</p>
<p>scrapy、flask、Django、numpy、scipy、NLTK、jieba一般都被认为是 lib，因为关注点并不是代码是怎么组织容的。</p>
<ol>
<li>Python 程序由模块组成。一个模块对应 python 源文件，一般后缀名是:.py。</li>
<li>模块由语句组成。运行 Python 程序时，按照模块中语句的顺序依次执行。</li>
<li>语句是 Python 程序的构造单元，用于创建对象、变量赋值、调用函数、控制语句等。</li>
</ol>
<h2 id="1-python模块是："><a href="#1-python模块是：" class="headerlink" title="1.python模块是："></a>1.python模块是：</h2><p>python模块：包含并且有组织的代码片段为模块。</p>
<p>表现形式为：写的代码保存为文件。这个文件就是一个模块。sample.py 其中文件名smaple为模块名字。</p>
<p>关系图：</p>
<p><a href="https://iknow-pic.cdn.bcebos.com/1ad5ad6eddc451dad2c24565bffd5266d0163203" target="_blank" rel="noopener"><img src="https://iknow-pic.cdn.bcebos.com/1ad5ad6eddc451dad2c24565bffd5266d0163203?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" alt="img"></a></p>
<h2 id="2-python包是："><a href="#2-python包是：" class="headerlink" title="2.python包是："></a>2.python包是：</h2><p>包是一个有层次的文件目录结构，它定义了由n个模块或n个子包组成的python应用程序执行环境。通俗一点：包是一个包含<strong>init</strong>.py 文件的目录，该目录下一定得有这个<strong>init</strong>.py文件和其它e68a84e79fa5e9819331333365656638模块或子包。</p>
<p>常见问题：</p>
<p>引入某一特定路径下的模块</p>
<p>使用sys.path.append(yourmodulepath)</p>
<p>将一个路径加入到python系统路径下，避免每次通过代码指定路径</p>
<p>利用系统环境变量 export PYTHONPATH=$PYTHONPATH:yourmodulepath，</p>
<p>直接将这个路径链接到类似/Library/Python/2.7/site-packages目录下</p>
<p>好的建议：</p>
<p>经常使用if <strong>name</strong> == ‘<strong>main</strong>‘，保证写包既可以import又可以独立运行，用于test。</p>
<p>多次import不会多次执行模块，只会执行一次。可以使用reload来强制运行模块，但不提倡。</p>
<p>常见的包结构如下：</p>
<p>package_a├── <strong>init</strong>.py├── module_a1.py└── module_a2.pypackage_b├── <strong>init</strong>.py├── module_b1.py└── module_b2.py</p>
<p>main.py</p>
<p>如果main.py想要引用packagea中的模块modulea1，可以使用:</p>
<p>from package_a import module_a1</p>
<p>import package_a.module_a1</p>
<p>如果packagea中的modulea1需要引用packageb，那么默认情况下，python是找不到packageb。我们可以使用sys.path.append(‘../‘),可以在packagea中的<strong>init</strong>.py添加这句话，然后该包下得所有module都添加* import __init_即可。</p>
<p>关系图：</p>
<p><a href="https://iknow-pic.cdn.bcebos.com/1c950a7b02087bf4949b1e67fbd3572c10dfcfcd" target="_blank" rel="noopener"><img src="https://iknow-pic.cdn.bcebos.com/1c950a7b02087bf4949b1e67fbd3572c10dfcfcd?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" alt="img"></a></p>
<h2 id="3-库（library）"><a href="#3-库（library）" class="headerlink" title="3.库（library）"></a>3.库（library）</h2><p>库的概念是具有相关功能模块的集合。这也是Python的一大特色之一，即具有强大的标准库、第三方库以及自定义模块。</p>
<h2 id="1-2-标准库模块-standard-library"><a href="#1-2-标准库模块-standard-library" class="headerlink" title="1.2 标准库模块(standard library)"></a><strong>1.2 标准库模块(standard library)</strong></h2><p>与函数类似，模块也分为标准库模块和用户自定义模块。<br> Python 标准库提供了操作系统功能、网络通信、文本处理、文件处理、数学运算等基 本的功能。比如:random(随机数)、math(数学运算)、time(时间处理)、file(文件处理)、 os(和操作系统交互)、sys(和解释器交互)等。</p>
<p>另外，Python 还提供了海量的第三方模块，使用方式和标准库类似。功能覆盖了我们 能想象到的所有领域，比如:科学计算、WEB 开发、大数据、人工智能、图形系统等。</p>
<p>模块化编程有如下几个重要优势:<br> \1. 便于将一个任务分解成多个模块，实现团队协同开发，完成大规模程序 2. 实现代码复用。一个模块实现后，可以被反复调用。<br> \3. 可维护性增强。</p>
<p><strong>1.4 模块化编程的流程</strong></p>
<p>模块化编程的一般流程:<br> \1. 设计 API，进行功能描述</p>
<p>\2. 编码实现 API 中描述的功能。<br> \3. 在模块中编写测试代码，并消除全局代码。<br> \4. 使用私有函数实现不被外部客户端调用的模块函数。</p>
<p>API(Application Programming Interface 应用程序编程接口)是用于描述模 块中提供的函数和类的功能描述和使用方式描述。</p>
<p>模块化编程中，首先设计的就是模块的 API(即要实现的功能描述)，然后开始编 码实现 API 中描述的功能。最后，在其他模块中导入本模块进行调用。</p>
<p>我们可以通过help(模块名)查看模块的API。一般使用时先导入模块 然后通过help函数查看</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">help(math)</span><br></pre></td></tr></table></figure>

<p>设计计算薪水模块的 API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">本模块用于计算公司员工的薪资</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">company &#x3D; &quot;北京尚学堂&quot;</span><br><span class="line"></span><br><span class="line">def yearSalary(monthSalary):</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;根据传入的月薪，计算出年薪&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">  pass</span><br><span class="line"></span><br><span class="line">def daySalary(monthSalary): </span><br><span class="line">&quot;&quot;&quot;根据传入的月薪，计算出每天的薪资&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>

<p>如上模块只有功能描述和规范，需要编码人员按照要求实现编码。 我们可以通过<strong>doc</strong>可以获得模块的文档字符串的内容。</p>
<p>test.py 的源代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import salary</span><br><span class="line"></span><br><span class="line">print(salary.__doc__)</span><br><span class="line"></span><br><span class="line">print(salary.yearSalary.__doc__)</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p>本模块用于计算公司员工的薪资 </p>
<p>根据传入的月薪，计算出年薪</p>
<p><strong>模块的创建和测试代码</strong></p>
<p>每个模块都有一个名称，通过特殊变量<strong>name</strong>可以获取模块的名称。在正常情况下，模块名字对应源文件名。 仅有一个例外，就是当一个模块被作为程序入口时(主 程序、交互式提示符下)，它的<strong>name</strong>的值为“<strong>main</strong>”。我们可以根据这个特 点，将模块源代码文件中的测试代码进行独立的处理。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> import math</span><br><span class="line"></span><br><span class="line">math.__name__ #输出&#39;math&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">company = <span class="string">"北京尚学堂"</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">yearSalary</span><span class="params">(monthSalary)</span>:</span> </span><br><span class="line"> <span class="string">"""根据传入的月薪，计算出年薪"""</span></span><br><span class="line">		<span class="keyword">return</span> monthSalary*<span class="number">12</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">daySalary</span><span class="params">(monthSalary)</span>:</span></span><br><span class="line"><span class="string">"""根据传入的月薪，计算出每天的薪资"""</span></span><br><span class="line">	<span class="keyword">return</span> monthSalary/<span class="number">22.5</span> <span class="comment">#国家规定每个月的平均工作日是 22.5</span></span><br><span class="line"> <span class="keyword">if</span> __name__ ==<span class="string">"__main__"</span>: <span class="comment">#测试代码</span></span><br><span class="line">		print(yearSalary(<span class="number">3000</span>))</span><br><span class="line">		print(daySalary(<span class="number">3000</span>))</span><br></pre></td></tr></table></figure>

<p><strong>1.7 模块文档字符串和 API 设计</strong></p>
<p>我们可以在模块的第一行增加一个文档字符串，用于描述模块的相关功能。然后，通过 <strong>doc</strong>可以获得文档字符串的内容。</p>
<h2 id="2-模块的导入"><a href="#2-模块的导入" class="headerlink" title="2. 模块的导入"></a><strong>2. 模块的导入</strong></h2><p>模块化设计的好处之一就是“代码复用性高”。写好的模块可以被反复调用，重复使用。 模块的导入就是“在本模块中使用其他模块”。</p>
<p><strong>2.1 import 语句导入</strong></p>
<p>import 语句的基本语法格式如下: import 模块名</p>
<p>import 模块 1，模块 2… import 模块名 as 模块别名</p>
<p>#导入一个模块 #导入多个模块</p>
<p>#导入模块并使用新名字</p>
<p>import 加载的模块分为四个通用类别:<br> a.使用 python 编写的代码(.py 文件); b.已被编译为共享库或 DLL 的 C 或 C++扩展; c.包好一组模块的包<br> d.使用 C 编写并链接到 python 解释器的内置模块;</p>
<p>我们一般通过 import 语句实现模块的导入和使用，import 本质上是使用了内置函数 <strong>import</strong>()。</p>
<p>当我们通过 import 导入一个模块时，python 解释器进行执行，最终会生成一个对象， 这个对象就代表了被加载的模块。</p>
<p>我们可以看到 math 模块被加载后，实际会生成一个 module 类的对象，该对象被 math 变量引用。我们可以通过 math 变量引用模块中所有的内容。</p>
<p>我们通过 import 导入多个模块，本质上也是生成多个 module 类的对象而已。</p>
<p>有时候，我们也需要给模块起个别名，本质上，这个别名仅仅是新创建一个变量引用加 载的模块对象而已。</p>
<p><strong>2.2 from…import 导入</strong></p>
<p>Python 中可以使用 from…import 导入模块中的成员。基本语法格式如下: from 模块名 import 成员 1，成员 2，…</p>
<p>如果希望导入一个模块中的所有成员，则可以采用如下方式: from 模块名 import *</p>
<p>【注】尽量避免“from 模块名 import <em>”这种写法。</em> 它表示导入模块中所有的不 是以下划线(_)开头的名字都导入到当前位置。 但你不知道你导入什么名字，很有可能 会覆盖掉你之前已经定义的名字。而且可读性极其的差。一般生产环境中尽量避免使用， 学习时没有关系。</p>
<h2 id="2-3-import-语句和-from…import-语句的区别"><a href="#2-3-import-语句和-from…import-语句的区别" class="headerlink" title="2.3 import 语句和 from…import 语句的区别"></a><strong>2.3 import 语句和 from…import 语句的区别</strong></h2><p>import 导入的是模块。from…import 导入的是模块中的一个函数/一个类。</p>
<p>如果进行类比的话，import 导入的是“文件”，我们要使用该“文件”下的内容，必 须前面加“文件名称”。from…import 导入的是文件下的“内容”，我们直接使用这 些“内容”即可，前面再也不需要加“文件名称”了。</p>
<p><strong>2.4 <strong>import</strong>()动态导入</strong></p>
<p>import 语句本质上就是调用内置函数<strong>import</strong>()，我们可以通过它实现动态导入。给 <strong>import</strong>()动态传递不同的的参数值，就能导入不同的模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;math&quot;</span><br><span class="line">m &#x3D; __import__(s) #导入后生成的模块对象的引用给变量 m</span><br><span class="line">print(m.pi)</span><br></pre></td></tr></table></figure>

<p>注意:一般不建议我们自行使用<strong>import</strong>()导入，其行为在 python2 和 python3 中 有差异，会导致意外错误。如果需要动态导入可以使用 importlib 模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import importlib</span><br><span class="line">a &#x3D; importlib.import_module(&quot;math&quot;)</span><br><span class="line">print(a.pi)</span><br></pre></td></tr></table></figure>

<p><strong>2.5 模块的加载问题</strong></p>
<p>当导入一个模块时， 模块中的代码都会被执行。不过，如果再次导入这个模块， 则不会再次执行。</p>
<p>Python 的设计者为什么这么设计?因为，导入模块更多的时候需要的是定义模块 中的变量、函数、对象等。这些并不需要反复定义和执行。“只导入一次 import-only-once”就成了一种优化。</p>
<p>一个模块无论导入多少次，这个模块在整个解释器进程内有且仅有一个实例对象。</p>
<p><strong>重新加载 有时候我们确实需要重新加载一个模块，这时候可以使用:**</strong>importlib.reload()**</p>
<p><strong>方法:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import test02</span><br><span class="line">import test02</span><br><span class="line">print(&quot;####&quot;)</span><br><span class="line">import importlib </span><br><span class="line">importlib.reload(test02)</span><br></pre></td></tr></table></figure>

<h2 id="3-包-package-的使用"><a href="#3-包-package-的使用" class="headerlink" title="3. 包 package 的使用"></a><strong>3. 包 package 的使用</strong></h2><p><strong>3.1 包(package)的概念和结构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个项目中有很多个模块时，需要再进行组织。我们将功能类似的模块放到一起， 形成了“包”。本质上，“包”就是一个必须有__init__.py 的文件夹。典型结构如下:</span><br></pre></td></tr></table></figure>

<p>包下面可以包含“模块(module)”，也可以再包含“子包(subpackage)”。就像文件 夹下面可以有文件，也可以有子文件夹一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">，a 是上层的包，下面有一个子包:aa。可以看到每个包里面都有__init__.py 文件。</span><br></pre></td></tr></table></figure>

<p><strong>3.2 pycharm 中创建包</strong></p>
<p>在 pycharm 开发环境中创建包，非常简单。在要创建包的地方单击右键:New–&gt;Python package 即可。pycharm 会自动帮助我们生成带有<strong>init</strong>.py 文件的包。</p>
<p><strong>3.3 导入包操作和本质</strong></p>
<p>上一节中的包结构，我们需要导入 module_AA.py。方式如下:</p>
<ol>
<li><p>import a.aa.module_AA</p>
<p>在使用时，必须加完整名称来引用，比如:a.aa.module_AA.fun_AA()</p>
</li>
<li><p>from a.aa import module_AA</p>
<p>在使用时，直接可以使用模块名。 比如:module_AA.fun_AA()</p>
</li>
<li><p>from a.aa.module_AA import fun_AA 直接导入函数</p>
<p>在使用时，直接可以使用函数名。 比如:fun_AA()</p>
<p>【注】<br> \1. from package import item 这种语法中，item 可以是包、模块，也可以是函数、</p>
<p>类、变量。<br> \2. import item1.item2 这种语法中，item 必须是包或模块，不能是其他。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">导入包的本质其实是“导入了包的__init__.py”文件。也就是说，”import pack1”意味 着执行了包 pack1 下面的__init__.py 文件。 这样，可以在__init__.py 中批量导入我们需要 的模块，而不再需要一个个导入。</span><br><span class="line"></span><br><span class="line">__init__.py 的三个核心作用:</span><br><span class="line">1. 作为包的标识，不能删除。</span><br><span class="line">2. 用来实现模糊导入</span><br><span class="line">3. 导入包实质是执行__init__.py 文件，可以在__init__.py 文件中做这个包的初始化、以及 需要统一执行代码、批量导入。</span><br></pre></td></tr></table></figure>

<h4 id="可以说“包的本质还是模块”。"><a href="#可以说“包的本质还是模块”。" class="headerlink" title="可以说“包的本质还是模块”。"></a>可以说“包的本质还是模块”。</h4><p><strong>3.4 用*导入包</strong></p>
<p>import * 这样的语句理论上是希望文件系统找出包中所有的子模块，然后导入它们。 这可能会花长时间等。Python 解决方案是提供一个明确的包索引。</p>
<p>这个索引由 <strong>init</strong>.py 定义 <strong>all</strong> 变量，该变量为一列表，如上例 a 包下的 <strong>init</strong>.py 中，可定义 <strong>all</strong> = [“module_A”,”module_A2”]</p>
<p>这意味着， from sound.effects import * 会从对应的包中导入以上两个子模块;</p>
<p>【注】尽管提供 import * 的方法，仍不建议在生产代码中使用这种写法。</p>
<p><strong>3.5 包内引用</strong></p>
<p>如果是子包内的引用，可以按相对位置引入子模块 以 aa 包下的 module_AA 中导入 a 包下内容为例:</p>
<p>from .. import module_A #..表示上级目录 .表示同级目录 </p>
<p>from . import module_A2 #.表示同级目录</p>
<p><strong>3.6 sys.path 和模块搜索路径</strong></p>
<p>当我们导入某个模块文件时， Python 解释器去哪里找这个文件呢?只有找到这个文 件才能读取、装载运行该模块文件。它一般按照如下路径寻找模块文件(按照顺序寻找，找 到即停不继续往下寻找):</p>
<p>\1. 内置模块<br> \2. 当前目录<br> \3. 程序的主目录<br> \4. pythonpath 目录(如果已经设置了 pythonpath 环境变量) 5. 标准链接库目录<br> \6. 第三方库目录(site-packages 目录)<br> \7. .pth 文件的内容(如果存在的话)<br> \8. sys.path.append()临时添加的目录</p>
<p>当任何一个 python 程序启动时，就将上面这些搜索路径(除内置模块以外的路径)进行收集， 放到 sys 模块的 path 属性中(sys.path)。</p>
<p><strong>使用 sys.path 查看和临时修改搜索路径</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys </span><br><span class="line">sys.path.append(&quot;d:&#x2F;&quot;) </span><br><span class="line">print(sys.path)</span><br></pre></td></tr></table></figure>

<h2 id="4-模块发布和安装"><a href="#4-模块发布和安装" class="headerlink" title="4. 模块发布和安装"></a><strong>4. 模块发布和安装</strong></h2><p>4.1 模块的本地发布**</p>
<p>当我们完成了某个模块开发后，可以将他对外发布，其他开发者也可以以“第三方扩展 库”的方式使用我们的模块。我们按照如下步骤即可实现模块的发布:</p>
<p>1.为模块文件创建如下结构的文件夹(一般，文件夹的名字和模块的名字一样):</p>
<p>2.在文件夹中创建一个名为『setup.py』的文件</p>
<p>\3. 构建一个发布文件。通过终端，cd 到模块文件夹 c 下面，再键入命令:</p>
<p>python setup.py sdist</p>
<p><strong>4.3 上传模块到 PyPI</strong></p>
<p>将自己开发好的模块上传到 PyPI 网站上，将成为公开的资源，可以让全球用户自由使 用。按照如下步骤做，很容易就实现上传模块操作。</p>
<p><strong>·管理你的模块</strong></p>
<p><strong>4.4 让别人使用你的模块</strong></p>
<p>模块发布完成后，其他人只需要使用 pip 就可以安装你的模块文件。比如:</p>
<p>pip <strong>install package</strong>-<strong>name</strong></p>
<h2 id="5-库-Library"><a href="#5-库-Library" class="headerlink" title="5. 库(Library)"></a><strong>5. 库(Library)</strong></h2><p>Python 中库是借用其他编程语言的概念，没有特别具体的定义。模块和包侧重于代码 组织，有明确的定义。</p>
<p>一般情况，库强调的是功能性，而不是代码组织。我们通常将某个功能的“模块的集合”， 称为库。</p>
<p><strong>5.1 标准库(Standard Library)</strong></p>
<p>Python 拥有一个强大的标准库。Python 语言的核心只包含数字、字符串、列表、字典、 文件等常见类型和函数，而由 Python 标准库提供了系统管理、网络通信、文本处理、数据 库接口、图形系统、XML 处理等额外的功能。</p>
<p>Python 标准库的主要功能有:<br> \1. 文本处理，包含文本格式化、正则表达式匹配、文本差异计算与合并、Unicode 支 持，二进制数据处理等功能<br> \2. 文件处理，包含文件操作、创建临时文件、文件压缩与归档、操作配置文件等功能</p>
<p>\3. 操作系统功能，包含线程与进程支持、IO 复用、日期与时间处理、调用系统函数、 日志(logging)等功能<br> \4. 网络通信，包含网络套接字，SSL 加密通信、异步网络通信等功能<br> \5. 网络协议，支持 HTTP，FTP，SMTP，POP，IMAP，NNTP，XMLRPC 等多种网 络协议，并提供了编写网络服务器的框架</p>
<p>\6. W3C 格式支持，包含 HTML，SGML，XML 的处理<br> \7. 其它功能，包括国际化支持、数学运算、HASH、Tkinter 等</p>
<p>目前学过的有:random、math、time、file、os、sys 等模块。可以通过 random 模 块实现随机数处理、math 模块实现数学相关的运算、time 模块实现时间的处理、file 模块 实现对文件的操作、OS 模块实现和操作系统的交互、sys 模块实现和解释器的交互。</p>
<p><strong>5.2 第三方扩展库的介绍</strong></p>
<p>强大的标准库奠定了 python 发展的基石，丰富和不断扩展的第三方库是 python 壮大 的保证。我们可以进入 PyPI 官网:</p>
<p><strong>常用第三方库大汇总</strong></p>
<table>
<thead>
<tr>
<th>分类</th>
<th>库名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>环境管理</td>
<td>P</td>
<td>非常简单的交互式 python 版本管理工具</td>
</tr>
<tr>
<td>Pyenv</td>
<td>简单的 Python 版本管理工具</td>
<td></td>
</tr>
<tr>
<td>Vex</td>
<td><code>可以在虚拟环境中执行命令</code></td>
<td></td>
</tr>
<tr>
<td>Virtualenv virtualenvwrapp</td>
<td>创建独立 Python 环境的工具</td>
<td></td>
</tr>
</tbody></table>
<p>尚学堂·百战程序员 <a href="http://www.itbaizhan.cn" target="_blank" rel="noopener">www.itbaizhan.cn</a></p>
<table>
<thead>
<tr>
<th></th>
<th>er</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>包管理</td>
<td>pip</td>
<td>Python 包和依赖关系管理工具</td>
</tr>
<tr>
<td>pip-tools</td>
<td>保证 Python 包依赖关系更新的一组工具</td>
<td></td>
</tr>
<tr>
<td>Pipenv</td>
<td>Python 官方推荐的新一代包管理工具</td>
<td></td>
</tr>
<tr>
<td>Poetry</td>
<td>可完全取代 setup.py 的包管理工具</td>
<td></td>
</tr>
<tr>
<td>包仓库</td>
<td>warehouse</td>
<td>下一代 PyPI</td>
</tr>
<tr>
<td>Devpi</td>
<td>PyPI 服务和打包/测试/分发工具</td>
<td></td>
</tr>
<tr>
<td>分发 (打包为可执行文件 以便分发)</td>
<td>PyInstaller</td>
<td>将 Python 程序转成独立的执行文件(跨平台)</td>
</tr>
<tr>
<td>Nuitka</td>
<td>将脚本、模块、包编译成可执行文件或扩展模块</td>
<td></td>
</tr>
<tr>
<td>py2app</td>
<td>将 Python 脚本变为独立软件包(Mac OS X)</td>
<td></td>
</tr>
<tr>
<td>py2exe</td>
<td>将 Python 脚本变为独立软件包(Windows)</td>
<td></td>
</tr>
<tr>
<td>pynsist</td>
<td>一个用来创建 Windows 安装程序的工具，可 以在安装程序中打包 Python 本身</td>
<td></td>
</tr>
<tr>
<td>构建工具 (将源码编译成软件)</td>
<td>Buildout</td>
<td>构建系统，从多个组件来创建，组装和部署应用</td>
</tr>
<tr>
<td>BitBake</td>
<td>针对嵌入式 Linux 的类似 make 的构建工具</td>
<td></td>
</tr>
<tr>
<td>Fabricate</td>
<td><code>对任何语言自动找到依赖关系的构建工具</code></td>
<td></td>
</tr>
<tr>
<td>交互式 Python 解 析器</td>
<td>IPython</td>
<td>功能丰富的工具，非常有效的使用交互式 Python</td>
</tr>
<tr>
<td>bpython</td>
<td>界面丰富的 Python 解析器</td>
<td></td>
</tr>
<tr>
<td>Ptpython</td>
<td>高级交互式 Python 解析器，构建 于 python-prompt-toolkit 之上</td>
<td></td>
</tr>
<tr>
<td>文件管理</td>
<td>Aiofiles</td>
<td>基于 asyncio，提供文件异步操作</td>
</tr>
<tr>
<td>Imghdr</td>
<td>(Python 标准库)检测图片类型</td>
<td></td>
</tr>
<tr>
<td>Mimetypes</td>
<td>(Python 标准库)将文件名映射为 MIME 类型</td>
<td></td>
</tr>
<tr>
<td>path.py</td>
<td>对 os.path 进行封装的模块</td>
<td></td>
</tr>
<tr>
<td>Pathlib</td>
<td>(Python3.4+ 标准库)跨平台的、面向对象的 路径操作库</td>
<td></td>
</tr>
<tr>
<td>Unipath</td>
<td><code>用面向对象的方式操作文件和目录</code></td>
<td></td>
</tr>
<tr>
<td>Watchdog</td>
<td>管理文件系统事件的 API 和 shell 工具</td>
<td></td>
</tr>
<tr>
<td>日期和时间</td>
<td>Arrow</td>
<td>更好的 Python 日期时间操作类库</td>
</tr>
<tr>
<td>Chronyk</td>
<td><code>解析手写格式的时间和日期</code></td>
<td></td>
</tr>
<tr>
<td>Dateutil</td>
<td>Python datetime 模块的扩展</td>
<td></td>
</tr>
<tr>
<td>PyTime</td>
<td>一个简单易用的 Python 模块，用于通过字符 串来操作日期/时间</td>
<td></td>
</tr>
<tr>
<td>when.py</td>
<td>提供用户友好的函数来帮助用户进行常用的日 期和时间操作</td>
<td></td>
</tr>
<tr>
<td>文本处理</td>
<td>chardet</td>
<td>字符编码检测器，兼容 Python2 和 Python3</td>
</tr>
</tbody></table>
<p>尚学堂·百战程序员 <a href="http://www.itbaizhan.cn" target="_blank" rel="noopener">www.itbaizhan.cn</a></p>
<table>
<thead>
<tr>
<th></th>
<th>Difflib</th>
<th>(Python 标准库)帮助我们进行差异化比较</th>
</tr>
</thead>
<tbody><tr>
<td>Fuzzywuzzy</td>
<td>模糊字符串匹配</td>
<td></td>
</tr>
<tr>
<td>Levenshtein</td>
<td><code>快速计算编辑距离以及字符串的相似度</code></td>
<td></td>
</tr>
<tr>
<td>Pypinyin</td>
<td>汉字拼音转换工具 Python 版</td>
<td></td>
</tr>
<tr>
<td>Shortuuid</td>
<td>一个生成器库，用以生成简洁的，明白的，URL 安全的 UUID</td>
<td></td>
</tr>
<tr>
<td>simplejson</td>
<td>Python 的 JSON 编码、解码器</td>
<td></td>
</tr>
<tr>
<td>Unidecode</td>
<td>Unicode 文本的 ASCII 转换形式</td>
<td></td>
</tr>
<tr>
<td>Xpinyin</td>
<td>一个用于把汉字转换为拼音的库</td>
<td></td>
</tr>
<tr>
<td>Pygment</td>
<td>通用语法高亮工具</td>
<td></td>
</tr>
<tr>
<td>Phonenumbers</td>
<td>解析，格式化，储存，验证电话号码</td>
<td></td>
</tr>
<tr>
<td>Sqlparse</td>
<td>一个无验证的 SQL 解析器</td>
<td></td>
</tr>
<tr>
<td>特殊文本格式处理</td>
<td>Tablib</td>
<td>一个用来处理中表格数据的模块</td>
</tr>
<tr>
<td>Pyexcel</td>
<td>用来读写，操作 Excel 文件的库</td>
<td></td>
</tr>
<tr>
<td>python-docx</td>
<td>读取，查询以及修改 word 文件</td>
<td></td>
</tr>
<tr>
<td>PDFMiner</td>
<td>一个用于从 PDF 文档中抽取信息的工具</td>
<td></td>
</tr>
<tr>
<td>Python-Markdo wn2</td>
<td>纯 Python 实现的 Markdown 解析器</td>
<td></td>
</tr>
<tr>
<td>Csvkit</td>
<td>用于转换和操作 CSV 的工具</td>
<td></td>
</tr>
<tr>
<td>自然语言处理</td>
<td>NLTK</td>
<td>一个先进的平台，用以构建处理人类语言数据的 Python 程序</td>
</tr>
<tr>
<td>Jieba</td>
<td>中文分词工具</td>
<td></td>
</tr>
<tr>
<td>langid.py</td>
<td>独立的语言识别系统</td>
<td></td>
</tr>
<tr>
<td>SnowNLP</td>
<td>一个用来处理中文文本的库</td>
<td></td>
</tr>
<tr>
<td>Thulac</td>
<td>清华大学自然语言处理与社会人文计算实验室 研制推出的一套中文词法分析工具包</td>
<td></td>
</tr>
<tr>
<td>下载器</td>
<td>you-get</td>
<td>一个 YouTube/Youku/Niconico 视频下载器</td>
</tr>
<tr>
<td>图像处理</td>
<td>pillow</td>
<td>最常用的图像处理库</td>
</tr>
<tr>
<td>imgSeek</td>
<td>一个使用视觉相似性搜索一组图片集合的项目</td>
<td></td>
</tr>
<tr>
<td>face_recognition</td>
<td>简单易用的 python 人脸识别</td>
<td></td>
</tr>
<tr>
<td>python-qrcode</td>
<td>一个纯 Python 实现的二维码生成器</td>
<td></td>
</tr>
<tr>
<td>OCR</td>
<td>Pyocr</td>
<td>Tesseract 和 Cuneiform 的 一 个 封 装 (wrapper)</td>
</tr>
<tr>
<td>pytesseract</td>
<td>Google Tesseract OCR 的 另 一 个 封 装</td>
<td></td>
</tr>
</tbody></table>
<p>尚学堂·百战程序员 <a href="http://www.itbaizhan.cn" target="_blank" rel="noopener">www.itbaizhan.cn</a></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>(wrapper)</th>
</tr>
</thead>
<tbody><tr>
<td>音频处理</td>
<td>Audiolazy</td>
<td>Python 的数字信号处理包</td>
</tr>
<tr>
<td>Dejavu</td>
<td>音频指纹提取和识别</td>
<td></td>
</tr>
<tr>
<td>id3reader</td>
<td>一个用来读取 MP3 元数据的 Python 模块</td>
<td></td>
</tr>
<tr>
<td>TimeSide</td>
<td>开源 web 音频处理框架</td>
<td></td>
</tr>
<tr>
<td>Tinytag</td>
<td>一个用来读取 MP3, OGG, FLAC 以及 Wave 文件音乐元数据的库</td>
<td></td>
</tr>
<tr>
<td>Mingus</td>
<td>一个高级音乐理论和曲谱包，支持 MIDI 文件 和回放功能</td>
<td></td>
</tr>
<tr>
<td>视频和 GIF 处理</td>
<td>Moviepy</td>
<td>一个用来进行基于脚本的视频编辑模块，适用于 多种格式，包括动图 GIFs</td>
</tr>
<tr>
<td>scikit-video</td>
<td>SciPy 视频处理常用程序</td>
<td></td>
</tr>
<tr>
<td>地理位置</td>
<td>GeoDjango</td>
<td>世界级地理图形 web 框架</td>
</tr>
<tr>
<td>GeoIP</td>
<td>MaxMind GeoIP Legacy 数 据 库 的 Python API</td>
<td></td>
</tr>
<tr>
<td>Geopy</td>
<td>Python 地址编码工具箱</td>
<td></td>
</tr>
<tr>
<td>HTTP</td>
<td>requests</td>
<td>人性化的 HTTP 请求库</td>
</tr>
<tr>
<td>httplib2</td>
<td>全面的 HTTP 客户端库</td>
<td></td>
</tr>
<tr>
<td>urllib3</td>
<td>一个具有线程安全连接池，支持文件 post，清 晰友好的 HTTP 库</td>
<td></td>
</tr>
<tr>
<td>Python 实现的 数据库</td>
<td>pickleDB</td>
<td>一个简单，轻量级键值储存数据库</td>
</tr>
<tr>
<td>PipelineDB</td>
<td>流式 SQL 数据库</td>
<td></td>
</tr>
<tr>
<td>TinyDB</td>
<td>一个微型的，面向文档型数据库</td>
<td></td>
</tr>
<tr>
<td>web 框架</td>
<td>Django</td>
<td>Python 界最流行的 web 框架</td>
</tr>
<tr>
<td>Flask</td>
<td>一个 Python 微型框架</td>
<td></td>
</tr>
<tr>
<td>Tornado</td>
<td>一个 web 框架和异步网络库</td>
<td></td>
</tr>
<tr>
<td>CMS 内容管理系统</td>
<td>odoo-cms</td>
<td>一个开源的，企业级 CMS，基于 odoo</td>
</tr>
<tr>
<td>djedi-cms</td>
<td>一个轻量级但却非常强大的 Django CMS ，考 虑到了插件，内联编辑以及性能</td>
<td></td>
</tr>
<tr>
<td>Opps</td>
<td>一个为杂志，报纸网站以及大流量门户网站设计 的 CMS 平台，基于 Django</td>
<td></td>
</tr>
<tr>
<td>电子商务和支付系 统</td>
<td>django-oscar</td>
<td>一个用于 Django 的开源的电子商务框架</td>
</tr>
<tr>
<td>django-shop</td>
<td>一个基于 Django 的店铺系统</td>
<td></td>
</tr>
<tr>
<td>Shoop</td>
<td>一个基于 Django 的开源电子商务平台</td>
<td></td>
</tr>
<tr>
<td>Alipay</td>
<td>Python 支付宝 API</td>
<td></td>
</tr>
<tr>
<td>Merchant</td>
<td>一个可以接收来自多种支付平台支付的</td>
<td></td>
</tr>
</tbody></table>
<p>尚学堂·百战程序员 <a href="http://www.itbaizhan.cn" target="_blank" rel="noopener">www.itbaizhan.cn</a></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>Django 应用</th>
</tr>
</thead>
<tbody><tr>
<td>游戏开发</td>
<td>Cocos2d</td>
<td>用来开发 2D 游戏</td>
</tr>
<tr>
<td>Panda3D</td>
<td>由迪士尼开发的 3D 游戏引擎，并由卡内基梅 陇娱乐技术中心负责维护。使用 C++ 编写, 针 对 Python 进行了完全的封装</td>
<td></td>
</tr>
<tr>
<td>Pygame</td>
<td>Pygame 是一组 Python 模块，用来编写游戏</td>
<td></td>
</tr>
<tr>
<td>RenPy</td>
<td>一个视觉小说(visual novel)引擎</td>
<td></td>
</tr>
<tr>
<td>计算机视觉库</td>
<td>OpenCV</td>
<td>开源计算机视觉库</td>
</tr>
<tr>
<td>Pyocr</td>
<td>Tesseract 和 Cuneiform 的包装库</td>
<td></td>
</tr>
<tr>
<td>SimpleCV</td>
<td>一个用来创建计算机视觉应用的开源框架</td>
<td></td>
</tr>
<tr>
<td>机器学习 人工智能</td>
<td>TensorFlow</td>
<td><code>谷歌开源的最受欢迎的深度学习框架</code></td>
</tr>
<tr>
<td>keras</td>
<td>以 tensorflow/theano/CNTK 为 后 端 的 深 度 学习封装库，快速上手神经网络</td>
<td></td>
</tr>
<tr>
<td>Hebel</td>
<td>GPU 加速的深度学习库</td>
<td></td>
</tr>
<tr>
<td>Pytorch</td>
<td>一个具有张量和动态神经网络，并有强大 GPU 加速能力的深度学习框架</td>
<td></td>
</tr>
<tr>
<td>scikit-learn</td>
<td>基于 SciPy 构建的机器学习 Python 模块</td>
<td></td>
</tr>
<tr>
<td>NuPIC</td>
<td>智能计算 Numenta 平台</td>
<td></td>
</tr>
<tr>
<td>科学计算和数据分 析</td>
<td>NumPy</td>
<td>使用 Python 进行科学计算的基础包</td>
</tr>
<tr>
<td>Pandas</td>
<td>提供高性能，易用的数据结构和数据分析工具</td>
<td></td>
</tr>
<tr>
<td>SciPy</td>
<td>用于数学，科学和工程的开源软件构成的生态系 统</td>
<td></td>
</tr>
<tr>
<td>PyMC</td>
<td><code>马尔科夫链蒙特卡洛采样工具</code></td>
<td></td>
</tr>
<tr>
<td>代码分析和调试</td>
<td>code2flow</td>
<td>把你的 Python 和 JavaScript 代码转换为流 程图</td>
</tr>
<tr>
<td>Pycallgraph</td>
<td>这个库可以把你的 Python 应用的流程(调用 图)进行可视化</td>
<td></td>
</tr>
<tr>
<td>Pylint</td>
<td>一个完全可定制的源码分析器</td>
<td></td>
</tr>
<tr>
<td>autopep8</td>
<td>自动格式化 Python 代码，以使其符合 PEP8 规范</td>
<td></td>
</tr>
<tr>
<td>Wdb</td>
<td>一个奇异的 web 调试器，通过 WebSockets 工作</td>
<td></td>
</tr>
<tr>
<td>Lineprofiler</td>
<td>逐行性能分析</td>
<td></td>
</tr>
<tr>
<td>Memory Profiler</td>
<td>监控 Python 代码的内存使用</td>
<td></td>
</tr>
<tr>
<td>图形用户界面</td>
<td>Pyglet</td>
<td>一个 Python 的跨平台窗口及多媒体库</td>
</tr>
</tbody></table>
<p>尚学堂·百战程序员 <a href="http://www.itbaizhan.cn" target="_blank" rel="noopener">www.itbaizhan.cn</a></p>
<table>
<thead>
<tr>
<th></th>
<th>PyQt</th>
<th>跨平台用户界面框架 Qt 的 Python 绑定 ，支 持 Qtv4 和 Qtv5</th>
</tr>
</thead>
<tbody><tr>
<td>Tkinter</td>
<td>Tkinter 是 Python GUI 的一个事实标准库</td>
<td></td>
</tr>
<tr>
<td>wxPython</td>
<td>wxPython 是 wxWidgets C++ 类 库 和 Python 语言混合的产物</td>
<td></td>
</tr>
<tr>
<td>网络爬虫和 HTML 分析</td>
<td>Scrapy</td>
<td>一个快速高级的屏幕爬取及网页采集框架</td>
</tr>
<tr>
<td>Cola</td>
<td>一个分布式爬虫框架</td>
<td></td>
</tr>
<tr>
<td>Grab</td>
<td>站点爬取框架</td>
<td></td>
</tr>
<tr>
<td>Pyspider</td>
<td>一个强大的爬虫系统</td>
<td></td>
</tr>
<tr>
<td>html2text</td>
<td>将 HTML 转换为 Markdown 格式文本</td>
<td></td>
</tr>
<tr>
<td>python-goose</td>
<td>HTML 内容/文章提取器</td>
<td></td>
</tr>
<tr>
<td>硬件编程</td>
<td>Ino</td>
<td>操作 Arduino 的命令行工具</td>
</tr>
<tr>
<td>Pyro</td>
<td>Python 机器人编程库</td>
<td></td>
</tr>
<tr>
<td>PyUserInput</td>
<td>跨平台的，控制鼠标和键盘的模块</td>
<td></td>
</tr>
<tr>
<td>Pingo</td>
<td>Pingo 为类似 RaspberryPi，pcDuino，Intel Galileo 等设备提供统一的 API</td>
<td></td>
</tr>
</tbody></table>
<p><strong>5.4 安装第三方扩展库的 2 种方式</strong></p>
<p>第三方库有数十万种之多，以 pillow 库为例讲解第三方扩展库的安装。pillow 是 Python 平台事实上的图像处理标准库，本节以安装 pillow 为例，给大家介绍第三方库的两 种常用的安装方法。</p>
<p>尚学堂·百战程序员 <a href="http://www.itbaizhan.cn" target="_blank" rel="noopener">www.itbaizhan.cn</a></p>
<p><strong>第一种方式:命令行下远程安装</strong></p>
<p>以安装第三方 pillow 图像库为例，在命令行提示符下输入:pip 安装完成后，我们就可以开始使用。</p>
<p><strong>第二种方式:Pycharm 中直接安装到项目中</strong></p>
<p>在 Pycharm 中，依次点击:file–&gt;setting–&gt;Project 本项目名–&gt;Project Interpreter</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/03/python400%E9%9B%865/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/03/python400%E9%9B%865/" class="post-title-link" itemprop="url">python400集5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-03 19:13:49" itemprop="dateCreated datePublished" datetime="2020-05-03T19:13:49-05:00">2020-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-06 20:20:09" itemprop="dateModified" datetime="2020-05-06T20:20:09-05:00">2020-05-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件操作（IO技术）"><a href="#文件操作（IO技术）" class="headerlink" title="文件操作（IO技术）"></a>文件操作（IO技术）</h1><p>一个完整的程序一般都包括数据的存储和读取;我们在前面写的程序数据都没有进行实 际的存储，因此 python 解释器执行完数据就消失了。实际开发中，我们经常需要从外部存 储介质(硬盘、光盘、U 盘等)读取数据，或者将程序产生的数据存储到文件中，实现“持 久化”保存。</p>
<p>很多软件系统是将数据存储的数据库中;数据库实际也是基于文件 形式存储的</p>
<p><strong>文本文件和二进制文件</strong></p>
<p>按文件中数据组织形式，我们把文件分为文本文件和二进制文件两大类。</p>
<ol>
<li>文本文件</li>
</ol>
<p>文本文件存储的是普通“字符”文本，python 默认为 unicode 字符集(两个字节表示 一个字符，最多可以表示:65536 个)，可以使用记事本程序打开。但是，像 word 软件 编辑的文档不是文本文件。</p>
<ol start="2">
<li>二进制文件</li>
</ol>
<p>二进制文件把数据内容用“字节”进行存储，无法用记事本打开。必须使用专用的软件 解码。常见的有:MP4 视频文件、MP3 音频文件、JPG 图片、doc 文档等等。</p>
<h2 id="文件操作相关模块概述"><a href="#文件操作相关模块概述" class="headerlink" title="文件操作相关模块概述"></a><strong>文件操作相关模块概述</strong></h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>io 模块</td>
<td>文件流的输入和输出操作 input output</td>
</tr>
<tr>
<td>os 模块</td>
<td>基本操作系统功能，包括文件操作</td>
</tr>
<tr>
<td>glob 模块</td>
<td><code>查找符合特定规则的文件路径名</code></td>
</tr>
<tr>
<td>fnmatch 模块</td>
<td><code>使用模式来匹配文件路径名</code></td>
</tr>
<tr>
<td>fileinput 模块</td>
<td>处理多个输入文件</td>
</tr>
<tr>
<td>filecmp 模块</td>
<td>用于文件的比较</td>
</tr>
<tr>
<td>cvs 模块</td>
<td>用于 csv 文件处理</td>
</tr>
<tr>
<td>pickle 和 cPickle</td>
<td>用于序列化和反序列化</td>
</tr>
<tr>
<td>xml 包</td>
<td>用于 XML 数据处理</td>
</tr>
<tr>
<td>bz2、gzip、zipfile、zlib、tarfile</td>
<td><code>用于处理压缩和解压缩文件(分别对应不同的算法)</code></td>
</tr>
</tbody></table>
<h2 id="创建文件对象-open"><a href="#创建文件对象-open" class="headerlink" title="创建文件对象 open()"></a><strong>创建文件对象 open()</strong></h2><p>open()函数用于创建文件对象，基本语法格式如下: open(文件名[,打开方式])</p>
<p>如果只是文件名，代表在当前目录下的文件。文件名可以录入全路径，比如:D:\a\b.txt。</p>
<h3 id="为了减少“-”的输入，可以使用原始字符串-r-“d-b-txt”。"><a href="#为了减少“-”的输入，可以使用原始字符串-r-“d-b-txt”。" class="headerlink" title="为了减少“\”的输入，可以使用原始字符串:r “d:\b.txt”。"></a>为了减少“\”的输入，可以使用原始字符串:r “d:\b.txt”。</h3><h3 id="示例如下"><a href="#示例如下" class="headerlink" title="示例如下:"></a>示例如下:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f &#x3D; open(r&quot;d:\b.txt&quot;,&quot;w&quot;)</span><br></pre></td></tr></table></figure>

<p>打开方式有如下几种:</p>
<p>模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> r 读 read 模式</span><br><span class="line"></span><br><span class="line">w 写 write 模式。如果文件不存在则创建;如果文件存在，则重写新内容;</span><br><span class="line"></span><br><span class="line">a 追加 append 模式。如果文件不存在则创建;如果文件存在，则在文件末尾追加内容</span><br><span class="line"></span><br><span class="line">b 二进制 binary 模式(可与其他模式组合使用)</span><br><span class="line"></span><br><span class="line">+ 读、写模式(可与其他模式组合使用)</span><br></pre></td></tr></table></figure>

<p>文本文件对象和二进制文件对象的创建: 如果我们没有增加模式“b”，则默认创建的是文本文件对象，处理的基本单元是“字符”。如果是二进制模式“b”，则创建的是二进制文件对象，处理的基本单元是“字节”。</p>
<h2 id="文本文件的写入"><a href="#文本文件的写入" class="headerlink" title="文本文件的写入"></a><strong>文本文件的写入</strong></h2><p><strong>基本的文件写入操作</strong></p>
<p>文本文件的写入一般就是三个步骤: </p>
<ol>
<li>创建文件对象</li>
<li>写入数据</li>
<li>关闭文件对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">r"a.txt"</span>,<span class="string">"a"</span>) </span><br><span class="line">s = <span class="string">"itbaizhan\nsxt\n"</span> </span><br><span class="line">f.write(s)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h2 id="常用编码介绍"><a href="#常用编码介绍" class="headerlink" title="常用编码介绍"></a><strong>常用编码介绍</strong></h2><p>在操作文本文件时，经常会操作中文，这时候就经常会碰到乱码问题。</p>
<h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a><strong>ASCII</strong></h3><p>全称为 American Standard Code for Information Interchange，美国信 息交换标准代码，这是世界上最早最通用的单字节编码系统，主要用来显示现代 英语及其他西欧语言。</p>
<p>ASCII 码用 7 位表示，只能表示 128 个字符。只定义了 27=128 个字符，用 7bit 即可完全编码，而一字节 8bit 的容量是 256，所以一字节 ASCII 的编码最 高位总是 0。</p>
<p>0<del>31 表示控制字符如回车、退格、删除等;32</del>126 表示打印字符即可以 通过键盘输入并且能显示出来的字符;其中 48<del>57 为 0 到 9 十个阿拉伯数字， 65</del>90 为 26 个大写英文字母，97~122 号为 26 个小写英文字母，其余为一 些标点符号、运算符号等，具体可以参考 ASCII 标准表(大家自行百度，不在此 赘述)。</p>
<h3 id="ISO8859-1"><a href="#ISO8859-1" class="headerlink" title="ISO8859-1"></a><strong>ISO8859-1</strong></h3><p>ISO-8859-1 又称 Latin-1，是一个 8 位单字节字符集，它把 ASCII 的最高 位也利用起来，并兼容了 ASCII，新增的空间是 128，但它并没有完全用完。</p>
<p>在 ASCII 编码之上又增加了西欧语言、希腊语、泰语、阿拉伯语、希伯来语 对应的文字符号，它是向下兼容 ASCII 编码</p>
<h3 id="GB2312-GBK-GB18030"><a href="#GB2312-GBK-GB18030" class="headerlink" title="GB2312,GBK,GB18030"></a><strong>GB2312,GBK,GB18030</strong></h3><h4 id="·GB2312"><a href="#·GB2312" class="headerlink" title="·GB2312"></a><strong>·GB2312</strong></h4><p>GB2312 全称为信息交换用汉字编码字符集，是中国于 1980 年发布，主要 用于计算机系统中的汉字处理。GB2312 主要收录了 6763 个汉字、682 个符号。</p>
<p>GB2312 覆盖了汉字的大部分使用率，但不能处理像古汉语等特殊的罕用字， 所以后来出现了像 GBK、GB18030 这种编码。</p>
<p><strong>GB2312 完全兼容 ISO8859-1。</strong></p>
<h4 id="·GBK"><a href="#·GBK" class="headerlink" title="·GBK"></a><strong>·GBK</strong></h4><p>全称为 Chinese Internal Code Specification，即汉字内码扩展规范，于 1995 年制定。 它主要是扩展了 GB2312，在它的基础上又加了更多的汉字，它一共收录了 21003 个汉字</p>
<h4 id="·GB18030"><a href="#·GB18030" class="headerlink" title="·GB18030"></a><strong>·GB18030</strong></h4><p>现在最新的内码字集于 2000 年发布，并于 2001 年强制执行，包含了中国大部分少数 民族的语言字符，收录汉字数超过 70000 余个。</p>
<p>它主要采用单字节、双字节、四字节对字符编码，它是向下兼容 GB2312 和 GBK 的， 虽然是我国的强制使用标准，但在实际生产中很少用到，用得最多的反而是 GBK 和 GB2312</p>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a><strong>Unicode</strong></h3><p>Unicode 编码设计成了固定两个字节，所有的字符都用 16 位(2^16=65536) 表示，包括之前只占 8 位的英文字符等，所以会造成空间的浪费，UNICODE 在 很长的一段时间内都没有得到推广应用。</p>
<p>6</p>
<p>北京尚学堂·百战程序员 高淇的 python400 集:从零打好内功，直达手写神经网络 Unicode 完全重新设计，不兼容 iso8859-1，也不兼容任何其他编码。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a><strong>UTF-8</strong></h3><p>对于英文字母，unicode 也需要两个字节来表示。所以 unicode 不便 于传输和存储。因此而产生了 UTF 编码，UTF-8 全称是(8-bit Unicode Transformation Format)。</p>
<p>UTF 编码兼容 iso8859-1 编码，同时也可以用来表示所有语言的字符， 不过，UTF 编码是不定长编码，每一个字符的长度从 1-4 个字节不等。其中， 英文字母都是用一个字节表示，而汉字使用三个字节。</p>
<p>【老鸟建议】一般项目都会使用 UTF-8。unicode 中虽然汉字是两个字节， UTF-8 中汉字是 3 个字节。但是互联网中一个网页也包含了大量的英文字母， 这些英文字母只占用 1 个字节，整体占用空间，UTF-8 仍然由于 Unicode。</p>
<h2 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a><strong>中文乱码问题</strong></h2><p>windows 操作系统默认的编码是 GBK，Linux 操作系统默认的编码是 UTF-8。当我们 用 open()时，调用的是操作系统打开的文件，默认的编码是 GBK。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在文件编辑区单击右键，选择 FileEncoding，选择 GBK 即可:</span><br></pre></td></tr></table></figure>

<h2 id="write-writelines-写入数据"><a href="#write-writelines-写入数据" class="headerlink" title="write()/writelines()写入数据"></a><strong>write()/writelines()写入数据</strong></h2><p>write(a):把字符串 a 写入到文件中 </p>
<p>writelines(b):把字符串列表写入文件中，不添加换行符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">r"d:\bb.txt"</span>,<span class="string">"w"</span>,encoding=<span class="string">"utf-8"</span>) </span><br><span class="line">s = [<span class="string">"高淇\n"</span>,<span class="string">"高老三\n"</span>,<span class="string">"高老四\n"</span>] </span><br><span class="line">f.writelines(s)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h2 id="close-关闭文件流"><a href="#close-关闭文件流" class="headerlink" title="close()关闭文件流"></a><strong>close()关闭文件流</strong></h2><p>由于文件底层是由操作系统控制，所以我们打开的文件对象必须显式调用 close()方法 关闭文件对象。当调用 close()方法时，首先会把缓冲区数据写入文件(也可以直接调用 flush() 方法)，再关闭文件，释放文件对象。</p>
<p>为了确保打开的文件对象正常关闭，一般结合异常机制的 finally 或者 with 关键字实现 无论何种情况都能关闭打开的文件对象。</p>
<p>结合异常机制 finally 确保关闭文件对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	f = open(<span class="string">r"my01.txt"</span>,<span class="string">"a"</span>) </span><br><span class="line">  str = <span class="string">"gaoqi"</span></span><br><span class="line">	f.write(str)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e: </span><br><span class="line">  print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  f.close()</span><br></pre></td></tr></table></figure>

<h2 id="with-语句-上下文管理器"><a href="#with-语句-上下文管理器" class="headerlink" title="with 语句(上下文管理器)"></a><strong>with 语句(上下文管理器)</strong></h2><p>with 关键字(上下文管理器)可以自动管理上下文资源，不论什么原因跳出 with 块，都能 确保文件正确的关闭，并且可以在代码块执行完毕后自动还原进入该代码块时的现场。</p>
<p>使用 with 管理文件写入操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="string">"高淇\n"</span>,<span class="string">"高老三\n"</span>,<span class="string">"高老五\n"</span>]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"d:\bb.txt"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">	f.writelines(s)</span><br></pre></td></tr></table></figure>

<h2 id="文本文件的读取"><a href="#文本文件的读取" class="headerlink" title="文本文件的读取"></a><strong>文本文件的读取</strong></h2><p>文件的读取一般使用如下三个方法: 1. read([size])</p>
<p>从文件中读取 size 个字符，并作为结果返回。如果没有 size 参数，则读取整个文件。</p>
<p>读取到文件末尾，会返回空字符串。 2. readline()</p>
<p>读取一行内容作为结果返回。读取到文件末尾，会返回空字符串。 3. readlines()</p>
<p>文本文件中，每一行作为一个字符串存入列表中，返回该列表</p>
<p>读取一个文件前 4 个字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(r&quot;bb&quot;,&quot;r&quot;,encoding&#x3D;&quot;utf-8&quot;) as f: </span><br><span class="line">	print(f.read(4))</span><br></pre></td></tr></table></figure>

<p>文件较小，一次将文件内容读入到程序中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(r&quot;d:\bb.txt&quot;,&quot;r&quot;) as f: </span><br><span class="line">	print(f.read())</span><br></pre></td></tr></table></figure>

<p>按行读取一个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with open(r&quot;bb.txt&quot;,&quot;r&quot;) as f: </span><br><span class="line">	while True:</span><br><span class="line">		fragment &#x3D; f.readline() </span><br><span class="line">		if not fragment:</span><br><span class="line">			break </span><br><span class="line">		else:</span><br><span class="line">			print(fragment,end&#x3D;&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p>使用迭代器(每次返回一行)读取文本文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(r&quot;d:\bb.txt&quot;,&quot;r&quot;) as f: </span><br><span class="line">	for a in f:</span><br><span class="line">		print(a,end&#x3D;&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p>为文本文件每一行的末尾增加行号</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"e.txt"</span>,<span class="string">"r"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f: </span><br><span class="line">  lines = f.readlines()</span><br><span class="line">  lines = [ line.rstrip()+<span class="string">" #"</span>+str(index+<span class="number">1</span>)+<span class="string">"\n"</span> <span class="keyword">for</span> index,line <span class="keyword">in</span> enumerate(lines)] <span class="comment">#推导式生成列表</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"e.txt"</span>,<span class="string">"w"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f: </span><br><span class="line">  f.writelines(lines)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">执行前文件内容:</span><br><span class="line">我 love u! </span><br><span class="line">尚学堂 </span><br><span class="line">百战程序员</span><br><span class="line">执行程序后文件内容:</span><br><span class="line">我 love u! #1 </span><br><span class="line">尚学堂 #2 </span><br><span class="line">百战程序员 #3</span><br></pre></td></tr></table></figure>

<p><strong>二进制文件的读取和写入</strong></p>
<p>二进制文件的处理流程和文本文件流程一致。首先还是要创建文件对象，不过，我们需要指 定二进制模式，从而创建出二进制文件对象。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f &#x3D; open(r&quot;d:\a.txt&quot;, &#39;wb&#39;) #可写的、重写模式的二进制文件对象</span><br><span class="line">f &#x3D; open(r&quot;d:\a.txt&quot;, &#39;ab&#39;)  #可写的、追加模式的二进制文件对象</span><br><span class="line">f &#x3D; open(r&quot;d:\a.txt&quot;, &#39;rb&#39;) #可读的二进制文件对象</span><br></pre></td></tr></table></figure>

<p>创建好二进制文件对象后，仍然可以使用 write()、read()实现文件的读写操作。</p>
<p>读取图片文件，实现文件的拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with open(&#39;aa.gif&#39;, &#39;rb&#39;) as f:</span><br><span class="line">	with open(&#39;aa_copy.gif&#39;, &#39;wb&#39;) as w:</span><br><span class="line">		for line in f.readlines():</span><br><span class="line">    w.write(line)</span><br><span class="line">print(&#39;图片拷贝完成!&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="文件对象的常用属性和方法"><a href="#文件对象的常用属性和方法" class="headerlink" title="文件对象的常用属性和方法"></a>文件对象的常用属性和方法</h2><p>文件对象封装了文件相关的操作。在前面我们学习了通过文件对象对文件进行读写操作。本 节我们详细列出文件对象的常用属性和方法，并进行说明。</p>
<p>文件对象的属性<br> 属性                                                说明</p>
<table>
<thead>
<tr>
<th>name</th>
<th>返回文件的名字</th>
</tr>
</thead>
<tbody><tr>
<td>mode</td>
<td>返回文件的打开模式</td>
</tr>
<tr>
<td>closed</td>
<td>若文件被关闭则返回 True</td>
</tr>
</tbody></table>
<p>文件对象的打开模式</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读模式</td>
</tr>
<tr>
<td>w</td>
<td>写模式</td>
</tr>
<tr>
<td>a</td>
<td>追加模式</td>
</tr>
<tr>
<td>b</td>
<td><code>二进制模式(可与其他模式组合)</code></td>
</tr>
<tr>
<td>+</td>
<td><code>读写模式(可以其他模式组合)</code></td>
</tr>
</tbody></table>
<p>文件对象的常用方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>read([size])</td>
<td>从文件中读取 size 个字节或字符的内容返回。若省略[size]，则读 取到文件末尾，即一次读取文件所有内容</td>
</tr>
<tr>
<td>readline()</td>
<td>从文本文件中读取一行内容</td>
</tr>
<tr>
<td>readlines()</td>
<td>把文本文件中每一行都作为独立的字符串对象，并将这些对象放入 列表返回</td>
</tr>
<tr>
<td>write(str)</td>
<td>将字符串 str 内容写入文件</td>
</tr>
<tr>
<td>writelines(s)</td>
<td>将字符串列表 s 写入文件文件，不添加换行符</td>
</tr>
<tr>
<td>seek(offset ,whence])</td>
<td>把文件指针移动到新的位置，offset 表示相对于 whence 的多少个 字节的偏移量; offset:                                 off 为正往结束方向移动，为负往开始方向移动 whence 不同的值代表不同含义:  0: 从文件头开始计算(默认值) 1:从当前位置开始计算  2:从文件尾开始计算</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>tell()</td>
<td>返回文件指针的当前位置</td>
</tr>
<tr>
<td>truncate([size])</td>
<td>不论指针在什么位置，只留下指针前 size 个字节的内容，其余全 部删除;  如果没有传入 size，则当指针当前位置到文件末尾内容全部删除</td>
</tr>
<tr>
<td>flush()</td>
<td>把缓冲区的内容写入文件，但不关闭文件</td>
</tr>
<tr>
<td>close()</td>
<td>把缓冲区内容写入文件，同时关闭文件，释放文件对象相关资源</td>
</tr>
</tbody></table>
<h2 id="文件任意位置操作"><a href="#文件任意位置操作" class="headerlink" title="文件任意位置操作"></a><strong>文件任意位置操作</strong></h2><p>seek()移动文件指针示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;e.txt&quot;,&quot;r&quot;,encoding&#x3D;&quot;utf-8&quot;) as f: </span><br><span class="line">	print(&quot;文件名是:&#123;0&#125;&quot;.format(f.name)) </span><br><span class="line">	print(f.tell())</span><br><span class="line">	print(&quot;读取的内容:&#123;0&#125;&quot;.format(str(f.readline()))) </span><br><span class="line">	print(f.tell())</span><br><span class="line">	f.seek(0,0) </span><br><span class="line">	print(&quot;读取的内容:&#123;0&#125;&quot;.format(str(f.readline())))</span><br></pre></td></tr></table></figure>

<h2 id="使用-pickle-序列化"><a href="#使用-pickle-序列化" class="headerlink" title="使用 pickle 序列化"></a><strong>使用 pickle 序列化</strong></h2><p>Python 中，一切皆对象，对象本质上就是一个“存储数据的内存块”。有时候，我们 需要将“内存块的数据”保存到硬盘上，或者通过网络传输到其他的计算机上。这时候，就 需要“对象的序列化和反序列化”。 对象的序列化机制广泛的应用在分布式、并行系统上。</p>
<p>序列化指的是:将对象转化成“串行化”数据形式，存储到硬盘或通过网络传输到其他 地方。反序列化是指相反的过程，将读取到的“串行化数据”转化成对象。</p>
<p>我们可以使用 pickle 模块中的函数，实现序列化和反序列操作。</p>
<p>序列化我们使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> pickle.dump(obj, file) obj 就是要被序列化的对象，file 指的是存储的文件</span><br><span class="line">pickle.load(file) 从 file 读取数据，反序列化成对象</span><br></pre></td></tr></table></figure>

<p>1.序列化是指把对象转换为字节序列的过程，而反序列化是指把字节序列恢复为对象的过程</p>
<p>2.对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。</p>
<p>3.序列化机制的核心作用就是对象状态的保存与重建。</p>
<p>4.反序列化就是客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p>
<p>5.序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态。</p>
<p>6.序列化算法一般会按步骤做如下事情：</p>
<p>（1）将对象实例相关的类元数据输出。<br>（2）递归地输出类的超类描述直到不再有超类。<br>（3）类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。<br>（4）从上至下递归输出实例的数据</p>
<p>7.序列化的好处：</p>
<p>一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），</p>
<p>二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。</p>
<h4 id="对象序列化到文件中-反序列化"><a href="#对象序列化到文件中-反序列化" class="headerlink" title="对象序列化到文件中,反序列化"></a>对象序列化到文件中,反序列化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"d:\data.dat"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> f:<span class="comment">#序列化</span></span><br><span class="line">  a1=<span class="string">"nihao"</span></span><br><span class="line">  a2=<span class="string">"223"</span></span><br><span class="line">  pickle.dump(a1,f)</span><br><span class="line">  pickle.dump(a2,f)</span><br><span class="line"> <span class="comment">#反序列化</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"d:\data.dat"</span>,<span class="string">"rb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">  a1 = pickle.load(f)</span><br><span class="line">  a2 = pickle.load(f)</span><br><span class="line">  print(a1);print(a2)</span><br><span class="line">  <span class="comment">#打印出：nihao</span></span><br><span class="line">          <span class="number">223</span></span><br></pre></td></tr></table></figure>

<h2 id="CSV-文件的操作"><a href="#CSV-文件的操作" class="headerlink" title="CSV 文件的操作"></a><strong>CSV 文件的操作</strong></h2><p>csv(Comma Separated Values)是逗号分隔符文本格式，常用于数据交换、Excel 文件和数据库数据的导入和导出。与 Excel 文件不同，CSV 文件中:</p>
<p>值没有类型，所有值都是字符串 不能指定字体颜色等样式 不能指定单元格的宽高，不能合并单元格，没有多个工作表</p>
<p>不能嵌入图像图表</p>
<h3 id="csv-reader-对象和-csv-文件读取"><a href="#csv-reader-对象和-csv-文件读取" class="headerlink" title="csv.reader 对象和 csv 文件读取"></a><strong>csv.reader 对象和 csv 文件读取</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"d:\a.csv"</span>) <span class="keyword">as</span> a:</span><br><span class="line">	a_csv = csv.reader(a) <span class="comment">#创建 csv 对象,它是一个包含所有数据的列表，每一行为一个元素</span></span><br><span class="line">  headers = next(a_csv) <span class="comment">#获得列表对象，包含标题行的信息</span></span><br><span class="line">  print(headers)</span><br><span class="line">	<span class="keyword">for</span> row <span class="keyword">in</span> a_csv:<span class="comment">#循环打印各行内容</span></span><br><span class="line">		print(row)</span><br><span class="line">    <span class="comment">#['高老三', '19', '测试工程师', '20000'] </span></span><br><span class="line">    [<span class="string">'高老五'</span>, <span class="string">'20'</span>, <span class="string">'人工智能开发'</span>, <span class="string">'50000'</span>]</span><br></pre></td></tr></table></figure>

<h3 id="csv-writer-对象和-csv-文件写入"><a href="#csv-writer-对象和-csv-文件写入" class="headerlink" title="csv.writer 对象和 csv 文件写入"></a><strong>csv.writer 对象和 csv 文件写入</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">headers = [<span class="string">"工号"</span>,<span class="string">"姓名"</span>,<span class="string">"年龄"</span>,<span class="string">"地址"</span>,<span class="string">"月薪"</span>]</span><br><span class="line">rows = [(<span class="string">"1001"</span>,<span class="string">"高淇"</span>,<span class="number">18</span>,<span class="string">"西三旗 1 号院"</span>,<span class="string">"50000"</span>),(<span class="string">"1002"</span>,<span class="string">"高八"</span>,<span class="number">19</span>,<span class="string">"西三旗 1 号院"</span>,<span class="string">"30000"</span>)] </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"d:\b.csv"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> b:</span><br><span class="line">	b_csv = csv.writer(b) <span class="comment">#创建 csv 对象</span></span><br><span class="line">	b_csv.writerow(headers) <span class="comment">#写入一行(标题)</span></span><br><span class="line">	b_csv.writerows(rows)  <span class="comment">#写入多行(数据)</span></span><br><span class="line">```</span><br><span class="line">执行结果:</span><br><span class="line">工号,姓名,年龄,地址,月薪 </span><br><span class="line"><span class="number">1001</span>,高淇,<span class="number">18</span>,西三旗 <span class="number">1</span> 号院,<span class="number">50000</span> </span><br><span class="line"><span class="number">1002</span>,高八,<span class="number">19</span>,西三旗 <span class="number">1</span> 号院,<span class="number">30000</span></span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="os-和-os-path-模块"><a href="#os-和-os-path-模块" class="headerlink" title="os 和 os.path 模块"></a><strong>os 和 os.path 模块</strong></h2><p>os 模块可以帮助我们直接对操作系统进行操作。我们可以直接调用操作系统的可执行 文件、命令，直接操作文件、目录等等。在系统运维的核心基础。</p>
<p>**os 模块-调用操作系统命令</p>
<h3 id="·os-system-可以帮助我们直接调用系统的命令"><a href="#·os-system-可以帮助我们直接调用系统的命令" class="headerlink" title="** ·os.system 可以帮助我们直接调用系统的命令"></a>** <strong>·os.system 可以帮助我们直接调用系统的命令</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import os </span><br><span class="line">os.system(&quot;notepad.exe&quot;)#os.system 调用 windows 系统的记事本程序</span><br><span class="line">import os</span><br><span class="line">os.system(&quot;ping www.baidu.com&quot;)#os.system 调用 windows 系统中 ping 命令</span><br><span class="line">import os</span><br><span class="line">os.startfile(r&quot;C:\Program Files (x86)\Tencent\WeChat\WeChat.exe&quot;)#运行安装好的微信</span><br></pre></td></tr></table></figure>

<p><strong>【注】</strong>Linux 是命令行操作更容易，我们可以通过 os.system 可以更加容易的调用相关的命 令;</p>
<p>【注】控制台输出中文可能会有乱码问题，可以在 file–&gt;setting 中设置</p>
<p><strong>os.startfile:直接调用可执行文件</strong></p>
<p><strong>os 模块-文件和目录操作</strong></p>
<p>我们可以通过前面讲的文件对象实现对于文件内容的读写操作。如果，还需要对文件和 目录做其他操作，可以使用 os 和 os.path 模块。</p>
<p>os 模块下常用操作文件的方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>remove(path)</td>
<td>删除指定的文件</td>
</tr>
<tr>
<td>rename(src,dest)</td>
<td>重命名文件或目录</td>
</tr>
<tr>
<td>stat(path)</td>
<td>返回文件的所有属性</td>
</tr>
<tr>
<td>listdir(path)</td>
<td>返回 path 目录下的文件和目录列表</td>
</tr>
</tbody></table>
<p>os 模块下关于目录操作的相关方法，汇总如下:</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>mkdir(path)</td>
<td>创建目录</td>
</tr>
<tr>
<td>makedirs(path1/path2/path3/… )</td>
<td>创建多级目录</td>
</tr>
<tr>
<td>rmdir(path)</td>
<td>删除目录</td>
</tr>
<tr>
<td>removedirs(path1/path2…)</td>
<td>删除多级目录</td>
</tr>
<tr>
<td>getcwd()</td>
<td>返回当前工作目录:current work dir</td>
</tr>
<tr>
<td>chdir(path)</td>
<td>把 path 设为当前工作目录</td>
</tr>
<tr>
<td>walk()</td>
<td>遍历目录树</td>
</tr>
<tr>
<td>sep</td>
<td><code>当前操作系统所使用的路径分隔符</code></td>
</tr>
</tbody></table>
<p>os 模块:创建、删除目录、获取文件信息等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#coding&#x3D;utf-8</span><br><span class="line">#测试 os 模块中，关于文件和目录的操作 import os</span><br><span class="line">#############获取文件和文件夹相关的信息################ print(os.name) #windows-&gt;nt linux 和 unix-&gt;posix print(os.sep) #windows-&gt;\ linux 和 unix-&gt;&#x2F; print(repr(os.linesep)) #windows-&gt;\r\n linux--&gt;\n\</span><br><span class="line">print(os.stat(&quot;my02.py&quot;))</span><br><span class="line">##############关于工作目录的操作############### #print(os.getcwd())</span><br><span class="line">#os.chdir(&quot;d:&quot;) #改变当前的工作目录为:d:盘根目录 #os.mkdir(&quot;书籍&quot;) ################创建目录、创建多级目录、删除############# #os.mkdir(&quot;书籍&quot;)</span><br><span class="line">#os.rmdir(&quot;书籍&quot;) #相对路径都是相对于当前的工作目录</span><br><span class="line"></span><br><span class="line">#os.rename(&quot;电影&quot;,&quot;movie&quot;)</span><br><span class="line">dirs &#x3D; os.listdir(&quot;movie&quot;)</span><br><span class="line">print(dirs)</span><br></pre></td></tr></table></figure>

<p><strong>os.path 模块</strong></p>
<p>os.path 模块提供了目录相关(路径判断、路径切分、路径连接、文件夹遍历)的操作</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>isabs(path)</td>
<td>判断 path 是否绝对路径</td>
</tr>
<tr>
<td>isdir(path)</td>
<td>判断 path 是否为目录</td>
</tr>
<tr>
<td>isfile(path)</td>
<td>判断 path 是否为文件</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>exists(path)</th>
<th><code>判断指定路径的文件是否存在</code></th>
</tr>
</thead>
<tbody><tr>
<td>getsize(filename)</td>
<td>返回文件的大小</td>
</tr>
<tr>
<td>abspath(path)</td>
<td>返回绝对路径</td>
</tr>
<tr>
<td>dirname(p)</td>
<td>返回目录的路径</td>
</tr>
<tr>
<td>getatime(filename)</td>
<td>返回文件的最后访问时间</td>
</tr>
<tr>
<td>getmtime(filename)</td>
<td>返回文件的最后修改时间</td>
</tr>
<tr>
<td>walk(top,func,arg)</td>
<td>递归方式遍历目录</td>
</tr>
<tr>
<td>join(path,*paths)</td>
<td>连接多个 path</td>
</tr>
<tr>
<td>split(path)</td>
<td>对路径进行分割，以列表形式返回</td>
</tr>
<tr>
<td>splitext(path)</td>
<td><code>从路径中分割文件的扩展名</code></td>
</tr>
</tbody></table>
<p><strong>walk()递归遍历所有文件和目录</strong></p>
<p>os.walk()方法:</p>
<p>返回一个 3 个元素的元组，(dirpath, dirnames, filenames), </p>
<p>dirpath:要列出指定目录的路径 dirnames:目录下的所有文件夹 filenames:目录下的所有文件</p>
<p><strong>shutil 模块(拷贝和压缩)</strong></p>
<p>shutil 模块是 python 标准库中提供的，主要用来做文件和文件夹的拷贝、移动、删除等;还可以做 文件和文件夹的压缩、解压缩操作。</p>
<p>os 模块提供了对目录或文件的一般操作。shutil 模块作为补充，提供了移动、复制、压缩、解压等操 作，这些 os 模块都没有提供。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/01/rsa%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/01/rsa%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">rsa加密算法详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-01 14:12:10 / Modified: 14:25:12" itemprop="dateCreated datePublished" datetime="2020-05-01T14:12:10-05:00">2020-05-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们日常传输数据想防止hacker的攻击，需要加密算法，常见的：对称加密，非对称加密，对称加密相对于交易双方有相同钥匙，但是任意一方被黑，两方都有危险，而非对称加密，最经典的rsa解决了这个问题。</p>
<p>rsa算法原理：</p>
<p>首先找出两个质数 p和q</p>
<p>计算   n = p * q</p>
<p>φ(n) = (p-1)  * (q-1)      这个函数又叫欧拉函数</p>
<p>公钥e    1 &lt; e &lt; φ(n)   在这个范围取出一个整数，并且 e 和 φ(n) 互质</p>
<p>私钥d    (e * d ) / φ(n)  = x  ······ 1       (x是几无所谓，余数必须是1，比如 φ(n)是20 e是3 那么d就是7)</p>
<p> 加密  m^e / n =x  ······  c     (这几个x都代表任意数的商，在这里面没有直接意义，可以忽略不看，这三个x也都不相等)</p>
<p> 解密  c^d  / n =x   ······ m   (可以从数学上证明，经过这一系列的计算，得到结果的余数一定是m)<br>————————————————<br>版权声明：本文为CSDN博主「狱蝶阿一」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_42510528/java/article/details/80765361" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42510528/java/article/details/80765361</a></p>
<p><strong>一、RSA加密简介</strong>（ssh典型用此算法）</p>
<p>　　RSA加密是一种非对称加密。可以在不直接传递密钥的情况下，完成解密。这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。是由一对密钥来进行加解密的过程，分别称为公钥和私钥。两者之间有数学相关，该加密算法的原理就是对一极大整数做因数分解的困难性来保证安全性。通常个人保存私钥，公钥是公开的（可能同时多人持有）。</p>
<p>　　</p>
<p><strong>二、RSA加密、签名区别</strong></p>
<p>　　加密和签名都是为了安全性考虑，但略有不同。常有人问加密和签名是用私钥还是公钥？其实都是对加密和签名的作用有所混淆。简单的说，加密是为了防止信息被泄露，而签名是为了防止信息被篡改。这里举2个例子说明。</p>
<p><strong>第一个场景</strong>：战场上，B要给A传递一条消息，内容为某一指令。</p>
<p>RSA的加密过程如下：</p>
<p>（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。</p>
<p>（2）A传递自己的公钥给B，B用A的公钥对消息进行加密。</p>
<p>（3）A接收到B加密的消息，利用A自己的私钥对消息进行解密。</p>
<p>　　在这个过程中，只有2次传递过程，第一次是A传递公钥给B，第二次是B传递加密消息给A，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行解密，防止了消息内容的泄露。</p>
<p>所以.ssh文件中私钥千万别动，那是你唯一救命稻草。但是公钥随便给别人。 </p>
<p><strong>第二个场景：</strong>A收到B发的消息后，需要进行回复“收到”。</p>
<p>RSA签名的过程如下：</p>
<p>（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。</p>
<p>（2）A用自己的私钥对消息加签，形成签名，并将加签的消息和消息本身一起传递给B。</p>
<p>（3）B收到消息后，在获取A的公钥进行验签，如果验签出来的内容与消息本身一致，证明消息是A回复的。</p>
<p>　　在这个过程中，只有2次传递过程，第一次是A传递加签的消息和消息本身给B，第二次是B获取A的公钥，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行签名，即使知道了消息内容，也无法伪造带签名的回复给B，防止了消息内容的篡改。</p>
<p>　　但是，综合两个场景你会发现，第一个场景虽然被截获的消息没有泄露，但是可以利用截获的公钥，将假指令进行加密，然后传递给A。第二个场景虽然截获的消息不能被篡改，但是消息的内容可以利用公钥验签来获得，并不能防止泄露。所以在实际应用中，要根据情况使用，也可以同时使用加密和签名，比如A和B都有一套自己的公钥和私钥，当A要给B发送消息时，先用B的公钥对消息加密，再对加密的消息使用A的私钥加签名，达到既不泄露也不被篡改，更能保证消息的安全性。</p>
<p>　　<strong>总结：公钥加密、私钥解密、私钥签名、公钥验签。</strong></p>
<p><strong>三、RSA加密、签名的方法，代码例子如下：</strong></p>
<p>java实现此算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">  1 import java.io.ByteArrayOutputStream;&#x2F;&#x2F;都是javase6以后的包</span><br><span class="line">  2 import java.security.KeyFactory;</span><br><span class="line">  3 import java.security.KeyPair;</span><br><span class="line">  4 import java.security.KeyPairGenerator;</span><br><span class="line">  5 import java.security.PrivateKey;</span><br><span class="line">  6 import java.security.PublicKey;</span><br><span class="line">  7 import java.security.Signature;</span><br><span class="line">  8 import java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line">  9 import java.security.spec.X509EncodedKeySpec;</span><br><span class="line"> 10 import javax.crypto.Cipher;</span><br><span class="line"> 11 import org.apache.commons.codec.binary.Base64;</span><br><span class="line"> 12 </span><br><span class="line"> 13 public class TestRSA &#123;</span><br><span class="line"> 14 </span><br><span class="line"> 15     &#x2F;**</span><br><span class="line"> 16      * RSA最大加密明文大小</span><br><span class="line"> 17      *&#x2F;</span><br><span class="line"> 18     private static final int MAX_ENCRYPT_BLOCK &#x3D; 117;</span><br><span class="line"> 19 </span><br><span class="line"> 20     &#x2F;**</span><br><span class="line"> 21      * RSA最大解密密文大小</span><br><span class="line"> 22      *&#x2F;</span><br><span class="line"> 23     private static final int MAX_DECRYPT_BLOCK &#x3D; 128;</span><br><span class="line"> 24 </span><br><span class="line"> 25     &#x2F;**</span><br><span class="line"> 26      * 获取密钥对</span><br><span class="line"> 27      * </span><br><span class="line"> 28      * @return 密钥对</span><br><span class="line"> 29      *&#x2F;</span><br><span class="line"> 30     public static KeyPair getKeyPair() throws Exception &#123;</span><br><span class="line"> 31         KeyPairGenerator generator &#x3D; KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line"> 32         generator.initialize(1024);</span><br><span class="line"> 33         return generator.generateKeyPair();</span><br><span class="line"> 34     &#125;</span><br><span class="line"> 35 </span><br><span class="line"> 36     &#x2F;**</span><br><span class="line"> 37      * 获取私钥</span><br><span class="line"> 38      * </span><br><span class="line"> 39      * @param privateKey 私钥字符串</span><br><span class="line"> 40      * @return</span><br><span class="line"> 41      *&#x2F;</span><br><span class="line"> 42     public static PrivateKey getPrivateKey(String privateKey) throws Exception &#123;</span><br><span class="line"> 43         KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line"> 44         byte[] decodedKey &#x3D; Base64.decodeBase64(privateKey.getBytes());</span><br><span class="line"> 45         PKCS8EncodedKeySpec keySpec &#x3D; new PKCS8EncodedKeySpec(decodedKey);</span><br><span class="line"> 46         return keyFactory.generatePrivate(keySpec);</span><br><span class="line"> 47     &#125;</span><br><span class="line"> 48 </span><br><span class="line"> 49     &#x2F;**</span><br><span class="line"> 50      * 获取公钥</span><br><span class="line"> 51      * </span><br><span class="line"> 52      * @param publicKey 公钥字符串</span><br><span class="line"> 53      * @return</span><br><span class="line"> 54      *&#x2F;</span><br><span class="line"> 55     public static PublicKey getPublicKey(String publicKey) throws Exception &#123;</span><br><span class="line"> 56         KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line"> 57         byte[] decodedKey &#x3D; Base64.decodeBase64(publicKey.getBytes());</span><br><span class="line"> 58         X509EncodedKeySpec keySpec &#x3D; new X509EncodedKeySpec(decodedKey);</span><br><span class="line"> 59         return keyFactory.generatePublic(keySpec);</span><br><span class="line"> 60     &#125;</span><br><span class="line"> 61     </span><br><span class="line"> 62     &#x2F;**</span><br><span class="line"> 63      * RSA加密</span><br><span class="line"> 64      * </span><br><span class="line"> 65      * @param data 待加密数据</span><br><span class="line"> 66      * @param publicKey 公钥</span><br><span class="line"> 67      * @return</span><br><span class="line"> 68      *&#x2F;</span><br><span class="line"> 69     public static String encrypt(String data, PublicKey publicKey) throws Exception &#123;</span><br><span class="line"> 70         Cipher cipher &#x3D; Cipher.getInstance(&quot;RSA&quot;);</span><br><span class="line"> 71         cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line"> 72         int inputLen &#x3D; data.getBytes().length;</span><br><span class="line"> 73         ByteArrayOutputStream out &#x3D; new ByteArrayOutputStream();</span><br><span class="line"> 74         int offset &#x3D; 0;</span><br><span class="line"> 75         byte[] cache;</span><br><span class="line"> 76         int i &#x3D; 0;</span><br><span class="line"> 77         &#x2F;&#x2F; 对数据分段加密</span><br><span class="line"> 78         while (inputLen - offset &gt; 0) &#123;</span><br><span class="line"> 79             if (inputLen - offset &gt; MAX_ENCRYPT_BLOCK) &#123;</span><br><span class="line"> 80                 cache &#x3D; cipher.doFinal(data.getBytes(), offset, MAX_ENCRYPT_BLOCK);</span><br><span class="line"> 81             &#125; else &#123;</span><br><span class="line"> 82                 cache &#x3D; cipher.doFinal(data.getBytes(), offset, inputLen - offset);</span><br><span class="line"> 83             &#125;</span><br><span class="line"> 84             out.write(cache, 0, cache.length);</span><br><span class="line"> 85             i++;</span><br><span class="line"> 86             offset &#x3D; i * MAX_ENCRYPT_BLOCK;</span><br><span class="line"> 87         &#125;</span><br><span class="line"> 88         byte[] encryptedData &#x3D; out.toByteArray();</span><br><span class="line"> 89         out.close();</span><br><span class="line"> 90         &#x2F;&#x2F; 获取加密内容使用base64进行编码,并以UTF-8为标准转化成字符串</span><br><span class="line"> 91         &#x2F;&#x2F; 加密后的字符串</span><br><span class="line"> 92         return new String(Base64.encodeBase64String(encryptedData));</span><br><span class="line"> 93     &#125;</span><br><span class="line"> 94 </span><br><span class="line"> 95     &#x2F;**</span><br><span class="line"> 96      * RSA解密</span><br><span class="line"> 97      * </span><br><span class="line"> 98      * @param data 待解密数据</span><br><span class="line"> 99      * @param privateKey 私钥</span><br><span class="line">100      * @return</span><br><span class="line">101      *&#x2F;</span><br><span class="line">102     public static String decrypt(String data, PrivateKey privateKey) throws Exception &#123;</span><br><span class="line">103         Cipher cipher &#x3D; Cipher.getInstance(&quot;RSA&quot;);</span><br><span class="line">104         cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">105         byte[] dataBytes &#x3D; Base64.decodeBase64(data);</span><br><span class="line">106         int inputLen &#x3D; dataBytes.length;</span><br><span class="line">107         ByteArrayOutputStream out &#x3D; new ByteArrayOutputStream();</span><br><span class="line">108         int offset &#x3D; 0;</span><br><span class="line">109         byte[] cache;</span><br><span class="line">110         int i &#x3D; 0;</span><br><span class="line">111         &#x2F;&#x2F; 对数据分段解密</span><br><span class="line">112         while (inputLen - offset &gt; 0) &#123;</span><br><span class="line">113             if (inputLen - offset &gt; MAX_DECRYPT_BLOCK) &#123;</span><br><span class="line">114                 cache &#x3D; cipher.doFinal(dataBytes, offset, MAX_DECRYPT_BLOCK);</span><br><span class="line">115             &#125; else &#123;</span><br><span class="line">116                 cache &#x3D; cipher.doFinal(dataBytes, offset, inputLen - offset);</span><br><span class="line">117             &#125;</span><br><span class="line">118             out.write(cache, 0, cache.length);</span><br><span class="line">119             i++;</span><br><span class="line">120             offset &#x3D; i * MAX_DECRYPT_BLOCK;</span><br><span class="line">121         &#125;</span><br><span class="line">122         byte[] decryptedData &#x3D; out.toByteArray();</span><br><span class="line">123         out.close();</span><br><span class="line">124         &#x2F;&#x2F; 解密后的内容 </span><br><span class="line">125         return new String(decryptedData, &quot;UTF-8&quot;);</span><br><span class="line">126     &#125;</span><br><span class="line">127 </span><br><span class="line">128     &#x2F;**</span><br><span class="line">129      * 签名</span><br><span class="line">130      * </span><br><span class="line">131      * @param data 待签名数据</span><br><span class="line">132      * @param privateKey 私钥</span><br><span class="line">133      * @return 签名</span><br><span class="line">134      *&#x2F;</span><br><span class="line">135     public static String sign(String data, PrivateKey privateKey) throws Exception &#123;</span><br><span class="line">136         byte[] keyBytes &#x3D; privateKey.getEncoded();</span><br><span class="line">137         PKCS8EncodedKeySpec keySpec &#x3D; new PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">138         KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line">139         PrivateKey key &#x3D; keyFactory.generatePrivate(keySpec);</span><br><span class="line">140         Signature signature &#x3D; Signature.getInstance(&quot;MD5withRSA&quot;);</span><br><span class="line">141         signature.initSign(key);</span><br><span class="line">142         signature.update(data.getBytes());</span><br><span class="line">143         return new String(Base64.encodeBase64(signature.sign()));</span><br><span class="line">144     &#125;</span><br><span class="line">145 </span><br><span class="line">146     &#x2F;**</span><br><span class="line">147      * 验签</span><br><span class="line">148      * </span><br><span class="line">149      * @param srcData 原始字符串</span><br><span class="line">150      * @param publicKey 公钥</span><br><span class="line">151      * @param sign 签名</span><br><span class="line">152      * @return 是否验签通过</span><br><span class="line">153      *&#x2F;</span><br><span class="line">154     public static boolean verify(String srcData, PublicKey publicKey, String sign) throws Exception &#123;</span><br><span class="line">155         byte[] keyBytes &#x3D; publicKey.getEncoded();</span><br><span class="line">156         X509EncodedKeySpec keySpec &#x3D; new X509EncodedKeySpec(keyBytes);</span><br><span class="line">157         KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line">158         PublicKey key &#x3D; keyFactory.generatePublic(keySpec);</span><br><span class="line">159         Signature signature &#x3D; Signature.getInstance(&quot;MD5withRSA&quot;);</span><br><span class="line">160         signature.initVerify(key);</span><br><span class="line">161         signature.update(srcData.getBytes());</span><br><span class="line">162         return signature.verify(Base64.decodeBase64(sign.getBytes()));</span><br><span class="line">163     &#125;</span><br><span class="line">164 </span><br><span class="line">165     public static void main(String[] args) &#123;</span><br><span class="line">166         try &#123;</span><br><span class="line">167             &#x2F;&#x2F; 生成密钥对</span><br><span class="line">168             KeyPair keyPair &#x3D; getKeyPair();</span><br><span class="line">169             String privateKey &#x3D; new String(Base64.encodeBase64(keyPair.getPrivate().getEncoded()));</span><br><span class="line">170             String publicKey &#x3D; new String(Base64.encodeBase64(keyPair.getPublic().getEncoded()));</span><br><span class="line">171             System.out.println(&quot;私钥:&quot; + privateKey);</span><br><span class="line">172             System.out.println(&quot;公钥:&quot; + publicKey);</span><br><span class="line">173             &#x2F;&#x2F; RSA加密</span><br><span class="line">174             String data &#x3D; &quot;待加密的文字内容&quot;;</span><br><span class="line">175             String encryptData &#x3D; encrypt(data, getPublicKey(publicKey));</span><br><span class="line">176             System.out.println(&quot;加密后内容:&quot; + encryptData);</span><br><span class="line">177             &#x2F;&#x2F; RSA解密</span><br><span class="line">178             String decryptData &#x3D; decrypt(encryptData, getPrivateKey(privateKey));</span><br><span class="line">179             System.out.println(&quot;解密后内容:&quot; + decryptData);</span><br><span class="line">180             </span><br><span class="line">181             &#x2F;&#x2F; RSA签名</span><br><span class="line">182             String sign &#x3D; sign(data, getPrivateKey(privateKey));</span><br><span class="line">183             &#x2F;&#x2F; RSA验签</span><br><span class="line">184             boolean result &#x3D; verify(data, getPublicKey(publicKey), sign);</span><br><span class="line">185             System.out.print(&quot;验签结果:&quot; + result);</span><br><span class="line">186         &#125; catch (Exception e) &#123;</span><br><span class="line">187             e.printStackTrace();</span><br><span class="line">188             System.out.print(&quot;加解密异常&quot;);</span><br><span class="line">189         &#125;</span><br><span class="line">190     &#125;</span><br><span class="line">191 &#125;</span><br></pre></td></tr></table></figure>

<p>　　PS:RSA加密对明文的长度有所限制，规定需加密的明文最大长度=密钥长度-11（单位是字节，即byte），所以在<strong>加密和解密的过程中需要分块进行</strong>。而密钥默认是1024位，即1024位/8位-11=128-11=117字节。所以默认加密前的明文最大长度117字节，解密密文最大长度为128字。那么为啥两者相差11字节呢？是因为RSA加密使用到了填充模式（padding），即内容不足117字节时会自动填满，用到填充模式自然会占用一定的字节，而且这部分字节也是参与加密的。</p>
<p>　　密钥长度的设置就是上面例子的第32行。可自行调整，当然非对称加密随着密钥变长，安全性上升的同时性能也会有所下降。</p>
<p>改编自：<a href="https://www.cnblogs.com/pcheng/p/9629621.html，https://blog.csdn.net/weixin_42510528/java/article/details/80765361" target="_blank" rel="noopener">https://www.cnblogs.com/pcheng/p/9629621.html，https://blog.csdn.net/weixin_42510528/java/article/details/80765361</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/python400%E9%9B%864/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/python400%E9%9B%864/" class="post-title-link" itemprop="url">python400集4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 15:09:31" itemprop="dateCreated datePublished" datetime="2020-04-29T15:09:31-05:00">2020-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-03 20:08:15" itemprop="dateModified" datetime="2020-05-03T20:08:15-05:00">2020-05-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="异常和错误"><a href="#异常和错误" class="headerlink" title="异常和错误"></a>异常和错误</h1><p>软件程序在运行过程中，非常可能遇到刚刚提到的这些问题，我们称之为 异常，英文是:Exception，意思是例外。</p>
<h2 id="异常机制本质"><a href="#异常机制本质" class="headerlink" title="异常机制本质"></a>异常机制本质</h2><p>异常指程序运行过程中出现的非正常现象，例如用户输入错误、除数为零、需 要处理的文件不存在、数组下标越界等。</p>
<p>所谓异常处理，就是指程序在出现问题时依然可以正确的执行剩余的程序，而 不会因为异常而终止程序执行。</p>
<p>python 中，引进了很多用来描述和处理异常的类，称为异常类。异常类定义中 包含了该类异常的信息和对异常进行处理的方法。</p>
<p>python 中内建异常类的继承层次:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseException:所以异常的父类</span><br><span class="line">有4子类：KeyBoardInterrupt, Exception, SystemExit,GeneratorExit</span><br><span class="line">Exception内子类：NameError, ValueError, AttributeError等</span><br></pre></td></tr></table></figure>

<p><strong>python 中一切都是对象，异常也采用对象的方式来处理。处理过程:</strong> </p>
<ol>
<li><p><strong>抛出异常:</strong>在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给解释器。</p>
</li>
<li><p><strong>捕获异常:</strong>解释器得到该异常后，寻找相应的代码来处理该异常。</p>
</li>
</ol>
<p>异常解决的关键:定位</p>
<p>当发生异常时，解释器会报相关的错误信息，并会在控制台打印出相关错误信息。我们 只需按照从上到下的顺序即可追溯(Trackback)错误发生的过程，最终定位引起错误的那一 行代码。</p>
<h2 id="try…-一个except-结构"><a href="#try…-一个except-结构" class="headerlink" title="try… 一个except 结构"></a><strong>try…</strong> 一个<strong>except</strong> 结构</h2><p>try…except 是最常见的异常处理结构。结构如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">	被监控的可能引发异常的语句块</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> BaseException [<span class="keyword">as</span> e]:</span><br><span class="line"></span><br><span class="line">	异常处理语句块</span><br></pre></td></tr></table></figure>

<p>try 块包含着可能引发异常的代码，except 块则用来捕捉和处理发生的异常。执行的时 候，如果 try 块中没有引发异常，则跳过 ecept 块继续执行后续代码;执行的时候，如果 try块中发生了异常，则跳过 try 块中的后续代码，跳到相应的 except 块中处理异常;异常处理 完后，继续执行后续代码。</p>
<p>例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  print(<span class="string">"step1"</span>)</span><br><span class="line">  a=<span class="number">3</span>/<span class="number">0</span></span><br><span class="line">  print(<span class="string">"step2"</span>)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">  print(<span class="string">"step3"</span>)</span><br><span class="line">  print(<span class="string">"e"</span>)</span><br><span class="line">print(<span class="string">"step4"</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">step1</span><br><span class="line">step3</span><br><span class="line">division by zero </span><br><span class="line">step4</span><br></pre></td></tr></table></figure>

<p>例子2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">  print(&quot;step1&quot;)</span><br><span class="line">  a&#x3D;3&#x2F;2</span><br><span class="line">  print(&quot;step2&quot;)</span><br><span class="line">except BaseException as e:</span><br><span class="line">  print(&quot;step3&quot;)</span><br><span class="line">  print(&quot;e&quot;)</span><br><span class="line">print(&quot;step4&quot;)</span><br></pre></td></tr></table></figure>

<p>#结果</p>
<p>step1<br>step2<br>step4</p>
<h2 id="try…多个-except-结构"><a href="#try…多个-except-结构" class="headerlink" title="try…多个 except 结构"></a><strong>try…</strong>多个 <strong>except</strong> 结构</h2><p>上面的结构可以捕获所有的异常，工作中也很常见。但是，从经典理论考虑，一般建议 尽量捕获可能出现的多个异常(按照先子类后父类的顺序)，并且针对性的写出异常处理代 码。为了避免遗漏可能出现的异常，可以在最后增加 BaseException。结构如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">	被监控的可能引发异常的语句块</span><br><span class="line">except Exception1:</span><br><span class="line"> 处理 Exception1 的语句块</span><br><span class="line"></span><br><span class="line">except Exception2:</span><br><span class="line"> 处理 Exception2 的语句块</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	a=input(<span class="string">"输入一个被除数："</span>)</span><br><span class="line">	b=input(<span class="string">"输入一个除数："</span>)</span><br><span class="line">  c=float(a)/float(b)</span><br><span class="line">  print(c)</span><br><span class="line"><span class="keyword">except</span> ZeroDicisionError:</span><br><span class="line">  print(<span class="string">"除数不为0"</span>)</span><br><span class="line"><span class="keyword">except</span> TypeError: </span><br><span class="line">  print(<span class="string">"异常:除数和被除数都应该为数值类型"</span>)</span><br><span class="line"><span class="keyword">except</span> NameError: </span><br><span class="line">  print(<span class="string">"异常:变量不存在"</span>)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">    print(type(e)) </span><br><span class="line"> ```</span><br><span class="line">请输入被除数:<span class="number">10</span> </span><br><span class="line">请输入除数:<span class="number">0</span> </span><br><span class="line">异常:除数不能为 <span class="number">0</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="try…except…else-结构"><a href="#try…except…else-结构" class="headerlink" title="try…except…else 结构"></a><strong>try…except…else</strong> 结构</h2><p> try…except…else 结构增加了“else 块”。如果 try 块中没有抛出异常，则执行 else 块。如果</p>
<p>try 块中抛出异常，则执行 except 块，不执行 else 块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发生异常的执行情况(执行 except 块，没有执行 else):</span><br><span class="line"></span><br><span class="line">没有发生异常的执行情况(执行完 try 块后，执行 else):</span><br></pre></td></tr></table></figure>

<h2 id="try…except…finally-结构"><a href="#try…except…finally-结构" class="headerlink" title="try…except…finally 结构"></a><strong>try…except…finally</strong> 结构</h2><p> try…except…finally 结构中，finally 块无论是否发生异常都会被执行;通常用来释放 try 块中申请的资源</p>
<p> finally 中的语句，无论是否发生异常都执行</p>
<p>读取文件，finally 中保证关闭文件资源</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	f = open(<span class="string">"d:/a.txt"</span>,<span class="string">'r'</span>) </span><br><span class="line">  content = f.readline() </span><br><span class="line">  print(content)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	f.close() <span class="comment">#释放资源。此处也可能会发生异常。若发生异常，则程序终止,不会继续往下执行</span></span><br><span class="line">print(<span class="string">"step4"</span>)</span><br><span class="line">```</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">[Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">'d:/a.txt'</span></span><br><span class="line">File <span class="string">"C:/PycharmProjects/mypro_exception/my01.py"</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">f.close() <span class="comment">#释放资源。此处也可能会发生异常。若发生异常，则程序终止,不会继续往下执行</span></span><br><span class="line">NameError: name <span class="string">'f'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined Process finished <span class="keyword">with</span> exit code <span class="number">1</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>需要把f.close也try except</p>
<h2 id="return-语句和异常处理问题"><a href="#return-语句和异常处理问题" class="headerlink" title="return 语句和异常处理问题"></a><strong>return</strong> 语句和异常处理问题</h2><p> 由于 return 有两种作用:结束方法运行、返回值。我们一般不把 return 放到异常处理结构</p>
<p>中，而是放到方法最后。</p>
<h3 id="一般不要将-return-语句放到-try、except、else、finally-块中，会发生一些意想不到的错误。建议放到方法最后。"><a href="#一般不要将-return-语句放到-try、except、else、finally-块中，会发生一些意想不到的错误。建议放到方法最后。" class="headerlink" title="一般不要将 return 语句放到 try、except、else、finally 块中，会发生一些意想不到的错误。建议放到方法最后。"></a>一般不要将 return 语句放到 try、except、else、finally 块中，会发生一些意想不到的错误。建议放到方法最后。</h3><h2 id="常见异常的解决"><a href="#常见异常的解决" class="headerlink" title="常见异常的解决"></a>常见异常的解决</h2><p>Python 中的异常都派生自 BaseException 类</p>
<p>\1. SyntaxError:语法错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D;3 </span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>\2. NameError:尝试访问一个没有申明的变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(a)</span><br><span class="line">NameError: name &#39;a&#39; is not defined</span><br></pre></td></tr></table></figure>

<p>\3. ZeroDivisionError:除数为0错误(零除错误)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 3&#x2F;0</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>

<p>\4. ValueError:数值错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float(&quot;gaoqi&quot;)</span><br><span class="line">ValueError: could not convert string to float: &#39;gaoqi&#39;</span><br></pre></td></tr></table></figure>

<p>\5. TypeError:类型错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123+&quot;abc&quot;</span><br><span class="line">TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;</span><br></pre></td></tr></table></figure>

<p>\6. AttributeError:访问对象的不存在的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.sayhi()</span><br><span class="line">AttributeError: &#39;int&#39; object has no attribute &#39;sayhi&#39;</span><br></pre></td></tr></table></figure>

<p>\7. IndexError:索引越界异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[10]</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure>

<p>\8. KeyError:字典的关键字不存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[&#39;salary&#39;] KeyError: &#39;salary&#39;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>异常名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArithmeticError</code></td>
<td>所有数值计算错误的基类</td>
</tr>
<tr>
<td><code>AssertionError</code></td>
<td>断言语句失败</td>
</tr>
<tr>
<td><code>AttributeError</code></td>
<td>对象没有这个属性</td>
</tr>
<tr>
<td><code>BaseException</code></td>
<td>所有异常的基类</td>
</tr>
<tr>
<td><code>DeprecationWarning</code></td>
<td>关于被弃用的特征的警告</td>
</tr>
<tr>
<td><code>EnvironmentError</code></td>
<td>操作系统错误的基类</td>
</tr>
<tr>
<td>EOFError</td>
<td>没有内建输入,到达 EOF 标记</td>
</tr>
<tr>
<td>Exception</td>
<td>常规错误的基类</td>
</tr>
<tr>
<td><code>FloatingPointError</code></td>
<td>浮点计算错误</td>
</tr>
<tr>
<td><code>FutureWarning</code></td>
<td><code>关于构造将来语义会有改变的警告</code></td>
</tr>
<tr>
<td><code>GeneratorExit</code></td>
<td>生成器(generator)发生异常来通知退出</td>
</tr>
<tr>
<td>ImportError</td>
<td>导入模块/对象失败</td>
</tr>
<tr>
<td><code>IndentationError</code></td>
<td>缩进错误</td>
</tr>
<tr>
<td>IndexError</td>
<td>序列中没有此索引(index)</td>
</tr>
<tr>
<td>IOError</td>
<td>输入/输出操作失败</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>KeyboardInterrupt</code></th>
<th>用户中断执行(通常是输入^C)</th>
</tr>
</thead>
<tbody><tr>
<td>KeyError</td>
<td>映射中没有这个键</td>
</tr>
<tr>
<td>LookupError</td>
<td>无效数据查询的基类</td>
</tr>
<tr>
<td>MemoryError</td>
<td>内存溢出错误(对于 Python 解释器不是致命的)</td>
</tr>
<tr>
<td>NameError</td>
<td>未声明/初始化对象 (没有属性)</td>
</tr>
<tr>
<td><code>NotImplementedError</code></td>
<td>尚未实现的方法</td>
</tr>
<tr>
<td>OSError</td>
<td>操作系统错误</td>
</tr>
<tr>
<td><code>OverflowError</code></td>
<td>数值运算超出最大限制</td>
</tr>
<tr>
<td><code>OverflowWarning</code></td>
<td>旧的关于自动提升为长整型(long)的警告</td>
</tr>
<tr>
<td><code>PendingDeprecationWarning</code></td>
<td><code>关于特性将会被废弃的警告</code></td>
</tr>
<tr>
<td><code>ReferenceError</code></td>
<td>弱引用(Weak reference)试图访问已经垃圾回收了的对象</td>
</tr>
<tr>
<td><code>RuntimeError</code></td>
<td>一般的运行时错误</td>
</tr>
<tr>
<td><code>RuntimeWarning</code></td>
<td>可疑的运行时行为(runtime behavior)的警告</td>
</tr>
<tr>
<td><code>StandardError</code></td>
<td><code>所有的内建标准异常的基类</code></td>
</tr>
<tr>
<td><code>StopIteration</code></td>
<td>迭代器没有更多的值</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>Python 语法错误</td>
</tr>
<tr>
<td><code>SyntaxWarning</code></td>
<td>可疑的语法的警告</td>
</tr>
<tr>
<td>SystemError</td>
<td>一般的解释器系统错误</td>
</tr>
<tr>
<td>SystemExit</td>
<td>解释器请求退出</td>
</tr>
<tr>
<td>TabError</td>
<td>Tab 和空格混用</td>
</tr>
<tr>
<td>TypeError</td>
<td>对类型无效的操作</td>
</tr>
<tr>
<td><code>UnboundLocalError</code></td>
<td>访问未初始化的本地变量</td>
</tr>
<tr>
<td><code>UnicodeDecodeError</code></td>
<td>Unicode 解码时的错误</td>
</tr>
<tr>
<td><code>UnicodeEncodeError</code></td>
<td>Unicode 编码时错误</td>
</tr>
<tr>
<td><code>UnicodeError</code></td>
<td>Unicode 相关的错误</td>
</tr>
<tr>
<td><code>UnicodeTranslateError</code></td>
<td>Unicode 转换时错误</td>
</tr>
<tr>
<td>UserWarning</td>
<td>用户代码生成的警告</td>
</tr>
<tr>
<td>ValueError</td>
<td>传入无效的参数</td>
</tr>
<tr>
<td>Warning</td>
<td>警告的基类</td>
</tr>
<tr>
<td><code>WindowsError</code></td>
<td>系统调用失败</td>
</tr>
<tr>
<td><code>ZeroDivisionError</code></td>
<td>除(或取模)零 (所有数据类型)</td>
</tr>
</tbody></table>
<h2 id="with-上下文管理"><a href="#with-上下文管理" class="headerlink" title="with 上下文管理"></a><strong>with</strong> 上下文管理</h2><p> finally 块由于是否发生异常都会执行，通常我们放释放资源的代码。其实，我们可以通过 with 上下文管理，更方便的实现释放资源的操作。 with 上下文管理的语法结构如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> context_expr [ <span class="keyword">as</span> var]: </span><br><span class="line">	语句块</span><br></pre></td></tr></table></figure>

<p>with 上下文管理可以自动管理资源，在 with 代码块执行完毕后自动还原进入该代码之前的 现场或上下文。不论何种原因跳出 with 块，不论是否有异常，总能保证资源正常释放。极 大的简化了工作，在文件操作、网络通信相关的场合非常常用。</p>
<h3 id="With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发"><a href="#With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发" class="headerlink" title="With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发"></a>With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"d:/bb.txt"</span>) <span class="keyword">as</span> f: </span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">		print(line)</span><br></pre></td></tr></table></figure>

<h2 id="trackback-模块"><a href="#trackback-模块" class="headerlink" title="trackback 模块"></a><strong>trackback</strong> 模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">  print(<span class="string">"step1"</span>)</span><br><span class="line">	num = <span class="number">1</span>/<span class="number">0</span> </span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	traceback.print_exc()</span><br><span class="line">  ```</span><br><span class="line">  step1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/mengxiaowang/Documents/a.py"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    num = <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">  ```</span><br></pre></td></tr></table></figure>

<p>使用 traceback 将异常信息写入日志文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">  print(<span class="string">"step1"</span>)</span><br><span class="line">	num = <span class="number">1</span>/<span class="number">0</span> </span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="keyword">with</span> open(<span class="string">"d:/a.log"</span>,<span class="string">"a"</span>) <span class="keyword">as</span> f: </span><br><span class="line">    traceback.print_exc(file=f)</span><br></pre></td></tr></table></figure>

<h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>程序开发中，有时候我们也需要自己定义异常类。自定义异常类一般都是运行时异常，通常继承 Exception 或其子类即可。命名一般以 Error、Exception 为后缀。</p>
<p> 自定义异常由 raise 语句主动抛出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">classAgeError(Exception): <span class="comment">#继承Exception </span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,errorInfo)</span>:</span></span><br><span class="line">		Exception.__init__(self)</span><br><span class="line">		self.errorInfo = errorInfo </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> str(self.errorInfo)+<span class="string">",年龄错误!应该在 1-150 之间"</span></span><br><span class="line"><span class="comment">############测试代码################</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: <span class="comment">#如果为 True，则模块是作为独立文件运行， 可以执行测试代码</span></span><br><span class="line">	age = int(input(<span class="string">"输入一个年龄:"</span>)) </span><br><span class="line">  	<span class="keyword">if</span> age&lt;<span class="number">1</span> <span class="keyword">or</span> age&gt;<span class="number">150</span>:</span><br><span class="line">    	<span class="keyword">raise</span> AgeError(age)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">			print(<span class="string">"正常的年龄:"</span>,age)</span><br><span class="line">```</span><br><span class="line">输入一个年龄：<span class="number">160</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"C:/Users/Administrator/PycharmProjects/mypro_exception/my10.py"</span>, line <span class="number">16</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"><span class="keyword">raise</span> AgeError(age)</span><br><span class="line">__main__.AgeError: <span class="number">200</span>,年龄错误!应该在 <span class="number">1</span><span class="number">-150</span> 之间</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="if-name-‘main‘-的作用"><a href="#if-name-‘main‘-的作用" class="headerlink" title="if name == ‘main‘:的作用"></a>if <strong>name</strong> == ‘<strong>main</strong>‘:的作用</h2><p>简单说：</p>
<h4 id="在当前执行的程序下（例如当前程序为test-py），如果导入其他模块（other-test-py），则运行程序时other-test-py的if-name-‘main‘-语句判断失败，将不会运行下面的方法。"><a href="#在当前执行的程序下（例如当前程序为test-py），如果导入其他模块（other-test-py），则运行程序时other-test-py的if-name-‘main‘-语句判断失败，将不会运行下面的方法。" class="headerlink" title="在当前执行的程序下（例如当前程序为test.py），如果导入其他模块（other_test.py），则运行程序时other_test.py的if name == ‘main‘ 语句判断失败，将不会运行下面的方法。"></a>在当前执行的程序下（例如当前程序为test.py），如果导入其他模块（other_test.py），则运行程序时other_test.py的if <strong>name</strong> == ‘<strong>main</strong>‘ 语句判断失败，将不会运行下面的方法。</h4><p>也就是说导入的模块的if <strong>name</strong> == ‘<strong>main</strong>‘ 语句下的方法是不会执行的。只会执行当前的if <strong>name</strong> == ‘<strong>main</strong>‘ 下的方法。<br>一个python文件通常有两种使用方法，第一是作为脚本直接执行，第二是 import 到其他的 python 脚本中被调用（模块重用）执行。因此 if <strong>name</strong> == ‘main’: 的作用就是控制这两种情况执行代码的过程，在 if <strong>name</strong> == ‘main’: 下的代码只有在第一种情况下（即文件作为脚本直接执行）才会被执行，而 import 到其他脚本中是不会被执行的。举例说明如下：</p>
<ul>
<li>直接执行</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190510141202522.png" alt="img"></p>
<p><strong>直接执行 test.py，</strong>结果如下图，可以成功 print 两行字符串。即<strong>，if <strong>name</strong>==”<strong>main</strong>“: 语句之前和之后的代码都被执行。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190510141303114.png" alt="img"></p>
<ul>
<li>import 执行</li>
</ul>
<p>然后在同一文件夹新建名称为 import_test.py 的脚本，输入如下代码：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510141602268.png" alt="img"></p>
<p>执行 <strong>import_test.py 脚本</strong>，输出结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510141624918.png" alt="img"></p>
<p>只输出了第一行字符串。即，<strong>if <strong>name</strong>==”<strong>main</strong>“: 之前的语句被执行，之后的没有被执行。</strong></p>
<h3 id="if-name-‘main‘-的运行原理"><a href="#if-name-‘main‘-的运行原理" class="headerlink" title="if name == ‘main‘:的运行原理"></a>if <strong>name</strong> == ‘<strong>main</strong>‘:的运行原理</h3><p><strong>每个python模块</strong>（python文件，也就是此处的 test.py 和 import_test.py）都包含<strong>内置的变量 <strong>name</strong></strong>，当该模块被<strong>直接执行</strong>的时候，<strong><strong>name</strong> 等于文件名（包含后缀 .py ）</strong>；如果该模块 <strong>import</strong> 到其他模块中，<strong>则该模块的 <strong>name</strong> 等于模块名称（不包含后缀.py）。</strong></p>
<p>而 <strong>“<strong>main</strong>” 始终指当前执行模块的名称（包含后缀.py）</strong>。进而当模块被<strong>直接执行</strong>时<strong>，<strong>name</strong> == ‘main’ 结果为真。</strong></p>
<p>为了进一步说明，我们在 test.py 脚本的 if <strong>name</strong>==”<strong>main</strong>“: 之前<strong>加入 print(<strong>name</strong>)，</strong>即将 <strong>name</strong> 打印出来。文件内容和结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510142230219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlcWlhbmc1MjU=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190510142253482.png" alt="img"></p>
<p>可以看出，此时变量<strong><strong>name</strong>的值为”<strong>main</strong>“。</strong></p>
<p>再执行 import_test.py，执行结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510142441889.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190510142452571.png" alt="img"></p>
<p>此时，<strong>test.py中的<strong>name</strong>变量值为 test，</strong>不满足 <strong>name</strong>==”<strong>main</strong>“ 的条件，因此，无法执行其后的代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/python400%E9%9B%863/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/python400%E9%9B%863/" class="post-title-link" itemprop="url">python400集3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 15:09:28" itemprop="dateCreated datePublished" datetime="2020-04-29T15:09:28-05:00">2020-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-01 23:12:23" itemprop="dateModified" datetime="2020-05-01T23:12:23-05:00">2020-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="python面向对象"><a href="#python面向对象" class="headerlink" title="python面向对象"></a>python面向对象</h1><p>类定义数据类型的属性(数据)和方法(行为),也就是说，“类将行为和状态打 包在一起”。</p>
<p>对象是类的具体实体，一般称为“类的实例”。“方法代码是共享的，属性数据不共享”。</p>
<p>定义类的语法格式如下: class 类名:</p>
<p>类体</p>
<p>要点如下:</p>
<ol>
<li><p>类名必须符合“标识符”的规则;一般规定，首字母大写，多个单词使用“驼峰原则”。</p>
<ol start="2">
<li>类体中我们可以定义属性和方法。</li>
<li>. 属性用来描述数据，方法(即函数)用来描述这些数据相关的操作。</li>
</ol>
</li>
</ol>
<h2 id="init构造方法和new方法"><a href="#init构造方法和new方法" class="headerlink" title="init构造方法和new方法"></a><strong><strong>init</strong>构造方法和<strong>new</strong>方法</strong></h2><p>类是抽象的，也称之为“对象的模板”。我们需要通过类这个模板，创建类的实例对象，然 后才能使用类定义的功能。</p>
<p>我们前面说过一个 Python 对象包含三个部分:id(identity 识别码)、type(对象类型)、 value(对象的值)。</p>
<p>现在，我们可以更进一步的说，一个 Python 对象包含如下部分: 1. id(identity 识别码)</p>
<ol start="2">
<li>type(对象类型) 3. value(对象的值)：(1) 属性(attribute) (2) 方法(method)</li>
</ol>
<h4 id="创建对象，我们需要定义构造函数init-方法。构造方法用于执行“实例对象的初始化工-作”，即对象创建后，初始化当前对象的相关属性，无返回值。"><a href="#创建对象，我们需要定义构造函数init-方法。构造方法用于执行“实例对象的初始化工-作”，即对象创建后，初始化当前对象的相关属性，无返回值。" class="headerlink" title="创建对象，我们需要定义构造函数init()方法。构造方法用于执行“实例对象的初始化工 作”，即对象创建后，初始化当前对象的相关属性，无返回值。"></a>创建对象，我们需要定义构造函数<strong>init</strong>()方法。构造方法用于执行“实例对象的初始化工 作”，即对象创建后，初始化当前对象的相关属性，无返回值。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_init_()</span><br></pre></td></tr></table></figure>

<p>的要点如下:<br> \1. 名称固定，必须为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__init__()</span><br></pre></td></tr></table></figure>

<p> \2. 第一个参数固定，必须为:self。 self 指的就是刚刚创建好的实例对象。<br> \3. 构造函数通常用来初始化实例对象的实例属性，如下代码就是初始化实例属性:name 和 score。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,score)</span>:</span></span><br><span class="line">	self.name = name <span class="comment">#实例属性 </span></span><br><span class="line">	self.score = score</span><br></pre></td></tr></table></figure>

<p>\4. 通过“类名(参数列表)”来调用构造函数。调用后，将创建好的对象返回给相应的变量。 比如:s1 = Student(‘张三’, 80)</p>
<p>\5. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__init__()方法:初始化创建好的对象，初始化指的是:“给实例属性赋值”</span><br></pre></td></tr></table></figure>


<p> \6. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__new__()方法: 用于创建对象，但我们一般无需重定义该方法。</span><br></pre></td></tr></table></figure>


<p> \7.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果我们不定义__init__方法，系统会提供一个默认的__init__方法。如果我们定义了带参 的__init__方法，系统不创建默认的__init__方法。</span><br></pre></td></tr></table></figure>

<p>注:<br> \1. Python中的self相当于C++中的self指针，JAVA和C#中的this关键字。Python中， self 必须为构造函数的第一个参数，名字可以任意修改。但一般遵守惯例，都叫做 self。</p>
<h2 id="实例属性和实例方法"><a href="#实例属性和实例方法" class="headerlink" title="实例属性和实例方法"></a>实例属性和实例方法</h2><h3 id="实例属性instance（其实跟java差不多）"><a href="#实例属性instance（其实跟java差不多）" class="headerlink" title="实例属性instance（其实跟java差不多）"></a>实例属性instance（其实跟java差不多）</h3><p>实例属性是从属于实例对象的属性，也称为“实例变量”。他的使用有如下几个要点: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\1. 实例属性一般在__init__()方法中通过如下代码定义:</span><br><span class="line"></span><br><span class="line">self.实例属性名 &#x3D; 初始值</span><br><span class="line"> \2. 在本类的其他实例方法中，也是通过 self 进行访问:</span><br><span class="line"></span><br><span class="line">self.实例属性名</span><br><span class="line"> \3. 创建实例对象后，通过实例对象访问:</span><br><span class="line"></span><br><span class="line">obj01 &#x3D; 类名() #创建对象，调用__init__()初始化属性 </span><br><span class="line">obj01.实例属性名 &#x3D; 值 #可以给已有属性赋值，也可以新加属性</span><br></pre></td></tr></table></figure>



<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a><strong>实例方法</strong></h3><p>实例方法是从属于实例对象的方法。实例方法的定义格式如下: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def 方法名(self [, 形参列表]):</span><br><span class="line">	函数体</span><br><span class="line">方法的调用格式如下:</span><br><span class="line">	对象.方法名([实参列表])</span><br></pre></td></tr></table></figure>



<p>要点:<br> \1. 定义实例方法时，第一个参数必须为 self。和前面一样，self 指当前的实例对象。 2. 调用实例方法时，不需要也不能给 self 传参。self 由解释器自动传参。</p>
<h3 id="·-函数和方法的区别"><a href="#·-函数和方法的区别" class="headerlink" title="· 函数和方法的区别"></a><strong>· 函数和方法的区别</strong></h3><ol>
<li><p>都是用来完成一个功能的语句块，本质一样。</p>
</li>
<li><p>方法调用时，通过对象来调用。方法从属于特定实例对象，普通函数没有这个特点。 </p>
</li>
<li><p>直观上看，方法定义时需要传递 self，函数不需要。</p>
</li>
</ol>
<p><strong>· 实例对象的方法调用本质:</strong></p>
<p><strong>a = Student()</strong></p>
<p><strong>a.say_score()</strong></p>
<p>解释器翻译:</p>
<p><strong>Student.say_score(a)</strong></p>
<p><strong>· 其他操作:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> dir(obj)可以获得对象的所有属性、方法</span><br><span class="line"><span class="number">2.</span>obj.__dict__ 对象的属性字典</span><br><span class="line"><span class="number">3.</span><span class="keyword">pass</span> 空语句</span><br><span class="line"><span class="number">4.</span>isinstance(对象,类型) 判断“对象”是不是“指定类型”</span><br></pre></td></tr></table></figure>

<h2 id="类对象、类属性、类方法、静态方法"><a href="#类对象、类属性、类方法、静态方法" class="headerlink" title="类对象、类属性、类方法、静态方法"></a><strong>类对象、类属性、类方法、静态方法</strong></h2><p><strong>类对象</strong></p>
<p>我们在前面讲的类定义格式中，“class 类名:”。实际上，当解释器执行 class 语句时， 就会创建一个类对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	<span class="keyword">pass</span> <span class="comment">#空语句</span></span><br><span class="line">print(type(Student)) </span><br><span class="line">print(id(Student))</span><br><span class="line">Stu2 = Student </span><br><span class="line">s1 = Stu2() </span><br><span class="line">print(s1)</span><br></pre></td></tr></table></figure>

<p>执行结果如下:<br> &lt;class ‘type’&gt;</p>
<p>51686328<br> &lt;<strong>main</strong>.Student object at 0x0000000002B5FDD8&gt;</p>
<p>我们可以看到实际上生成了一个变量名就是类名“Student”的对象。我们通过赋值给新变 量 Stu2，也能实现相关的调用。说明，确实创建了“类对象”。</p>
<p>【注】pass 为空语句。就是表示什么都不做，只是作为一个占位符存在。当你写代码时， 遇到暂时不知道往方法或者类中加入什么时，可以先用 pass 占位，后期再补上。</p>
<h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a><strong>类属性</strong></h3><p>类属性是从属于“类对象”的属性，也称为“类变量”。由于，类属性从属于类对象，可以 被所有实例对象共享。</p>
<p>类属性的定义方式:<br> class 类名:</p>
<p>类变量名= 初始值 在类中或者类的外面，我们可以通过:“类名.类变量名”来读写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	company = <span class="string">"SXT"</span> <span class="comment">#类属性 </span></span><br><span class="line">	count = <span class="number">0</span> <span class="comment">#类属性</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,score)</span>:</span> </span><br><span class="line">		self.name = name 	</span><br><span class="line">		self.score = score <span class="comment">#实例属性</span></span><br><span class="line">		Student.count = Student.count+<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_score</span><span class="params">(self)</span>:</span> <span class="comment">#实例方法 </span></span><br><span class="line">  print(<span class="string">"我的公司是:"</span>,Student.company) </span><br><span class="line">  print(self.name,<span class="string">'的分数是:'</span>,self.score)</span><br><span class="line">s1 = Student(<span class="string">'张三'</span>,<span class="number">80</span>) <span class="comment">#s1 是实例对象，自动调用__init__()方法 </span></span><br><span class="line">s1.say_score()</span><br><span class="line">print(<span class="string">'一共创建&#123;0&#125;个 Student 对象'</span>.format(Student.count))</span><br><span class="line">```</span><br><span class="line">执行结果:</span><br><span class="line">我的公司是: SXT</span><br><span class="line">张三 的分数是: <span class="number">80</span> </span><br><span class="line">一共创建 <span class="number">1</span> 个 Student 对象</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a><strong>类方法</strong></h3><p>类方法是从属于“类对象”的方法。类方法通过装饰器@classmethod 来定义，格式如下: @classmethod</p>
<p>def 类方法名(cls [，形参列表]) : 函数体</p>
<p>要点如下:<br> \1. @classmethod 必须位于方法上面一行<br> \2. 第一个 cls 必须有;cls 指的就是“类对象”本身;<br> \3. 调用类方法格式:“类名.类方法名(参数列表)”。 参数列表中，不需要也不能给 cls 传 值。<br> \4. 类方法中访问实例属性和实例方法会导致错误<br> \5. 子类继承父类方法时，传入 cls 是子类对象，而非父类对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	company = <span class="string">"SXT"</span> <span class="comment">#类属性 </span></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printCompany</span><span class="params">(cls)</span>:</span> </span><br><span class="line">    print(cls.company)</span><br><span class="line">Student.printCompany()</span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a><strong>静态方法</strong></h3><p>Python 中允许定义与“类对象”无关的方法，称为“静态方法”。</p>
<p>“静态方法”和在模块中定义普通函数没有区别，只不过“静态方法”放到了“类的名字空 间里面”，需要通过“类调用”。</p>
<p>静态方法通过装饰器@staticmethod 来定义，格式如下: @staticmethod</p>
<p>def 静态方法名([形参列表]) : 函数体</p>
<p>要点如下:</p>
<ol>
<li><p>@staticmethod 必须位于方法上面一行</p>
</li>
<li><p>调用静态方法格式:“类名.静态方法名(参数列表)”。 </p>
</li>
<li><p>静态方法中访问实例属性和实例方法会导致错误</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	company = <span class="string">"SXT"</span> <span class="comment"># 类属性</span></span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span> <span class="comment"># 静态方法</span></span><br><span class="line"> 		print(<span class="string">"&#123;0&#125;+&#123;1&#125;=&#123;2&#125;"</span>.format(a,b,(a+b)))</span><br><span class="line"> 		<span class="keyword">return</span> a+b</span><br><span class="line"> Student.add(<span class="number">20</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h2 id="del方法-析构函数-和垃圾回收机制"><a href="#del方法-析构函数-和垃圾回收机制" class="headerlink" title="del方法(析构函数)和垃圾回收机制"></a><strong><strong>del</strong>方法(析构函数)和垃圾回收机制</strong></h2><p><strong>del</strong>方法称为“析构方法”，用于实现对象被销毁时所需的操作。比如:释放对象 占用的资源，例如:打开的文件资源、网络连接等。</p>
<p>Python 实现自动的垃圾回收，当对象没有被引用时(引用计数为 0)，由垃圾回收器 调用<strong>del</strong>方法。</p>
<p>我们也可以通过 del 语句删除对象，从而保证调用<strong>del</strong>方法。 系统会自动提供<strong>del</strong>方法，一般不需要自定义析构方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#析构函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span> </span><br><span class="line">  print(<span class="string">"销毁对象:&#123;0&#125;"</span>.format(self))</span><br><span class="line">p1 = Person() </span><br><span class="line">p2 = Person()</span><br><span class="line"><span class="keyword">del</span> p2</span><br><span class="line">print(<span class="string">"end"</span>)</span><br><span class="line">```</span><br><span class="line">运算结果:</span><br><span class="line">销毁对象:&lt;__main__.Person object at <span class="number">0x02175610</span>&gt; 程序结束</span><br><span class="line">销毁对象:&lt;__main__.Person object at <span class="number">0x021755D0</span>&gt;</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="call方法和可调用对象"><a href="#call方法和可调用对象" class="headerlink" title="call方法和可调用对象"></a><strong><strong>call</strong>方法和可调用对象</strong></h2><p>定义了<strong>call</strong>方法的对象，称为“可调用对象”，即该对象可以像函数一样被调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalaryAccount</span>:</span> <span class="string">'''工资计算类'''</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, salary)</span>:</span> </span><br><span class="line">    yearSalary = salary*<span class="number">12</span> </span><br><span class="line">    daySalary = salary//<span class="number">30</span></span><br><span class="line">		hourSalary = daySalary//<span class="number">8</span> </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">dict(monthSalary=salary,yearSalary=yearSalary,daySalary=daySalary ,hourSalary=hourSalary)</span><br><span class="line">s = SalaryAccount()</span><br><span class="line">print(s(<span class="number">5000</span>)) <span class="comment">#可以像调用函数一样调用对象的__call__方法</span></span><br><span class="line"><span class="comment">#&#123;'monthSalary': 5000, 'yearSalary': 60000, 'daySalary': 166, 'hourSalary': 20&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="方法没有重载"><a href="#方法没有重载" class="headerlink" title="方法没有重载"></a><strong>方法没有重载</strong></h2><p>在其他语言中，可以定义多个重名的方法，只要保证方法签名唯一即可。方法签名包含 3 个部分:方法名、参数数量、参数类型。</p>
<p>Python 中，方法的的参数没有声明类型(调用时确定参数的类型)，参数的数量也可以由 可变参数控制。因此，Python 中是没有方法的重载的。定义一个方法即可有多种调用方式， 相当于实现了其他语言中的方法的重载。</p>
<h3 id="如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。-建议-不要使用重名的方法-Python-中方法没有重载。"><a href="#如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。-建议-不要使用重名的方法-Python-中方法没有重载。" class="headerlink" title="如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。 建议:不要使用重名的方法!Python 中方法没有重载。"></a>如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。 建议:不要使用重名的方法!Python 中方法没有重载。</h3><h2 id="方法的动态性"><a href="#方法的动态性" class="headerlink" title="方法的动态性"></a><strong>方法的动态性</strong></h2><p>Python 是动态语言，我们可以动态的为类添加新的方法，或者动态的修改类的已有的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"努力上班!"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_game</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;0&#125;玩游戏"</span>.format(self))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work2</span><span class="params">(s)</span>:</span></span><br><span class="line">    print(<span class="string">"好好工作，努力上班!"</span>)</span><br><span class="line">Person.play = play_game</span><br><span class="line">Person.work = work2 </span><br><span class="line">p = Person()</span><br><span class="line">p.play()</span><br><span class="line">p.work()</span><br><span class="line">```</span><br><span class="line">&lt;__main__.Person object at <span class="number">0x7fb0405fdee0</span>&gt;玩游戏</span><br><span class="line">好好工作，努力上班!</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>我们可以看到，Person 动态的新增了 play_game 方法，以及用 work2 替换了 work 方法。</p>
<h2 id="私有属性和私有方法-实现封装"><a href="#私有属性和私有方法-实现封装" class="headerlink" title="私有属性和私有方法(实现封装)"></a><strong>私有属性和私有方法(实现封装)</strong></h2><p>Python 对于类的成员没有严格的访问控制限制，这与其他面向对象语言有区别。关于私有 属性和私有方法，有如下要点:</p>
<ol>
<li><p>通常我们约定，两个下划线开头的属性是私有的(private)。其他为公共的(public)。 </p>
</li>
<li><p>类内部可以访问私有属性(方法)</p>
</li>
<li><p>类外部不能直接访问私有属性(方法)</p>
</li>
<li><p>类外部可以通过“_类名__私有属性(方法)名”访问私有属性(方法)</p>
</li>
</ol>
<p>【注】方法本质上也是属性!只不过是可以通过()执行而已。所以，此处讲的私有属性和公有属性，也同时讲解了私有方法和公有方法的用法。如下测试中，同时也包含了私有方法和 公有方法的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试私有属性、私有方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">	__company = <span class="string">"google"</span> <span class="comment">#私有类属性. 通过 dir 可以查到_Employee__company</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.__age = age <span class="comment">#私有实例属性</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">say_company</span><span class="params">(self)</span>:</span> </span><br><span class="line">    print(<span class="string">"我的公司是:"</span>,Employee.__company) <span class="comment">#类内部可以直接访问私有属性</span></span><br><span class="line">		print(self.name,<span class="string">"的年龄是:"</span>,self.__age) </span><br><span class="line">    self.__work()</span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">__work</span><span class="params">(self)</span>:</span> <span class="comment">#私有实例方法 通过 dir 可以查到 _Employee__work</span></span><br><span class="line">		print(<span class="string">"工作!好好工作，好好赚钱，娶个媳妇!"</span>)</span><br><span class="line">p1 = Employee(<span class="string">"高淇"</span>,<span class="number">32</span>)</span><br><span class="line">print(p1.name)</span><br><span class="line">print(dir(p1)) <span class="comment"># </span></span><br><span class="line">p1.say_company()</span><br><span class="line">print(p1._Employee__age) <span class="comment">#通过这种方式可以直接访问到私有属性 。通过 dir 可以查到属性:_Employee__age </span></span><br><span class="line"><span class="comment">#print(p1.__age) #直接访问私有属性，报错</span></span><br><span class="line"> <span class="comment">#p1.__sleep() #直接访问私有方法，报错</span></span><br><span class="line">  ```</span><br><span class="line">  执行结果:</span><br><span class="line">高淇</span><br><span class="line">[<span class="string">'_Person__age'</span>, <span class="string">'_Person__leg_num'</span>, <span class="string">'_Person__sleep'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'name'</span>, <span class="string">'say_age'</span>]</span><br><span class="line">腿的数目: <span class="number">2</span></span><br><span class="line">高淇 的年龄是: <span class="number">18</span></span><br><span class="line">睡觉</span><br><span class="line"><span class="number">18</span></span><br><span class="line">从打印的 Person 对象所有属性我们可以看出。私有属性“__age”在实际存储时是按照 “_Person__age”这个属性来存储的。这也就是为什么我们不能直接使用“__age”而可以 使用“_Person__age”的根本原因。</span><br><span class="line">  ```</span><br></pre></td></tr></table></figure>

<h2 id="property-装饰器"><a href="#property-装饰器" class="headerlink" title="@property 装饰器"></a><strong>@property 装饰器</strong></h2><p>@property 可以将一个方法的调用方式变成“属性调用”</p>
<p>@property 主要用于帮助我们处理属性的读操作、写操作。对于某一个属性，我们可以直 接通过:</p>
<p>emp1.salary = 30000 如上的操作读操作、写操作。但是，这种做法不安全。比如，我需要限制薪水必须为 1-10000 的数字。这时候，我们就需要通过 getter、setter 方法来处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,salary)</span>:</span> </span><br><span class="line">    self.name = name</span><br><span class="line"> 		self.__salary = salary</span><br><span class="line"><span class="meta">	@property #相当于 salary 属性的 getter 方法</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">salary</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"月薪为&#123;0&#125;,年薪为 &#123;1&#125;"</span>.format(self.__salary,(<span class="number">12</span>*self.__salary)))</span><br><span class="line"> 		<span class="keyword">return</span> self.__salary;</span><br><span class="line"><span class="meta"> 	@salary.setter</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">salary</span><span class="params">(self,salary)</span>:</span> <span class="comment">#相当于 salary 属性的 setter 方法</span></span><br><span class="line"> 		<span class="keyword">if</span>(<span class="number">0</span>&lt;salary&lt;<span class="number">1000000</span>): </span><br><span class="line">      self.__salary = salary</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line"> 			print(<span class="string">"薪水录入错误!只能在 0-1000000 之间"</span>)</span><br><span class="line">emp1 = Employee(<span class="string">"高淇"</span>,<span class="number">100</span>) </span><br><span class="line">print(emp1.salary)</span><br><span class="line">emp1.salary = <span class="number">-200</span></span><br></pre></td></tr></table></figure>

<p>运行结果:<br> 月薪为 100,年薪为 1200</p>
<p>100<br> 月薪为 100,年薪为 1200<br> 100<br> 薪水录入错误!只能在 0-1000000 之间</p>
<h2 id="属性和方法命名总结"><a href="#属性和方法命名总结" class="headerlink" title="属性和方法命名总结"></a><strong>属性和方法命名总结</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· _xxx:保护成员，不能用“from module import * ”导入，只有类对象和子类对象能访 问这些成员。(类似java 的proetected)</span><br><span class="line"> · __xxx__:系统定义的特殊成员</span><br><span class="line"> · __xxx: 类中的私有成员，只有类对象自己能访问，子类对象也不能访问。(但，在类外 部可以通过“对象名. _类名__xxx”这种特殊方式访问。Python 不存在严格意义的私有成员)（类似java的private）</span><br></pre></td></tr></table></figure>

<p>注:再次强调，方法和属性都遵循上面的规则。</p>
<p>私有属性是无法被继承的。由此可知，在 Python 中私有属性为假私有属性。那为什么不从语法上保证 private 字段的私密性呢？用最简单的一句话来说：We are all consenting adults here。正如Python 程序员的观点：开放要比封闭好。</p>
<p>综上所述：</p>
<p>Python 编译器无法严格保证 private 字段的私密性。</p>
<p>只有当子类不受自己控制的时候，才可以考虑使用 private 属性来避免名称冲突。所以python还是不如java啊。</p>
<h2 id="类编码风格"><a href="#类编码风格" class="headerlink" title="类编码风格"></a><strong>类编码风格</strong></h2><p>\1. 类名首字母大写，多个单词之间采用驼峰原则。<br> \2. 实例名、模块名采用小写，多个单词之间采用下划线隔开。<br> \3. 每个类，应紧跟“文档字符串”，说明这个类的作用。<br> \4. 可以用空行组织代码，但不能滥用。在类中，使用一个空行隔开方法;模块中，使用两 个空行隔开多个类。</p>
<h1 id="面向对象进阶"><a href="#面向对象进阶" class="headerlink" title="面向对象进阶"></a>面向对象进阶</h1><p><strong>面向对象三大特征介绍</strong></p>
<p>Python 是面向对象的语言，也支持面向对象编程的三大特性:继承、封装(隐藏)、多态。</p>
<p><strong>·封装(隐藏)</strong></p>
<p>隐藏对象的属性和实现细节，只对外提供必要的方法。相当于将“细节封装起来”，只 对外暴露“相关调用方法”。</p>
<p>通过前面学习的“私有属性、私有方法”的方式，实现“封装”。Python 追求简洁的 语法，没有严格的语法级别的“访问控制符”，更多的是依靠程序员自觉实现。</p>
<p><strong>·继承</strong></p>
<p>继承可以让子类具有父类的特性，提高了代码的重用性。</p>
<p>从设计上是一种增量进化，原有父类设计不变的情况下，可以增加新的功能，或者改进 已有的算法。</p>
<p><strong>·多态</strong></p>
<p>多态是指同一个方法调用由于对象不同会产生不同的行为。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h2><p>继承是面向对象程序设计的重要特征，也是实现“代码复用”的重要手段。</p>
<p>如果一个新类继承自一个设计好的类，就直接具备了已有类的特征，就大大降低了工作 难度。已有的类，我们称为“父类或者基类”，新的类，我们称为“子类或者派生类”。</p>
<h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a><strong>语法格式</strong></h3><p>Python 支持多重继承，一个子类可以继承多个父类。继承的语法格式如下: </p>
<p>class 子类类名(父类 1[，父类 2，…]):</p>
<p>​    类体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果在类定义中没有指定父类，则默认父类是 object 类。也就是说，object 是所有类的父 类，里面定义了一些所有类共有的默认实现，比如:__new__()。</span><br><span class="line"></span><br><span class="line">定义子类时，必须在其构造函数中调用父类的构造函数。调用格式如下: 父类名.__init__(self, 参数列表)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,score)</span>:</span></span><br><span class="line"> 		self.score = score</span><br><span class="line">		Person.__init__(self,name,age) <span class="comment">#构造函数中包含调用父类构造函数。根据需要，不是必须。 子类并不会自动调用父类的__init__()，我们必须显式的调用它</span></span><br></pre></td></tr></table></figure>

<h3 id="类成员的继承和重写"><a href="#类成员的继承和重写" class="headerlink" title="类成员的继承和重写"></a><strong>类成员的继承和重写</strong></h3><p>\1. 成员继承:子类继承了父类除构造方法之外的所有成员。<br> \2. 方法重写:子类可以重新定义父类中的方法，这样就会覆盖父类的方法，也称为“重写”</p>
<h3 id="查看类的继承层次结构"><a href="#查看类的继承层次结构" class="headerlink" title="查看类的继承层次结构"></a><strong>查看类的继承层次结构</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过类的方法 mro()或者类的属性__mro__可以输出这个类的继承层次结构。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">pass</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span><span class="keyword">pass</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B)</span>:</span><span class="keyword">pass</span></span><br><span class="line">print(C.mro())</span><br><span class="line"><span class="comment">#[&lt;class '__main__.C'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]</span></span><br><span class="line"><span class="comment">#c继承B，继承A，继承object</span></span><br></pre></td></tr></table></figure>

<h3 id="object-根类"><a href="#object-根类" class="headerlink" title="object 根类"></a><strong>object 根类</strong></h3><p>object 类是所有类的父类，因此所有的类都有 object 类的属性和方法。我们显然有必要深 入研究一下 object 类的结构。对于我们继续深入学习 Python 很有好处。</p>
<p><strong>dir()查看对象属性</strong></p>
<p>为了深入学习对象，我们先学习内置函数 dir()，他可以让我们方便的看到指定对象所有的 属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span> </span><br><span class="line">    self.name = name</span><br><span class="line"> 		self.age = age</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say_age</span><span class="params">(self)</span>:</span> </span><br><span class="line">    print(self.name,<span class="string">"的年龄是:"</span>,self.age)</span><br><span class="line">obj = object() </span><br><span class="line">print(dir(obj))</span><br><span class="line">s2 = Person(<span class="string">"高淇"</span>,<span class="number">18</span>)</span><br><span class="line">print(dir(s2))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;]</span><br><span class="line">[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;age&#39;, &#39;name&#39;, &#39;say_age&#39;]</span><br></pre></td></tr></table></figure>

<p>从上面我们可以发现这样几个要点: </p>
<ol>
<li>Person 对象增加了六个属性:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__dict__ __module__ __weakref__ age name say_age</span><br></pre></td></tr></table></figure>

<p>\2. object 的所有属性，Person 类作为 object 的子类，显然包含了所有的属性。<br> \3. 我们打印 age、name、say_age，发现 say_age 虽然是方法，实际上也是属性。只不过， 这个属性的类型是“method”而已。</p>
<p>age &lt;class ‘int’&gt;<br> name &lt;class ‘str’&gt;</p>
<p>say_age &lt;class ‘method’&gt;</p>
<h2 id="重写str-方法"><a href="#重写str-方法" class="headerlink" title="重写str()方法"></a><strong>重写<strong>str</strong>()方法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object 有一个__str__()方法，用于返回一个对于“对象的描述”，对应于内置函数 str() 经常用于 print()方法，帮助我们查看对象的信息。__str__()可以重写。</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"> <span class="string">'''将对象转化成一个字符串，一般用于 print 方法'''</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"名字是:&#123;0&#125;,年龄是&#123;1&#125;"</span>.format(self.name,self.__age)</span><br></pre></td></tr></table></figure>

<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a><strong>多重继承</strong></h2><p>Python 支持多重继承，一个子类可以有多个“直接父类”。这样，就具备了“多个父 类”的特点。但是由于，这样会被“类的整体层次”搞的异常复杂，尽量避免使用。<strong>class</strong> C(B,A):</p>
<h2 id="MRO"><a href="#MRO" class="headerlink" title="MRO()"></a><strong>MRO()</strong></h2><p>Python 支持多继承，如果父类中有相同名字的方法，在子类没有指定父类名时，解释器将 “从左向右”按顺序搜索。<br> MRO(Method Resolution Order):方法解析顺序。 我们可以通过 mro()方法获得 “类的层次结构”，方法解析顺序也是按照这个“类的层次结构”寻找的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">aa</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"aa"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span> </span><br><span class="line">    print(<span class="string">"say AAA!"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">bb</span><span class="params">(self)</span>:</span></span><br><span class="line">			print(<span class="string">"bb"</span>)</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span> </span><br><span class="line">      print(<span class="string">"say BBB!"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B,A)</span>:</span> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cc</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"cc"</span>)</span><br><span class="line">c = C()</span><br><span class="line">print(C.mro()) <span class="comment">#打印类的层次结构</span></span><br><span class="line">c.say() <span class="comment">#解释器寻找方法是“从左到右”的方式寻找，此时会执行 B 类中的 say()</span></span><br></pre></td></tr></table></figure>

<p>[&lt;class ‘<strong>main</strong>.C’&gt;, &lt;class ‘<strong>main</strong>.B’&gt;, &lt;class ‘<strong>main</strong>.A’&gt;, &lt;class ‘object’&gt;]<br>say BBB!</p>
<h2 id="super-获得父类定义"><a href="#super-获得父类定义" class="headerlink" title="super()获得父类定义"></a><strong>super()获得父类定义</strong></h2><p>在子类中，如果想要获得父类的方法时，我们可以通过 super()来做。super()代表父类的定义，不是父类对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def say(self):</span><br><span class="line"> #A.say(self) 调用父类的 say 方法 </span><br><span class="line"> super().say() #通过 super()调用父类的方法</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h2><p>多态(polymorphism)是指同一个方法调用由于对象不同可能会产生不同的行为。在现实 生活中，我们有很多例子。比如:同样是调用人的休息方法，张三的休息是睡觉，李四的休 息是玩游戏，高淇老师是敲代码。同样是吃饭的方法，中国人用筷子吃饭，英国人用刀叉吃 饭，印度人用手吃饭。</p>
<p>关于多态要注意以下 2 点:<br> \1. 多态是方法的多态，属性没有多态。<br> \2. 多态的存在有 2 个必要条件:继承、方法重写。</p>
<h2 id="特殊方法和运算符重载"><a href="#特殊方法和运算符重载" class="headerlink" title="特殊方法和运算符重载"></a><strong>特殊方法和运算符重载</strong></h2><p>Python 的运算符实际上是通过调用对象的特殊方法实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span> </span><br><span class="line">b = <span class="number">30</span></span><br><span class="line">c = a+b</span><br><span class="line">d = a.__add__(b) </span><br><span class="line">print(<span class="string">"c="</span>,c)</span><br><span class="line">print(<span class="string">"d="</span>,d)</span><br><span class="line"><span class="comment">#运算结果: c= 50</span></span><br><span class="line">d= <span class="number">50</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">常见的特殊方法统计如下:</span><br><span class="line"></span><br><span class="line">__init__  构造方法      对象创建:p &#x3D; Person()</span><br><span class="line">__del__  析构方法 对象回收</span><br><span class="line">__repr__,__str__  打印，转换     rint(a)</span><br><span class="line">__call__ 函数调用 a()</span><br><span class="line">__getattr__ 点号运算 a.xxx</span><br><span class="line">__setattr__ 属性赋值 a.xxx &#x3D; value</span><br><span class="line">__getitem__ 索引运算 a[key]</span><br><span class="line">__setitem__ 索引赋值 a[key]&#x3D;value</span><br><span class="line">__len__ 长度 len(a)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运算符+ __add__ 加法</span><br><span class="line">运算符- __sub__ 减法</span><br><span class="line">&lt;,&lt;&#x3D;,&#x3D;&#x3D;  __lt__,__le__，__eq__ 比较运算符</span><br><span class="line">&gt;,&gt;&#x3D;,!&#x3D; __gt__,__ge__,__ne__ 比较运算符</span><br><span class="line">|,^,&amp; __or__,__xor__,__and__  或、异或、与</span><br><span class="line">&lt;&lt;,&gt;&gt; __lshift__,__rshift__ 左移、右移</span><br><span class="line">*,&#x2F;,%,&#x2F;&#x2F; __mul__,__truediv__,__mod__,_ _floordiv__ 乘、浮点除、模运算 (取余)、整数除</span><br><span class="line">** __pow__ 指数运算</span><br></pre></td></tr></table></figure>

<p>我们可以重写上面的特殊方法，即实现了“运算符的重载”。</p>
<h2 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a><strong>特殊属性</strong></h2><p>Python 对象中包含了很多双下划线开始和结束的属性，这些是特殊属性，有特殊用法。这 里我们列出常见的特殊属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">obj.__dict__对象的属性字典</span><br><span class="line">obj.__class__对象所属的类</span><br><span class="line">class.__bases__类的基类元组(多继承)</span><br><span class="line">class.__base__类的基类</span><br><span class="line">class.__mro__类层次结构</span><br><span class="line">class.__subclasses__()子类列表</span><br><span class="line">print(dir(c)) </span><br><span class="line">print(c.__dict__) </span><br><span class="line">print(c.__class__) </span><br><span class="line">print(C.__bases__) </span><br><span class="line">print(C.mro()) </span><br><span class="line">print(A.__subclasses__())</span><br></pre></td></tr></table></figure>

<p><strong>对象的浅拷贝和深拷贝</strong></p>
<p><strong>·变量的赋值操作</strong></p>
<p>只是形成两个变量，实际还是指向同一个对象。</p>
<p><strong>·浅拷贝</strong></p>
<p>Python 拷贝一般都是浅拷贝。拷贝时，对象包含的子对象内容不拷贝。因此，源对象 和拷贝对象会引用同一个子对象。<br> <strong>·深拷贝</strong></p>
<p>使用 copy 模块的 deepcopy 函数，递归拷贝对象中包含的子对象。源对象和拷贝对象 所有的子对象也不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">m2 &#x3D; copy.copy(m) #m2 是新拷贝的另一个手机对象</span><br><span class="line">m3 &#x3D; copy.deepcopy(m)</span><br></pre></td></tr></table></figure>

<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a><strong>组合</strong></h2><p>“is-a”关系，我们可以使用“继承”。从而实现子类拥有的父类的方法和属性。“is-a” 关系指的是类似这样的关系:狗是动物，dog is animal。狗类就应该继承动物类。</p>
<p>“has-a”关系，我们可以使用“组合”，也能实现一个类拥有另一个类的方法和属性。” has-a”关系指的是这样的关系:手机拥有 CPU。 MobilePhone has a CPU。self.cpu=cpu</p>
<h2 id="设计模式-工厂模式实现"><a href="#设计模式-工厂模式实现" class="headerlink" title="设计模式_工厂模式实现"></a><strong>设计模式_工厂模式实现</strong></h2><p>设计模式是面向对象语言特有的内容，是我们在面临某一类问题时候固定的做法，设计 模式有很多种，比较流行的是:GOF(Goup Of Four)23 种设计模式。当然，我们没有 必要全部学习，学习几个常用的即可。</p>
<p>对于初学者，我们学习两个最常用的模式:工厂模式和单例模式。</p>
<p>工厂模式实现了创建者和调用者的分离，使用专门的工厂类将选择实现类、创建对象进 行统一的管理和控制。</p>
<h2 id="设计模式-单例模式实现"><a href="#设计模式-单例模式实现" class="headerlink" title="设计模式_单例模式实现"></a><strong>设计模式_单例模式实现</strong></h2><p>单例模式(Singleton Pattern)的核心作用是确保一个类只有一个实例，并且提供一 个访问该实例的全局访问点。</p>
<p>单例模式只生成一个实例对象，减少了对系统资源的开销。当一个对象的产生需要比较 多的资源，如读取配置文件、产生其他依赖对象时，可以产生一个“单例对象”，然后永久 驻留内存中，从而极大的降低开销。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单例模式有多种实现的方式，我们这里推荐重写__new__()的方法。</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/python400%E9%9B%862/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/python400%E9%9B%862/" class="post-title-link" itemprop="url">python400集2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 15:09:25" itemprop="dateCreated datePublished" datetime="2020-04-29T15:09:25-05:00">2020-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-30 13:07:49" itemprop="dateModified" datetime="2020-04-30T13:07:49-05:00">2020-04-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="python基础入门"><a href="#python基础入门" class="headerlink" title="python基础入门"></a>python基础入门</h1><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>python 中常用的序列结构有:</p>
<p>字符串、列表、元组、字典、集合</p>
<h2 id="列表简介"><a href="#列表简介" class="headerlink" title="列表简介"></a><strong>列表简介</strong></h2><p><strong>列表:用于存储任意数目、任意类型的数据集合。</strong></p>
<p>列表是内置可变序列，是包含多个元素的有序连续的内存空间。列表定义的标准语法格式: a = [10,20,30,40]</p>
<p>其中，10,20,30,40 这些称为:列表 a 的元素。 列表中的元素可以各不相同，可以是任意类型。比如:</p>
<p>a = [10,20,’abc’,True] 列表对象的常用方法汇总如下，方便大家学习和查阅。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>要点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>list.append(x)</td>
<td>增加元素</td>
<td>将元素 x 增加到列表 list 尾部</td>
</tr>
<tr>
<td>list.extend(aList)</td>
<td>增加元素</td>
<td>将列表 alist 所有元素加到列表 list 尾部</td>
</tr>
<tr>
<td>list.insert(index,x)</td>
<td>增加元素</td>
<td>在列表 list 指定位置 index 处插入元素 x</td>
</tr>
<tr>
<td>list.remove(x)</td>
<td>删除元素</td>
<td>在列表 list 中删除首次出现的指定元素 x</td>
</tr>
<tr>
<td>list.pop([index])</td>
<td>删除元素</td>
<td>删除并返回列表 list 指定为止 index 处的元素，默认是 最后一个元素</td>
</tr>
<tr>
<td>list.clear()</td>
<td>删除所有元素</td>
<td>删除列表所有元素，并不是删除列表对象</td>
</tr>
<tr>
<td>list.index(x)</td>
<td>访问元素</td>
<td>返回第一个 x 的索引位置，若不存在 x 元素抛出异常</td>
</tr>
<tr>
<td>list.count(x)</td>
<td>计数</td>
<td>返回指定元素 x 在列表 list 中出现的次数</td>
</tr>
<tr>
<td>len(list)</td>
<td>列表长度</td>
<td><code>返回列表中包含元素的个数</code></td>
</tr>
<tr>
<td>list.reverse()</td>
<td>翻转列表</td>
<td>所有元素原地翻转</td>
</tr>
<tr>
<td>list.sort()</td>
<td>排序</td>
<td>所有元素原地排序</td>
</tr>
<tr>
<td>list.copy()</td>
<td>浅拷贝</td>
<td>返回列表对象的浅拷贝</td>
</tr>
</tbody></table>
<p>Python 的列表大小可变，根据需要随时增加或缩小。</p>
<p>字符串和列表都是序列类型，一个字符串是一个字符序列，一个列表是任何元素的序列。我 们前面学习的很多字符串的方法，在列表中也有类似的用法，几乎一模一样。</p>
<p><strong>列表的创建</strong></p>
<h5 id="基本语法-创建"><a href="#基本语法-创建" class="headerlink" title="基本语法[]创建"></a><strong>基本语法[]创建</strong></h5><p><strong>list()创建</strong>: 使用 list()可以将任何可迭代的数据转化成列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; list(&quot;gaoqi,sxt&quot;)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[&#39;g&#39;, &#39;a&#39;, &#39;o&#39;, &#39;q&#39;, &#39;i&#39;, &#39;,&#39;, &#39;s&#39;, &#39;x&#39;, &#39;t&#39;]</span><br></pre></td></tr></table></figure>

<p><strong>range()创建整数列表</strong></p>
<p>range()可以帮助我们非常方便的创建整数列表，这在开发中及其有用。语法格式为: range([start,] end [,step])</p>
<p>start 参数:可选，表示起始数字。默认是 0<br> end 参数:必选，表示结尾数字。<br> step 参数:可选，表示步长，默认为 1<br> python3 中 range()返回的是一个 range 对象，而不是列表。我们需要通过 list()方法将其 转换成列表对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(3,15,2))</span><br><span class="line">[3, 5, 7, 9, 11, 13]</span><br></pre></td></tr></table></figure>

<p><strong>推导式生成列表</strong></p>
<p>使用列表推导式可以非常方便的创建列表，在开发中经常使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> a &#x3D; [x*2 for x in range(100) if x%9&#x3D;&#x3D;0] #通过 if 过滤元素 </span><br><span class="line"> &gt;&gt;&gt; a</span><br><span class="line">[0, 18, 36, 54, 72, 90, 108, 126, 144, 162, 180, 198]</span><br></pre></td></tr></table></figure>

<p><strong>列表元素的增加和删除</strong></p>
<p>当列表增加和删除元素时，列表会自动进行内存管理，大大减少了程序员的负担。但这 个特点涉及列表元素的大量移动，效率较低。除非必要，我们一般只在列表的尾部添加元素 或删除元素，这会大大提高列表的操作效率。</p>
<p><strong>append()方法</strong></p>
<p>原地修改列表对象，是真正的列表尾部添加新的元素，速度最快，推荐使用。 a.append(80)</p>
<p><strong>+运算符操作</strong></p>
<p>并不是真正的尾部添加元素，而是创建新的列表对象;将原列表的元素和新列表的元素依次 复制到新的列表对象中。这样，会涉及大量的复制操作，对于操作大量元素不建议使用。a = a+[50]</p>
<p><strong>extend()方法</strong></p>
<p>将目标列表的所有元素添加到本列表的尾部，属于原地操作，不创建新的列表对象。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [20,40]</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">46016072</span><br><span class="line">&gt;&gt;&gt; a.extend([50,60])</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">46016072</span><br></pre></td></tr></table></figure>

<p><strong>insert()插入元素</strong></p>
<p>使用 insert()方法可以将指定的元素插入到列表对象的任意制定位置。这样会让插入位置后 面所有的元素进行移动，会影响处理速度。涉及大量元素时，尽量避免使用。类似发生这种 移动的函数还有:remove()、pop()、del()，它们在删除非尾部元素时也会发生操作位置后 面元素的移动。</p>
<p>a.insert(2,100)#在index2处加入100</p>
<p><strong>乘法扩展</strong></p>
<p>使用乘法扩展列表，生成一个新列表，新列表元素时原列表元素的多次重复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b &#x3D; a*3 </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[&#39;sxt&#39;, 100] </span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[&#39;sxt&#39;, 100, &#39;sxt&#39;, 100, &#39;sxt&#39;, 100]</span><br></pre></td></tr></table></figure>

<p><strong>列表元素的删除 del 删除</strong></p>
<p>删除列表指定位置的元素。del a[1]</p>
<p><strong>pop()方法</strong></p>
<p>pop()删除并返回指定位置元素，如果未指定位置则默认操作列表最后一个元素。</p>
<p>a.pop(1)#返回index 1的元素</p>
<p><strong>remove()方法</strong></p>
<p>删除首次出现的指定元素，若不存在该元素抛出异常。a.remove(20)</p>
<h3 id="列表元素访问和计数"><a href="#列表元素访问和计数" class="headerlink" title="列表元素访问和计数"></a>列表元素访问和计数</h3><p>我们可以通过索引直接访问元素。索引的区间在[0, 列表长度-1]这个范围。超过这个范围则 会抛出异常。</p>
<p><strong>index()获得指定元素在列表中首次出现的索引</strong></p>
<p>index()可以获取指定元素首次出现的索引位置。语法是:index(value,[start,[end]])。其中， start 和 end 指定了搜索的范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a.index(30,5,7) #从索引位置 5 到 7 这个区间，第一次出现 30 元素的位置</span><br></pre></td></tr></table></figure>

<p><strong>count()获得指定元素在列表中出现的次数</strong></p>
<p>count()可以返回指定元素在列表中出现的次数。 a.count(20)</p>
<p><strong>len()返回列表长度</strong></p>
<p>len()返回列表长度，即列表中包含元素的个数。 len(a)</p>
<p><strong>成员资格判断</strong></p>
<p>判断列表中是否存在指定的元素，我们可以使用 count()方法，返回 0 则表示不存在，返回 大于 0 则表示存在。但是，一般我们会使用更加简洁的 in 关键字来判断，直接返回 True 或 False。100 not in a</p>
<ol>
<li><p><strong>切片操作</strong></p>
<p>我们在前面学习字符串时，学习过字符串的切片操作，对于列表的切片操作和字符串类似。 切片是 Python 序列及其重要的操作，适用于列表、元组、字符串等等。切片的格式如下:</p>
<p>切片 slice 操作可以让我们快速提取子列表或修改。标准格式为: [起始偏移量 start:终止偏移量 end[:步长 step]]</p>
<p>注:当步长省略时顺便可以省略第二个冒号</p>
<table>
<thead>
<tr>
<th>操作和说明</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>[:] 提取整个列表</td>
<td>[10,20,30][:]</td>
<td>[10,20,30]</td>
</tr>
<tr>
<td>[start:]从 start 索引开始到 结尾</td>
<td>[10,20,30][1:]</td>
<td>[20,30]</td>
</tr>
<tr>
<td>[:end]从头开始知道 end-1</td>
<td>[10,20,30][:2]</td>
<td>[10,20]</td>
</tr>
<tr>
<td>[start:end]从 start 到 end-1</td>
<td>[10,20,30,40][1:3]</td>
<td>[20,30]</td>
</tr>
<tr>
<td>[start:end:step] 从 start 提 取到 end-1，步长是 step</td>
<td>[10,20,30,40,50,60,70][1:6: 2]</td>
<td>[20, 40, 60]</td>
</tr>
</tbody></table>
</li>
</ol>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>[10,20,30,40,50,60,70][-3:]</td>
<td>倒数三个</td>
<td>[50,60,70]</td>
</tr>
<tr>
<td>10,20,30,40,50,60,70][-5:-3]</td>
<td>倒数第五个到倒数 第三个(包头不包尾)</td>
<td>[30,40]</td>
</tr>
<tr>
<td>[10,20,30,40,50,60,70][::-1]</td>
<td>步长为负，从右到左 反向提取</td>
<td>[70, 60, 50, 40, 30, 20, 10]</td>
</tr>
</tbody></table>
<p>切片操作时，起始偏移量和终止偏移量不在[0,字符串长度-1]这个范围，也不会报错。起始 偏移量小于 0 则会当做 0，终止偏移量大于“长度-1”会被当成”长度-1”</p>
<p><strong>列表的遍历</strong></p>
<p>for obj in listObj: print(obj)</p>
<h3 id="复制列表所有的元素到新列表对象"><a href="#复制列表所有的元素到新列表对象" class="headerlink" title="复制列表所有的元素到新列表对象"></a>复制列表所有的元素到新列表对象</h3><p>我们可以通过如下简单方式，实现列表元素内容的复制: list1 = [30,40,50]</p>
<p>list2 = [] + list1</p>
<h3 id="列表排序"><a href="#列表排序" class="headerlink" title="*列表排序 *"></a>*<em>列表排序 *</em></h3><p><strong>修改原列表，不建新列表的排序</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [20,10,30,40]</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">46017416</span><br><span class="line">&gt;&gt;&gt; a.sort() #默认是升序排列 </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[10, 20, 30, 40]</span><br><span class="line">&gt;&gt;&gt; a &#x3D; [10,20,30,40] </span><br><span class="line">&gt;&gt;&gt; a.sort(reverse&#x3D;True) #降序</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[40, 30, 20, 10]</span><br><span class="line">&gt;&gt;&gt; import random </span><br><span class="line">&gt;&gt;&gt; random.shuffle(a) #打乱排序</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[20, 40, 30, 10]</span><br></pre></td></tr></table></figure>

<h3 id="建新列表排序"><a href="#建新列表排序" class="headerlink" title="建新列表排序"></a>建新列表排序</h3><p>我们也可以通过内置函数 sorted()进行排序，这个方法返回新列表，不对原列表做修改。</p>
<p> a = sorted(a)</p>
<p> c = sorted(a,reverse=True)   #降序</p>
<p><strong>reversed()返回迭代器</strong></p>
<p>内置函数 reversed()也支持进行逆序排列，与列表对象 reverse()方法不同的是，内置函数 reversed()不对原列表做任何修改，只是返回一个逆序排列的迭代器对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">20</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">40</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = reversed(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">&lt;list_reverseiterator object at <span class="number">0x0000000002BCCEB8</span>&gt; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(c)</span><br><span class="line">[<span class="number">40</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(c)</span><br><span class="line">[]</span><br><span class="line">···</span><br><span class="line">我们打印输出 c 发现提示是:list_reverseiterator。也就是一个迭代对象。同时，我们使用 list(c)进行输出，发现只能使用一次。第一次输出了元素，第二次为空。那是因为迭代对象 在第一次时已经遍历结束了，第二次不能再使用。</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p><strong>列表相关的其他内置函数汇总 max 和 min</strong></p>
<p>用于返回列表中最大和最小值。max（a）</p>
<p><strong>sum</strong></p>
<p>对数值型列表的所有元素进行求和操作，对非数值型列表运算则会报错。</p>
<h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 tuple"></a><strong>元组 tuple</strong></h2><p>列表属于可变序列，可以任意修改列表中的元素。元组属于不可变序列，不能修改元组中的 元素。因此，元组没有增加元素、修改元素、删除元素相关的方法。</p>
<p>因此，我们只需要学习元组的创建和删除，元组中元素的访问和计数即可。元组支持如 下操作:</p>
<p>\1. 索引访问<br> \2. 切片操作<br> \3. 连接操作<br> \4. 成员关系操作<br> \5. 比较运算操作<br> \6. 计数:元组长度 len()、最大值 max()、最小值 min()、求和 sum()等。</p>
<h3 id="元组的创建"><a href="#元组的创建" class="headerlink" title="元组的创建"></a><strong>元组的创建</strong></h3><p>\1. 通过()创建元组。小括号可以省略。</p>
<p> 如果元组只有一个元素，则必须后面加逗号。这是因为解释器会把(1)解释为整数 1，(1,) 解释为元组。</p>
<p>a = (10,20,30) 或者 a = 10,20,30</p>
<p>\2. 通过 tuple()创建元组 tuple(可迭代的对象)</p>
<p>tuple()可以接收列表、字符串、其他序列类型、迭代器等生成元组。 list()可以接收元组、字符串、其他序列类型、迭代器等生成列表。</p>
<h3 id="元组的元素访问和计数"><a href="#元组的元素访问和计数" class="headerlink" title="元组的元素访问和计数"></a><strong>元组的元素访问和计数</strong></h3><p>\1. 元组的元素不能修改</p>
<p>\2. 元组的元素访问和列表一样，只不过返回的仍然是元组对象。</p>
<p>\3. 列表关于排序的方法 list.sorted()是修改原列表对象，元组没有该方法。如果要对元组排 序，只能使用内置函数 sorted(tupleObj)，并生成新的列表对象。 sorted(a)</p>
<p><strong>zip</strong></p>
<p>zip(列表 1，列表 2，…)将多个列表对应位置的元素组合成为元组，并返回这个 zip 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [10,20,30]</span><br><span class="line">&gt;&gt;&gt; b &#x3D; [40,50,60]</span><br><span class="line">&gt;&gt;&gt; c &#x3D; [70,80,90]</span><br><span class="line">&gt;&gt;&gt; d &#x3D; zip(a,b,c)</span><br><span class="line">&gt;&gt;&gt; list(d)</span><br><span class="line">[(10, 40, 70), (20, 50, 80), (30, 60, 90)]</span><br></pre></td></tr></table></figure>

<p><strong>生成器推导式创建元组</strong></p>
<p>从形式上看，生成器推导式与列表推导式类似，只是生成器推导式使用小括号。列表推 导式直接生成列表对象，生成器推导式生成的不是列表也不是元组，而是一个生成器对象。</p>
<p>我们可以通过生成器对象，转化成列表或者元组。也可以使用生成器对象的<strong>next</strong>() 方法进行遍历，或者直接作为迭代器对象来使用。不管什么方式使用，元素访问结束后，如 果需要重新访问其中的元素，必须重新创建该生成器对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; (x*2 for x in range(5))</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x0000000002BDEB48&gt;</span><br><span class="line">&gt;&gt;&gt; tuple(s)</span><br><span class="line">(0, 2, 4, 6, 8)</span><br><span class="line">&gt;&gt;&gt; list(s) #只能访问一次元素。第二次就为空了。需要再生成一次 </span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x0000000002BDEB48&gt;</span><br><span class="line">&gt;&gt;&gt; tuple(s)</span><br><span class="line">()</span><br><span class="line">&gt;&gt;&gt; s &#x3D; (x*2 for x in range(5))</span><br><span class="line">&gt;&gt;&gt; s.__next__()</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; s.__next__()</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; s.__next__()</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><strong>元组总结</strong></p>
<p>\1. 元组的核心特点是:不可变序列。<br> \2. 元组的访问和处理速度比列表快。<br> \3. 与整数和字符串一样，元组可以作为字典的键，列表则永远不能作为字典的键使用。</p>
<h2 id="字典介绍"><a href="#字典介绍" class="headerlink" title="字典介绍"></a><strong>字典介绍</strong></h2><p>字典是“键值对”的无序可变序列，字典中的每个元素都是一个“键值对”，包含:“键 对象”和“值对象”。可以通过“键对象”实现快速获取、删除、更新对应的“值对象”。</p>
<p>列表中我们通过“下标数字”找到对应的对象。字典中通过“键对象”找到对应的“值 对象”。“键”是任意的不可变数据，比如:整数、浮点数、字符串、元组。但是:列表、 字典、集合这些可变对象，不能作为“键”。并且“键”不可重复。</p>
<p>“值”可以是任意的数据，并且可重复。</p>
<p><strong>字典的创建</strong></p>
<p>\1. 我们可以通过{}、dict()来创建字典对象。</p>
<p>\2. 通过 zip()创建字典对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; k &#x3D; [&#39;name&#39;,&#39;age&#39;,&#39;job&#39;]</span><br><span class="line">&gt;&gt;&gt; v &#x3D; [&#39;gaoqi&#39;,18,&#39;techer&#39;]</span><br><span class="line">&gt;&gt;&gt; d &#x3D; dict(zip(k,v))</span><br></pre></td></tr></table></figure>

<p>\3. 通过 fromkeys 创建值为空的字典</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; dict.fromkeys([&#39;name&#39;,&#39;age&#39;,&#39;job&#39;]) </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#39;name&#39;: None, &#39;age&#39;: None, &#39;job&#39;: None&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字典元素的访问</strong></p>
<p>\1. 通过 [键] 获得“值”。若键不存在，则抛出异常。 a[‘name’]</p>
<p>\2. 通过 get()方法获得“值”。推荐使用。优点是:指定键不存在，返回 None;也可以设 定指定键不存在时默认返回的对象。推荐使用 get()获取“值对象”。a.get(‘name’)</p>
<p>\3. 列出所有的键值对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a.items()</span><br><span class="line">dict_items([(&#39;name&#39;, &#39;gaoqi&#39;), (&#39;age&#39;, 18), (&#39;job&#39;, &#39;programmer&#39;)])</span><br></pre></td></tr></table></figure>

<p>\4. 列出所有的键，列出所有的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a.keys()</span><br><span class="line">dict_keys([&#39;name&#39;, &#39;age&#39;, &#39;job&#39;])</span><br><span class="line">&gt;&gt;&gt; a.values()</span><br><span class="line">dict_values([&#39;gaoqi&#39;, 18, &#39;programmer&#39;])</span><br></pre></td></tr></table></figure>

<p>\5. len() 键值对的个数<br> \6. 检测一个“键”是否在字典中 用in</p>
<h3 id="字典元素添加、修改、删除"><a href="#字典元素添加、修改、删除" class="headerlink" title="字典元素添加、修改、删除"></a><strong>字典元素添加、修改、删除</strong></h3><p>\1. 给字典新增“键值对”。如果“键”已经存在，则覆盖旧的键值对;如果“键”不存在， 则新增“键值对”。a[‘age’]=16</p>
<p>\2. 使用 update()将新字典中所有键值对全部添加到旧字典对象上。如果 key 有重复，则直 接覆盖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &#123;&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;job&#39;:&#39;programmer&#39;&#125; </span><br><span class="line">&gt;&gt;&gt; b &#x3D; &#123;&#39;name&#39;:&#39;gaoxixi&#39;,&#39;money&#39;:1000,&#39;sex&#39;:&#39;男的&#39;&#125; </span><br><span class="line">&gt;&gt;&gt; a.update(b)</span><br></pre></td></tr></table></figure>

<p>\3. 字典中元素的删除，可以使用 del()方法;或者 clear()删除所有键值对;pop()删除指定 键值对，并返回对应的“值对象”;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; del(a[&#39;name&#39;])</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#39;age&#39;: 18, &#39;job&#39;: &#39;programmer&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; a.pop(&#39;age&#39;)</span><br></pre></td></tr></table></figure>

<p>\4. popitem() :随机删除和返回该键值对。字典是“无序可变序列”，因此没有第一个元 素、最后一个元素的概念;popitem 弹出随机的项，因为字典并没有”最后的元素”或者其 他有关顺序的概念。若想一个接一个地移除并处理项，这个方法就非常有效(因为不用首先获取键的列表)。</p>
<p> a.popitem()</p>
<p><strong>序列解包</strong></p>
<p>序列解包可以用于元组、列表、字典。序列解包可以让我们方便的对多个变量赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x,y,z&#x3D;(20,30,10)</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">30</span><br><span class="line">&gt;&gt;&gt; z</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; (a,b,c)&#x3D;(9,8,10) </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; [a,b,c]&#x3D;[10,20,30] </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<p>序列解包用于字典时，默认是对“键”进行操作; 如果需要对键值对操作，则需要使用 items();如果需要对“值”进行操作，则需要使用 values();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; &#123;&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;job&#39;:&#39;teacher&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; name,age,job&#x3D;s #默认对键进行操作 </span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">&#39;name&#39;</span><br><span class="line">&gt;&gt;&gt; name,age,job&#x3D;s.items() </span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">(&#39;name&#39;, &#39;gaoqi&#39;)</span><br><span class="line">&gt;&gt;&gt; name,age,job&#x3D;s.values() </span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">&#39;gaoqi&#39;</span><br></pre></td></tr></table></figure>

<h3 id="字典核心底层原理-重要"><a href="#字典核心底层原理-重要" class="headerlink" title="字典核心底层原理(重要)"></a><strong>字典核心底层原理(重要)</strong></h3><p>字典对象的核心是散列表。散列表是一个稀疏数组(总是有空白元素的数组)，数组的 每个单元叫做 bucket。每个 bucket 有两部分:一个是键对象的引用，一个是值对象的引 用。<br> 由于，所有 bucket 结构和大小一致，我们可以通过偏移量来读取指定 bucket。</p>
<p><strong>扩容</strong></p>
<p>python 会根据散列表的拥挤程度扩容。“扩容”指的是:创造更大的数组，将原有内容 拷贝到新数组中。</p>
<p>接近 2/3 时，数组就会扩容。</p>
<p>用法总结:<br> \1. 键必须可散列</p>
<p>(1) 数字、字符串、元组，都是可散列的。 </p>
<p>(2) 自定义对象需要支持下面三点:</p>
<ol>
<li>1  支持 hash()函数</li>
<li>2  支持通过<strong>eq</strong>()方法检测相等性。</li>
<li>3  若 a==b 为真，则 hash(a)==hash(b)也为真。</li>
</ol>
<p>\2. 字典在内存中开销巨大，典型的空间换时间。<br> \3. 键查询速度很快<br> \4. 往字典里面添加新建可能导致扩容，导致散列表中键的次序变化。因此，不要在遍历字 典的同时进行字典的修改。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h2><p><strong>集合创建和删除</strong></p>
<p>\1. 使用{}创建集合对象，并使用 add()方法添加元素</p>
<p>\2. 使用 set()，将列表、元组等可迭代对象转成集合。如果原来数据存在重复数据，则只保 留一个。</p>
<p>\3. remove()删除指定元素;clear()清空整个集合</p>
<p><strong>集合相关操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &#123;1,3,&#39;sxt&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; &#123;&#39;he&#39;,&#39;it&#39;,&#39;sxt&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a|b #并集</span><br><span class="line">&#123;1, 3, &#39;sxt&#39;, &#39;he&#39;, &#39;it&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a&amp;b #交集 </span><br><span class="line">&#123;&#39;sxt&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a-b #差集 </span><br><span class="line">&#123;1, 3&#125;</span><br><span class="line">&gt;&gt;&gt; a.union(b) #并集 </span><br><span class="line">&#123;1, 3, &#39;sxt&#39;, &#39;he&#39;, &#39;it&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a.intersection(b) #交集 </span><br><span class="line">&#123;&#39;sxt&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a.difference(b) #差集 </span><br><span class="line">&#123;1, 3&#125;</span><br></pre></td></tr></table></figure>

<h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="三元条件运算符"><a href="#三元条件运算符" class="headerlink" title="三元条件运算符"></a><strong>三元条件运算符</strong></h2><p>Python 提供了三元运算符，用来在某些简单双分支赋值情况。三元条件运算符语法格式如 下:</p>
<h3 id="条件为真时的值-if-条件表达式-else-条件为假时的值"><a href="#条件为真时的值-if-条件表达式-else-条件为假时的值" class="headerlink" title="条件为真时的值 if (条件表达式) else 条件为假时的值"></a>条件为真时的值 if (条件表达式) else 条件为假时的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print( num if int(num)&lt;10 else &quot;数字太大&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>可迭代对象</strong></p>
<p>Python 包含以下几种可迭代对象: </p>
<ol>
<li>​    序列。包含:字符串、列表、元组 </li>
<li><ol start="2">
<li>字典</li>
<li>. 迭代器对象(iterator)<br>  \4. 生成器函数(generator)<br>  \5. 文件对象</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for x in print(x)</span><br><span class="line">for x in print(x)</span><br><span class="line">d.keys():#遍历字典所有的 key</span><br><span class="line">d.values():#遍历字典所有的 value</span><br><span class="line">for x in d.items():#遍历字典所有的&quot;键值对&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【操作】利用嵌套循环打印九九乘法表</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">		<span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">			print(<span class="string">"&#123;0&#125;*&#123;1&#125;=&#123;2&#125;"</span>.format(m,n,(m*n)),end=<span class="string">"\t"</span>) </span><br><span class="line">		print()</span><br></pre></td></tr></table></figure>

<p><strong>使用 zip()并行迭代</strong></p>
<p>我们可以通过 zip()函数对多个序列进行并行迭代，zip()函数在最短序列“用完”时就会停止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names &#x3D; (&quot;高淇&quot;,&quot;高老二&quot;,&quot;高老三&quot;,&quot;高老四&quot;) </span><br><span class="line">ages &#x3D; (18,16,20,25)</span><br><span class="line">jobs &#x3D; (&quot;老师&quot;,&quot;程序员&quot;,&quot;公务员&quot;)</span><br><span class="line">for name,age,job in zip(names,ages,jobs): </span><br><span class="line">	print(&quot;&#123;0&#125;--&#123;1&#125;--&#123;2&#125;&quot;.format(name,age,job))</span><br></pre></td></tr></table></figure>

<p><strong>推导式创建序列</strong></p>
<p>推导式是从一个或者多个迭代器快速创建序列的一种方法。它可以将循环和条件判断结合， 从而避免冗长的代码。推导式是典型的 Python 风格，会使用它代表你已经超过 Python 初 学者的水平。</p>
<p><strong>列表推导式</strong></p>
<p>列表推导式生成列表对象，语法如下:<br> [表达式 for item in 可迭代对象 ]</p>
<p>或者:{表达式 for item in 可迭代对象 if 条件判断}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; [x for x in range(1,5)] </span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; [x*2 for x in range(1,5)]</span><br><span class="line">[2, 4, 6, 8]</span><br><span class="line">&gt;&gt;&gt; [x*2 for x in range(1,20) if x%5&#x3D;&#x3D;0 ] </span><br><span class="line">[10, 20, 30]</span><br><span class="line">&gt;&gt;&gt; [a for a in &quot;abcdefg&quot;]</span><br><span class="line">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span><br><span class="line">&gt;&gt;&gt; cells &#x3D; [(row,col) for row in range(1,10) for col in range(1,10)]</span><br><span class="line">#可以使用两个循环</span><br><span class="line">&gt;&gt;&gt; for cell in cells:</span><br><span class="line">print(cell)</span><br></pre></td></tr></table></figure>

<p><strong>字典推导式</strong></p>
<p>row in range(1,10) for col in range(1,10)]</p>
<p>#可以使用两</p>
<p>字典的推导式生成字典对象，格式如下:<br> {key_expression : value_expression for 表达式 in 可迭代对象}</p>
<p>类似于列表推导式，字典推导也可以增加 if 条件判断、多个 for 循环。</p>
<p>统计文本中字符出现的次数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\&gt;&gt;&gt; my_text &#x3D; &#39; i love you, i love sxt, i love gaoqi&#39;</span><br><span class="line">\&gt;&gt;&gt; char_count &#x3D; &#123;c:my_text.count(c) for c in my_text&#125;</span><br><span class="line">\&gt;&gt;&gt; char_count</span><br><span class="line">&#123;&#39; &#39;: 9, &#39;i&#39;: 4, &#39;l&#39;: 3, &#39;o&#39;: 5, &#39;v&#39;: 3, &#39;e&#39;: 3, &#39;y&#39;: 1, &#39;u&#39;: 1, &#39;,&#39;: 2, &#39;s&#39;: 1, &#39;x&#39;: 1, &#39;t&#39;: 1, &#39;g&#39;: 1, &#39;a&#39;: 1, &#39;q&#39;: 1&#125;</span><br></pre></td></tr></table></figure>

<p><strong>集合推导式</strong></p>
<p>集合推导式生成集合，和列表推导式的语法格式类似:<br> {表达式 for item in 可迭代对象 }</p>
<p>或者:{表达式 for item in 可迭代对象 if 条件判断}</p>
<p>&gt;&gt;&gt; {x for x in range(1,100) if x%9==0} {99, 36, 72, 9, 45, 81, 18, 54, 90, 27, 63}</p>
<h4 id="生成器推导式-生成元组"><a href="#生成器推导式-生成元组" class="headerlink" title="生成器推导式(生成元组)"></a>生成器推导式(生成元组)</h4><p>很多同学可能会问:“都有推导式，元组有没有?”，能不能用小括号呢? </p>
<p> (x for x in range(1,100) if x%9==0)<br> &lt;generator object <genexpr> at 0x0000000002BD3048&gt; </p>
<p>我们发现提示的是“一个生成器对象”。显然，元组是没有推导式的。</p>
<p>一个生成器只能运行一次。第一次迭代可以得到数据，第二次迭代发现数据已经没有了。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; gnt &#x3D; (x for x in range(1,100) if x%9&#x3D;&#x3D;0)</span><br><span class="line"> &gt;&gt;&gt; for x in gnt:</span><br><span class="line"></span><br><span class="line">print(x,end&#x3D;&#39; &#39;)</span><br><span class="line"> 9 18 27 36 45 54 63 72 81 90 99 </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; for x in gnt:</span><br><span class="line"></span><br><span class="line">print(x,end&#x3D;&#39; &#39;)</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Python 中函数分为如下几类: 1. 内置函数</p>
<p>我们前面使用的 str()、list()、len()等这些都是内置函数，我们可以拿来直接使用。</p>
<ol start="2">
<li>标准库函数</li>
</ol>
<p>我们可以通过 import 语句导入库，然后使用其中定义的函数 </p>
<ol start="3">
<li>第三方库函数</li>
</ol>
<p>Python 社区也提供了很多高质量的库。下载安装这些库后，也是通过 import 语句导 入，然后可以使用这些第三方库的函数</p>
<ol start="4">
<li>用户自定义函数</li>
</ol>
<p>用户自己定义的函数，显然也是开发中适应用户自身需求定义的函数。今天我们学习的 就是如何自定义函数。</p>
<h2 id="文档字符串-函数的注释"><a href="#文档字符串-函数的注释" class="headerlink" title="文档字符串(函数的注释)"></a><strong>文档字符串(函数的注释)</strong></h2><p>程序的可读性最重要，一般建议在函数体开始的部分附上函数定义说明，这就是“文档字符 串”，也有人成为“函数的注释”。我们通过三个单引号或者三个双引号来实现，中间可以</p>
<p>北京尚学堂·百战程序员 实战 系统 好教育</p>
<p>加入多行文字进行说明。</p>
<p><strong>函数也是对象，内存底层分析</strong></p>
<p>Python 中，“一切都是对象”。实际上，执行 def 定义函数后，系统就创建了相应的函数 对象。</p>
<h3 id="变量的作用域-全局变量和局部变量"><a href="#变量的作用域-全局变量和局部变量" class="headerlink" title="变量的作用域(全局变量和局部变量)"></a>变量的作用域<strong>(</strong>全局变量和局部变量<strong>)</strong></h3><p>变量起作用的范围称为变量的作用域，不同作用域内同名变量之间互不影响。变量分为:全局变量、局部变量。</p>
<p>全局变量:</p>
<p>\1. 在函数和类定义之外声明的变量。作用域为定义的模块，从定义位置开始直到模块 结束。</p>
<ol>
<li>全局变量降低了函数的通用性和可读性。应尽量避免全局变量的使用。</li>
<li>全局变量一般做常量使用。</li>
<li>函数内要改变全局变量的值，使用 global 声明一下</li>
</ol>
<p>局部变量:<br> \1. 在函数体中(包含形式参数)声明的变量。<br> \2. 局部变量的引用比全局变量快，优先考虑使用。<br> \3. 如果局部变量和全局变量同名，则在函数内隐藏全局变量，只使用同名的局部变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">100</span> <span class="comment">#全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> a <span class="comment">#如果要在函数内改变全局变量的值，增加 global 关键字声明</span></span><br><span class="line">	print(a) <span class="comment">#打印全局变量 a 的值, </span></span><br><span class="line">	a = <span class="number">300</span></span><br><span class="line">  print(a)<span class="comment">#局部变量a</span></span><br><span class="line">  print(locals())</span><br><span class="line">  print(globals())</span><br><span class="line">f1() </span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">```结果</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">300</span></span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': '/Users/mengxiaowang/Documents/a.py', 'a': 300, 'f1': &lt;function f1 at 0x7ff5602dc430&gt;&#125;</span><br><span class="line"><span class="number">300</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>另一种输出，因为local变global后没有了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">100</span> <span class="comment">#全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">300</span></span><br><span class="line">    print(locals())<span class="comment">#&#123;'a': 300&#125;</span></span><br><span class="line">    print(globals())<span class="comment">#&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'a': &lt;function a at 0x7f9388270830&gt;&#125;</span></span><br><span class="line">f1() </span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">```</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">300</span>&#125;</span><br><span class="line">&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': '/Users/mengxiaowang/Documents/a.py', 'a': 100, 'f1': &lt;function f1 at 0x7fc050745430&gt;&#125;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h3 id="局部变量和全局变量效率测试"><a href="#局部变量和全局变量效率测试" class="headerlink" title="局部变量和全局变量效率测试"></a>局部变量和全局变量效率测试</h3><p>局部变量的查询和访问速度比全局变量快，优先考虑使用，尤其是在循环的时候。 在特别强调效率的地方或者循环次数较多的地方，可以通过将全局变量转为局部变量提高运 行速度。</p>
<h3 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a><strong>参数的传递</strong></h3><p>函数的参数传递本质上就是:从实参到形参的赋值操作。 Python 中“一切皆对象”， 所有的赋值操作都是“引用的赋值”。所以，Python 中参数的传递都是“引用传递”，不 是“值传递”。具体操作时分为两类:</p>
<p>\1. 对“可变对象”进行“写操作”，直接作用于原对象本身。</p>
<p>\2. 对“不可变对象”进行“写操作”，会产生一个新的“对象空间”，并用新的值填 充这块空间。(起到其他语言的“值传递”效果，但不是“值传递”)</p>
<p>可变对象有: 字典、列表、集合、自定义的对象等</p>
<p>不可变对象有: 数字、字符串、元组、function 等</p>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a><strong>浅拷贝和深拷贝</strong></h3><p>为了更深入的了解参数传递的底层原理，我们需要讲解一下“浅拷贝和深拷贝”。我们可以 使用内置函数:copy(浅拷贝)、deepcopy(深拷贝)。</p>
<p>浅拷贝:不拷贝子对象的内容，只是拷贝子对象的引用。 深拷贝:会连子对象的内存也全部拷贝一份，对子对象的修改不会影响源对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testCopy</span><span class="params">()</span>:</span> <span class="string">'''测试浅拷贝'''</span></span><br><span class="line">	a = [<span class="number">10</span>, <span class="number">20</span>, [<span class="number">5</span>, <span class="number">6</span>]] </span><br><span class="line">  b = copy.copy(a)</span><br><span class="line">	print(<span class="string">"a"</span>, a) </span><br><span class="line">  print(<span class="string">"b"</span>, b) </span><br><span class="line">  b.append(<span class="number">30</span>) </span><br><span class="line">  b[<span class="number">2</span>].append(<span class="number">7</span>) </span><br><span class="line">  print(<span class="string">"浅拷贝......"</span>) </span><br><span class="line">  print(<span class="string">"a"</span>, a) </span><br><span class="line">  print(<span class="string">"b"</span>, b)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testDeepCopy</span><span class="params">()</span>:</span> <span class="string">'''测试深拷贝'''</span></span><br><span class="line">	a = [<span class="number">10</span>, <span class="number">20</span>, [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">  b = copy.deepcopy(a)</span><br><span class="line">	print(<span class="string">"a"</span>, a) </span><br><span class="line">  print(<span class="string">"b"</span>, b) </span><br><span class="line">  b.append(<span class="number">30</span>) </span><br><span class="line">  b[<span class="number">2</span>].append(<span class="number">7</span>) </span><br><span class="line">  print(<span class="string">"深拷贝......"</span>) </span><br><span class="line">  print(<span class="string">"a"</span>, a) </span><br><span class="line">  print(<span class="string">"b"</span>, b)</span><br><span class="line">testCopy() </span><br><span class="line">print(<span class="string">"*************"</span>) </span><br><span class="line">testDeepCopy()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">结果</span><br><span class="line"></span><br><span class="line">a [10, 20, [5, 6]]</span><br><span class="line">b [10, 20, [5, 6]]</span><br><span class="line">浅拷贝......</span><br><span class="line">a [10, 20, [5, 6, 7]]</span><br><span class="line">b [10, 20, [5, 6, 7], 30]</span><br><span class="line">   *************</span><br><span class="line">a [10, 20, [5, 6]]</span><br><span class="line">b [10, 20, [5, 6]] </span><br><span class="line">深拷贝......</span><br><span class="line">a [10, 20, [5, 6]]</span><br><span class="line">b [10, 20, [5, 6, 7], 30]</span><br></pre></td></tr></table></figure>

<h3 id="传递不可变对象包含的子对象是可变的情况"><a href="#传递不可变对象包含的子对象是可变的情况" class="headerlink" title="传递不可变对象包含的子对象是可变的情况"></a>传递不可变对象包含的子对象是可变的情况</h3><p>#传递不可变对象时。不可变对象里面包含的子对象是可变的。则 方法内修改了这个可变对象，源对象也发生了变化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">10</span>,<span class="number">20</span>,[<span class="number">5</span>,<span class="number">6</span>]) </span><br><span class="line">print(<span class="string">"a:"</span>,id(a))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test01</span><span class="params">(m)</span>:</span> </span><br><span class="line">	print(<span class="string">"m:"</span>,id(m)) </span><br><span class="line">  m[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">888</span> </span><br><span class="line">  print(m) </span><br><span class="line">  print(<span class="string">"m:"</span>,id(m))</span><br><span class="line">test01(a)</span><br><span class="line">print(a)</span><br><span class="line">运行结果:</span><br><span class="line">a: <span class="number">41611632</span></span><br><span class="line">m: <span class="number">41611632</span> </span><br><span class="line">  (<span class="number">10</span>, <span class="number">20</span>, [<span class="number">888</span>, <span class="number">6</span>]) </span><br><span class="line">  m: <span class="number">41611632</span> </span><br><span class="line">    (<span class="number">10</span>, <span class="number">20</span>, [<span class="number">888</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>

<p>id相对于c中地址符&amp;</p>
<h3 id="参数的几种类型"><a href="#参数的几种类型" class="headerlink" title="*参数的几种类型 *"></a>*<em>参数的几种类型 *</em></h3><p><strong>位置参数</strong></p>
<p>函数调用时，实参默认按位置顺序传递，需要个数和形参匹配。按位置传递的参数，称为: “位置参数”。</p>
<p><strong>默认值参数</strong></p>
<p>我们可以为某些参数设置默认值，这样这些参数在传递时就是可选的。称为“默认值参数”。 默认值参数放到位置参数后面。def f1(a,b,c=10,d=20): #默认值参数必须位于普通位置参数后面</p>
<p><strong>命名参数</strong></p>
<p>我们也可以按照形参的名称传递参数，称为“命名参数”，也称“关键字参数”。f1(8,9,19) #位置参数 f1(c=10,a=20,b=30) #命名参数</p>
<p><strong>强制命名参数</strong></p>
<p>在带星号的“可变参数”后面增加新的参数，必须在调用的时候“强制命名参数”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(*a,b,c)</span>:</span> </span><br><span class="line">	print(a,b,c)</span><br><span class="line"><span class="comment">#f1(2,3,4) #会报错。由于 a 是可变参数，将 2,3,4 全部收集。造成 b 和 c 没有赋值。 </span></span><br><span class="line">f1(<span class="number">2</span>,b=<span class="number">3</span>,c=<span class="number">4</span>)</span><br><span class="line">执行结果: (<span class="number">2</span>,) <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="lambda-表达式和匿名函数"><a href="#lambda-表达式和匿名函数" class="headerlink" title="lambda 表达式和匿名函数"></a><strong>lambda 表达式和匿名函数</strong></h2><p>lambda 表达式可以用来声明匿名函数。lambda 函数是一种简单的、在同一行中定义函数 的方法。lambda 函数实际生成了一个函数对象。<br> lambda 表达式只允许包含一个表达式，不能包含复杂语句，该表达式的计算结果就是函数 的返回值。</p>
<p>lambda 表达式的基本语法如下:<br> lambda arg1,arg2,arg3… : &lt;表达式&gt;</p>
<p>arg1/arg2/arg3 为函数的参数。&lt;表达式&gt;相当于函数体。运算结果是:表达式的运算结果。</p>
<p>g = [lambda a:a<em>2,lambda b:b</em>3,lambda c:c*4]</p>
<h3 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a><strong>eval()函数</strong></h3><p>功能:将字符串 str 当成有效的表达式来求值并返回计算结果。</p>
<p>语法: eval(source[, globals[, locals]]) -&gt; value</p>
<p>参数:<br> source:一个 Python 表达式或函数 compile()返回的代码对象 globals:可选。必须是 dictionary locals:可选。任意映射对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict1 = dict(a=<span class="number">100</span>,b=<span class="number">200</span>)</span><br><span class="line">d = eval(<span class="string">"a+b"</span>,dict1) </span><br><span class="line">print(d)<span class="comment">#eval 函数会将字符串当做语句来执行，因此会被注入安全隐患。比如:字符串中含有删除文 件的语句。那就麻烦大了。因此，使用时候，要慎重!!!</span></span><br></pre></td></tr></table></figure>

<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a><strong>递归函数</strong></h2><p>递归函数指的是:自己调用自己的函数，在函数体内部直接或间接的自己调用自己。递归类 似于大家中学数学学习过的“数学归纳法”。 每个递归函数必须包含两个部分:<br> \1. 终止条件</p>
<p>表示递归什么时候结束。一般用于返回值，不再调用自己。 2. 递归步骤</p>
<p>把第 n 步的值和第 n-1 步相关联。</p>
<p>递归函数由于会创建大量的函数对象、过量的消耗内存和运算能力。在处理大量数据时，谨 慎使用。</p>
<p><strong>嵌套函数(内部函数)</strong></p>
<p>嵌套函数: 在函数内部定义的函数!</p>
<p>一般在什么情况下使用嵌套函数? </p>
<ol>
<li>封装 - 数据隐藏外部无法访问“嵌套函数”。</li>
<li>贯彻 DRY(Don’t Repeat Yourself) 原则嵌套函数，可以让我们在函数内部避免重复代码。</li>
<li>闭包</li>
</ol>
<h3 id="nonlocal-关键字"><a href="#nonlocal-关键字" class="headerlink" title="nonlocal 关键字"></a><strong>nonlocal 关键字</strong></h3><p>nonlocal 用来声明外层的局部变量。 global 用来声明全局变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">  b=<span class="number">10</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">  	<span class="keyword">nonlocal</span> b<span class="comment">#声明外部函数的局部变量</span></span><br><span class="line">  	print(<span class="string">"inner b:"</span>,b)</span><br><span class="line"> 		b=<span class="number">20</span></span><br><span class="line">  	<span class="keyword">global</span> a<span class="comment">#声明全局变量</span></span><br><span class="line">  	a=<span class="number">1000</span></span><br><span class="line">	inner()</span><br><span class="line">	print(<span class="string">"outer b:"</span>,b)</span><br><span class="line">outer()</span><br><span class="line">print(<span class="string">"a:"</span>,a)</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">inner b: <span class="number">10</span></span><br><span class="line">outer b: <span class="number">20</span></span><br><span class="line">a: <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<h2 id="LEGB-规则"><a href="#LEGB-规则" class="headerlink" title="LEGB 规则"></a><strong>LEGB 规则</strong></h2><h3 id="Python-在查找“名称”时，是按照-LEGB-规则查找的-Local–-gt-Enclosed–-gt-Global–-gt-Built-in"><a href="#Python-在查找“名称”时，是按照-LEGB-规则查找的-Local–-gt-Enclosed–-gt-Global–-gt-Built-in" class="headerlink" title="Python 在查找“名称”时，是按照 LEGB 规则查找的: Local–&gt;Enclosed–&gt;Global–&gt;Built in"></a>Python 在查找“名称”时，是按照 LEGB 规则查找的: Local–&gt;Enclosed–&gt;Global–&gt;Built in</h3><p>Local 指的就是函数或者类的方法内部<br> Enclosed 指的是嵌套函数(一个函数包裹另一个函数，闭包) Global 指的是模块中的全局变量<br> Built in 指的是 Python 为自己保留的特殊名称。</p>
<p>如果某个 name 映射在局部(local)命名空间中没有找到，接下来就会在闭包作用域 (enclosed)进行搜索，如果闭包作用域也没有找到，Python 就会到全局(global)命名空 间中进行查找，最后会在内建(built-in)命名空间搜索 (如果一个名称在所有命名空间 中都没有找到，就会产生一个 NameError)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/python400%E9%9B%861/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/python400%E9%9B%861/" class="post-title-link" itemprop="url">python400集1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-29 15:09:21 / Modified: 16:25:10" itemprop="dateCreated datePublished" datetime="2020-04-29T15:09:21-05:00">2020-04-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="python基础入门"><a href="#python基础入门" class="headerlink" title="python基础入门"></a>python基础入门</h1><h2 id="python入门"><a href="#python入门" class="headerlink" title="python入门"></a>python入门</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h3><ol>
<li><p>(1)  行注释</p>
<p>每行注释前加#号。当解释器看到#，则忽略这一行#后面的内容</p>
</li>
<li><p>(2)  段注释</p>
<p>使用三个连续单引号(‘’’)。当解释看到’’’，则会扫描到下一个’’’，然后忽略他们</p>
</li>
</ol>
<p>之间的内容。</p>
<h3 id="2-行连接符"><a href="#2-行连接符" class="headerlink" title="2.行连接符"></a>2.行连接符</h3><p><strong>使用\行连接符</strong></p>
<p>一行程序长度是没有限制的，但是为了可读性更强，通常将一行比较长的程序分为多行。这 是，我们可以使用\行连接符，把它放在行结束的地方。Python 解释器仍然将它们解释为同 一行。</p>
<p>&gt;&gt;&gt;  a = [10,20,30,40,\ 50,60,70,\</p>
<p>​        80,90,100]</p>
<h3 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h3><p><strong>Python 中，一切皆对象。</strong>每个对象由:标识(identity)、类型(type)、value(值)</p>
<p>组成。</p>
<ol>
<li><p>标识用于唯一标识对象，通常对应于对象在计算机内存中的地址。使用内置函数 id(obj) 可返回对象 obj 的标识。</p>
</li>
<li><p>类型用于表示对象存储的“数据”的类型。类型可以限制对象的取值范围以及可执行的 操作。可以使用 type(obj)获得对象的所属类型。</p>
</li>
<li><p>值表示对象所存储的数据的信息。使用 print(obj)可以直接打印出值。</p>
</li>
</ol>
<p><strong>对象的本质就是:一个内存块，拥有特定的值，支持特定类型的相关操作。</strong></p>
<p>源码:</p>
<p>&gt;&gt;&gt; a = 3<br> &gt;&gt;&gt; a<br> 3<br> &gt;&gt;&gt; id(3) 1531372336<br> &gt;&gt;&gt; type(3) &lt;class ‘int’&gt;<br> &gt;&gt;&gt; b = “我爱你” &gt;&gt;&gt; id(a) 1531372336</p>
<p>&gt;&gt;&gt; type(a) &lt;class ‘int’&gt; &gt;&gt;&gt; print(a) 3</p>
<p>&gt;&gt;&gt; id(b) 46806816 &gt;&gt;&gt; type(b) &lt;class ‘str’&gt;</p>
<p><strong>引用</strong></p>
<p>在 Python 中，变量也称为:对象的引用。因为，变量存储的就是对象的地址。 变量通过地址引用了“对象”。</p>
<p>变量位于:栈内存(压栈出栈等细节，后续再介绍)。 对象位于:堆内存。</p>
<p><strong>·Python 是动态类型语言</strong></p>
<p>变量不需要显式声明类型。根据变量引用的对象，Python 解释器自动确定数据类型。</p>
<p><strong>·Python 是强类型语言</strong></p>
<p>每个对象都有数据类型，只支持该类型支持的操作。</p>
<h3 id="4-python标识符规则"><a href="#4-python标识符规则" class="headerlink" title="4.python标识符规则"></a>4.python标识符规则</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>模块和包名</td>
<td>全小写字母，尽量简单。若多个单词之间用 下划线</td>
<td>math, os, sys</td>
</tr>
<tr>
<td>函数名</td>
<td>全小写字母，多个单词之间用下划线隔开</td>
<td>phone, my_name</td>
</tr>
<tr>
<td>类名</td>
<td>首字母大写，采用驼峰原则。多个单词时， 每个单词第一个字母大写，其余部分小写</td>
<td>MyPhone 、 MyClass 、 Phone</td>
</tr>
<tr>
<td>常量名</td>
<td>全大写字母，多个单词使用下划线隔开</td>
<td>SPEED、MAX_SPEED</td>
</tr>
</tbody></table>
<h3 id="5-变量声明赋值"><a href="#5-变量声明赋值" class="headerlink" title="5.变量声明赋值"></a>5.变量声明赋值</h3><p>变量的声明和赋值用于将一个变量绑定到一个对象上，格式如下: 变量名 = 表达式</p>
<p>最简单的表达式就是字面量。比如:a = 123 。 运行过程中，解释器先运行右边的表达式， 生成一个代表表达式运算结果的对象;然后，将这个对象地址赋值给左边的变量。</p>
<p><strong>变量在使用前必须先被初始化(先被赋值)</strong>，否则出现NameError</p>
<p>可以通过 del 语句删除不在使用的变量。</p>
<p>如果对象没有变量引用，就会被垃圾回收器回收，清空内存空间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;pyshell#20&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; x</span><br><span class="line">NameError: name <span class="string">'x'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>

<p><strong>链式赋值</strong></p>
<p>链式赋值用于同一个对象赋值给多个变量。 x=y=123 相当于:x=123; y=123</p>
<p><strong>系列解包赋值</strong></p>
<p>系列数据赋值给对应相同个数的变量(个数必须保持一致) &gt;&gt;&gt; a,b,c=4,5,6 相当于:a=4;b=5;c=6</p>
<p>使用系列解包赋值实现变量交换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a,b&#x3D;1,2 </span><br><span class="line">&gt;&gt;&gt; a,b&#x3D;b,a </span><br><span class="line">&gt;&gt;&gt; print(a,b) </span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<p>Python 不支持常量，即没有语法规则限制改变一个常量的值。我们只能约定常量的命名规 则，以及在程序的逻辑上不对常量的值作出修改。（bug，其实可以改，所以说还是java好啊）</p>
<h3 id="6-数据类型"><a href="#6-数据类型" class="headerlink" title="6.数据类型"></a>6.数据类型</h3><p><strong>使用 int()实现类型转换:</strong>：其他类型转int</p>
<p>python有自动转型，小转大，int+float自动转float</p>
<p>最大整数是googol，也就是Google最初的名字，googol = 10**100</p>
<p>类似于 int()，我们也可以使用 float()将其他类型转化成浮点数。</p>
<p>round(value)可以返回四舍五入的值 注:但不会改变原有值，而是产生新的值</p>
<p>运算符+、-、<em>，/、//、*</em>和%和赋值符=结合可以构成“增强型赋值运算符”。</p>
<p>注意:“+=”中间不能加空格!</p>
<p>python 中可以通过 time.time() 获得当前时刻，返回的值是以秒为单位，带微秒 (1/1000 毫秒)精度的浮点值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import time</span><br><span class="line">&gt;&gt;&gt; b &#x3D; int(time.time())</span><br><span class="line">&gt;&gt;&gt; totalMinutes &#x3D; b&#x2F;60</span><br><span class="line">&gt;&gt;&gt; totalMinutes &#x3D; b&#x2F;&#x2F;60</span><br><span class="line">&gt;&gt;&gt; totalHours &#x3D; totalMinutes&#x2F;&#x2F;60</span><br><span class="line">&gt;&gt;&gt; totalDays &#x3D; totalHours&#x2F;&#x2F;24</span><br><span class="line">&gt;&gt;&gt; totalYears &#x3D; totalDays&#x2F;&#x2F;365</span><br></pre></td></tr></table></figure>

<p>Python2 中没有布尔值，直接用数字 0 表示 False,用数字 1 表示 True。（类似c）<br> Python3 中，把 True 和 False 定义成了关键字，但他们的本质还是 1 和 0，甚至可以和数 字相加。</p>
<p>同一运算符用于比较两个对象的存储单元，实际比较的是对象的地址。</p>
<p>is;is 是判断两个标识符是不是引用同一个对象</p>
<p>is not：is not 是判断两个标识符是不是引用不同对象</p>
<p>is 与 == 区别:<br> is 用于判断两个变量引用对象是否为同一个，既比较对象的地址。</p>
<p>== 用于判断引用变量引用对象的值是否相等，默认调用对象的 <strong>eq</strong>()方法。</p>
<h4 id="Python-仅仅对比较小的整数对象进行缓存-范围为-5-256-缓存起来，而并非是所有整数对-象。需要注意的是，这仅仅是在命令行中执行，而在-Pycharm-或者保存为文件执行，结果是不一样-的，这是因为解释器做了一部分优化-范围是-5-任意正整数-。"><a href="#Python-仅仅对比较小的整数对象进行缓存-范围为-5-256-缓存起来，而并非是所有整数对-象。需要注意的是，这仅仅是在命令行中执行，而在-Pycharm-或者保存为文件执行，结果是不一样-的，这是因为解释器做了一部分优化-范围是-5-任意正整数-。" class="headerlink" title="Python 仅仅对比较小的整数对象进行缓存(范围为[-5, 256])缓存起来，而并非是所有整数对 象。需要注意的是，这仅仅是在命令行中执行，而在 Pycharm 或者保存为文件执行，结果是不一样 的，这是因为解释器做了一部分优化(范围是[-5,任意正整数])。"></a>Python 仅仅对比较小的整数对象进行缓存(范围为[-5, 256])缓存起来，而并非是所有整数对 象。需要注意的是，这仅仅是在命令行中执行，而在 Pycharm 或者保存为文件执行，结果是不一样 的，这是因为解释器做了一部分优化(范围是[-5,任意正整数])。</h4><table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
<tr>
<td><strong>·总结</strong></td>
</tr>
<tr>
<td>1、is 比较两个对象的 id 值是否相等，是否指向同一个内存地址;</td>
</tr>
<tr>
<td>2、== 比较的是两个对象的内容是否相等，值是否相等;</td>
</tr>
<tr>
<td>3、小整数对象[-5,256]在全局解释器范围内被放入缓存供重复使用;</td>
</tr>
<tr>
<td>4、is 运算符比 == 效率高，在变量和 None 进行比较时，应该使用 is。</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; 1000</span><br><span class="line">&gt;&gt;&gt; b &#x3D; 1000</span><br><span class="line">&gt;&gt;&gt; a &#x3D;&#x3D; b </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a is b </span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; id(a) 46764560 </span><br><span class="line">&gt;&gt;&gt; id(b) 46765216 </span><br><span class="line">&gt;&gt;&gt; c &#x3D; 10 </span><br><span class="line">&gt;&gt;&gt; d &#x3D; 10 </span><br><span class="line">&gt;&gt;&gt; c is d </span><br><span class="line">True#和整数缓存有关，类似java</span><br><span class="line">&gt;&gt;&gt; id(c) 1388831648 </span><br><span class="line">&gt;&gt;&gt; id(d) 1388831648</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="与-C-和-JAVA-不一样，Python-不支持自增-和自减-–"><a href="#与-C-和-JAVA-不一样，Python-不支持自增-和自减-–" class="headerlink" title="与 C 和 JAVA 不一样，Python 不支持自增(++)和自减(–)"></a>与 C 和 JAVA 不一样，Python 不支持自增(++)和自减(–)</h4><h3 id="7。字符串"><a href="#7。字符串" class="headerlink" title="7。字符串"></a>7。字符串</h3><p>字符串的本质是:字符序列。Python 的字符串是不可变的，我们无法对原字符串做任 何修改。但，可以将字符串的一部分复制到新创建的字符串，达到“看起来修改”的效果。</p>
<p>Python 不支持单字符类型，单字符也是作为一个字符串使用的。</p>
<p>Python3 直接支持 Unicode，可以表示世界上任何书面语言的字符。Python3 的字符 默认就是 16 位 Unicode 编码，ASCII 码是 Unicode 编码的子集。</p>
<p>使用内置函数 ord()可以把字符转换成对应的 Unicode 码; 使用内置函数 chr()可以把十进制数字转换成对应的字符。</p>
<p>连续三个单引号或三个双引号，可以帮助我们创建多行字符串。例如: </p>
<p>resume = ‘’’ name=”gaoqi”<br> company=”sxt” age=18<br> lover=”Tom”‘’’</p>
<p>&gt;&gt;&gt; print(resume) </p>
<p>name=”gaoqi”</p>
<p>company=”sxt” age=18 lover=”Tom”</p>
<p>转义字符： 我们可以使用“\+特殊字符”，实现某些难以用字符表示的效果</p>
<p>我们前面调用 print 时，会自动打印一个换行符。有时，我们不想换行，不想自动添加换行 符。我们可以自己通过参数 end = “任意字符串”。实现末尾添加任何内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;sxt&quot;,end&#x3D;&#39; &#39;) </span><br><span class="line">print(&quot;sxt&quot;,end&#x3D;&#39;##&#39;) </span><br><span class="line">print(&quot;sxt&quot;)</span><br><span class="line">运行结果:</span><br><span class="line">sxt sxt##sxt</span><br></pre></td></tr></table></figure>

<p>我们可以使用 input()从控制台读取键盘输入的内容。</p>
<p>当我们调用 print()函数时，解释器自动调用了 str()将非字符串的对象转成了字符串。</p>
<p>字符串的本质就是字符序列，我们可以通过在字符串后面添加[]，在[]里面指定偏移量， 可以提取该位置的单个字符。</p>
<p>正向搜索:<br> 最左侧第一个字符，偏移量是 0，第二个偏移量是 1，以此类推。直到 len(str)-1</p>
<p>为止。 反向搜索:</p>
<p>最右侧第一个字符，偏移量是-1，倒数第二个偏移量是-2，以此类推，直到-len(str) 为止。</p>
<p>字符串不可改变。但是，我们确实有时候需要替换某些字符。这时，只能通过创建新的字符 串来实现。</p>
<p>使用replace</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;&quot;alfjoashoa&quot;</span><br><span class="line">a&#x3D;a.replace(&quot;a&quot;,&quot;替换字&quot;)</span><br></pre></td></tr></table></figure>

<p>切片 slice 操作可以让我们快速的提取子字符串。标准格式为: [起始偏移量 start:终止偏移量 end:步长 step]</p>
<p>典型操作(三个量为正数的情况)如下:</p>
<table>
<thead>
<tr>
<th>操作和说明</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>[:] 提取整个字符串</td>
<td>“abcdef”[:]</td>
<td>“abcdef”</td>
</tr>
<tr>
<td>[start:]从 start 索引开始到结尾</td>
<td>“abcdef”[2:]</td>
<td>“cdef”</td>
</tr>
<tr>
<td>[:end]从头开始知道 end-1</td>
<td>“abcdef”[:2]</td>
<td>“ab”</td>
</tr>
<tr>
<td>[start:end]从 start 到 end-1</td>
<td>“abcdef”[2:4]</td>
<td>“cd”</td>
</tr>
<tr>
<td>[start​：end:step]从 start 提取到 end-1，步长是 step</td>
<td>“abcdef”[1:5:2]</td>
<td>“bd”</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其他操作(三个量为负数)的情况:</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>“abcdefghijklmnopqrstuv wxyz”[-3:]</td>
<td>倒数三个</td>
<td>“xyz”</td>
</tr>
<tr>
<td>“abcdefghijklmnopqrstuv wxyz”[-8:-3]</td>
<td>倒数第八个到倒数第 三个(包头不包尾)</td>
<td>‘stuvw’</td>
</tr>
<tr>
<td>“abcdefghijklmnopqrstuv wxyz”[::-1]</td>
<td>步长为负，从右到左 反向提取</td>
<td>‘zyxwvutsrqpon mlkjihgfedcba’</td>
</tr>
</tbody></table>
<p><strong>split()分割和 join()合并</strong></p>
<p>split()可以基于指定分隔符将字符串分隔成多个子字符串(存储到列表中)。如果不指定分隔 符，则默认使用空白字符(换行符/空格/制表符)。示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;to be or not to be&quot; </span><br><span class="line">&gt;&gt;&gt; a.split()</span><br><span class="line">[&#39;to&#39;, &#39;be&#39;, &#39;or&#39;, &#39;not&#39;, &#39;to&#39;, &#39;be&#39;] </span><br><span class="line">&gt;&gt;&gt; a.split(&#39;be&#39;)</span><br><span class="line">[&#39;to &#39;, &#39; or not to &#39;, &#39;&#39;]</span><br></pre></td></tr></table></figure>

<p>join()的作用和 split()作用刚好相反，用于将一系列子字符串连接起来。示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [&#39;sxt&#39;,&#39;sxt100&#39;,&#39;sxt200&#39;]</span><br><span class="line">&gt;&gt;&gt; &#39;*&#39;.join(a)</span><br><span class="line">&#39;sxt*sxt100*sxt200&#39;</span><br></pre></td></tr></table></figure>

<p><strong>拼接字符串要点:</strong></p>
<p>使用字符串拼接符+，会生成新的字符串对象，因此不推荐使用+来拼接字符串。推荐 使用 join 函数，因为 join 函数在拼接字符串之前会计算所有字符串的长度，然后逐一拷贝， 仅新建一次对象。</p>
<p><strong>字符串驻留:</strong>仅保存一份相同且不可变字符串的方法，不同的值被存放在字符串驻留池中。 Python 支持字符串驻留机制，对于符合标识符规则的字符串(仅包含下划线(_)、字母 和数字)会启用字符串驻留机制驻留机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;abd_33&quot;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; &quot;abd_33&quot;</span><br><span class="line">&gt;&gt;&gt; a is b </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; c &#x3D; &quot;dd#&quot;</span><br><span class="line">&gt;&gt;&gt; d &#x3D; &quot;dd#&quot;</span><br><span class="line">&gt;&gt;&gt; c is d </span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; str1 &#x3D; &quot;aa&quot;</span><br><span class="line">&gt;&gt;&gt; str2 &#x3D; &quot;bb&quot;</span><br><span class="line">&gt;&gt;&gt; str1+str2 is &quot;aabb&quot;</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; str1+str2 &#x3D;&#x3D; &quot;aabb&quot; </span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p><strong>字符串比较和同一性</strong></p>
<p>我们可以直接使用==,!=对字符串进行比较，是否含有相同的字符。<br> 我们使用 is / not is，判断两个对象是否同一个对象。比较的是对象的地址，即 id(obj1)是 否和 id(obj2)相等。</p>
<h3 id="字符串常用方法汇总"><a href="#字符串常用方法汇总" class="headerlink" title="字符串常用方法汇总"></a><strong>字符串常用方法汇总</strong></h3><p><strong>常用查找方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;&quot;akhfahglwaejiorhsdlhgkld&quot;</span><br><span class="line">len(a)#返回长度</span><br><span class="line">a.startswith(&#39;a&#39;)#以指定字符串开头</span><br><span class="line">a.endswith(&#39;d&#39;)#以指定字符串结尾</span><br><span class="line">a.find(&#39;k&#39;)#第一次出现指定字符串的位置</span><br><span class="line">a.rfind(&#39;d&#39;)#最后一次出现指定字符串的位置</span><br><span class="line">a.count(&#39;ad&#39;)#指定字符串出现几次</span><br><span class="line">a.isalnum()#所有字符全是字母数字</span><br></pre></td></tr></table></figure>

<p><strong>去除首尾信息</strong></p>
<p>我们可以通过 strip()去除字符串首尾指定信息。通过 lstrip()去除字符串左边指定信息， rstrip()去除字符串右边指定信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;*s*x*t*&quot;.strip(&quot;*&quot;) </span><br><span class="line">&#39;s*x*t&#39;</span><br><span class="line">&gt;&gt;&gt; &quot;*s*x*t*&quot;.lstrip(&quot;*&quot;) </span><br><span class="line">&#39;s*x*t*&#39;</span><br><span class="line">&gt;&gt;&gt; &quot;*s*x*t*&quot;.rstrip(&quot;*&quot;) </span><br><span class="line">&#39;*s*x*t&#39;</span><br><span class="line">&gt;&gt;&gt; &quot; sxt &quot;.strip() </span><br><span class="line">&#39;sxt&#39;</span><br></pre></td></tr></table></figure>

<p><strong>大小写转换</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>a.capitalize()</td>
<td>产生新的字符串,首字母 大写</td>
<td></td>
</tr>
<tr>
<td>a.title()</td>
<td>产生新的字符串,每个单 词都首字母大写</td>
<td></td>
</tr>
<tr>
<td>a.upper()</td>
<td>产生新的字符串,所有字 符全转成大写</td>
<td></td>
</tr>
<tr>
<td>a.lower()</td>
<td>产生新的字符串,所有字 符全转成小写</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>a.swapcase()</th>
<th>产生新的,所有字母大小 写转换</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>格式排版</strong></p>
<p>center()、ljust()、rjust()这三个函数用于对字符串实现排版。示例如下: &gt;&gt;&gt; a=”SXT”<br> &gt;&gt;&gt; a.center(10,”*”)<br> ‘<strong><em>SXT*</em></strong>‘</p>
<p>&gt;&gt;&gt; a.center(10)<br> ‘ SXT ‘<br> &gt;&gt;&gt; a.ljust(10,”*”) ‘SXT<strong>***</strong>‘</p>
<p><strong>其他方法</strong></p>
<p>\1. isalnum() 是否为字母或数字<br> \2. isalpha() 检测字符串是否只由字母组成(含汉字)。 3. isdigit() 检测字符串是否只由数字组成。<br> \4. isspace() 检测是否为空白符<br> \5. isupper() 是否为大写字母<br> \6. islower() 是否为小写字母</p>
<p><strong>字符串的格式化</strong> </p>
<p><strong>format()基本用法</strong></p>
<p>Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的 功能。<br> 基本语法是通过 {} 和 : 来代替以前的 % 。</p>
<p>format 函数可以接受不限个参数，位置可以不按顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;名字是:&#123;0&#125;,年龄是:&#123;1&#125;&quot; </span><br><span class="line">&gt;&gt;&gt; a.format(&quot;高淇&quot;,18) </span><br><span class="line">&#39;名字是:高淇,年龄是:18&#39;</span><br><span class="line">&gt;&gt;&gt; a.format(&quot;高希希&quot;,6) </span><br><span class="line">&#39;名字是:高希希,年龄是:6&#39;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; &quot;名字是:&#123;0&#125;，年龄是&#123;1&#125;。&#123;0&#125;是个好小伙&quot; </span><br><span class="line">&gt;&gt;&gt; b.format(&quot;高淇&quot;,18)</span><br><span class="line">&#39;名字是:高淇，年龄是 18。高淇是个好小伙&#39;</span><br><span class="line">&gt;&gt;&gt; c &#x3D; &quot;名字是&#123;name&#125;，年龄是&#123;age&#125;&quot;</span><br><span class="line">&gt;&gt;&gt; c.format(age&#x3D;19,name&#x3D;&#39;高淇&#39;) </span><br><span class="line">&#39;名字是高淇，年龄是 19&#39;#我们可以通过&#123;索引&#125;&#x2F;&#123;参数名&#125;，直接映射参数值，实现对字符串的格式化，非常方便。</span><br></pre></td></tr></table></figure>

<p><strong>填充与对齐</strong></p>
<p>填充常跟对齐一起使用 ^、&lt;、&gt;分别是居中、左对齐、右对齐，后面带宽度</p>
<p>:号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;:*&gt;8&#125;&quot;.format(&quot;245&quot;)</span><br><span class="line">&#39;*****245&#39;</span><br></pre></td></tr></table></figure>



<p>浮点数通过 f，整数通过 d 进行需要的格式化。案例如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;我是&#123;0&#125;，我的存款有&#123;1:.2f&#125;&quot;</span><br><span class="line"></span><br><span class="line"> &gt;&gt;&gt; a.format(&quot;高淇&quot;,3888.234342) </span><br><span class="line"> &#39;我是高淇，我的存款有 3888.23&#39;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>数字</th>
<th>格式</th>
<th>输出</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>3.1415926</td>
<td>{:.2f}</td>
<td>3.14</td>
<td>保留小数点后两位</td>
</tr>
<tr>
<td>3.1415926</td>
<td>{:+.2f}</td>
<td>3.14</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>2.71828</td>
<td>{:.0f}</td>
<td>3</td>
<td>不带小数</td>
</tr>
<tr>
<td>5</td>
<td>{:0&gt;2d}</td>
<td>05</td>
<td>数字补零 (填充左边, 宽度为 2)</td>
</tr>
<tr>
<td>5</td>
<td>{:x&lt;4d}</td>
<td>5xxx</td>
<td>数字补 x (填充右边, 宽度为 4)</td>
</tr>
<tr>
<td>10</td>
<td>{:x&lt;4d}</td>
<td>10xx</td>
<td>数字补 x (填充右边, 宽度为 4)</td>
</tr>
<tr>
<td>1000000</td>
<td>{:,}</td>
<td>1,000,000</td>
<td>以逗号分隔的数字格式</td>
</tr>
<tr>
<td>0.25</td>
<td>{:.2%}</td>
<td>25.00%</td>
<td>百分比格式</td>
</tr>
<tr>
<td>1000000000</td>
<td>{:.2e}</td>
<td>1.00E+09</td>
<td>指数记法</td>
</tr>
<tr>
<td>13</td>
<td>{:10d}</td>
<td>13</td>
<td>右对齐 (默认, 宽度为 10)</td>
</tr>
<tr>
<td>13</td>
<td>{:&lt;10d}</td>
<td>13</td>
<td>左对齐 (宽度为 10)</td>
</tr>
<tr>
<td>13</td>
<td>{:^10d}</td>
<td>13</td>
<td>中间对齐 (宽度为 10)</td>
</tr>
</tbody></table>
<p><strong>可变字符串</strong></p>
<p>在 Python 中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，智 能创建新的字符串对象。但是，经常我们确实需要原地修改字符串，可以使用 io.StringIO 对象或 array 模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import io</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &quot;hello, sxt&quot;</span><br><span class="line">&gt;&gt;&gt; sio &#x3D; io.StringIO(s)</span><br><span class="line">&gt;&gt;&gt; sio</span><br><span class="line">&lt;_io.StringIO object at 0x02F462B0&gt; &gt;&gt;&gt; sio.getvalue()</span><br><span class="line">&#39;hello, sxt&#39;</span><br><span class="line">&gt;&gt;&gt; sio.seek(7)</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; sio.write(&quot;g&quot;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; sio.getvalue()</span><br><span class="line">&#39;hello, gxt&#39;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/ssh%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/ssh%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">ssh，scp详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 10:36:17" itemprop="dateCreated datePublished" datetime="2020-04-29T10:36:17-05:00">2020-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-07 21:22:27" itemprop="dateModified" datetime="2020-05-07T21:22:27-05:00">2020-05-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用"><a href="#教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用" class="headerlink" title="教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用"></a>教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用</h1><p>如何获取本地ip</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifconfig | grep inet</span><br><span class="line">#如果没有ifconfig命令</span><br><span class="line">linux中</span><br><span class="line">sudo apt install net-tools</span><br></pre></td></tr></table></figure>



<h2 id="教你玩转ssh"><a href="#教你玩转ssh" class="headerlink" title="教你玩转ssh"></a>教你玩转ssh</h2><p>ssh， secure shell，远程登录服务器，机器的一种命令。</p>
<p>此教程仅适合mac，unix，linux系统，windows系统请使用PuTTy 等软件进行操作。</p>
<h3 id="1-先在本机生成rsa密钥对"><a href="#1-先在本机生成rsa密钥对" class="headerlink" title="1.先在本机生成rsa密钥对"></a>1.先在本机生成rsa密钥对</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<h3 id="2-然后一路enter，不要设置密码"><a href="#2-然后一路enter，不要设置密码" class="headerlink" title="2.然后一路enter，不要设置密码"></a>2.然后一路enter，不要设置密码</h3><p>本机 .ssh 隐藏目录中会多几个文件，</p>
<p>authorized-keys    config        id_rsa        id_rsa.pub    known_hosts</p>
<p>其中id_rsa.pub是你的公钥，id_rsa是私钥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi config</span><br><span class="line">#点i进入insert模式,按照各人信息填入，school是你想要的快捷名，以后无需输入ip和用户名了，ip是远程服务器ip</span><br><span class="line">Host school</span><br><span class="line">	HostName ip address</span><br><span class="line">	User username</span><br><span class="line">	Port portnumber</span><br></pre></td></tr></table></figure>

<h3 id="3-然后开始免密操作，很简单，mac需要homebrew"><a href="#3-然后开始免密操作，很简单，mac需要homebrew" class="headerlink" title="3.然后开始免密操作，很简单，mac需要homebrew"></a>3.然后开始免密操作，很简单，mac需要homebrew</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ssh-copy-id</span><br></pre></td></tr></table></figure>

<p>然后，主要此处school是你的快捷名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id school</span><br></pre></td></tr></table></figure>

<p>这是最简单的操作，或者手动把你的公钥复制到远程服务器~/.ssh/authorized_keys中。</p>
<h2 id="教你玩会scp"><a href="#教你玩会scp" class="headerlink" title="教你玩会scp"></a>教你玩会scp</h2><p>ssh就这么简单，既然如此简单，我们顺便提一下scp。</p>
<p>scp就是安全传输文件的命令，</p>
<p>scp没有那么多小技巧，唯一就是要注意路径怎么写，要用绝对路径，最好不要相对路径。</p>
<p>还有就是目录需要加-r</p>
<p>. 表示当前目录</p>
<p>~表示家目录</p>
<p>/表示根目录</p>
<p>了解以上3个即可帮你灵活使用scp了，记住，unix类的操作系统都是树形管理文件的，而不是windows分区形（其实我也不了解）</p>
<p>下面我们开始了解scp命令</p>
<h3 id="1、从本地复制到远程"><a href="#1、从本地复制到远程" class="headerlink" title="1、从本地复制到远程"></a>1、从本地复制到远程</h3><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_username@remote_ip:remote_file </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_ip:remote_file</span><br></pre></td></tr></table></figure>



<ul>
<li>第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名； </li>
<li>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；</li>
</ul>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3 </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3</span><br></pre></td></tr></table></figure>

<p>复制目录命令格式： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp -r local_folder remote_ip:remote_folder</span><br></pre></td></tr></table></figure>

<ul>
<li>第1个指定了用户名，命令执行后需要再输入密码；</li>
<li>第2个没有指定用户名，命令执行后需要输入用户名和密码；</li>
</ul>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; </span><br><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;</span><br></pre></td></tr></table></figure>

<p>上面命令将本地 music 目录复制到远程 others 目录下。</p>
<h3 id="2、从远程复制到本地"><a href="#2、从远程复制到本地" class="headerlink" title="2、从远程复制到本地"></a>2、从远程复制到本地</h3><p>从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例 </p>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 </span><br><span class="line">scp -r www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; &#x2F;home&#x2F;space&#x2F;music&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>1.如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#scp 命令使用端口号 4588</span><br><span class="line">scp -P 4588 remote@www.runoob.com:&#x2F;usr&#x2F;local&#x2F;sin.sh &#x2F;home&#x2F;administrator</span><br></pre></td></tr></table></figure>

<p>2.使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/27/crawlerblog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/27/crawlerblog/" class="post-title-link" itemprop="url">crawlerblog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-27 16:24:44 / Modified: 16:42:23" itemprop="dateCreated datePublished" datetime="2020-04-27T16:24:44-05:00">2020-04-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：[<a href="https://www.zhihu.com/search?type=content&amp;q=%20%E7%88%AC%E8%99%AB%E6%80%8E%E4%B9%88%E5%AD%A6]" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=%20%E7%88%AC%E8%99%AB%E6%80%8E%E4%B9%88%E5%AD%A6]</a>(<a href="https://www.zhihu.com/search?type=content&amp;q=" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=</a> 爬虫怎么学)</p>
<p>博客：<a href="https://cuiqingcai.com/947.html" target="_blank" rel="noopener">https://cuiqingcai.com/947.html</a></p>
<h1 id="python爬虫入门"><a href="#python爬虫入门" class="headerlink" title="python爬虫入门"></a>python爬虫入门</h1><h2 id="1-爬虫基础了解"><a href="#1-爬虫基础了解" class="headerlink" title="1.爬虫基础了解"></a>1.爬虫基础了解</h2><h3 id="1-什么是爬虫"><a href="#1-什么是爬虫" class="headerlink" title="1.什么是爬虫"></a>1.什么是爬虫</h3><p>爬虫，即网络爬虫，大家可以理解为在网络上爬行的一直蜘蛛，互联网就比作一张大网，而爬虫便是在这张网上爬来爬去的蜘蛛咯，如果它遇到资源，那么它就会抓取下来。想抓取什么？这个由你来控制它咯。</p>
<p>比如它在抓取一个网页，在这个网中他发现了一条道路，其实就是指向网页的超链接，那么它就可以爬到另一张网上来获取数据。这样，整个连在一起的大网对这之蜘蛛来说触手可及，分分钟爬下来不是事儿。</p>
<h3 id="2-浏览网页的过程"><a href="#2-浏览网页的过程" class="headerlink" title="2.浏览网页的过程"></a>2.浏览网页的过程</h3><p>在用户浏览网页的过程中，我们可能会看到许多好看的图片，比如 <a href="http://image.baidu.com/" target="_blank" rel="noopener">http://image.baidu.com/</a> ，我们会看到几张的图片以及百度搜索框，这个过程其实就是用户输入网址之后，经过DNS服务器，找到服务器主机，向服务器发出一个请求，服务器经过解析之后，发送给用户的浏览器 HTML、JS、CSS 等文件，浏览器解析出来，用户便可以看到形形色色的图片了。</p>
<p>因此，用户看到的网页实质是由 HTML 代码构成的，爬虫爬来的便是这些内容，通过分析和过滤这些 HTML 代码，实现对图片、文字等资源的获取。</p>
<h3 id="3-URL的含义"><a href="#3-URL的含义" class="headerlink" title="3.URL的含义"></a>3.URL的含义</h3><p>URL，即统一资源定位符，也就是我们说的网址，统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p>
<blockquote>
<p>URL的格式由三部分组成：<br>①第一部分是协议(或称为服务方式)。<br>②第二部分是存有该资源的主机IP地址(有时也包括端口号)。<br>③第三部分是主机资源的具体地址，如目录和文件名等。</p>
</blockquote>
<p>爬虫爬取数据时必须要有一个目标的URL才可以获取数据，因此，它是爬虫获取数据的基本依据，准确理解它的含义对爬虫学习有很大帮助。</p>
<h2 id="2-Urllib库基本使用"><a href="#2-Urllib库基本使用" class="headerlink" title="2. Urllib库基本使用"></a>2. Urllib库基本使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib2</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">response = urllib2.urlopen(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">print(response.read())</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> urlopen(url, data, timeout)</span><br><span class="line"></span><br><span class="line">第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。</span><br><span class="line"></span><br><span class="line">第二三个参数是可以不传送的，data默认为空<span class="literal">None</span>，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT</span><br><span class="line"></span><br><span class="line">第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> print response.read()</span><br><span class="line">response对象有一个read方法，可以返回获取到的网页内容。</span><br><span class="line">如果不加read直接打印会是什么？</span><br><span class="line">&lt;addinfourl at 139728495260376 whose fp &#x3D; &lt;socket._fileobject **object** at 0x7f1513fb3ad0&gt;&gt;</span><br><span class="line">直接打印出了该对象的描述，所以记得一定要加read方法</span><br></pre></td></tr></table></figure>

<h3 id="构造Request"><a href="#构造Request" class="headerlink" title="构造Request"></a>构造Request</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib2</span><br><span class="line"> </span><br><span class="line">request = urllib2.Request(<span class="string">"http://www.baidu.com"</span>)<span class="comment">#推荐这样书写，因为在构建请求时还需要加入好多内容，通过构建一个request，服务器响应请求得到应答，这样显得逻辑上清晰明确。</span></span><br><span class="line">response = urllib2.urlopen(request)</span><br><span class="line">print(response.read())</span><br></pre></td></tr></table></figure>

<h3 id="POST和GET数据传送"><a href="#POST和GET数据传送" class="headerlink" title="POST和GET数据传送"></a>POST和GET数据传送</h3><p>上面的程序演示了最基本的网页抓取，不过，现在大多数网站都是动态网页，需要你动态地传递参数给它，它做出对应的响应。所以，在访问时，我们需要传递数据给它。</p>
<p>GET方式是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。POST则不会在网址上显示所有的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jackson</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">87</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jackson</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
