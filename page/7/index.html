<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jackson Blog">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Jackson Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jackson">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jackson Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jackson Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/python400%E9%9B%864/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/python400%E9%9B%864/" class="post-title-link" itemprop="url">python400集4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 15:09:31" itemprop="dateCreated datePublished" datetime="2020-04-29T15:09:31-05:00">2020-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-03 20:08:15" itemprop="dateModified" datetime="2020-05-03T20:08:15-05:00">2020-05-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="异常和错误"><a href="#异常和错误" class="headerlink" title="异常和错误"></a>异常和错误</h1><p>软件程序在运行过程中，非常可能遇到刚刚提到的这些问题，我们称之为 异常，英文是:Exception，意思是例外。</p>
<h2 id="异常机制本质"><a href="#异常机制本质" class="headerlink" title="异常机制本质"></a>异常机制本质</h2><p>异常指程序运行过程中出现的非正常现象，例如用户输入错误、除数为零、需 要处理的文件不存在、数组下标越界等。</p>
<p>所谓异常处理，就是指程序在出现问题时依然可以正确的执行剩余的程序，而 不会因为异常而终止程序执行。</p>
<p>python 中，引进了很多用来描述和处理异常的类，称为异常类。异常类定义中 包含了该类异常的信息和对异常进行处理的方法。</p>
<p>python 中内建异常类的继承层次:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseException:所以异常的父类</span><br><span class="line">有4子类：KeyBoardInterrupt, Exception, SystemExit,GeneratorExit</span><br><span class="line">Exception内子类：NameError, ValueError, AttributeError等</span><br></pre></td></tr></table></figure>

<p><strong>python 中一切都是对象，异常也采用对象的方式来处理。处理过程:</strong> </p>
<ol>
<li><p><strong>抛出异常:</strong>在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给解释器。</p>
</li>
<li><p><strong>捕获异常:</strong>解释器得到该异常后，寻找相应的代码来处理该异常。</p>
</li>
</ol>
<p>异常解决的关键:定位</p>
<p>当发生异常时，解释器会报相关的错误信息，并会在控制台打印出相关错误信息。我们 只需按照从上到下的顺序即可追溯(Trackback)错误发生的过程，最终定位引起错误的那一 行代码。</p>
<h2 id="try…-一个except-结构"><a href="#try…-一个except-结构" class="headerlink" title="try… 一个except 结构"></a><strong>try…</strong> 一个<strong>except</strong> 结构</h2><p>try…except 是最常见的异常处理结构。结构如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">	被监控的可能引发异常的语句块</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> BaseException [<span class="keyword">as</span> e]:</span><br><span class="line"></span><br><span class="line">	异常处理语句块</span><br></pre></td></tr></table></figure>

<p>try 块包含着可能引发异常的代码，except 块则用来捕捉和处理发生的异常。执行的时 候，如果 try 块中没有引发异常，则跳过 ecept 块继续执行后续代码;执行的时候，如果 try块中发生了异常，则跳过 try 块中的后续代码，跳到相应的 except 块中处理异常;异常处理 完后，继续执行后续代码。</p>
<p>例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  print(<span class="string">"step1"</span>)</span><br><span class="line">  a=<span class="number">3</span>/<span class="number">0</span></span><br><span class="line">  print(<span class="string">"step2"</span>)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">  print(<span class="string">"step3"</span>)</span><br><span class="line">  print(<span class="string">"e"</span>)</span><br><span class="line">print(<span class="string">"step4"</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">step1</span><br><span class="line">step3</span><br><span class="line">division by zero </span><br><span class="line">step4</span><br></pre></td></tr></table></figure>

<p>例子2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">  print(&quot;step1&quot;)</span><br><span class="line">  a&#x3D;3&#x2F;2</span><br><span class="line">  print(&quot;step2&quot;)</span><br><span class="line">except BaseException as e:</span><br><span class="line">  print(&quot;step3&quot;)</span><br><span class="line">  print(&quot;e&quot;)</span><br><span class="line">print(&quot;step4&quot;)</span><br></pre></td></tr></table></figure>

<p>#结果</p>
<p>step1<br>step2<br>step4</p>
<h2 id="try…多个-except-结构"><a href="#try…多个-except-结构" class="headerlink" title="try…多个 except 结构"></a><strong>try…</strong>多个 <strong>except</strong> 结构</h2><p>上面的结构可以捕获所有的异常，工作中也很常见。但是，从经典理论考虑，一般建议 尽量捕获可能出现的多个异常(按照先子类后父类的顺序)，并且针对性的写出异常处理代 码。为了避免遗漏可能出现的异常，可以在最后增加 BaseException。结构如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">	被监控的可能引发异常的语句块</span><br><span class="line">except Exception1:</span><br><span class="line"> 处理 Exception1 的语句块</span><br><span class="line"></span><br><span class="line">except Exception2:</span><br><span class="line"> 处理 Exception2 的语句块</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	a=input(<span class="string">"输入一个被除数："</span>)</span><br><span class="line">	b=input(<span class="string">"输入一个除数："</span>)</span><br><span class="line">  c=float(a)/float(b)</span><br><span class="line">  print(c)</span><br><span class="line"><span class="keyword">except</span> ZeroDicisionError:</span><br><span class="line">  print(<span class="string">"除数不为0"</span>)</span><br><span class="line"><span class="keyword">except</span> TypeError: </span><br><span class="line">  print(<span class="string">"异常:除数和被除数都应该为数值类型"</span>)</span><br><span class="line"><span class="keyword">except</span> NameError: </span><br><span class="line">  print(<span class="string">"异常:变量不存在"</span>)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">    print(type(e)) </span><br><span class="line"> ```</span><br><span class="line">请输入被除数:<span class="number">10</span> </span><br><span class="line">请输入除数:<span class="number">0</span> </span><br><span class="line">异常:除数不能为 <span class="number">0</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="try…except…else-结构"><a href="#try…except…else-结构" class="headerlink" title="try…except…else 结构"></a><strong>try…except…else</strong> 结构</h2><p> try…except…else 结构增加了“else 块”。如果 try 块中没有抛出异常，则执行 else 块。如果</p>
<p>try 块中抛出异常，则执行 except 块，不执行 else 块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发生异常的执行情况(执行 except 块，没有执行 else):</span><br><span class="line"></span><br><span class="line">没有发生异常的执行情况(执行完 try 块后，执行 else):</span><br></pre></td></tr></table></figure>

<h2 id="try…except…finally-结构"><a href="#try…except…finally-结构" class="headerlink" title="try…except…finally 结构"></a><strong>try…except…finally</strong> 结构</h2><p> try…except…finally 结构中，finally 块无论是否发生异常都会被执行;通常用来释放 try 块中申请的资源</p>
<p> finally 中的语句，无论是否发生异常都执行</p>
<p>读取文件，finally 中保证关闭文件资源</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	f = open(<span class="string">"d:/a.txt"</span>,<span class="string">'r'</span>) </span><br><span class="line">  content = f.readline() </span><br><span class="line">  print(content)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	f.close() <span class="comment">#释放资源。此处也可能会发生异常。若发生异常，则程序终止,不会继续往下执行</span></span><br><span class="line">print(<span class="string">"step4"</span>)</span><br><span class="line">```</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">[Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">'d:/a.txt'</span></span><br><span class="line">File <span class="string">"C:/PycharmProjects/mypro_exception/my01.py"</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">f.close() <span class="comment">#释放资源。此处也可能会发生异常。若发生异常，则程序终止,不会继续往下执行</span></span><br><span class="line">NameError: name <span class="string">'f'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined Process finished <span class="keyword">with</span> exit code <span class="number">1</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>需要把f.close也try except</p>
<h2 id="return-语句和异常处理问题"><a href="#return-语句和异常处理问题" class="headerlink" title="return 语句和异常处理问题"></a><strong>return</strong> 语句和异常处理问题</h2><p> 由于 return 有两种作用:结束方法运行、返回值。我们一般不把 return 放到异常处理结构</p>
<p>中，而是放到方法最后。</p>
<h3 id="一般不要将-return-语句放到-try、except、else、finally-块中，会发生一些意想不到的错误。建议放到方法最后。"><a href="#一般不要将-return-语句放到-try、except、else、finally-块中，会发生一些意想不到的错误。建议放到方法最后。" class="headerlink" title="一般不要将 return 语句放到 try、except、else、finally 块中，会发生一些意想不到的错误。建议放到方法最后。"></a>一般不要将 return 语句放到 try、except、else、finally 块中，会发生一些意想不到的错误。建议放到方法最后。</h3><h2 id="常见异常的解决"><a href="#常见异常的解决" class="headerlink" title="常见异常的解决"></a>常见异常的解决</h2><p>Python 中的异常都派生自 BaseException 类</p>
<p>\1. SyntaxError:语法错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D;3 </span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>\2. NameError:尝试访问一个没有申明的变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(a)</span><br><span class="line">NameError: name &#39;a&#39; is not defined</span><br></pre></td></tr></table></figure>

<p>\3. ZeroDivisionError:除数为0错误(零除错误)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 3&#x2F;0</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>

<p>\4. ValueError:数值错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float(&quot;gaoqi&quot;)</span><br><span class="line">ValueError: could not convert string to float: &#39;gaoqi&#39;</span><br></pre></td></tr></table></figure>

<p>\5. TypeError:类型错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123+&quot;abc&quot;</span><br><span class="line">TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;</span><br></pre></td></tr></table></figure>

<p>\6. AttributeError:访问对象的不存在的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.sayhi()</span><br><span class="line">AttributeError: &#39;int&#39; object has no attribute &#39;sayhi&#39;</span><br></pre></td></tr></table></figure>

<p>\7. IndexError:索引越界异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[10]</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure>

<p>\8. KeyError:字典的关键字不存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[&#39;salary&#39;] KeyError: &#39;salary&#39;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>异常名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArithmeticError</code></td>
<td>所有数值计算错误的基类</td>
</tr>
<tr>
<td><code>AssertionError</code></td>
<td>断言语句失败</td>
</tr>
<tr>
<td><code>AttributeError</code></td>
<td>对象没有这个属性</td>
</tr>
<tr>
<td><code>BaseException</code></td>
<td>所有异常的基类</td>
</tr>
<tr>
<td><code>DeprecationWarning</code></td>
<td>关于被弃用的特征的警告</td>
</tr>
<tr>
<td><code>EnvironmentError</code></td>
<td>操作系统错误的基类</td>
</tr>
<tr>
<td>EOFError</td>
<td>没有内建输入,到达 EOF 标记</td>
</tr>
<tr>
<td>Exception</td>
<td>常规错误的基类</td>
</tr>
<tr>
<td><code>FloatingPointError</code></td>
<td>浮点计算错误</td>
</tr>
<tr>
<td><code>FutureWarning</code></td>
<td><code>关于构造将来语义会有改变的警告</code></td>
</tr>
<tr>
<td><code>GeneratorExit</code></td>
<td>生成器(generator)发生异常来通知退出</td>
</tr>
<tr>
<td>ImportError</td>
<td>导入模块/对象失败</td>
</tr>
<tr>
<td><code>IndentationError</code></td>
<td>缩进错误</td>
</tr>
<tr>
<td>IndexError</td>
<td>序列中没有此索引(index)</td>
</tr>
<tr>
<td>IOError</td>
<td>输入/输出操作失败</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>KeyboardInterrupt</code></th>
<th>用户中断执行(通常是输入^C)</th>
</tr>
</thead>
<tbody><tr>
<td>KeyError</td>
<td>映射中没有这个键</td>
</tr>
<tr>
<td>LookupError</td>
<td>无效数据查询的基类</td>
</tr>
<tr>
<td>MemoryError</td>
<td>内存溢出错误(对于 Python 解释器不是致命的)</td>
</tr>
<tr>
<td>NameError</td>
<td>未声明/初始化对象 (没有属性)</td>
</tr>
<tr>
<td><code>NotImplementedError</code></td>
<td>尚未实现的方法</td>
</tr>
<tr>
<td>OSError</td>
<td>操作系统错误</td>
</tr>
<tr>
<td><code>OverflowError</code></td>
<td>数值运算超出最大限制</td>
</tr>
<tr>
<td><code>OverflowWarning</code></td>
<td>旧的关于自动提升为长整型(long)的警告</td>
</tr>
<tr>
<td><code>PendingDeprecationWarning</code></td>
<td><code>关于特性将会被废弃的警告</code></td>
</tr>
<tr>
<td><code>ReferenceError</code></td>
<td>弱引用(Weak reference)试图访问已经垃圾回收了的对象</td>
</tr>
<tr>
<td><code>RuntimeError</code></td>
<td>一般的运行时错误</td>
</tr>
<tr>
<td><code>RuntimeWarning</code></td>
<td>可疑的运行时行为(runtime behavior)的警告</td>
</tr>
<tr>
<td><code>StandardError</code></td>
<td><code>所有的内建标准异常的基类</code></td>
</tr>
<tr>
<td><code>StopIteration</code></td>
<td>迭代器没有更多的值</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>Python 语法错误</td>
</tr>
<tr>
<td><code>SyntaxWarning</code></td>
<td>可疑的语法的警告</td>
</tr>
<tr>
<td>SystemError</td>
<td>一般的解释器系统错误</td>
</tr>
<tr>
<td>SystemExit</td>
<td>解释器请求退出</td>
</tr>
<tr>
<td>TabError</td>
<td>Tab 和空格混用</td>
</tr>
<tr>
<td>TypeError</td>
<td>对类型无效的操作</td>
</tr>
<tr>
<td><code>UnboundLocalError</code></td>
<td>访问未初始化的本地变量</td>
</tr>
<tr>
<td><code>UnicodeDecodeError</code></td>
<td>Unicode 解码时的错误</td>
</tr>
<tr>
<td><code>UnicodeEncodeError</code></td>
<td>Unicode 编码时错误</td>
</tr>
<tr>
<td><code>UnicodeError</code></td>
<td>Unicode 相关的错误</td>
</tr>
<tr>
<td><code>UnicodeTranslateError</code></td>
<td>Unicode 转换时错误</td>
</tr>
<tr>
<td>UserWarning</td>
<td>用户代码生成的警告</td>
</tr>
<tr>
<td>ValueError</td>
<td>传入无效的参数</td>
</tr>
<tr>
<td>Warning</td>
<td>警告的基类</td>
</tr>
<tr>
<td><code>WindowsError</code></td>
<td>系统调用失败</td>
</tr>
<tr>
<td><code>ZeroDivisionError</code></td>
<td>除(或取模)零 (所有数据类型)</td>
</tr>
</tbody></table>
<h2 id="with-上下文管理"><a href="#with-上下文管理" class="headerlink" title="with 上下文管理"></a><strong>with</strong> 上下文管理</h2><p> finally 块由于是否发生异常都会执行，通常我们放释放资源的代码。其实，我们可以通过 with 上下文管理，更方便的实现释放资源的操作。 with 上下文管理的语法结构如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> context_expr [ <span class="keyword">as</span> var]: </span><br><span class="line">	语句块</span><br></pre></td></tr></table></figure>

<p>with 上下文管理可以自动管理资源，在 with 代码块执行完毕后自动还原进入该代码之前的 现场或上下文。不论何种原因跳出 with 块，不论是否有异常，总能保证资源正常释放。极 大的简化了工作，在文件操作、网络通信相关的场合非常常用。</p>
<h3 id="With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发"><a href="#With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发" class="headerlink" title="With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发"></a>With不是取代try…except…finally的，而是作为补充，方便文件管理，网络通信时的开发</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"d:/bb.txt"</span>) <span class="keyword">as</span> f: </span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">		print(line)</span><br></pre></td></tr></table></figure>

<h2 id="trackback-模块"><a href="#trackback-模块" class="headerlink" title="trackback 模块"></a><strong>trackback</strong> 模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">  print(<span class="string">"step1"</span>)</span><br><span class="line">	num = <span class="number">1</span>/<span class="number">0</span> </span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	traceback.print_exc()</span><br><span class="line">  ```</span><br><span class="line">  step1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/mengxiaowang/Documents/a.py"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    num = <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">  ```</span><br></pre></td></tr></table></figure>

<p>使用 traceback 将异常信息写入日志文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">  print(<span class="string">"step1"</span>)</span><br><span class="line">	num = <span class="number">1</span>/<span class="number">0</span> </span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="keyword">with</span> open(<span class="string">"d:/a.log"</span>,<span class="string">"a"</span>) <span class="keyword">as</span> f: </span><br><span class="line">    traceback.print_exc(file=f)</span><br></pre></td></tr></table></figure>

<h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>程序开发中，有时候我们也需要自己定义异常类。自定义异常类一般都是运行时异常，通常继承 Exception 或其子类即可。命名一般以 Error、Exception 为后缀。</p>
<p> 自定义异常由 raise 语句主动抛出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">classAgeError(Exception): <span class="comment">#继承Exception </span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,errorInfo)</span>:</span></span><br><span class="line">		Exception.__init__(self)</span><br><span class="line">		self.errorInfo = errorInfo </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> str(self.errorInfo)+<span class="string">",年龄错误!应该在 1-150 之间"</span></span><br><span class="line"><span class="comment">############测试代码################</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: <span class="comment">#如果为 True，则模块是作为独立文件运行， 可以执行测试代码</span></span><br><span class="line">	age = int(input(<span class="string">"输入一个年龄:"</span>)) </span><br><span class="line">  	<span class="keyword">if</span> age&lt;<span class="number">1</span> <span class="keyword">or</span> age&gt;<span class="number">150</span>:</span><br><span class="line">    	<span class="keyword">raise</span> AgeError(age)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">			print(<span class="string">"正常的年龄:"</span>,age)</span><br><span class="line">```</span><br><span class="line">输入一个年龄：<span class="number">160</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"C:/Users/Administrator/PycharmProjects/mypro_exception/my10.py"</span>, line <span class="number">16</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"><span class="keyword">raise</span> AgeError(age)</span><br><span class="line">__main__.AgeError: <span class="number">200</span>,年龄错误!应该在 <span class="number">1</span><span class="number">-150</span> 之间</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="if-name-‘main‘-的作用"><a href="#if-name-‘main‘-的作用" class="headerlink" title="if name == ‘main‘:的作用"></a>if <strong>name</strong> == ‘<strong>main</strong>‘:的作用</h2><p>简单说：</p>
<h4 id="在当前执行的程序下（例如当前程序为test-py），如果导入其他模块（other-test-py），则运行程序时other-test-py的if-name-‘main‘-语句判断失败，将不会运行下面的方法。"><a href="#在当前执行的程序下（例如当前程序为test-py），如果导入其他模块（other-test-py），则运行程序时other-test-py的if-name-‘main‘-语句判断失败，将不会运行下面的方法。" class="headerlink" title="在当前执行的程序下（例如当前程序为test.py），如果导入其他模块（other_test.py），则运行程序时other_test.py的if name == ‘main‘ 语句判断失败，将不会运行下面的方法。"></a>在当前执行的程序下（例如当前程序为test.py），如果导入其他模块（other_test.py），则运行程序时other_test.py的if <strong>name</strong> == ‘<strong>main</strong>‘ 语句判断失败，将不会运行下面的方法。</h4><p>也就是说导入的模块的if <strong>name</strong> == ‘<strong>main</strong>‘ 语句下的方法是不会执行的。只会执行当前的if <strong>name</strong> == ‘<strong>main</strong>‘ 下的方法。<br>一个python文件通常有两种使用方法，第一是作为脚本直接执行，第二是 import 到其他的 python 脚本中被调用（模块重用）执行。因此 if <strong>name</strong> == ‘main’: 的作用就是控制这两种情况执行代码的过程，在 if <strong>name</strong> == ‘main’: 下的代码只有在第一种情况下（即文件作为脚本直接执行）才会被执行，而 import 到其他脚本中是不会被执行的。举例说明如下：</p>
<ul>
<li>直接执行</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190510141202522.png" alt="img"></p>
<p><strong>直接执行 test.py，</strong>结果如下图，可以成功 print 两行字符串。即<strong>，if <strong>name</strong>==”<strong>main</strong>“: 语句之前和之后的代码都被执行。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190510141303114.png" alt="img"></p>
<ul>
<li>import 执行</li>
</ul>
<p>然后在同一文件夹新建名称为 import_test.py 的脚本，输入如下代码：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510141602268.png" alt="img"></p>
<p>执行 <strong>import_test.py 脚本</strong>，输出结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510141624918.png" alt="img"></p>
<p>只输出了第一行字符串。即，<strong>if <strong>name</strong>==”<strong>main</strong>“: 之前的语句被执行，之后的没有被执行。</strong></p>
<h3 id="if-name-‘main‘-的运行原理"><a href="#if-name-‘main‘-的运行原理" class="headerlink" title="if name == ‘main‘:的运行原理"></a>if <strong>name</strong> == ‘<strong>main</strong>‘:的运行原理</h3><p><strong>每个python模块</strong>（python文件，也就是此处的 test.py 和 import_test.py）都包含<strong>内置的变量 <strong>name</strong></strong>，当该模块被<strong>直接执行</strong>的时候，<strong><strong>name</strong> 等于文件名（包含后缀 .py ）</strong>；如果该模块 <strong>import</strong> 到其他模块中，<strong>则该模块的 <strong>name</strong> 等于模块名称（不包含后缀.py）。</strong></p>
<p>而 <strong>“<strong>main</strong>” 始终指当前执行模块的名称（包含后缀.py）</strong>。进而当模块被<strong>直接执行</strong>时<strong>，<strong>name</strong> == ‘main’ 结果为真。</strong></p>
<p>为了进一步说明，我们在 test.py 脚本的 if <strong>name</strong>==”<strong>main</strong>“: 之前<strong>加入 print(<strong>name</strong>)，</strong>即将 <strong>name</strong> 打印出来。文件内容和结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510142230219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlcWlhbmc1MjU=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190510142253482.png" alt="img"></p>
<p>可以看出，此时变量<strong><strong>name</strong>的值为”<strong>main</strong>“。</strong></p>
<p>再执行 import_test.py，执行结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190510142441889.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190510142452571.png" alt="img"></p>
<p>此时，<strong>test.py中的<strong>name</strong>变量值为 test，</strong>不满足 <strong>name</strong>==”<strong>main</strong>“ 的条件，因此，无法执行其后的代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/python400%E9%9B%863/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/python400%E9%9B%863/" class="post-title-link" itemprop="url">python400集3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 15:09:28" itemprop="dateCreated datePublished" datetime="2020-04-29T15:09:28-05:00">2020-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-01 23:12:23" itemprop="dateModified" datetime="2020-05-01T23:12:23-05:00">2020-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="python面向对象"><a href="#python面向对象" class="headerlink" title="python面向对象"></a>python面向对象</h1><p>类定义数据类型的属性(数据)和方法(行为),也就是说，“类将行为和状态打 包在一起”。</p>
<p>对象是类的具体实体，一般称为“类的实例”。“方法代码是共享的，属性数据不共享”。</p>
<p>定义类的语法格式如下: class 类名:</p>
<p>类体</p>
<p>要点如下:</p>
<ol>
<li><p>类名必须符合“标识符”的规则;一般规定，首字母大写，多个单词使用“驼峰原则”。</p>
<ol start="2">
<li>类体中我们可以定义属性和方法。</li>
<li>. 属性用来描述数据，方法(即函数)用来描述这些数据相关的操作。</li>
</ol>
</li>
</ol>
<h2 id="init构造方法和new方法"><a href="#init构造方法和new方法" class="headerlink" title="init构造方法和new方法"></a><strong><strong>init</strong>构造方法和<strong>new</strong>方法</strong></h2><p>类是抽象的，也称之为“对象的模板”。我们需要通过类这个模板，创建类的实例对象，然 后才能使用类定义的功能。</p>
<p>我们前面说过一个 Python 对象包含三个部分:id(identity 识别码)、type(对象类型)、 value(对象的值)。</p>
<p>现在，我们可以更进一步的说，一个 Python 对象包含如下部分: 1. id(identity 识别码)</p>
<ol start="2">
<li>type(对象类型) 3. value(对象的值)：(1) 属性(attribute) (2) 方法(method)</li>
</ol>
<h4 id="创建对象，我们需要定义构造函数init-方法。构造方法用于执行“实例对象的初始化工-作”，即对象创建后，初始化当前对象的相关属性，无返回值。"><a href="#创建对象，我们需要定义构造函数init-方法。构造方法用于执行“实例对象的初始化工-作”，即对象创建后，初始化当前对象的相关属性，无返回值。" class="headerlink" title="创建对象，我们需要定义构造函数init()方法。构造方法用于执行“实例对象的初始化工 作”，即对象创建后，初始化当前对象的相关属性，无返回值。"></a>创建对象，我们需要定义构造函数<strong>init</strong>()方法。构造方法用于执行“实例对象的初始化工 作”，即对象创建后，初始化当前对象的相关属性，无返回值。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_init_()</span><br></pre></td></tr></table></figure>

<p>的要点如下:<br> \1. 名称固定，必须为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__init__()</span><br></pre></td></tr></table></figure>

<p> \2. 第一个参数固定，必须为:self。 self 指的就是刚刚创建好的实例对象。<br> \3. 构造函数通常用来初始化实例对象的实例属性，如下代码就是初始化实例属性:name 和 score。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,score)</span>:</span></span><br><span class="line">	self.name = name <span class="comment">#实例属性 </span></span><br><span class="line">	self.score = score</span><br></pre></td></tr></table></figure>

<p>\4. 通过“类名(参数列表)”来调用构造函数。调用后，将创建好的对象返回给相应的变量。 比如:s1 = Student(‘张三’, 80)</p>
<p>\5. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__init__()方法:初始化创建好的对象，初始化指的是:“给实例属性赋值”</span><br></pre></td></tr></table></figure>


<p> \6. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__new__()方法: 用于创建对象，但我们一般无需重定义该方法。</span><br></pre></td></tr></table></figure>


<p> \7.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果我们不定义__init__方法，系统会提供一个默认的__init__方法。如果我们定义了带参 的__init__方法，系统不创建默认的__init__方法。</span><br></pre></td></tr></table></figure>

<p>注:<br> \1. Python中的self相当于C++中的self指针，JAVA和C#中的this关键字。Python中， self 必须为构造函数的第一个参数，名字可以任意修改。但一般遵守惯例，都叫做 self。</p>
<h2 id="实例属性和实例方法"><a href="#实例属性和实例方法" class="headerlink" title="实例属性和实例方法"></a>实例属性和实例方法</h2><h3 id="实例属性instance（其实跟java差不多）"><a href="#实例属性instance（其实跟java差不多）" class="headerlink" title="实例属性instance（其实跟java差不多）"></a>实例属性instance（其实跟java差不多）</h3><p>实例属性是从属于实例对象的属性，也称为“实例变量”。他的使用有如下几个要点: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\1. 实例属性一般在__init__()方法中通过如下代码定义:</span><br><span class="line"></span><br><span class="line">self.实例属性名 &#x3D; 初始值</span><br><span class="line"> \2. 在本类的其他实例方法中，也是通过 self 进行访问:</span><br><span class="line"></span><br><span class="line">self.实例属性名</span><br><span class="line"> \3. 创建实例对象后，通过实例对象访问:</span><br><span class="line"></span><br><span class="line">obj01 &#x3D; 类名() #创建对象，调用__init__()初始化属性 </span><br><span class="line">obj01.实例属性名 &#x3D; 值 #可以给已有属性赋值，也可以新加属性</span><br></pre></td></tr></table></figure>



<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a><strong>实例方法</strong></h3><p>实例方法是从属于实例对象的方法。实例方法的定义格式如下: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def 方法名(self [, 形参列表]):</span><br><span class="line">	函数体</span><br><span class="line">方法的调用格式如下:</span><br><span class="line">	对象.方法名([实参列表])</span><br></pre></td></tr></table></figure>



<p>要点:<br> \1. 定义实例方法时，第一个参数必须为 self。和前面一样，self 指当前的实例对象。 2. 调用实例方法时，不需要也不能给 self 传参。self 由解释器自动传参。</p>
<h3 id="·-函数和方法的区别"><a href="#·-函数和方法的区别" class="headerlink" title="· 函数和方法的区别"></a><strong>· 函数和方法的区别</strong></h3><ol>
<li><p>都是用来完成一个功能的语句块，本质一样。</p>
</li>
<li><p>方法调用时，通过对象来调用。方法从属于特定实例对象，普通函数没有这个特点。 </p>
</li>
<li><p>直观上看，方法定义时需要传递 self，函数不需要。</p>
</li>
</ol>
<p><strong>· 实例对象的方法调用本质:</strong></p>
<p><strong>a = Student()</strong></p>
<p><strong>a.say_score()</strong></p>
<p>解释器翻译:</p>
<p><strong>Student.say_score(a)</strong></p>
<p><strong>· 其他操作:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> dir(obj)可以获得对象的所有属性、方法</span><br><span class="line"><span class="number">2.</span>obj.__dict__ 对象的属性字典</span><br><span class="line"><span class="number">3.</span><span class="keyword">pass</span> 空语句</span><br><span class="line"><span class="number">4.</span>isinstance(对象,类型) 判断“对象”是不是“指定类型”</span><br></pre></td></tr></table></figure>

<h2 id="类对象、类属性、类方法、静态方法"><a href="#类对象、类属性、类方法、静态方法" class="headerlink" title="类对象、类属性、类方法、静态方法"></a><strong>类对象、类属性、类方法、静态方法</strong></h2><p><strong>类对象</strong></p>
<p>我们在前面讲的类定义格式中，“class 类名:”。实际上，当解释器执行 class 语句时， 就会创建一个类对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	<span class="keyword">pass</span> <span class="comment">#空语句</span></span><br><span class="line">print(type(Student)) </span><br><span class="line">print(id(Student))</span><br><span class="line">Stu2 = Student </span><br><span class="line">s1 = Stu2() </span><br><span class="line">print(s1)</span><br></pre></td></tr></table></figure>

<p>执行结果如下:<br> &lt;class ‘type’&gt;</p>
<p>51686328<br> &lt;<strong>main</strong>.Student object at 0x0000000002B5FDD8&gt;</p>
<p>我们可以看到实际上生成了一个变量名就是类名“Student”的对象。我们通过赋值给新变 量 Stu2，也能实现相关的调用。说明，确实创建了“类对象”。</p>
<p>【注】pass 为空语句。就是表示什么都不做，只是作为一个占位符存在。当你写代码时， 遇到暂时不知道往方法或者类中加入什么时，可以先用 pass 占位，后期再补上。</p>
<h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a><strong>类属性</strong></h3><p>类属性是从属于“类对象”的属性，也称为“类变量”。由于，类属性从属于类对象，可以 被所有实例对象共享。</p>
<p>类属性的定义方式:<br> class 类名:</p>
<p>类变量名= 初始值 在类中或者类的外面，我们可以通过:“类名.类变量名”来读写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	company = <span class="string">"SXT"</span> <span class="comment">#类属性 </span></span><br><span class="line">	count = <span class="number">0</span> <span class="comment">#类属性</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,score)</span>:</span> </span><br><span class="line">		self.name = name 	</span><br><span class="line">		self.score = score <span class="comment">#实例属性</span></span><br><span class="line">		Student.count = Student.count+<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_score</span><span class="params">(self)</span>:</span> <span class="comment">#实例方法 </span></span><br><span class="line">  print(<span class="string">"我的公司是:"</span>,Student.company) </span><br><span class="line">  print(self.name,<span class="string">'的分数是:'</span>,self.score)</span><br><span class="line">s1 = Student(<span class="string">'张三'</span>,<span class="number">80</span>) <span class="comment">#s1 是实例对象，自动调用__init__()方法 </span></span><br><span class="line">s1.say_score()</span><br><span class="line">print(<span class="string">'一共创建&#123;0&#125;个 Student 对象'</span>.format(Student.count))</span><br><span class="line">```</span><br><span class="line">执行结果:</span><br><span class="line">我的公司是: SXT</span><br><span class="line">张三 的分数是: <span class="number">80</span> </span><br><span class="line">一共创建 <span class="number">1</span> 个 Student 对象</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a><strong>类方法</strong></h3><p>类方法是从属于“类对象”的方法。类方法通过装饰器@classmethod 来定义，格式如下: @classmethod</p>
<p>def 类方法名(cls [，形参列表]) : 函数体</p>
<p>要点如下:<br> \1. @classmethod 必须位于方法上面一行<br> \2. 第一个 cls 必须有;cls 指的就是“类对象”本身;<br> \3. 调用类方法格式:“类名.类方法名(参数列表)”。 参数列表中，不需要也不能给 cls 传 值。<br> \4. 类方法中访问实例属性和实例方法会导致错误<br> \5. 子类继承父类方法时，传入 cls 是子类对象，而非父类对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	company = <span class="string">"SXT"</span> <span class="comment">#类属性 </span></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printCompany</span><span class="params">(cls)</span>:</span> </span><br><span class="line">    print(cls.company)</span><br><span class="line">Student.printCompany()</span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a><strong>静态方法</strong></h3><p>Python 中允许定义与“类对象”无关的方法，称为“静态方法”。</p>
<p>“静态方法”和在模块中定义普通函数没有区别，只不过“静态方法”放到了“类的名字空 间里面”，需要通过“类调用”。</p>
<p>静态方法通过装饰器@staticmethod 来定义，格式如下: @staticmethod</p>
<p>def 静态方法名([形参列表]) : 函数体</p>
<p>要点如下:</p>
<ol>
<li><p>@staticmethod 必须位于方法上面一行</p>
</li>
<li><p>调用静态方法格式:“类名.静态方法名(参数列表)”。 </p>
</li>
<li><p>静态方法中访问实例属性和实例方法会导致错误</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	company = <span class="string">"SXT"</span> <span class="comment"># 类属性</span></span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span> <span class="comment"># 静态方法</span></span><br><span class="line"> 		print(<span class="string">"&#123;0&#125;+&#123;1&#125;=&#123;2&#125;"</span>.format(a,b,(a+b)))</span><br><span class="line"> 		<span class="keyword">return</span> a+b</span><br><span class="line"> Student.add(<span class="number">20</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h2 id="del方法-析构函数-和垃圾回收机制"><a href="#del方法-析构函数-和垃圾回收机制" class="headerlink" title="del方法(析构函数)和垃圾回收机制"></a><strong><strong>del</strong>方法(析构函数)和垃圾回收机制</strong></h2><p><strong>del</strong>方法称为“析构方法”，用于实现对象被销毁时所需的操作。比如:释放对象 占用的资源，例如:打开的文件资源、网络连接等。</p>
<p>Python 实现自动的垃圾回收，当对象没有被引用时(引用计数为 0)，由垃圾回收器 调用<strong>del</strong>方法。</p>
<p>我们也可以通过 del 语句删除对象，从而保证调用<strong>del</strong>方法。 系统会自动提供<strong>del</strong>方法，一般不需要自定义析构方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#析构函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span> </span><br><span class="line">  print(<span class="string">"销毁对象:&#123;0&#125;"</span>.format(self))</span><br><span class="line">p1 = Person() </span><br><span class="line">p2 = Person()</span><br><span class="line"><span class="keyword">del</span> p2</span><br><span class="line">print(<span class="string">"end"</span>)</span><br><span class="line">```</span><br><span class="line">运算结果:</span><br><span class="line">销毁对象:&lt;__main__.Person object at <span class="number">0x02175610</span>&gt; 程序结束</span><br><span class="line">销毁对象:&lt;__main__.Person object at <span class="number">0x021755D0</span>&gt;</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="call方法和可调用对象"><a href="#call方法和可调用对象" class="headerlink" title="call方法和可调用对象"></a><strong><strong>call</strong>方法和可调用对象</strong></h2><p>定义了<strong>call</strong>方法的对象，称为“可调用对象”，即该对象可以像函数一样被调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalaryAccount</span>:</span> <span class="string">'''工资计算类'''</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, salary)</span>:</span> </span><br><span class="line">    yearSalary = salary*<span class="number">12</span> </span><br><span class="line">    daySalary = salary//<span class="number">30</span></span><br><span class="line">		hourSalary = daySalary//<span class="number">8</span> </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">dict(monthSalary=salary,yearSalary=yearSalary,daySalary=daySalary ,hourSalary=hourSalary)</span><br><span class="line">s = SalaryAccount()</span><br><span class="line">print(s(<span class="number">5000</span>)) <span class="comment">#可以像调用函数一样调用对象的__call__方法</span></span><br><span class="line"><span class="comment">#&#123;'monthSalary': 5000, 'yearSalary': 60000, 'daySalary': 166, 'hourSalary': 20&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="方法没有重载"><a href="#方法没有重载" class="headerlink" title="方法没有重载"></a><strong>方法没有重载</strong></h2><p>在其他语言中，可以定义多个重名的方法，只要保证方法签名唯一即可。方法签名包含 3 个部分:方法名、参数数量、参数类型。</p>
<p>Python 中，方法的的参数没有声明类型(调用时确定参数的类型)，参数的数量也可以由 可变参数控制。因此，Python 中是没有方法的重载的。定义一个方法即可有多种调用方式， 相当于实现了其他语言中的方法的重载。</p>
<h3 id="如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。-建议-不要使用重名的方法-Python-中方法没有重载。"><a href="#如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。-建议-不要使用重名的方法-Python-中方法没有重载。" class="headerlink" title="如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。 建议:不要使用重名的方法!Python 中方法没有重载。"></a>如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。 建议:不要使用重名的方法!Python 中方法没有重载。</h3><h2 id="方法的动态性"><a href="#方法的动态性" class="headerlink" title="方法的动态性"></a><strong>方法的动态性</strong></h2><p>Python 是动态语言，我们可以动态的为类添加新的方法，或者动态的修改类的已有的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"努力上班!"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_game</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;0&#125;玩游戏"</span>.format(self))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work2</span><span class="params">(s)</span>:</span></span><br><span class="line">    print(<span class="string">"好好工作，努力上班!"</span>)</span><br><span class="line">Person.play = play_game</span><br><span class="line">Person.work = work2 </span><br><span class="line">p = Person()</span><br><span class="line">p.play()</span><br><span class="line">p.work()</span><br><span class="line">```</span><br><span class="line">&lt;__main__.Person object at <span class="number">0x7fb0405fdee0</span>&gt;玩游戏</span><br><span class="line">好好工作，努力上班!</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>我们可以看到，Person 动态的新增了 play_game 方法，以及用 work2 替换了 work 方法。</p>
<h2 id="私有属性和私有方法-实现封装"><a href="#私有属性和私有方法-实现封装" class="headerlink" title="私有属性和私有方法(实现封装)"></a><strong>私有属性和私有方法(实现封装)</strong></h2><p>Python 对于类的成员没有严格的访问控制限制，这与其他面向对象语言有区别。关于私有 属性和私有方法，有如下要点:</p>
<ol>
<li><p>通常我们约定，两个下划线开头的属性是私有的(private)。其他为公共的(public)。 </p>
</li>
<li><p>类内部可以访问私有属性(方法)</p>
</li>
<li><p>类外部不能直接访问私有属性(方法)</p>
</li>
<li><p>类外部可以通过“_类名__私有属性(方法)名”访问私有属性(方法)</p>
</li>
</ol>
<p>【注】方法本质上也是属性!只不过是可以通过()执行而已。所以，此处讲的私有属性和公有属性，也同时讲解了私有方法和公有方法的用法。如下测试中，同时也包含了私有方法和 公有方法的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试私有属性、私有方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">	__company = <span class="string">"google"</span> <span class="comment">#私有类属性. 通过 dir 可以查到_Employee__company</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.__age = age <span class="comment">#私有实例属性</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">say_company</span><span class="params">(self)</span>:</span> </span><br><span class="line">    print(<span class="string">"我的公司是:"</span>,Employee.__company) <span class="comment">#类内部可以直接访问私有属性</span></span><br><span class="line">		print(self.name,<span class="string">"的年龄是:"</span>,self.__age) </span><br><span class="line">    self.__work()</span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">__work</span><span class="params">(self)</span>:</span> <span class="comment">#私有实例方法 通过 dir 可以查到 _Employee__work</span></span><br><span class="line">		print(<span class="string">"工作!好好工作，好好赚钱，娶个媳妇!"</span>)</span><br><span class="line">p1 = Employee(<span class="string">"高淇"</span>,<span class="number">32</span>)</span><br><span class="line">print(p1.name)</span><br><span class="line">print(dir(p1)) <span class="comment"># </span></span><br><span class="line">p1.say_company()</span><br><span class="line">print(p1._Employee__age) <span class="comment">#通过这种方式可以直接访问到私有属性 。通过 dir 可以查到属性:_Employee__age </span></span><br><span class="line"><span class="comment">#print(p1.__age) #直接访问私有属性，报错</span></span><br><span class="line"> <span class="comment">#p1.__sleep() #直接访问私有方法，报错</span></span><br><span class="line">  ```</span><br><span class="line">  执行结果:</span><br><span class="line">高淇</span><br><span class="line">[<span class="string">'_Person__age'</span>, <span class="string">'_Person__leg_num'</span>, <span class="string">'_Person__sleep'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'name'</span>, <span class="string">'say_age'</span>]</span><br><span class="line">腿的数目: <span class="number">2</span></span><br><span class="line">高淇 的年龄是: <span class="number">18</span></span><br><span class="line">睡觉</span><br><span class="line"><span class="number">18</span></span><br><span class="line">从打印的 Person 对象所有属性我们可以看出。私有属性“__age”在实际存储时是按照 “_Person__age”这个属性来存储的。这也就是为什么我们不能直接使用“__age”而可以 使用“_Person__age”的根本原因。</span><br><span class="line">  ```</span><br></pre></td></tr></table></figure>

<h2 id="property-装饰器"><a href="#property-装饰器" class="headerlink" title="@property 装饰器"></a><strong>@property 装饰器</strong></h2><p>@property 可以将一个方法的调用方式变成“属性调用”</p>
<p>@property 主要用于帮助我们处理属性的读操作、写操作。对于某一个属性，我们可以直 接通过:</p>
<p>emp1.salary = 30000 如上的操作读操作、写操作。但是，这种做法不安全。比如，我需要限制薪水必须为 1-10000 的数字。这时候，我们就需要通过 getter、setter 方法来处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,salary)</span>:</span> </span><br><span class="line">    self.name = name</span><br><span class="line"> 		self.__salary = salary</span><br><span class="line"><span class="meta">	@property #相当于 salary 属性的 getter 方法</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">salary</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"月薪为&#123;0&#125;,年薪为 &#123;1&#125;"</span>.format(self.__salary,(<span class="number">12</span>*self.__salary)))</span><br><span class="line"> 		<span class="keyword">return</span> self.__salary;</span><br><span class="line"><span class="meta"> 	@salary.setter</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">salary</span><span class="params">(self,salary)</span>:</span> <span class="comment">#相当于 salary 属性的 setter 方法</span></span><br><span class="line"> 		<span class="keyword">if</span>(<span class="number">0</span>&lt;salary&lt;<span class="number">1000000</span>): </span><br><span class="line">      self.__salary = salary</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line"> 			print(<span class="string">"薪水录入错误!只能在 0-1000000 之间"</span>)</span><br><span class="line">emp1 = Employee(<span class="string">"高淇"</span>,<span class="number">100</span>) </span><br><span class="line">print(emp1.salary)</span><br><span class="line">emp1.salary = <span class="number">-200</span></span><br></pre></td></tr></table></figure>

<p>运行结果:<br> 月薪为 100,年薪为 1200</p>
<p>100<br> 月薪为 100,年薪为 1200<br> 100<br> 薪水录入错误!只能在 0-1000000 之间</p>
<h2 id="属性和方法命名总结"><a href="#属性和方法命名总结" class="headerlink" title="属性和方法命名总结"></a><strong>属性和方法命名总结</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· _xxx:保护成员，不能用“from module import * ”导入，只有类对象和子类对象能访 问这些成员。(类似java 的proetected)</span><br><span class="line"> · __xxx__:系统定义的特殊成员</span><br><span class="line"> · __xxx: 类中的私有成员，只有类对象自己能访问，子类对象也不能访问。(但，在类外 部可以通过“对象名. _类名__xxx”这种特殊方式访问。Python 不存在严格意义的私有成员)（类似java的private）</span><br></pre></td></tr></table></figure>

<p>注:再次强调，方法和属性都遵循上面的规则。</p>
<p>私有属性是无法被继承的。由此可知，在 Python 中私有属性为假私有属性。那为什么不从语法上保证 private 字段的私密性呢？用最简单的一句话来说：We are all consenting adults here。正如Python 程序员的观点：开放要比封闭好。</p>
<p>综上所述：</p>
<p>Python 编译器无法严格保证 private 字段的私密性。</p>
<p>只有当子类不受自己控制的时候，才可以考虑使用 private 属性来避免名称冲突。所以python还是不如java啊。</p>
<h2 id="类编码风格"><a href="#类编码风格" class="headerlink" title="类编码风格"></a><strong>类编码风格</strong></h2><p>\1. 类名首字母大写，多个单词之间采用驼峰原则。<br> \2. 实例名、模块名采用小写，多个单词之间采用下划线隔开。<br> \3. 每个类，应紧跟“文档字符串”，说明这个类的作用。<br> \4. 可以用空行组织代码，但不能滥用。在类中，使用一个空行隔开方法;模块中，使用两 个空行隔开多个类。</p>
<h1 id="面向对象进阶"><a href="#面向对象进阶" class="headerlink" title="面向对象进阶"></a>面向对象进阶</h1><p><strong>面向对象三大特征介绍</strong></p>
<p>Python 是面向对象的语言，也支持面向对象编程的三大特性:继承、封装(隐藏)、多态。</p>
<p><strong>·封装(隐藏)</strong></p>
<p>隐藏对象的属性和实现细节，只对外提供必要的方法。相当于将“细节封装起来”，只 对外暴露“相关调用方法”。</p>
<p>通过前面学习的“私有属性、私有方法”的方式，实现“封装”。Python 追求简洁的 语法，没有严格的语法级别的“访问控制符”，更多的是依靠程序员自觉实现。</p>
<p><strong>·继承</strong></p>
<p>继承可以让子类具有父类的特性，提高了代码的重用性。</p>
<p>从设计上是一种增量进化，原有父类设计不变的情况下，可以增加新的功能，或者改进 已有的算法。</p>
<p><strong>·多态</strong></p>
<p>多态是指同一个方法调用由于对象不同会产生不同的行为。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h2><p>继承是面向对象程序设计的重要特征，也是实现“代码复用”的重要手段。</p>
<p>如果一个新类继承自一个设计好的类，就直接具备了已有类的特征，就大大降低了工作 难度。已有的类，我们称为“父类或者基类”，新的类，我们称为“子类或者派生类”。</p>
<h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a><strong>语法格式</strong></h3><p>Python 支持多重继承，一个子类可以继承多个父类。继承的语法格式如下: </p>
<p>class 子类类名(父类 1[，父类 2，…]):</p>
<p>​    类体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果在类定义中没有指定父类，则默认父类是 object 类。也就是说，object 是所有类的父 类，里面定义了一些所有类共有的默认实现，比如:__new__()。</span><br><span class="line"></span><br><span class="line">定义子类时，必须在其构造函数中调用父类的构造函数。调用格式如下: 父类名.__init__(self, 参数列表)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,score)</span>:</span></span><br><span class="line"> 		self.score = score</span><br><span class="line">		Person.__init__(self,name,age) <span class="comment">#构造函数中包含调用父类构造函数。根据需要，不是必须。 子类并不会自动调用父类的__init__()，我们必须显式的调用它</span></span><br></pre></td></tr></table></figure>

<h3 id="类成员的继承和重写"><a href="#类成员的继承和重写" class="headerlink" title="类成员的继承和重写"></a><strong>类成员的继承和重写</strong></h3><p>\1. 成员继承:子类继承了父类除构造方法之外的所有成员。<br> \2. 方法重写:子类可以重新定义父类中的方法，这样就会覆盖父类的方法，也称为“重写”</p>
<h3 id="查看类的继承层次结构"><a href="#查看类的继承层次结构" class="headerlink" title="查看类的继承层次结构"></a><strong>查看类的继承层次结构</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过类的方法 mro()或者类的属性__mro__可以输出这个类的继承层次结构。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">pass</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span><span class="keyword">pass</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B)</span>:</span><span class="keyword">pass</span></span><br><span class="line">print(C.mro())</span><br><span class="line"><span class="comment">#[&lt;class '__main__.C'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]</span></span><br><span class="line"><span class="comment">#c继承B，继承A，继承object</span></span><br></pre></td></tr></table></figure>

<h3 id="object-根类"><a href="#object-根类" class="headerlink" title="object 根类"></a><strong>object 根类</strong></h3><p>object 类是所有类的父类，因此所有的类都有 object 类的属性和方法。我们显然有必要深 入研究一下 object 类的结构。对于我们继续深入学习 Python 很有好处。</p>
<p><strong>dir()查看对象属性</strong></p>
<p>为了深入学习对象，我们先学习内置函数 dir()，他可以让我们方便的看到指定对象所有的 属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span> </span><br><span class="line">    self.name = name</span><br><span class="line"> 		self.age = age</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say_age</span><span class="params">(self)</span>:</span> </span><br><span class="line">    print(self.name,<span class="string">"的年龄是:"</span>,self.age)</span><br><span class="line">obj = object() </span><br><span class="line">print(dir(obj))</span><br><span class="line">s2 = Person(<span class="string">"高淇"</span>,<span class="number">18</span>)</span><br><span class="line">print(dir(s2))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;]</span><br><span class="line">[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;age&#39;, &#39;name&#39;, &#39;say_age&#39;]</span><br></pre></td></tr></table></figure>

<p>从上面我们可以发现这样几个要点: </p>
<ol>
<li>Person 对象增加了六个属性:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__dict__ __module__ __weakref__ age name say_age</span><br></pre></td></tr></table></figure>

<p>\2. object 的所有属性，Person 类作为 object 的子类，显然包含了所有的属性。<br> \3. 我们打印 age、name、say_age，发现 say_age 虽然是方法，实际上也是属性。只不过， 这个属性的类型是“method”而已。</p>
<p>age &lt;class ‘int’&gt;<br> name &lt;class ‘str’&gt;</p>
<p>say_age &lt;class ‘method’&gt;</p>
<h2 id="重写str-方法"><a href="#重写str-方法" class="headerlink" title="重写str()方法"></a><strong>重写<strong>str</strong>()方法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object 有一个__str__()方法，用于返回一个对于“对象的描述”，对应于内置函数 str() 经常用于 print()方法，帮助我们查看对象的信息。__str__()可以重写。</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"> <span class="string">'''将对象转化成一个字符串，一般用于 print 方法'''</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"名字是:&#123;0&#125;,年龄是&#123;1&#125;"</span>.format(self.name,self.__age)</span><br></pre></td></tr></table></figure>

<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a><strong>多重继承</strong></h2><p>Python 支持多重继承，一个子类可以有多个“直接父类”。这样，就具备了“多个父 类”的特点。但是由于，这样会被“类的整体层次”搞的异常复杂，尽量避免使用。<strong>class</strong> C(B,A):</p>
<h2 id="MRO"><a href="#MRO" class="headerlink" title="MRO()"></a><strong>MRO()</strong></h2><p>Python 支持多继承，如果父类中有相同名字的方法，在子类没有指定父类名时，解释器将 “从左向右”按顺序搜索。<br> MRO(Method Resolution Order):方法解析顺序。 我们可以通过 mro()方法获得 “类的层次结构”，方法解析顺序也是按照这个“类的层次结构”寻找的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">aa</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"aa"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span> </span><br><span class="line">    print(<span class="string">"say AAA!"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">bb</span><span class="params">(self)</span>:</span></span><br><span class="line">			print(<span class="string">"bb"</span>)</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span> </span><br><span class="line">      print(<span class="string">"say BBB!"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B,A)</span>:</span> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cc</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"cc"</span>)</span><br><span class="line">c = C()</span><br><span class="line">print(C.mro()) <span class="comment">#打印类的层次结构</span></span><br><span class="line">c.say() <span class="comment">#解释器寻找方法是“从左到右”的方式寻找，此时会执行 B 类中的 say()</span></span><br></pre></td></tr></table></figure>

<p>[&lt;class ‘<strong>main</strong>.C’&gt;, &lt;class ‘<strong>main</strong>.B’&gt;, &lt;class ‘<strong>main</strong>.A’&gt;, &lt;class ‘object’&gt;]<br>say BBB!</p>
<h2 id="super-获得父类定义"><a href="#super-获得父类定义" class="headerlink" title="super()获得父类定义"></a><strong>super()获得父类定义</strong></h2><p>在子类中，如果想要获得父类的方法时，我们可以通过 super()来做。super()代表父类的定义，不是父类对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def say(self):</span><br><span class="line"> #A.say(self) 调用父类的 say 方法 </span><br><span class="line"> super().say() #通过 super()调用父类的方法</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h2><p>多态(polymorphism)是指同一个方法调用由于对象不同可能会产生不同的行为。在现实 生活中，我们有很多例子。比如:同样是调用人的休息方法，张三的休息是睡觉，李四的休 息是玩游戏，高淇老师是敲代码。同样是吃饭的方法，中国人用筷子吃饭，英国人用刀叉吃 饭，印度人用手吃饭。</p>
<p>关于多态要注意以下 2 点:<br> \1. 多态是方法的多态，属性没有多态。<br> \2. 多态的存在有 2 个必要条件:继承、方法重写。</p>
<h2 id="特殊方法和运算符重载"><a href="#特殊方法和运算符重载" class="headerlink" title="特殊方法和运算符重载"></a><strong>特殊方法和运算符重载</strong></h2><p>Python 的运算符实际上是通过调用对象的特殊方法实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span> </span><br><span class="line">b = <span class="number">30</span></span><br><span class="line">c = a+b</span><br><span class="line">d = a.__add__(b) </span><br><span class="line">print(<span class="string">"c="</span>,c)</span><br><span class="line">print(<span class="string">"d="</span>,d)</span><br><span class="line"><span class="comment">#运算结果: c= 50</span></span><br><span class="line">d= <span class="number">50</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">常见的特殊方法统计如下:</span><br><span class="line"></span><br><span class="line">__init__  构造方法      对象创建:p &#x3D; Person()</span><br><span class="line">__del__  析构方法 对象回收</span><br><span class="line">__repr__,__str__  打印，转换     rint(a)</span><br><span class="line">__call__ 函数调用 a()</span><br><span class="line">__getattr__ 点号运算 a.xxx</span><br><span class="line">__setattr__ 属性赋值 a.xxx &#x3D; value</span><br><span class="line">__getitem__ 索引运算 a[key]</span><br><span class="line">__setitem__ 索引赋值 a[key]&#x3D;value</span><br><span class="line">__len__ 长度 len(a)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运算符+ __add__ 加法</span><br><span class="line">运算符- __sub__ 减法</span><br><span class="line">&lt;,&lt;&#x3D;,&#x3D;&#x3D;  __lt__,__le__，__eq__ 比较运算符</span><br><span class="line">&gt;,&gt;&#x3D;,!&#x3D; __gt__,__ge__,__ne__ 比较运算符</span><br><span class="line">|,^,&amp; __or__,__xor__,__and__  或、异或、与</span><br><span class="line">&lt;&lt;,&gt;&gt; __lshift__,__rshift__ 左移、右移</span><br><span class="line">*,&#x2F;,%,&#x2F;&#x2F; __mul__,__truediv__,__mod__,_ _floordiv__ 乘、浮点除、模运算 (取余)、整数除</span><br><span class="line">** __pow__ 指数运算</span><br></pre></td></tr></table></figure>

<p>我们可以重写上面的特殊方法，即实现了“运算符的重载”。</p>
<h2 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a><strong>特殊属性</strong></h2><p>Python 对象中包含了很多双下划线开始和结束的属性，这些是特殊属性，有特殊用法。这 里我们列出常见的特殊属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">obj.__dict__对象的属性字典</span><br><span class="line">obj.__class__对象所属的类</span><br><span class="line">class.__bases__类的基类元组(多继承)</span><br><span class="line">class.__base__类的基类</span><br><span class="line">class.__mro__类层次结构</span><br><span class="line">class.__subclasses__()子类列表</span><br><span class="line">print(dir(c)) </span><br><span class="line">print(c.__dict__) </span><br><span class="line">print(c.__class__) </span><br><span class="line">print(C.__bases__) </span><br><span class="line">print(C.mro()) </span><br><span class="line">print(A.__subclasses__())</span><br></pre></td></tr></table></figure>

<p><strong>对象的浅拷贝和深拷贝</strong></p>
<p><strong>·变量的赋值操作</strong></p>
<p>只是形成两个变量，实际还是指向同一个对象。</p>
<p><strong>·浅拷贝</strong></p>
<p>Python 拷贝一般都是浅拷贝。拷贝时，对象包含的子对象内容不拷贝。因此，源对象 和拷贝对象会引用同一个子对象。<br> <strong>·深拷贝</strong></p>
<p>使用 copy 模块的 deepcopy 函数，递归拷贝对象中包含的子对象。源对象和拷贝对象 所有的子对象也不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">m2 &#x3D; copy.copy(m) #m2 是新拷贝的另一个手机对象</span><br><span class="line">m3 &#x3D; copy.deepcopy(m)</span><br></pre></td></tr></table></figure>

<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a><strong>组合</strong></h2><p>“is-a”关系，我们可以使用“继承”。从而实现子类拥有的父类的方法和属性。“is-a” 关系指的是类似这样的关系:狗是动物，dog is animal。狗类就应该继承动物类。</p>
<p>“has-a”关系，我们可以使用“组合”，也能实现一个类拥有另一个类的方法和属性。” has-a”关系指的是这样的关系:手机拥有 CPU。 MobilePhone has a CPU。self.cpu=cpu</p>
<h2 id="设计模式-工厂模式实现"><a href="#设计模式-工厂模式实现" class="headerlink" title="设计模式_工厂模式实现"></a><strong>设计模式_工厂模式实现</strong></h2><p>设计模式是面向对象语言特有的内容，是我们在面临某一类问题时候固定的做法，设计 模式有很多种，比较流行的是:GOF(Goup Of Four)23 种设计模式。当然，我们没有 必要全部学习，学习几个常用的即可。</p>
<p>对于初学者，我们学习两个最常用的模式:工厂模式和单例模式。</p>
<p>工厂模式实现了创建者和调用者的分离，使用专门的工厂类将选择实现类、创建对象进 行统一的管理和控制。</p>
<h2 id="设计模式-单例模式实现"><a href="#设计模式-单例模式实现" class="headerlink" title="设计模式_单例模式实现"></a><strong>设计模式_单例模式实现</strong></h2><p>单例模式(Singleton Pattern)的核心作用是确保一个类只有一个实例，并且提供一 个访问该实例的全局访问点。</p>
<p>单例模式只生成一个实例对象，减少了对系统资源的开销。当一个对象的产生需要比较 多的资源，如读取配置文件、产生其他依赖对象时，可以产生一个“单例对象”，然后永久 驻留内存中，从而极大的降低开销。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单例模式有多种实现的方式，我们这里推荐重写__new__()的方法。</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/python400%E9%9B%862/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/python400%E9%9B%862/" class="post-title-link" itemprop="url">python400集2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 15:09:25" itemprop="dateCreated datePublished" datetime="2020-04-29T15:09:25-05:00">2020-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-30 13:07:49" itemprop="dateModified" datetime="2020-04-30T13:07:49-05:00">2020-04-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="python基础入门"><a href="#python基础入门" class="headerlink" title="python基础入门"></a>python基础入门</h1><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>python 中常用的序列结构有:</p>
<p>字符串、列表、元组、字典、集合</p>
<h2 id="列表简介"><a href="#列表简介" class="headerlink" title="列表简介"></a><strong>列表简介</strong></h2><p><strong>列表:用于存储任意数目、任意类型的数据集合。</strong></p>
<p>列表是内置可变序列，是包含多个元素的有序连续的内存空间。列表定义的标准语法格式: a = [10,20,30,40]</p>
<p>其中，10,20,30,40 这些称为:列表 a 的元素。 列表中的元素可以各不相同，可以是任意类型。比如:</p>
<p>a = [10,20,’abc’,True] 列表对象的常用方法汇总如下，方便大家学习和查阅。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>要点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>list.append(x)</td>
<td>增加元素</td>
<td>将元素 x 增加到列表 list 尾部</td>
</tr>
<tr>
<td>list.extend(aList)</td>
<td>增加元素</td>
<td>将列表 alist 所有元素加到列表 list 尾部</td>
</tr>
<tr>
<td>list.insert(index,x)</td>
<td>增加元素</td>
<td>在列表 list 指定位置 index 处插入元素 x</td>
</tr>
<tr>
<td>list.remove(x)</td>
<td>删除元素</td>
<td>在列表 list 中删除首次出现的指定元素 x</td>
</tr>
<tr>
<td>list.pop([index])</td>
<td>删除元素</td>
<td>删除并返回列表 list 指定为止 index 处的元素，默认是 最后一个元素</td>
</tr>
<tr>
<td>list.clear()</td>
<td>删除所有元素</td>
<td>删除列表所有元素，并不是删除列表对象</td>
</tr>
<tr>
<td>list.index(x)</td>
<td>访问元素</td>
<td>返回第一个 x 的索引位置，若不存在 x 元素抛出异常</td>
</tr>
<tr>
<td>list.count(x)</td>
<td>计数</td>
<td>返回指定元素 x 在列表 list 中出现的次数</td>
</tr>
<tr>
<td>len(list)</td>
<td>列表长度</td>
<td><code>返回列表中包含元素的个数</code></td>
</tr>
<tr>
<td>list.reverse()</td>
<td>翻转列表</td>
<td>所有元素原地翻转</td>
</tr>
<tr>
<td>list.sort()</td>
<td>排序</td>
<td>所有元素原地排序</td>
</tr>
<tr>
<td>list.copy()</td>
<td>浅拷贝</td>
<td>返回列表对象的浅拷贝</td>
</tr>
</tbody></table>
<p>Python 的列表大小可变，根据需要随时增加或缩小。</p>
<p>字符串和列表都是序列类型，一个字符串是一个字符序列，一个列表是任何元素的序列。我 们前面学习的很多字符串的方法，在列表中也有类似的用法，几乎一模一样。</p>
<p><strong>列表的创建</strong></p>
<h5 id="基本语法-创建"><a href="#基本语法-创建" class="headerlink" title="基本语法[]创建"></a><strong>基本语法[]创建</strong></h5><p><strong>list()创建</strong>: 使用 list()可以将任何可迭代的数据转化成列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; list(&quot;gaoqi,sxt&quot;)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[&#39;g&#39;, &#39;a&#39;, &#39;o&#39;, &#39;q&#39;, &#39;i&#39;, &#39;,&#39;, &#39;s&#39;, &#39;x&#39;, &#39;t&#39;]</span><br></pre></td></tr></table></figure>

<p><strong>range()创建整数列表</strong></p>
<p>range()可以帮助我们非常方便的创建整数列表，这在开发中及其有用。语法格式为: range([start,] end [,step])</p>
<p>start 参数:可选，表示起始数字。默认是 0<br> end 参数:必选，表示结尾数字。<br> step 参数:可选，表示步长，默认为 1<br> python3 中 range()返回的是一个 range 对象，而不是列表。我们需要通过 list()方法将其 转换成列表对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(3,15,2))</span><br><span class="line">[3, 5, 7, 9, 11, 13]</span><br></pre></td></tr></table></figure>

<p><strong>推导式生成列表</strong></p>
<p>使用列表推导式可以非常方便的创建列表，在开发中经常使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> a &#x3D; [x*2 for x in range(100) if x%9&#x3D;&#x3D;0] #通过 if 过滤元素 </span><br><span class="line"> &gt;&gt;&gt; a</span><br><span class="line">[0, 18, 36, 54, 72, 90, 108, 126, 144, 162, 180, 198]</span><br></pre></td></tr></table></figure>

<p><strong>列表元素的增加和删除</strong></p>
<p>当列表增加和删除元素时，列表会自动进行内存管理，大大减少了程序员的负担。但这 个特点涉及列表元素的大量移动，效率较低。除非必要，我们一般只在列表的尾部添加元素 或删除元素，这会大大提高列表的操作效率。</p>
<p><strong>append()方法</strong></p>
<p>原地修改列表对象，是真正的列表尾部添加新的元素，速度最快，推荐使用。 a.append(80)</p>
<p><strong>+运算符操作</strong></p>
<p>并不是真正的尾部添加元素，而是创建新的列表对象;将原列表的元素和新列表的元素依次 复制到新的列表对象中。这样，会涉及大量的复制操作，对于操作大量元素不建议使用。a = a+[50]</p>
<p><strong>extend()方法</strong></p>
<p>将目标列表的所有元素添加到本列表的尾部，属于原地操作，不创建新的列表对象。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [20,40]</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">46016072</span><br><span class="line">&gt;&gt;&gt; a.extend([50,60])</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">46016072</span><br></pre></td></tr></table></figure>

<p><strong>insert()插入元素</strong></p>
<p>使用 insert()方法可以将指定的元素插入到列表对象的任意制定位置。这样会让插入位置后 面所有的元素进行移动，会影响处理速度。涉及大量元素时，尽量避免使用。类似发生这种 移动的函数还有:remove()、pop()、del()，它们在删除非尾部元素时也会发生操作位置后 面元素的移动。</p>
<p>a.insert(2,100)#在index2处加入100</p>
<p><strong>乘法扩展</strong></p>
<p>使用乘法扩展列表，生成一个新列表，新列表元素时原列表元素的多次重复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b &#x3D; a*3 </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[&#39;sxt&#39;, 100] </span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[&#39;sxt&#39;, 100, &#39;sxt&#39;, 100, &#39;sxt&#39;, 100]</span><br></pre></td></tr></table></figure>

<p><strong>列表元素的删除 del 删除</strong></p>
<p>删除列表指定位置的元素。del a[1]</p>
<p><strong>pop()方法</strong></p>
<p>pop()删除并返回指定位置元素，如果未指定位置则默认操作列表最后一个元素。</p>
<p>a.pop(1)#返回index 1的元素</p>
<p><strong>remove()方法</strong></p>
<p>删除首次出现的指定元素，若不存在该元素抛出异常。a.remove(20)</p>
<h3 id="列表元素访问和计数"><a href="#列表元素访问和计数" class="headerlink" title="列表元素访问和计数"></a>列表元素访问和计数</h3><p>我们可以通过索引直接访问元素。索引的区间在[0, 列表长度-1]这个范围。超过这个范围则 会抛出异常。</p>
<p><strong>index()获得指定元素在列表中首次出现的索引</strong></p>
<p>index()可以获取指定元素首次出现的索引位置。语法是:index(value,[start,[end]])。其中， start 和 end 指定了搜索的范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a.index(30,5,7) #从索引位置 5 到 7 这个区间，第一次出现 30 元素的位置</span><br></pre></td></tr></table></figure>

<p><strong>count()获得指定元素在列表中出现的次数</strong></p>
<p>count()可以返回指定元素在列表中出现的次数。 a.count(20)</p>
<p><strong>len()返回列表长度</strong></p>
<p>len()返回列表长度，即列表中包含元素的个数。 len(a)</p>
<p><strong>成员资格判断</strong></p>
<p>判断列表中是否存在指定的元素，我们可以使用 count()方法，返回 0 则表示不存在，返回 大于 0 则表示存在。但是，一般我们会使用更加简洁的 in 关键字来判断，直接返回 True 或 False。100 not in a</p>
<ol>
<li><p><strong>切片操作</strong></p>
<p>我们在前面学习字符串时，学习过字符串的切片操作，对于列表的切片操作和字符串类似。 切片是 Python 序列及其重要的操作，适用于列表、元组、字符串等等。切片的格式如下:</p>
<p>切片 slice 操作可以让我们快速提取子列表或修改。标准格式为: [起始偏移量 start:终止偏移量 end[:步长 step]]</p>
<p>注:当步长省略时顺便可以省略第二个冒号</p>
<table>
<thead>
<tr>
<th>操作和说明</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>[:] 提取整个列表</td>
<td>[10,20,30][:]</td>
<td>[10,20,30]</td>
</tr>
<tr>
<td>[start:]从 start 索引开始到 结尾</td>
<td>[10,20,30][1:]</td>
<td>[20,30]</td>
</tr>
<tr>
<td>[:end]从头开始知道 end-1</td>
<td>[10,20,30][:2]</td>
<td>[10,20]</td>
</tr>
<tr>
<td>[start:end]从 start 到 end-1</td>
<td>[10,20,30,40][1:3]</td>
<td>[20,30]</td>
</tr>
<tr>
<td>[start:end:step] 从 start 提 取到 end-1，步长是 step</td>
<td>[10,20,30,40,50,60,70][1:6: 2]</td>
<td>[20, 40, 60]</td>
</tr>
</tbody></table>
</li>
</ol>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>[10,20,30,40,50,60,70][-3:]</td>
<td>倒数三个</td>
<td>[50,60,70]</td>
</tr>
<tr>
<td>10,20,30,40,50,60,70][-5:-3]</td>
<td>倒数第五个到倒数 第三个(包头不包尾)</td>
<td>[30,40]</td>
</tr>
<tr>
<td>[10,20,30,40,50,60,70][::-1]</td>
<td>步长为负，从右到左 反向提取</td>
<td>[70, 60, 50, 40, 30, 20, 10]</td>
</tr>
</tbody></table>
<p>切片操作时，起始偏移量和终止偏移量不在[0,字符串长度-1]这个范围，也不会报错。起始 偏移量小于 0 则会当做 0，终止偏移量大于“长度-1”会被当成”长度-1”</p>
<p><strong>列表的遍历</strong></p>
<p>for obj in listObj: print(obj)</p>
<h3 id="复制列表所有的元素到新列表对象"><a href="#复制列表所有的元素到新列表对象" class="headerlink" title="复制列表所有的元素到新列表对象"></a>复制列表所有的元素到新列表对象</h3><p>我们可以通过如下简单方式，实现列表元素内容的复制: list1 = [30,40,50]</p>
<p>list2 = [] + list1</p>
<h3 id="列表排序"><a href="#列表排序" class="headerlink" title="*列表排序 *"></a>*<em>列表排序 *</em></h3><p><strong>修改原列表，不建新列表的排序</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [20,10,30,40]</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">46017416</span><br><span class="line">&gt;&gt;&gt; a.sort() #默认是升序排列 </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[10, 20, 30, 40]</span><br><span class="line">&gt;&gt;&gt; a &#x3D; [10,20,30,40] </span><br><span class="line">&gt;&gt;&gt; a.sort(reverse&#x3D;True) #降序</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[40, 30, 20, 10]</span><br><span class="line">&gt;&gt;&gt; import random </span><br><span class="line">&gt;&gt;&gt; random.shuffle(a) #打乱排序</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[20, 40, 30, 10]</span><br></pre></td></tr></table></figure>

<h3 id="建新列表排序"><a href="#建新列表排序" class="headerlink" title="建新列表排序"></a>建新列表排序</h3><p>我们也可以通过内置函数 sorted()进行排序，这个方法返回新列表，不对原列表做修改。</p>
<p> a = sorted(a)</p>
<p> c = sorted(a,reverse=True)   #降序</p>
<p><strong>reversed()返回迭代器</strong></p>
<p>内置函数 reversed()也支持进行逆序排列，与列表对象 reverse()方法不同的是，内置函数 reversed()不对原列表做任何修改，只是返回一个逆序排列的迭代器对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">20</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">40</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = reversed(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">&lt;list_reverseiterator object at <span class="number">0x0000000002BCCEB8</span>&gt; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(c)</span><br><span class="line">[<span class="number">40</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(c)</span><br><span class="line">[]</span><br><span class="line">···</span><br><span class="line">我们打印输出 c 发现提示是:list_reverseiterator。也就是一个迭代对象。同时，我们使用 list(c)进行输出，发现只能使用一次。第一次输出了元素，第二次为空。那是因为迭代对象 在第一次时已经遍历结束了，第二次不能再使用。</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p><strong>列表相关的其他内置函数汇总 max 和 min</strong></p>
<p>用于返回列表中最大和最小值。max（a）</p>
<p><strong>sum</strong></p>
<p>对数值型列表的所有元素进行求和操作，对非数值型列表运算则会报错。</p>
<h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 tuple"></a><strong>元组 tuple</strong></h2><p>列表属于可变序列，可以任意修改列表中的元素。元组属于不可变序列，不能修改元组中的 元素。因此，元组没有增加元素、修改元素、删除元素相关的方法。</p>
<p>因此，我们只需要学习元组的创建和删除，元组中元素的访问和计数即可。元组支持如 下操作:</p>
<p>\1. 索引访问<br> \2. 切片操作<br> \3. 连接操作<br> \4. 成员关系操作<br> \5. 比较运算操作<br> \6. 计数:元组长度 len()、最大值 max()、最小值 min()、求和 sum()等。</p>
<h3 id="元组的创建"><a href="#元组的创建" class="headerlink" title="元组的创建"></a><strong>元组的创建</strong></h3><p>\1. 通过()创建元组。小括号可以省略。</p>
<p> 如果元组只有一个元素，则必须后面加逗号。这是因为解释器会把(1)解释为整数 1，(1,) 解释为元组。</p>
<p>a = (10,20,30) 或者 a = 10,20,30</p>
<p>\2. 通过 tuple()创建元组 tuple(可迭代的对象)</p>
<p>tuple()可以接收列表、字符串、其他序列类型、迭代器等生成元组。 list()可以接收元组、字符串、其他序列类型、迭代器等生成列表。</p>
<h3 id="元组的元素访问和计数"><a href="#元组的元素访问和计数" class="headerlink" title="元组的元素访问和计数"></a><strong>元组的元素访问和计数</strong></h3><p>\1. 元组的元素不能修改</p>
<p>\2. 元组的元素访问和列表一样，只不过返回的仍然是元组对象。</p>
<p>\3. 列表关于排序的方法 list.sorted()是修改原列表对象，元组没有该方法。如果要对元组排 序，只能使用内置函数 sorted(tupleObj)，并生成新的列表对象。 sorted(a)</p>
<p><strong>zip</strong></p>
<p>zip(列表 1，列表 2，…)将多个列表对应位置的元素组合成为元组，并返回这个 zip 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [10,20,30]</span><br><span class="line">&gt;&gt;&gt; b &#x3D; [40,50,60]</span><br><span class="line">&gt;&gt;&gt; c &#x3D; [70,80,90]</span><br><span class="line">&gt;&gt;&gt; d &#x3D; zip(a,b,c)</span><br><span class="line">&gt;&gt;&gt; list(d)</span><br><span class="line">[(10, 40, 70), (20, 50, 80), (30, 60, 90)]</span><br></pre></td></tr></table></figure>

<p><strong>生成器推导式创建元组</strong></p>
<p>从形式上看，生成器推导式与列表推导式类似，只是生成器推导式使用小括号。列表推 导式直接生成列表对象，生成器推导式生成的不是列表也不是元组，而是一个生成器对象。</p>
<p>我们可以通过生成器对象，转化成列表或者元组。也可以使用生成器对象的<strong>next</strong>() 方法进行遍历，或者直接作为迭代器对象来使用。不管什么方式使用，元素访问结束后，如 果需要重新访问其中的元素，必须重新创建该生成器对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; (x*2 for x in range(5))</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x0000000002BDEB48&gt;</span><br><span class="line">&gt;&gt;&gt; tuple(s)</span><br><span class="line">(0, 2, 4, 6, 8)</span><br><span class="line">&gt;&gt;&gt; list(s) #只能访问一次元素。第二次就为空了。需要再生成一次 </span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x0000000002BDEB48&gt;</span><br><span class="line">&gt;&gt;&gt; tuple(s)</span><br><span class="line">()</span><br><span class="line">&gt;&gt;&gt; s &#x3D; (x*2 for x in range(5))</span><br><span class="line">&gt;&gt;&gt; s.__next__()</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; s.__next__()</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; s.__next__()</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><strong>元组总结</strong></p>
<p>\1. 元组的核心特点是:不可变序列。<br> \2. 元组的访问和处理速度比列表快。<br> \3. 与整数和字符串一样，元组可以作为字典的键，列表则永远不能作为字典的键使用。</p>
<h2 id="字典介绍"><a href="#字典介绍" class="headerlink" title="字典介绍"></a><strong>字典介绍</strong></h2><p>字典是“键值对”的无序可变序列，字典中的每个元素都是一个“键值对”，包含:“键 对象”和“值对象”。可以通过“键对象”实现快速获取、删除、更新对应的“值对象”。</p>
<p>列表中我们通过“下标数字”找到对应的对象。字典中通过“键对象”找到对应的“值 对象”。“键”是任意的不可变数据，比如:整数、浮点数、字符串、元组。但是:列表、 字典、集合这些可变对象，不能作为“键”。并且“键”不可重复。</p>
<p>“值”可以是任意的数据，并且可重复。</p>
<p><strong>字典的创建</strong></p>
<p>\1. 我们可以通过{}、dict()来创建字典对象。</p>
<p>\2. 通过 zip()创建字典对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; k &#x3D; [&#39;name&#39;,&#39;age&#39;,&#39;job&#39;]</span><br><span class="line">&gt;&gt;&gt; v &#x3D; [&#39;gaoqi&#39;,18,&#39;techer&#39;]</span><br><span class="line">&gt;&gt;&gt; d &#x3D; dict(zip(k,v))</span><br></pre></td></tr></table></figure>

<p>\3. 通过 fromkeys 创建值为空的字典</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; dict.fromkeys([&#39;name&#39;,&#39;age&#39;,&#39;job&#39;]) </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#39;name&#39;: None, &#39;age&#39;: None, &#39;job&#39;: None&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字典元素的访问</strong></p>
<p>\1. 通过 [键] 获得“值”。若键不存在，则抛出异常。 a[‘name’]</p>
<p>\2. 通过 get()方法获得“值”。推荐使用。优点是:指定键不存在，返回 None;也可以设 定指定键不存在时默认返回的对象。推荐使用 get()获取“值对象”。a.get(‘name’)</p>
<p>\3. 列出所有的键值对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a.items()</span><br><span class="line">dict_items([(&#39;name&#39;, &#39;gaoqi&#39;), (&#39;age&#39;, 18), (&#39;job&#39;, &#39;programmer&#39;)])</span><br></pre></td></tr></table></figure>

<p>\4. 列出所有的键，列出所有的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a.keys()</span><br><span class="line">dict_keys([&#39;name&#39;, &#39;age&#39;, &#39;job&#39;])</span><br><span class="line">&gt;&gt;&gt; a.values()</span><br><span class="line">dict_values([&#39;gaoqi&#39;, 18, &#39;programmer&#39;])</span><br></pre></td></tr></table></figure>

<p>\5. len() 键值对的个数<br> \6. 检测一个“键”是否在字典中 用in</p>
<h3 id="字典元素添加、修改、删除"><a href="#字典元素添加、修改、删除" class="headerlink" title="字典元素添加、修改、删除"></a><strong>字典元素添加、修改、删除</strong></h3><p>\1. 给字典新增“键值对”。如果“键”已经存在，则覆盖旧的键值对;如果“键”不存在， 则新增“键值对”。a[‘age’]=16</p>
<p>\2. 使用 update()将新字典中所有键值对全部添加到旧字典对象上。如果 key 有重复，则直 接覆盖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &#123;&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;job&#39;:&#39;programmer&#39;&#125; </span><br><span class="line">&gt;&gt;&gt; b &#x3D; &#123;&#39;name&#39;:&#39;gaoxixi&#39;,&#39;money&#39;:1000,&#39;sex&#39;:&#39;男的&#39;&#125; </span><br><span class="line">&gt;&gt;&gt; a.update(b)</span><br></pre></td></tr></table></figure>

<p>\3. 字典中元素的删除，可以使用 del()方法;或者 clear()删除所有键值对;pop()删除指定 键值对，并返回对应的“值对象”;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; del(a[&#39;name&#39;])</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#39;age&#39;: 18, &#39;job&#39;: &#39;programmer&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; a.pop(&#39;age&#39;)</span><br></pre></td></tr></table></figure>

<p>\4. popitem() :随机删除和返回该键值对。字典是“无序可变序列”，因此没有第一个元 素、最后一个元素的概念;popitem 弹出随机的项，因为字典并没有”最后的元素”或者其 他有关顺序的概念。若想一个接一个地移除并处理项，这个方法就非常有效(因为不用首先获取键的列表)。</p>
<p> a.popitem()</p>
<p><strong>序列解包</strong></p>
<p>序列解包可以用于元组、列表、字典。序列解包可以让我们方便的对多个变量赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x,y,z&#x3D;(20,30,10)</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">30</span><br><span class="line">&gt;&gt;&gt; z</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; (a,b,c)&#x3D;(9,8,10) </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; [a,b,c]&#x3D;[10,20,30] </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<p>序列解包用于字典时，默认是对“键”进行操作; 如果需要对键值对操作，则需要使用 items();如果需要对“值”进行操作，则需要使用 values();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; &#123;&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;job&#39;:&#39;teacher&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; name,age,job&#x3D;s #默认对键进行操作 </span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">&#39;name&#39;</span><br><span class="line">&gt;&gt;&gt; name,age,job&#x3D;s.items() </span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">(&#39;name&#39;, &#39;gaoqi&#39;)</span><br><span class="line">&gt;&gt;&gt; name,age,job&#x3D;s.values() </span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">&#39;gaoqi&#39;</span><br></pre></td></tr></table></figure>

<h3 id="字典核心底层原理-重要"><a href="#字典核心底层原理-重要" class="headerlink" title="字典核心底层原理(重要)"></a><strong>字典核心底层原理(重要)</strong></h3><p>字典对象的核心是散列表。散列表是一个稀疏数组(总是有空白元素的数组)，数组的 每个单元叫做 bucket。每个 bucket 有两部分:一个是键对象的引用，一个是值对象的引 用。<br> 由于，所有 bucket 结构和大小一致，我们可以通过偏移量来读取指定 bucket。</p>
<p><strong>扩容</strong></p>
<p>python 会根据散列表的拥挤程度扩容。“扩容”指的是:创造更大的数组，将原有内容 拷贝到新数组中。</p>
<p>接近 2/3 时，数组就会扩容。</p>
<p>用法总结:<br> \1. 键必须可散列</p>
<p>(1) 数字、字符串、元组，都是可散列的。 </p>
<p>(2) 自定义对象需要支持下面三点:</p>
<ol>
<li>1  支持 hash()函数</li>
<li>2  支持通过<strong>eq</strong>()方法检测相等性。</li>
<li>3  若 a==b 为真，则 hash(a)==hash(b)也为真。</li>
</ol>
<p>\2. 字典在内存中开销巨大，典型的空间换时间。<br> \3. 键查询速度很快<br> \4. 往字典里面添加新建可能导致扩容，导致散列表中键的次序变化。因此，不要在遍历字 典的同时进行字典的修改。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h2><p><strong>集合创建和删除</strong></p>
<p>\1. 使用{}创建集合对象，并使用 add()方法添加元素</p>
<p>\2. 使用 set()，将列表、元组等可迭代对象转成集合。如果原来数据存在重复数据，则只保 留一个。</p>
<p>\3. remove()删除指定元素;clear()清空整个集合</p>
<p><strong>集合相关操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &#123;1,3,&#39;sxt&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; &#123;&#39;he&#39;,&#39;it&#39;,&#39;sxt&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a|b #并集</span><br><span class="line">&#123;1, 3, &#39;sxt&#39;, &#39;he&#39;, &#39;it&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a&amp;b #交集 </span><br><span class="line">&#123;&#39;sxt&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a-b #差集 </span><br><span class="line">&#123;1, 3&#125;</span><br><span class="line">&gt;&gt;&gt; a.union(b) #并集 </span><br><span class="line">&#123;1, 3, &#39;sxt&#39;, &#39;he&#39;, &#39;it&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a.intersection(b) #交集 </span><br><span class="line">&#123;&#39;sxt&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a.difference(b) #差集 </span><br><span class="line">&#123;1, 3&#125;</span><br></pre></td></tr></table></figure>

<h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="三元条件运算符"><a href="#三元条件运算符" class="headerlink" title="三元条件运算符"></a><strong>三元条件运算符</strong></h2><p>Python 提供了三元运算符，用来在某些简单双分支赋值情况。三元条件运算符语法格式如 下:</p>
<h3 id="条件为真时的值-if-条件表达式-else-条件为假时的值"><a href="#条件为真时的值-if-条件表达式-else-条件为假时的值" class="headerlink" title="条件为真时的值 if (条件表达式) else 条件为假时的值"></a>条件为真时的值 if (条件表达式) else 条件为假时的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print( num if int(num)&lt;10 else &quot;数字太大&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>可迭代对象</strong></p>
<p>Python 包含以下几种可迭代对象: </p>
<ol>
<li>​    序列。包含:字符串、列表、元组 </li>
<li><ol start="2">
<li>字典</li>
<li>. 迭代器对象(iterator)<br>  \4. 生成器函数(generator)<br>  \5. 文件对象</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for x in print(x)</span><br><span class="line">for x in print(x)</span><br><span class="line">d.keys():#遍历字典所有的 key</span><br><span class="line">d.values():#遍历字典所有的 value</span><br><span class="line">for x in d.items():#遍历字典所有的&quot;键值对&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【操作】利用嵌套循环打印九九乘法表</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">		<span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">			print(<span class="string">"&#123;0&#125;*&#123;1&#125;=&#123;2&#125;"</span>.format(m,n,(m*n)),end=<span class="string">"\t"</span>) </span><br><span class="line">		print()</span><br></pre></td></tr></table></figure>

<p><strong>使用 zip()并行迭代</strong></p>
<p>我们可以通过 zip()函数对多个序列进行并行迭代，zip()函数在最短序列“用完”时就会停止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names &#x3D; (&quot;高淇&quot;,&quot;高老二&quot;,&quot;高老三&quot;,&quot;高老四&quot;) </span><br><span class="line">ages &#x3D; (18,16,20,25)</span><br><span class="line">jobs &#x3D; (&quot;老师&quot;,&quot;程序员&quot;,&quot;公务员&quot;)</span><br><span class="line">for name,age,job in zip(names,ages,jobs): </span><br><span class="line">	print(&quot;&#123;0&#125;--&#123;1&#125;--&#123;2&#125;&quot;.format(name,age,job))</span><br></pre></td></tr></table></figure>

<p><strong>推导式创建序列</strong></p>
<p>推导式是从一个或者多个迭代器快速创建序列的一种方法。它可以将循环和条件判断结合， 从而避免冗长的代码。推导式是典型的 Python 风格，会使用它代表你已经超过 Python 初 学者的水平。</p>
<p><strong>列表推导式</strong></p>
<p>列表推导式生成列表对象，语法如下:<br> [表达式 for item in 可迭代对象 ]</p>
<p>或者:{表达式 for item in 可迭代对象 if 条件判断}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; [x for x in range(1,5)] </span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; [x*2 for x in range(1,5)]</span><br><span class="line">[2, 4, 6, 8]</span><br><span class="line">&gt;&gt;&gt; [x*2 for x in range(1,20) if x%5&#x3D;&#x3D;0 ] </span><br><span class="line">[10, 20, 30]</span><br><span class="line">&gt;&gt;&gt; [a for a in &quot;abcdefg&quot;]</span><br><span class="line">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span><br><span class="line">&gt;&gt;&gt; cells &#x3D; [(row,col) for row in range(1,10) for col in range(1,10)]</span><br><span class="line">#可以使用两个循环</span><br><span class="line">&gt;&gt;&gt; for cell in cells:</span><br><span class="line">print(cell)</span><br></pre></td></tr></table></figure>

<p><strong>字典推导式</strong></p>
<p>row in range(1,10) for col in range(1,10)]</p>
<p>#可以使用两</p>
<p>字典的推导式生成字典对象，格式如下:<br> {key_expression : value_expression for 表达式 in 可迭代对象}</p>
<p>类似于列表推导式，字典推导也可以增加 if 条件判断、多个 for 循环。</p>
<p>统计文本中字符出现的次数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\&gt;&gt;&gt; my_text &#x3D; &#39; i love you, i love sxt, i love gaoqi&#39;</span><br><span class="line">\&gt;&gt;&gt; char_count &#x3D; &#123;c:my_text.count(c) for c in my_text&#125;</span><br><span class="line">\&gt;&gt;&gt; char_count</span><br><span class="line">&#123;&#39; &#39;: 9, &#39;i&#39;: 4, &#39;l&#39;: 3, &#39;o&#39;: 5, &#39;v&#39;: 3, &#39;e&#39;: 3, &#39;y&#39;: 1, &#39;u&#39;: 1, &#39;,&#39;: 2, &#39;s&#39;: 1, &#39;x&#39;: 1, &#39;t&#39;: 1, &#39;g&#39;: 1, &#39;a&#39;: 1, &#39;q&#39;: 1&#125;</span><br></pre></td></tr></table></figure>

<p><strong>集合推导式</strong></p>
<p>集合推导式生成集合，和列表推导式的语法格式类似:<br> {表达式 for item in 可迭代对象 }</p>
<p>或者:{表达式 for item in 可迭代对象 if 条件判断}</p>
<p>&gt;&gt;&gt; {x for x in range(1,100) if x%9==0} {99, 36, 72, 9, 45, 81, 18, 54, 90, 27, 63}</p>
<h4 id="生成器推导式-生成元组"><a href="#生成器推导式-生成元组" class="headerlink" title="生成器推导式(生成元组)"></a>生成器推导式(生成元组)</h4><p>很多同学可能会问:“都有推导式，元组有没有?”，能不能用小括号呢? </p>
<p> (x for x in range(1,100) if x%9==0)<br> &lt;generator object <genexpr> at 0x0000000002BD3048&gt; </p>
<p>我们发现提示的是“一个生成器对象”。显然，元组是没有推导式的。</p>
<p>一个生成器只能运行一次。第一次迭代可以得到数据，第二次迭代发现数据已经没有了。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; gnt &#x3D; (x for x in range(1,100) if x%9&#x3D;&#x3D;0)</span><br><span class="line"> &gt;&gt;&gt; for x in gnt:</span><br><span class="line"></span><br><span class="line">print(x,end&#x3D;&#39; &#39;)</span><br><span class="line"> 9 18 27 36 45 54 63 72 81 90 99 </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; for x in gnt:</span><br><span class="line"></span><br><span class="line">print(x,end&#x3D;&#39; &#39;)</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Python 中函数分为如下几类: 1. 内置函数</p>
<p>我们前面使用的 str()、list()、len()等这些都是内置函数，我们可以拿来直接使用。</p>
<ol start="2">
<li>标准库函数</li>
</ol>
<p>我们可以通过 import 语句导入库，然后使用其中定义的函数 </p>
<ol start="3">
<li>第三方库函数</li>
</ol>
<p>Python 社区也提供了很多高质量的库。下载安装这些库后，也是通过 import 语句导 入，然后可以使用这些第三方库的函数</p>
<ol start="4">
<li>用户自定义函数</li>
</ol>
<p>用户自己定义的函数，显然也是开发中适应用户自身需求定义的函数。今天我们学习的 就是如何自定义函数。</p>
<h2 id="文档字符串-函数的注释"><a href="#文档字符串-函数的注释" class="headerlink" title="文档字符串(函数的注释)"></a><strong>文档字符串(函数的注释)</strong></h2><p>程序的可读性最重要，一般建议在函数体开始的部分附上函数定义说明，这就是“文档字符 串”，也有人成为“函数的注释”。我们通过三个单引号或者三个双引号来实现，中间可以</p>
<p>北京尚学堂·百战程序员 实战 系统 好教育</p>
<p>加入多行文字进行说明。</p>
<p><strong>函数也是对象，内存底层分析</strong></p>
<p>Python 中，“一切都是对象”。实际上，执行 def 定义函数后，系统就创建了相应的函数 对象。</p>
<h3 id="变量的作用域-全局变量和局部变量"><a href="#变量的作用域-全局变量和局部变量" class="headerlink" title="变量的作用域(全局变量和局部变量)"></a>变量的作用域<strong>(</strong>全局变量和局部变量<strong>)</strong></h3><p>变量起作用的范围称为变量的作用域，不同作用域内同名变量之间互不影响。变量分为:全局变量、局部变量。</p>
<p>全局变量:</p>
<p>\1. 在函数和类定义之外声明的变量。作用域为定义的模块，从定义位置开始直到模块 结束。</p>
<ol>
<li>全局变量降低了函数的通用性和可读性。应尽量避免全局变量的使用。</li>
<li>全局变量一般做常量使用。</li>
<li>函数内要改变全局变量的值，使用 global 声明一下</li>
</ol>
<p>局部变量:<br> \1. 在函数体中(包含形式参数)声明的变量。<br> \2. 局部变量的引用比全局变量快，优先考虑使用。<br> \3. 如果局部变量和全局变量同名，则在函数内隐藏全局变量，只使用同名的局部变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">100</span> <span class="comment">#全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> a <span class="comment">#如果要在函数内改变全局变量的值，增加 global 关键字声明</span></span><br><span class="line">	print(a) <span class="comment">#打印全局变量 a 的值, </span></span><br><span class="line">	a = <span class="number">300</span></span><br><span class="line">  print(a)<span class="comment">#局部变量a</span></span><br><span class="line">  print(locals())</span><br><span class="line">  print(globals())</span><br><span class="line">f1() </span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">```结果</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">300</span></span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': '/Users/mengxiaowang/Documents/a.py', 'a': 300, 'f1': &lt;function f1 at 0x7ff5602dc430&gt;&#125;</span><br><span class="line"><span class="number">300</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>另一种输出，因为local变global后没有了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">100</span> <span class="comment">#全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">300</span></span><br><span class="line">    print(locals())<span class="comment">#&#123;'a': 300&#125;</span></span><br><span class="line">    print(globals())<span class="comment">#&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'a': &lt;function a at 0x7f9388270830&gt;&#125;</span></span><br><span class="line">f1() </span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">```</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">300</span>&#125;</span><br><span class="line">&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': '/Users/mengxiaowang/Documents/a.py', 'a': 100, 'f1': &lt;function f1 at 0x7fc050745430&gt;&#125;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h3 id="局部变量和全局变量效率测试"><a href="#局部变量和全局变量效率测试" class="headerlink" title="局部变量和全局变量效率测试"></a>局部变量和全局变量效率测试</h3><p>局部变量的查询和访问速度比全局变量快，优先考虑使用，尤其是在循环的时候。 在特别强调效率的地方或者循环次数较多的地方，可以通过将全局变量转为局部变量提高运 行速度。</p>
<h3 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a><strong>参数的传递</strong></h3><p>函数的参数传递本质上就是:从实参到形参的赋值操作。 Python 中“一切皆对象”， 所有的赋值操作都是“引用的赋值”。所以，Python 中参数的传递都是“引用传递”，不 是“值传递”。具体操作时分为两类:</p>
<p>\1. 对“可变对象”进行“写操作”，直接作用于原对象本身。</p>
<p>\2. 对“不可变对象”进行“写操作”，会产生一个新的“对象空间”，并用新的值填 充这块空间。(起到其他语言的“值传递”效果，但不是“值传递”)</p>
<p>可变对象有: 字典、列表、集合、自定义的对象等</p>
<p>不可变对象有: 数字、字符串、元组、function 等</p>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a><strong>浅拷贝和深拷贝</strong></h3><p>为了更深入的了解参数传递的底层原理，我们需要讲解一下“浅拷贝和深拷贝”。我们可以 使用内置函数:copy(浅拷贝)、deepcopy(深拷贝)。</p>
<p>浅拷贝:不拷贝子对象的内容，只是拷贝子对象的引用。 深拷贝:会连子对象的内存也全部拷贝一份，对子对象的修改不会影响源对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testCopy</span><span class="params">()</span>:</span> <span class="string">'''测试浅拷贝'''</span></span><br><span class="line">	a = [<span class="number">10</span>, <span class="number">20</span>, [<span class="number">5</span>, <span class="number">6</span>]] </span><br><span class="line">  b = copy.copy(a)</span><br><span class="line">	print(<span class="string">"a"</span>, a) </span><br><span class="line">  print(<span class="string">"b"</span>, b) </span><br><span class="line">  b.append(<span class="number">30</span>) </span><br><span class="line">  b[<span class="number">2</span>].append(<span class="number">7</span>) </span><br><span class="line">  print(<span class="string">"浅拷贝......"</span>) </span><br><span class="line">  print(<span class="string">"a"</span>, a) </span><br><span class="line">  print(<span class="string">"b"</span>, b)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testDeepCopy</span><span class="params">()</span>:</span> <span class="string">'''测试深拷贝'''</span></span><br><span class="line">	a = [<span class="number">10</span>, <span class="number">20</span>, [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">  b = copy.deepcopy(a)</span><br><span class="line">	print(<span class="string">"a"</span>, a) </span><br><span class="line">  print(<span class="string">"b"</span>, b) </span><br><span class="line">  b.append(<span class="number">30</span>) </span><br><span class="line">  b[<span class="number">2</span>].append(<span class="number">7</span>) </span><br><span class="line">  print(<span class="string">"深拷贝......"</span>) </span><br><span class="line">  print(<span class="string">"a"</span>, a) </span><br><span class="line">  print(<span class="string">"b"</span>, b)</span><br><span class="line">testCopy() </span><br><span class="line">print(<span class="string">"*************"</span>) </span><br><span class="line">testDeepCopy()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">结果</span><br><span class="line"></span><br><span class="line">a [10, 20, [5, 6]]</span><br><span class="line">b [10, 20, [5, 6]]</span><br><span class="line">浅拷贝......</span><br><span class="line">a [10, 20, [5, 6, 7]]</span><br><span class="line">b [10, 20, [5, 6, 7], 30]</span><br><span class="line">   *************</span><br><span class="line">a [10, 20, [5, 6]]</span><br><span class="line">b [10, 20, [5, 6]] </span><br><span class="line">深拷贝......</span><br><span class="line">a [10, 20, [5, 6]]</span><br><span class="line">b [10, 20, [5, 6, 7], 30]</span><br></pre></td></tr></table></figure>

<h3 id="传递不可变对象包含的子对象是可变的情况"><a href="#传递不可变对象包含的子对象是可变的情况" class="headerlink" title="传递不可变对象包含的子对象是可变的情况"></a>传递不可变对象包含的子对象是可变的情况</h3><p>#传递不可变对象时。不可变对象里面包含的子对象是可变的。则 方法内修改了这个可变对象，源对象也发生了变化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">10</span>,<span class="number">20</span>,[<span class="number">5</span>,<span class="number">6</span>]) </span><br><span class="line">print(<span class="string">"a:"</span>,id(a))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test01</span><span class="params">(m)</span>:</span> </span><br><span class="line">	print(<span class="string">"m:"</span>,id(m)) </span><br><span class="line">  m[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">888</span> </span><br><span class="line">  print(m) </span><br><span class="line">  print(<span class="string">"m:"</span>,id(m))</span><br><span class="line">test01(a)</span><br><span class="line">print(a)</span><br><span class="line">运行结果:</span><br><span class="line">a: <span class="number">41611632</span></span><br><span class="line">m: <span class="number">41611632</span> </span><br><span class="line">  (<span class="number">10</span>, <span class="number">20</span>, [<span class="number">888</span>, <span class="number">6</span>]) </span><br><span class="line">  m: <span class="number">41611632</span> </span><br><span class="line">    (<span class="number">10</span>, <span class="number">20</span>, [<span class="number">888</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>

<p>id相对于c中地址符&amp;</p>
<h3 id="参数的几种类型"><a href="#参数的几种类型" class="headerlink" title="*参数的几种类型 *"></a>*<em>参数的几种类型 *</em></h3><p><strong>位置参数</strong></p>
<p>函数调用时，实参默认按位置顺序传递，需要个数和形参匹配。按位置传递的参数，称为: “位置参数”。</p>
<p><strong>默认值参数</strong></p>
<p>我们可以为某些参数设置默认值，这样这些参数在传递时就是可选的。称为“默认值参数”。 默认值参数放到位置参数后面。def f1(a,b,c=10,d=20): #默认值参数必须位于普通位置参数后面</p>
<p><strong>命名参数</strong></p>
<p>我们也可以按照形参的名称传递参数，称为“命名参数”，也称“关键字参数”。f1(8,9,19) #位置参数 f1(c=10,a=20,b=30) #命名参数</p>
<p><strong>强制命名参数</strong></p>
<p>在带星号的“可变参数”后面增加新的参数，必须在调用的时候“强制命名参数”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(*a,b,c)</span>:</span> </span><br><span class="line">	print(a,b,c)</span><br><span class="line"><span class="comment">#f1(2,3,4) #会报错。由于 a 是可变参数，将 2,3,4 全部收集。造成 b 和 c 没有赋值。 </span></span><br><span class="line">f1(<span class="number">2</span>,b=<span class="number">3</span>,c=<span class="number">4</span>)</span><br><span class="line">执行结果: (<span class="number">2</span>,) <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="lambda-表达式和匿名函数"><a href="#lambda-表达式和匿名函数" class="headerlink" title="lambda 表达式和匿名函数"></a><strong>lambda 表达式和匿名函数</strong></h2><p>lambda 表达式可以用来声明匿名函数。lambda 函数是一种简单的、在同一行中定义函数 的方法。lambda 函数实际生成了一个函数对象。<br> lambda 表达式只允许包含一个表达式，不能包含复杂语句，该表达式的计算结果就是函数 的返回值。</p>
<p>lambda 表达式的基本语法如下:<br> lambda arg1,arg2,arg3… : &lt;表达式&gt;</p>
<p>arg1/arg2/arg3 为函数的参数。&lt;表达式&gt;相当于函数体。运算结果是:表达式的运算结果。</p>
<p>g = [lambda a:a<em>2,lambda b:b</em>3,lambda c:c*4]</p>
<h3 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a><strong>eval()函数</strong></h3><p>功能:将字符串 str 当成有效的表达式来求值并返回计算结果。</p>
<p>语法: eval(source[, globals[, locals]]) -&gt; value</p>
<p>参数:<br> source:一个 Python 表达式或函数 compile()返回的代码对象 globals:可选。必须是 dictionary locals:可选。任意映射对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict1 = dict(a=<span class="number">100</span>,b=<span class="number">200</span>)</span><br><span class="line">d = eval(<span class="string">"a+b"</span>,dict1) </span><br><span class="line">print(d)<span class="comment">#eval 函数会将字符串当做语句来执行，因此会被注入安全隐患。比如:字符串中含有删除文 件的语句。那就麻烦大了。因此，使用时候，要慎重!!!</span></span><br></pre></td></tr></table></figure>

<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a><strong>递归函数</strong></h2><p>递归函数指的是:自己调用自己的函数，在函数体内部直接或间接的自己调用自己。递归类 似于大家中学数学学习过的“数学归纳法”。 每个递归函数必须包含两个部分:<br> \1. 终止条件</p>
<p>表示递归什么时候结束。一般用于返回值，不再调用自己。 2. 递归步骤</p>
<p>把第 n 步的值和第 n-1 步相关联。</p>
<p>递归函数由于会创建大量的函数对象、过量的消耗内存和运算能力。在处理大量数据时，谨 慎使用。</p>
<p><strong>嵌套函数(内部函数)</strong></p>
<p>嵌套函数: 在函数内部定义的函数!</p>
<p>一般在什么情况下使用嵌套函数? </p>
<ol>
<li>封装 - 数据隐藏外部无法访问“嵌套函数”。</li>
<li>贯彻 DRY(Don’t Repeat Yourself) 原则嵌套函数，可以让我们在函数内部避免重复代码。</li>
<li>闭包</li>
</ol>
<h3 id="nonlocal-关键字"><a href="#nonlocal-关键字" class="headerlink" title="nonlocal 关键字"></a><strong>nonlocal 关键字</strong></h3><p>nonlocal 用来声明外层的局部变量。 global 用来声明全局变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">  b=<span class="number">10</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">  	<span class="keyword">nonlocal</span> b<span class="comment">#声明外部函数的局部变量</span></span><br><span class="line">  	print(<span class="string">"inner b:"</span>,b)</span><br><span class="line"> 		b=<span class="number">20</span></span><br><span class="line">  	<span class="keyword">global</span> a<span class="comment">#声明全局变量</span></span><br><span class="line">  	a=<span class="number">1000</span></span><br><span class="line">	inner()</span><br><span class="line">	print(<span class="string">"outer b:"</span>,b)</span><br><span class="line">outer()</span><br><span class="line">print(<span class="string">"a:"</span>,a)</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">inner b: <span class="number">10</span></span><br><span class="line">outer b: <span class="number">20</span></span><br><span class="line">a: <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<h2 id="LEGB-规则"><a href="#LEGB-规则" class="headerlink" title="LEGB 规则"></a><strong>LEGB 规则</strong></h2><h3 id="Python-在查找“名称”时，是按照-LEGB-规则查找的-Local–-gt-Enclosed–-gt-Global–-gt-Built-in"><a href="#Python-在查找“名称”时，是按照-LEGB-规则查找的-Local–-gt-Enclosed–-gt-Global–-gt-Built-in" class="headerlink" title="Python 在查找“名称”时，是按照 LEGB 规则查找的: Local–&gt;Enclosed–&gt;Global–&gt;Built in"></a>Python 在查找“名称”时，是按照 LEGB 规则查找的: Local–&gt;Enclosed–&gt;Global–&gt;Built in</h3><p>Local 指的就是函数或者类的方法内部<br> Enclosed 指的是嵌套函数(一个函数包裹另一个函数，闭包) Global 指的是模块中的全局变量<br> Built in 指的是 Python 为自己保留的特殊名称。</p>
<p>如果某个 name 映射在局部(local)命名空间中没有找到，接下来就会在闭包作用域 (enclosed)进行搜索，如果闭包作用域也没有找到，Python 就会到全局(global)命名空 间中进行查找，最后会在内建(built-in)命名空间搜索 (如果一个名称在所有命名空间 中都没有找到，就会产生一个 NameError)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/python400%E9%9B%861/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/python400%E9%9B%861/" class="post-title-link" itemprop="url">python400集1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-29 15:09:21 / Modified: 16:25:10" itemprop="dateCreated datePublished" datetime="2020-04-29T15:09:21-05:00">2020-04-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="python基础入门"><a href="#python基础入门" class="headerlink" title="python基础入门"></a>python基础入门</h1><h2 id="python入门"><a href="#python入门" class="headerlink" title="python入门"></a>python入门</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h3><ol>
<li><p>(1)  行注释</p>
<p>每行注释前加#号。当解释器看到#，则忽略这一行#后面的内容</p>
</li>
<li><p>(2)  段注释</p>
<p>使用三个连续单引号(‘’’)。当解释看到’’’，则会扫描到下一个’’’，然后忽略他们</p>
</li>
</ol>
<p>之间的内容。</p>
<h3 id="2-行连接符"><a href="#2-行连接符" class="headerlink" title="2.行连接符"></a>2.行连接符</h3><p><strong>使用\行连接符</strong></p>
<p>一行程序长度是没有限制的，但是为了可读性更强，通常将一行比较长的程序分为多行。这 是，我们可以使用\行连接符，把它放在行结束的地方。Python 解释器仍然将它们解释为同 一行。</p>
<p>&gt;&gt;&gt;  a = [10,20,30,40,\ 50,60,70,\</p>
<p>​        80,90,100]</p>
<h3 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h3><p><strong>Python 中，一切皆对象。</strong>每个对象由:标识(identity)、类型(type)、value(值)</p>
<p>组成。</p>
<ol>
<li><p>标识用于唯一标识对象，通常对应于对象在计算机内存中的地址。使用内置函数 id(obj) 可返回对象 obj 的标识。</p>
</li>
<li><p>类型用于表示对象存储的“数据”的类型。类型可以限制对象的取值范围以及可执行的 操作。可以使用 type(obj)获得对象的所属类型。</p>
</li>
<li><p>值表示对象所存储的数据的信息。使用 print(obj)可以直接打印出值。</p>
</li>
</ol>
<p><strong>对象的本质就是:一个内存块，拥有特定的值，支持特定类型的相关操作。</strong></p>
<p>源码:</p>
<p>&gt;&gt;&gt; a = 3<br> &gt;&gt;&gt; a<br> 3<br> &gt;&gt;&gt; id(3) 1531372336<br> &gt;&gt;&gt; type(3) &lt;class ‘int’&gt;<br> &gt;&gt;&gt; b = “我爱你” &gt;&gt;&gt; id(a) 1531372336</p>
<p>&gt;&gt;&gt; type(a) &lt;class ‘int’&gt; &gt;&gt;&gt; print(a) 3</p>
<p>&gt;&gt;&gt; id(b) 46806816 &gt;&gt;&gt; type(b) &lt;class ‘str’&gt;</p>
<p><strong>引用</strong></p>
<p>在 Python 中，变量也称为:对象的引用。因为，变量存储的就是对象的地址。 变量通过地址引用了“对象”。</p>
<p>变量位于:栈内存(压栈出栈等细节，后续再介绍)。 对象位于:堆内存。</p>
<p><strong>·Python 是动态类型语言</strong></p>
<p>变量不需要显式声明类型。根据变量引用的对象，Python 解释器自动确定数据类型。</p>
<p><strong>·Python 是强类型语言</strong></p>
<p>每个对象都有数据类型，只支持该类型支持的操作。</p>
<h3 id="4-python标识符规则"><a href="#4-python标识符规则" class="headerlink" title="4.python标识符规则"></a>4.python标识符规则</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>模块和包名</td>
<td>全小写字母，尽量简单。若多个单词之间用 下划线</td>
<td>math, os, sys</td>
</tr>
<tr>
<td>函数名</td>
<td>全小写字母，多个单词之间用下划线隔开</td>
<td>phone, my_name</td>
</tr>
<tr>
<td>类名</td>
<td>首字母大写，采用驼峰原则。多个单词时， 每个单词第一个字母大写，其余部分小写</td>
<td>MyPhone 、 MyClass 、 Phone</td>
</tr>
<tr>
<td>常量名</td>
<td>全大写字母，多个单词使用下划线隔开</td>
<td>SPEED、MAX_SPEED</td>
</tr>
</tbody></table>
<h3 id="5-变量声明赋值"><a href="#5-变量声明赋值" class="headerlink" title="5.变量声明赋值"></a>5.变量声明赋值</h3><p>变量的声明和赋值用于将一个变量绑定到一个对象上，格式如下: 变量名 = 表达式</p>
<p>最简单的表达式就是字面量。比如:a = 123 。 运行过程中，解释器先运行右边的表达式， 生成一个代表表达式运算结果的对象;然后，将这个对象地址赋值给左边的变量。</p>
<p><strong>变量在使用前必须先被初始化(先被赋值)</strong>，否则出现NameError</p>
<p>可以通过 del 语句删除不在使用的变量。</p>
<p>如果对象没有变量引用，就会被垃圾回收器回收，清空内存空间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;pyshell#20&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; x</span><br><span class="line">NameError: name <span class="string">'x'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>

<p><strong>链式赋值</strong></p>
<p>链式赋值用于同一个对象赋值给多个变量。 x=y=123 相当于:x=123; y=123</p>
<p><strong>系列解包赋值</strong></p>
<p>系列数据赋值给对应相同个数的变量(个数必须保持一致) &gt;&gt;&gt; a,b,c=4,5,6 相当于:a=4;b=5;c=6</p>
<p>使用系列解包赋值实现变量交换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a,b&#x3D;1,2 </span><br><span class="line">&gt;&gt;&gt; a,b&#x3D;b,a </span><br><span class="line">&gt;&gt;&gt; print(a,b) </span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<p>Python 不支持常量，即没有语法规则限制改变一个常量的值。我们只能约定常量的命名规 则，以及在程序的逻辑上不对常量的值作出修改。（bug，其实可以改，所以说还是java好啊）</p>
<h3 id="6-数据类型"><a href="#6-数据类型" class="headerlink" title="6.数据类型"></a>6.数据类型</h3><p><strong>使用 int()实现类型转换:</strong>：其他类型转int</p>
<p>python有自动转型，小转大，int+float自动转float</p>
<p>最大整数是googol，也就是Google最初的名字，googol = 10**100</p>
<p>类似于 int()，我们也可以使用 float()将其他类型转化成浮点数。</p>
<p>round(value)可以返回四舍五入的值 注:但不会改变原有值，而是产生新的值</p>
<p>运算符+、-、<em>，/、//、*</em>和%和赋值符=结合可以构成“增强型赋值运算符”。</p>
<p>注意:“+=”中间不能加空格!</p>
<p>python 中可以通过 time.time() 获得当前时刻，返回的值是以秒为单位，带微秒 (1/1000 毫秒)精度的浮点值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import time</span><br><span class="line">&gt;&gt;&gt; b &#x3D; int(time.time())</span><br><span class="line">&gt;&gt;&gt; totalMinutes &#x3D; b&#x2F;60</span><br><span class="line">&gt;&gt;&gt; totalMinutes &#x3D; b&#x2F;&#x2F;60</span><br><span class="line">&gt;&gt;&gt; totalHours &#x3D; totalMinutes&#x2F;&#x2F;60</span><br><span class="line">&gt;&gt;&gt; totalDays &#x3D; totalHours&#x2F;&#x2F;24</span><br><span class="line">&gt;&gt;&gt; totalYears &#x3D; totalDays&#x2F;&#x2F;365</span><br></pre></td></tr></table></figure>

<p>Python2 中没有布尔值，直接用数字 0 表示 False,用数字 1 表示 True。（类似c）<br> Python3 中，把 True 和 False 定义成了关键字，但他们的本质还是 1 和 0，甚至可以和数 字相加。</p>
<p>同一运算符用于比较两个对象的存储单元，实际比较的是对象的地址。</p>
<p>is;is 是判断两个标识符是不是引用同一个对象</p>
<p>is not：is not 是判断两个标识符是不是引用不同对象</p>
<p>is 与 == 区别:<br> is 用于判断两个变量引用对象是否为同一个，既比较对象的地址。</p>
<p>== 用于判断引用变量引用对象的值是否相等，默认调用对象的 <strong>eq</strong>()方法。</p>
<h4 id="Python-仅仅对比较小的整数对象进行缓存-范围为-5-256-缓存起来，而并非是所有整数对-象。需要注意的是，这仅仅是在命令行中执行，而在-Pycharm-或者保存为文件执行，结果是不一样-的，这是因为解释器做了一部分优化-范围是-5-任意正整数-。"><a href="#Python-仅仅对比较小的整数对象进行缓存-范围为-5-256-缓存起来，而并非是所有整数对-象。需要注意的是，这仅仅是在命令行中执行，而在-Pycharm-或者保存为文件执行，结果是不一样-的，这是因为解释器做了一部分优化-范围是-5-任意正整数-。" class="headerlink" title="Python 仅仅对比较小的整数对象进行缓存(范围为[-5, 256])缓存起来，而并非是所有整数对 象。需要注意的是，这仅仅是在命令行中执行，而在 Pycharm 或者保存为文件执行，结果是不一样 的，这是因为解释器做了一部分优化(范围是[-5,任意正整数])。"></a>Python 仅仅对比较小的整数对象进行缓存(范围为[-5, 256])缓存起来，而并非是所有整数对 象。需要注意的是，这仅仅是在命令行中执行，而在 Pycharm 或者保存为文件执行，结果是不一样 的，这是因为解释器做了一部分优化(范围是[-5,任意正整数])。</h4><table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
<tr>
<td><strong>·总结</strong></td>
</tr>
<tr>
<td>1、is 比较两个对象的 id 值是否相等，是否指向同一个内存地址;</td>
</tr>
<tr>
<td>2、== 比较的是两个对象的内容是否相等，值是否相等;</td>
</tr>
<tr>
<td>3、小整数对象[-5,256]在全局解释器范围内被放入缓存供重复使用;</td>
</tr>
<tr>
<td>4、is 运算符比 == 效率高，在变量和 None 进行比较时，应该使用 is。</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; 1000</span><br><span class="line">&gt;&gt;&gt; b &#x3D; 1000</span><br><span class="line">&gt;&gt;&gt; a &#x3D;&#x3D; b </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a is b </span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; id(a) 46764560 </span><br><span class="line">&gt;&gt;&gt; id(b) 46765216 </span><br><span class="line">&gt;&gt;&gt; c &#x3D; 10 </span><br><span class="line">&gt;&gt;&gt; d &#x3D; 10 </span><br><span class="line">&gt;&gt;&gt; c is d </span><br><span class="line">True#和整数缓存有关，类似java</span><br><span class="line">&gt;&gt;&gt; id(c) 1388831648 </span><br><span class="line">&gt;&gt;&gt; id(d) 1388831648</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="与-C-和-JAVA-不一样，Python-不支持自增-和自减-–"><a href="#与-C-和-JAVA-不一样，Python-不支持自增-和自减-–" class="headerlink" title="与 C 和 JAVA 不一样，Python 不支持自增(++)和自减(–)"></a>与 C 和 JAVA 不一样，Python 不支持自增(++)和自减(–)</h4><h3 id="7。字符串"><a href="#7。字符串" class="headerlink" title="7。字符串"></a>7。字符串</h3><p>字符串的本质是:字符序列。Python 的字符串是不可变的，我们无法对原字符串做任 何修改。但，可以将字符串的一部分复制到新创建的字符串，达到“看起来修改”的效果。</p>
<p>Python 不支持单字符类型，单字符也是作为一个字符串使用的。</p>
<p>Python3 直接支持 Unicode，可以表示世界上任何书面语言的字符。Python3 的字符 默认就是 16 位 Unicode 编码，ASCII 码是 Unicode 编码的子集。</p>
<p>使用内置函数 ord()可以把字符转换成对应的 Unicode 码; 使用内置函数 chr()可以把十进制数字转换成对应的字符。</p>
<p>连续三个单引号或三个双引号，可以帮助我们创建多行字符串。例如: </p>
<p>resume = ‘’’ name=”gaoqi”<br> company=”sxt” age=18<br> lover=”Tom”‘’’</p>
<p>&gt;&gt;&gt; print(resume) </p>
<p>name=”gaoqi”</p>
<p>company=”sxt” age=18 lover=”Tom”</p>
<p>转义字符： 我们可以使用“\+特殊字符”，实现某些难以用字符表示的效果</p>
<p>我们前面调用 print 时，会自动打印一个换行符。有时，我们不想换行，不想自动添加换行 符。我们可以自己通过参数 end = “任意字符串”。实现末尾添加任何内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;sxt&quot;,end&#x3D;&#39; &#39;) </span><br><span class="line">print(&quot;sxt&quot;,end&#x3D;&#39;##&#39;) </span><br><span class="line">print(&quot;sxt&quot;)</span><br><span class="line">运行结果:</span><br><span class="line">sxt sxt##sxt</span><br></pre></td></tr></table></figure>

<p>我们可以使用 input()从控制台读取键盘输入的内容。</p>
<p>当我们调用 print()函数时，解释器自动调用了 str()将非字符串的对象转成了字符串。</p>
<p>字符串的本质就是字符序列，我们可以通过在字符串后面添加[]，在[]里面指定偏移量， 可以提取该位置的单个字符。</p>
<p>正向搜索:<br> 最左侧第一个字符，偏移量是 0，第二个偏移量是 1，以此类推。直到 len(str)-1</p>
<p>为止。 反向搜索:</p>
<p>最右侧第一个字符，偏移量是-1，倒数第二个偏移量是-2，以此类推，直到-len(str) 为止。</p>
<p>字符串不可改变。但是，我们确实有时候需要替换某些字符。这时，只能通过创建新的字符 串来实现。</p>
<p>使用replace</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;&quot;alfjoashoa&quot;</span><br><span class="line">a&#x3D;a.replace(&quot;a&quot;,&quot;替换字&quot;)</span><br></pre></td></tr></table></figure>

<p>切片 slice 操作可以让我们快速的提取子字符串。标准格式为: [起始偏移量 start:终止偏移量 end:步长 step]</p>
<p>典型操作(三个量为正数的情况)如下:</p>
<table>
<thead>
<tr>
<th>操作和说明</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>[:] 提取整个字符串</td>
<td>“abcdef”[:]</td>
<td>“abcdef”</td>
</tr>
<tr>
<td>[start:]从 start 索引开始到结尾</td>
<td>“abcdef”[2:]</td>
<td>“cdef”</td>
</tr>
<tr>
<td>[:end]从头开始知道 end-1</td>
<td>“abcdef”[:2]</td>
<td>“ab”</td>
</tr>
<tr>
<td>[start:end]从 start 到 end-1</td>
<td>“abcdef”[2:4]</td>
<td>“cd”</td>
</tr>
<tr>
<td>[start​：end:step]从 start 提取到 end-1，步长是 step</td>
<td>“abcdef”[1:5:2]</td>
<td>“bd”</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其他操作(三个量为负数)的情况:</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>“abcdefghijklmnopqrstuv wxyz”[-3:]</td>
<td>倒数三个</td>
<td>“xyz”</td>
</tr>
<tr>
<td>“abcdefghijklmnopqrstuv wxyz”[-8:-3]</td>
<td>倒数第八个到倒数第 三个(包头不包尾)</td>
<td>‘stuvw’</td>
</tr>
<tr>
<td>“abcdefghijklmnopqrstuv wxyz”[::-1]</td>
<td>步长为负，从右到左 反向提取</td>
<td>‘zyxwvutsrqpon mlkjihgfedcba’</td>
</tr>
</tbody></table>
<p><strong>split()分割和 join()合并</strong></p>
<p>split()可以基于指定分隔符将字符串分隔成多个子字符串(存储到列表中)。如果不指定分隔 符，则默认使用空白字符(换行符/空格/制表符)。示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;to be or not to be&quot; </span><br><span class="line">&gt;&gt;&gt; a.split()</span><br><span class="line">[&#39;to&#39;, &#39;be&#39;, &#39;or&#39;, &#39;not&#39;, &#39;to&#39;, &#39;be&#39;] </span><br><span class="line">&gt;&gt;&gt; a.split(&#39;be&#39;)</span><br><span class="line">[&#39;to &#39;, &#39; or not to &#39;, &#39;&#39;]</span><br></pre></td></tr></table></figure>

<p>join()的作用和 split()作用刚好相反，用于将一系列子字符串连接起来。示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [&#39;sxt&#39;,&#39;sxt100&#39;,&#39;sxt200&#39;]</span><br><span class="line">&gt;&gt;&gt; &#39;*&#39;.join(a)</span><br><span class="line">&#39;sxt*sxt100*sxt200&#39;</span><br></pre></td></tr></table></figure>

<p><strong>拼接字符串要点:</strong></p>
<p>使用字符串拼接符+，会生成新的字符串对象，因此不推荐使用+来拼接字符串。推荐 使用 join 函数，因为 join 函数在拼接字符串之前会计算所有字符串的长度，然后逐一拷贝， 仅新建一次对象。</p>
<p><strong>字符串驻留:</strong>仅保存一份相同且不可变字符串的方法，不同的值被存放在字符串驻留池中。 Python 支持字符串驻留机制，对于符合标识符规则的字符串(仅包含下划线(_)、字母 和数字)会启用字符串驻留机制驻留机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;abd_33&quot;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; &quot;abd_33&quot;</span><br><span class="line">&gt;&gt;&gt; a is b </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; c &#x3D; &quot;dd#&quot;</span><br><span class="line">&gt;&gt;&gt; d &#x3D; &quot;dd#&quot;</span><br><span class="line">&gt;&gt;&gt; c is d </span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; str1 &#x3D; &quot;aa&quot;</span><br><span class="line">&gt;&gt;&gt; str2 &#x3D; &quot;bb&quot;</span><br><span class="line">&gt;&gt;&gt; str1+str2 is &quot;aabb&quot;</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; str1+str2 &#x3D;&#x3D; &quot;aabb&quot; </span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p><strong>字符串比较和同一性</strong></p>
<p>我们可以直接使用==,!=对字符串进行比较，是否含有相同的字符。<br> 我们使用 is / not is，判断两个对象是否同一个对象。比较的是对象的地址，即 id(obj1)是 否和 id(obj2)相等。</p>
<h3 id="字符串常用方法汇总"><a href="#字符串常用方法汇总" class="headerlink" title="字符串常用方法汇总"></a><strong>字符串常用方法汇总</strong></h3><p><strong>常用查找方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;&quot;akhfahglwaejiorhsdlhgkld&quot;</span><br><span class="line">len(a)#返回长度</span><br><span class="line">a.startswith(&#39;a&#39;)#以指定字符串开头</span><br><span class="line">a.endswith(&#39;d&#39;)#以指定字符串结尾</span><br><span class="line">a.find(&#39;k&#39;)#第一次出现指定字符串的位置</span><br><span class="line">a.rfind(&#39;d&#39;)#最后一次出现指定字符串的位置</span><br><span class="line">a.count(&#39;ad&#39;)#指定字符串出现几次</span><br><span class="line">a.isalnum()#所有字符全是字母数字</span><br></pre></td></tr></table></figure>

<p><strong>去除首尾信息</strong></p>
<p>我们可以通过 strip()去除字符串首尾指定信息。通过 lstrip()去除字符串左边指定信息， rstrip()去除字符串右边指定信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;*s*x*t*&quot;.strip(&quot;*&quot;) </span><br><span class="line">&#39;s*x*t&#39;</span><br><span class="line">&gt;&gt;&gt; &quot;*s*x*t*&quot;.lstrip(&quot;*&quot;) </span><br><span class="line">&#39;s*x*t*&#39;</span><br><span class="line">&gt;&gt;&gt; &quot;*s*x*t*&quot;.rstrip(&quot;*&quot;) </span><br><span class="line">&#39;*s*x*t&#39;</span><br><span class="line">&gt;&gt;&gt; &quot; sxt &quot;.strip() </span><br><span class="line">&#39;sxt&#39;</span><br></pre></td></tr></table></figure>

<p><strong>大小写转换</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>a.capitalize()</td>
<td>产生新的字符串,首字母 大写</td>
<td></td>
</tr>
<tr>
<td>a.title()</td>
<td>产生新的字符串,每个单 词都首字母大写</td>
<td></td>
</tr>
<tr>
<td>a.upper()</td>
<td>产生新的字符串,所有字 符全转成大写</td>
<td></td>
</tr>
<tr>
<td>a.lower()</td>
<td>产生新的字符串,所有字 符全转成小写</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>a.swapcase()</th>
<th>产生新的,所有字母大小 写转换</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>格式排版</strong></p>
<p>center()、ljust()、rjust()这三个函数用于对字符串实现排版。示例如下: &gt;&gt;&gt; a=”SXT”<br> &gt;&gt;&gt; a.center(10,”*”)<br> ‘<strong><em>SXT*</em></strong>‘</p>
<p>&gt;&gt;&gt; a.center(10)<br> ‘ SXT ‘<br> &gt;&gt;&gt; a.ljust(10,”*”) ‘SXT<strong>***</strong>‘</p>
<p><strong>其他方法</strong></p>
<p>\1. isalnum() 是否为字母或数字<br> \2. isalpha() 检测字符串是否只由字母组成(含汉字)。 3. isdigit() 检测字符串是否只由数字组成。<br> \4. isspace() 检测是否为空白符<br> \5. isupper() 是否为大写字母<br> \6. islower() 是否为小写字母</p>
<p><strong>字符串的格式化</strong> </p>
<p><strong>format()基本用法</strong></p>
<p>Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的 功能。<br> 基本语法是通过 {} 和 : 来代替以前的 % 。</p>
<p>format 函数可以接受不限个参数，位置可以不按顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;名字是:&#123;0&#125;,年龄是:&#123;1&#125;&quot; </span><br><span class="line">&gt;&gt;&gt; a.format(&quot;高淇&quot;,18) </span><br><span class="line">&#39;名字是:高淇,年龄是:18&#39;</span><br><span class="line">&gt;&gt;&gt; a.format(&quot;高希希&quot;,6) </span><br><span class="line">&#39;名字是:高希希,年龄是:6&#39;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; &quot;名字是:&#123;0&#125;，年龄是&#123;1&#125;。&#123;0&#125;是个好小伙&quot; </span><br><span class="line">&gt;&gt;&gt; b.format(&quot;高淇&quot;,18)</span><br><span class="line">&#39;名字是:高淇，年龄是 18。高淇是个好小伙&#39;</span><br><span class="line">&gt;&gt;&gt; c &#x3D; &quot;名字是&#123;name&#125;，年龄是&#123;age&#125;&quot;</span><br><span class="line">&gt;&gt;&gt; c.format(age&#x3D;19,name&#x3D;&#39;高淇&#39;) </span><br><span class="line">&#39;名字是高淇，年龄是 19&#39;#我们可以通过&#123;索引&#125;&#x2F;&#123;参数名&#125;，直接映射参数值，实现对字符串的格式化，非常方便。</span><br></pre></td></tr></table></figure>

<p><strong>填充与对齐</strong></p>
<p>填充常跟对齐一起使用 ^、&lt;、&gt;分别是居中、左对齐、右对齐，后面带宽度</p>
<p>:号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;:*&gt;8&#125;&quot;.format(&quot;245&quot;)</span><br><span class="line">&#39;*****245&#39;</span><br></pre></td></tr></table></figure>



<p>浮点数通过 f，整数通过 d 进行需要的格式化。案例如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &quot;我是&#123;0&#125;，我的存款有&#123;1:.2f&#125;&quot;</span><br><span class="line"></span><br><span class="line"> &gt;&gt;&gt; a.format(&quot;高淇&quot;,3888.234342) </span><br><span class="line"> &#39;我是高淇，我的存款有 3888.23&#39;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>数字</th>
<th>格式</th>
<th>输出</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>3.1415926</td>
<td>{:.2f}</td>
<td>3.14</td>
<td>保留小数点后两位</td>
</tr>
<tr>
<td>3.1415926</td>
<td>{:+.2f}</td>
<td>3.14</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>2.71828</td>
<td>{:.0f}</td>
<td>3</td>
<td>不带小数</td>
</tr>
<tr>
<td>5</td>
<td>{:0&gt;2d}</td>
<td>05</td>
<td>数字补零 (填充左边, 宽度为 2)</td>
</tr>
<tr>
<td>5</td>
<td>{:x&lt;4d}</td>
<td>5xxx</td>
<td>数字补 x (填充右边, 宽度为 4)</td>
</tr>
<tr>
<td>10</td>
<td>{:x&lt;4d}</td>
<td>10xx</td>
<td>数字补 x (填充右边, 宽度为 4)</td>
</tr>
<tr>
<td>1000000</td>
<td>{:,}</td>
<td>1,000,000</td>
<td>以逗号分隔的数字格式</td>
</tr>
<tr>
<td>0.25</td>
<td>{:.2%}</td>
<td>25.00%</td>
<td>百分比格式</td>
</tr>
<tr>
<td>1000000000</td>
<td>{:.2e}</td>
<td>1.00E+09</td>
<td>指数记法</td>
</tr>
<tr>
<td>13</td>
<td>{:10d}</td>
<td>13</td>
<td>右对齐 (默认, 宽度为 10)</td>
</tr>
<tr>
<td>13</td>
<td>{:&lt;10d}</td>
<td>13</td>
<td>左对齐 (宽度为 10)</td>
</tr>
<tr>
<td>13</td>
<td>{:^10d}</td>
<td>13</td>
<td>中间对齐 (宽度为 10)</td>
</tr>
</tbody></table>
<p><strong>可变字符串</strong></p>
<p>在 Python 中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，智 能创建新的字符串对象。但是，经常我们确实需要原地修改字符串，可以使用 io.StringIO 对象或 array 模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import io</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &quot;hello, sxt&quot;</span><br><span class="line">&gt;&gt;&gt; sio &#x3D; io.StringIO(s)</span><br><span class="line">&gt;&gt;&gt; sio</span><br><span class="line">&lt;_io.StringIO object at 0x02F462B0&gt; &gt;&gt;&gt; sio.getvalue()</span><br><span class="line">&#39;hello, sxt&#39;</span><br><span class="line">&gt;&gt;&gt; sio.seek(7)</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; sio.write(&quot;g&quot;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; sio.getvalue()</span><br><span class="line">&#39;hello, gxt&#39;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/ssh%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/ssh%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">ssh，scp详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 10:36:17" itemprop="dateCreated datePublished" datetime="2020-04-29T10:36:17-05:00">2020-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-07 21:22:27" itemprop="dateModified" datetime="2020-05-07T21:22:27-05:00">2020-05-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用"><a href="#教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用" class="headerlink" title="教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用"></a>教你如何ssh免密操作和无需输入ip及用户名，已经scp如何使用</h1><p>如何获取本地ip</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifconfig | grep inet</span><br><span class="line">#如果没有ifconfig命令</span><br><span class="line">linux中</span><br><span class="line">sudo apt install net-tools</span><br></pre></td></tr></table></figure>



<h2 id="教你玩转ssh"><a href="#教你玩转ssh" class="headerlink" title="教你玩转ssh"></a>教你玩转ssh</h2><p>ssh， secure shell，远程登录服务器，机器的一种命令。</p>
<p>此教程仅适合mac，unix，linux系统，windows系统请使用PuTTy 等软件进行操作。</p>
<h3 id="1-先在本机生成rsa密钥对"><a href="#1-先在本机生成rsa密钥对" class="headerlink" title="1.先在本机生成rsa密钥对"></a>1.先在本机生成rsa密钥对</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<h3 id="2-然后一路enter，不要设置密码"><a href="#2-然后一路enter，不要设置密码" class="headerlink" title="2.然后一路enter，不要设置密码"></a>2.然后一路enter，不要设置密码</h3><p>本机 .ssh 隐藏目录中会多几个文件，</p>
<p>authorized-keys    config        id_rsa        id_rsa.pub    known_hosts</p>
<p>其中id_rsa.pub是你的公钥，id_rsa是私钥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi config</span><br><span class="line">#点i进入insert模式,按照各人信息填入，school是你想要的快捷名，以后无需输入ip和用户名了，ip是远程服务器ip</span><br><span class="line">Host school</span><br><span class="line">	HostName ip address</span><br><span class="line">	User username</span><br><span class="line">	Port portnumber</span><br></pre></td></tr></table></figure>

<h3 id="3-然后开始免密操作，很简单，mac需要homebrew"><a href="#3-然后开始免密操作，很简单，mac需要homebrew" class="headerlink" title="3.然后开始免密操作，很简单，mac需要homebrew"></a>3.然后开始免密操作，很简单，mac需要homebrew</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ssh-copy-id</span><br></pre></td></tr></table></figure>

<p>然后，主要此处school是你的快捷名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id school</span><br></pre></td></tr></table></figure>

<p>这是最简单的操作，或者手动把你的公钥复制到远程服务器~/.ssh/authorized_keys中。</p>
<h2 id="教你玩会scp"><a href="#教你玩会scp" class="headerlink" title="教你玩会scp"></a>教你玩会scp</h2><p>ssh就这么简单，既然如此简单，我们顺便提一下scp。</p>
<p>scp就是安全传输文件的命令，</p>
<p>scp没有那么多小技巧，唯一就是要注意路径怎么写，要用绝对路径，最好不要相对路径。</p>
<p>还有就是目录需要加-r</p>
<p>. 表示当前目录</p>
<p>~表示家目录</p>
<p>/表示根目录</p>
<p>了解以上3个即可帮你灵活使用scp了，记住，unix类的操作系统都是树形管理文件的，而不是windows分区形（其实我也不了解）</p>
<p>下面我们开始了解scp命令</p>
<h3 id="1、从本地复制到远程"><a href="#1、从本地复制到远程" class="headerlink" title="1、从本地复制到远程"></a>1、从本地复制到远程</h3><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_username@remote_ip:remote_file </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_ip:remote_file</span><br></pre></td></tr></table></figure>



<ul>
<li>第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名； </li>
<li>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；</li>
</ul>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3 </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3</span><br></pre></td></tr></table></figure>

<p>复制目录命令格式： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp -r local_folder remote_ip:remote_folder</span><br></pre></td></tr></table></figure>

<ul>
<li>第1个指定了用户名，命令执行后需要再输入密码；</li>
<li>第2个没有指定用户名，命令执行后需要输入用户名和密码；</li>
</ul>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; </span><br><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;</span><br></pre></td></tr></table></figure>

<p>上面命令将本地 music 目录复制到远程 others 目录下。</p>
<h3 id="2、从远程复制到本地"><a href="#2、从远程复制到本地" class="headerlink" title="2、从远程复制到本地"></a>2、从远程复制到本地</h3><p>从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例 </p>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 </span><br><span class="line">scp -r www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; &#x2F;home&#x2F;space&#x2F;music&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>1.如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#scp 命令使用端口号 4588</span><br><span class="line">scp -P 4588 remote@www.runoob.com:&#x2F;usr&#x2F;local&#x2F;sin.sh &#x2F;home&#x2F;administrator</span><br></pre></td></tr></table></figure>

<p>2.使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/27/crawlerblog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/27/crawlerblog/" class="post-title-link" itemprop="url">crawlerblog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-27 16:24:44 / Modified: 16:42:23" itemprop="dateCreated datePublished" datetime="2020-04-27T16:24:44-05:00">2020-04-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：[<a href="https://www.zhihu.com/search?type=content&amp;q=%20%E7%88%AC%E8%99%AB%E6%80%8E%E4%B9%88%E5%AD%A6]" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=%20%E7%88%AC%E8%99%AB%E6%80%8E%E4%B9%88%E5%AD%A6]</a>(<a href="https://www.zhihu.com/search?type=content&amp;q=" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=</a> 爬虫怎么学)</p>
<p>博客：<a href="https://cuiqingcai.com/947.html" target="_blank" rel="noopener">https://cuiqingcai.com/947.html</a></p>
<h1 id="python爬虫入门"><a href="#python爬虫入门" class="headerlink" title="python爬虫入门"></a>python爬虫入门</h1><h2 id="1-爬虫基础了解"><a href="#1-爬虫基础了解" class="headerlink" title="1.爬虫基础了解"></a>1.爬虫基础了解</h2><h3 id="1-什么是爬虫"><a href="#1-什么是爬虫" class="headerlink" title="1.什么是爬虫"></a>1.什么是爬虫</h3><p>爬虫，即网络爬虫，大家可以理解为在网络上爬行的一直蜘蛛，互联网就比作一张大网，而爬虫便是在这张网上爬来爬去的蜘蛛咯，如果它遇到资源，那么它就会抓取下来。想抓取什么？这个由你来控制它咯。</p>
<p>比如它在抓取一个网页，在这个网中他发现了一条道路，其实就是指向网页的超链接，那么它就可以爬到另一张网上来获取数据。这样，整个连在一起的大网对这之蜘蛛来说触手可及，分分钟爬下来不是事儿。</p>
<h3 id="2-浏览网页的过程"><a href="#2-浏览网页的过程" class="headerlink" title="2.浏览网页的过程"></a>2.浏览网页的过程</h3><p>在用户浏览网页的过程中，我们可能会看到许多好看的图片，比如 <a href="http://image.baidu.com/" target="_blank" rel="noopener">http://image.baidu.com/</a> ，我们会看到几张的图片以及百度搜索框，这个过程其实就是用户输入网址之后，经过DNS服务器，找到服务器主机，向服务器发出一个请求，服务器经过解析之后，发送给用户的浏览器 HTML、JS、CSS 等文件，浏览器解析出来，用户便可以看到形形色色的图片了。</p>
<p>因此，用户看到的网页实质是由 HTML 代码构成的，爬虫爬来的便是这些内容，通过分析和过滤这些 HTML 代码，实现对图片、文字等资源的获取。</p>
<h3 id="3-URL的含义"><a href="#3-URL的含义" class="headerlink" title="3.URL的含义"></a>3.URL的含义</h3><p>URL，即统一资源定位符，也就是我们说的网址，统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p>
<blockquote>
<p>URL的格式由三部分组成：<br>①第一部分是协议(或称为服务方式)。<br>②第二部分是存有该资源的主机IP地址(有时也包括端口号)。<br>③第三部分是主机资源的具体地址，如目录和文件名等。</p>
</blockquote>
<p>爬虫爬取数据时必须要有一个目标的URL才可以获取数据，因此，它是爬虫获取数据的基本依据，准确理解它的含义对爬虫学习有很大帮助。</p>
<h2 id="2-Urllib库基本使用"><a href="#2-Urllib库基本使用" class="headerlink" title="2. Urllib库基本使用"></a>2. Urllib库基本使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib2</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">response = urllib2.urlopen(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">print(response.read())</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> urlopen(url, data, timeout)</span><br><span class="line"></span><br><span class="line">第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。</span><br><span class="line"></span><br><span class="line">第二三个参数是可以不传送的，data默认为空<span class="literal">None</span>，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT</span><br><span class="line"></span><br><span class="line">第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> print response.read()</span><br><span class="line">response对象有一个read方法，可以返回获取到的网页内容。</span><br><span class="line">如果不加read直接打印会是什么？</span><br><span class="line">&lt;addinfourl at 139728495260376 whose fp &#x3D; &lt;socket._fileobject **object** at 0x7f1513fb3ad0&gt;&gt;</span><br><span class="line">直接打印出了该对象的描述，所以记得一定要加read方法</span><br></pre></td></tr></table></figure>

<h3 id="构造Request"><a href="#构造Request" class="headerlink" title="构造Request"></a>构造Request</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib2</span><br><span class="line"> </span><br><span class="line">request = urllib2.Request(<span class="string">"http://www.baidu.com"</span>)<span class="comment">#推荐这样书写，因为在构建请求时还需要加入好多内容，通过构建一个request，服务器响应请求得到应答，这样显得逻辑上清晰明确。</span></span><br><span class="line">response = urllib2.urlopen(request)</span><br><span class="line">print(response.read())</span><br></pre></td></tr></table></figure>

<h3 id="POST和GET数据传送"><a href="#POST和GET数据传送" class="headerlink" title="POST和GET数据传送"></a>POST和GET数据传送</h3><p>上面的程序演示了最基本的网页抓取，不过，现在大多数网站都是动态网页，需要你动态地传递参数给它，它做出对应的响应。所以，在访问时，我们需要传递数据给它。</p>
<p>GET方式是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。POST则不会在网址上显示所有的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/27/crawler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/27/crawler/" class="post-title-link" itemprop="url">crawler爬虫</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-27 10:10:38 / Modified: 11:05:18" itemprop="dateCreated datePublished" datetime="2020-04-27T10:10:38-05:00">2020-04-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="爬虫入门"><a href="#爬虫入门" class="headerlink" title="爬虫入门"></a>爬虫入门</h2><p>pip3 install requests selenium beautifulsoup4 pyquery pymysql pymongo redis flask django jupyter</p>
<p>安装各种库，安装MongoDB，redis，anaconda，pycharm，Python3</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#带参数get请求</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.get(<span class="string">'https://httpbin.org/get?name=jackson&amp;age=100'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.text)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=&#123;<span class="string">'name'</span>:<span class="string">'ap'</span>,<span class="string">'age'</span>:<span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.get(<span class="string">'https://httpbin.org/get'</span>,params=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#解析json</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.get(<span class="string">'https://httpbin.org/get'</span>,params=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.json)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.loads(response.text))<span class="comment">#以上两个打印一样</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(response.json()))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">#获取二进制数据,可以保持图片视频</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.get(<span class="string">"https://github.com/favicon.ico"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(response.text),type(response.content))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt; &lt;<span class="title">class</span> '<span class="title">bytes</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(response.text)</span>#一堆乱码</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(response.content)</span>#一堆16进制数字</span></span><br><span class="line"><span class="class">#保存二进制图片视频</span></span><br><span class="line">&gt;&gt;&gt; response=requests.get("https://github.com/favicon.ico")</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'favicon.ico'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:<span class="comment">#命名为favicoc</span></span><br><span class="line"><span class="meta">... </span>    f.write(response.content)</span><br><span class="line"><span class="meta">... </span>    f.close()</span><br><span class="line"><span class="comment">#添加headers</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>headers=&#123;<span class="string">'User-Agent'</span>:<span class="string">'。。。一堆码读出来的'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.get(<span class="string">"https://www.zhihu.com/explore"</span>,headers=headers)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#基本post请求</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=&#123;<span class="string">'name'</span>:<span class="string">'ap'</span>,<span class="string">'age'</span>:<span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.post(<span class="string">'https://httpbin.org/post'</span>,data=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.text)</span><br><span class="line"><span class="comment">#headers post,报表表单</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=&#123;<span class="string">'name'</span>:<span class="string">'ap'</span>,<span class="string">'age'</span>:<span class="number">99</span>&#125;</span><br><span class="line">headers=&#123;<span class="string">'User-Agent'</span>:<span class="string">'。。。一堆码读出来的'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response=requests.post(<span class="string">"https://httpbin.org/post"</span>,data=data,headers=headers)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.json())</span><br><span class="line"></span><br><span class="line"><span class="comment">#response属性</span></span><br></pre></td></tr></table></figure>

<p>#找headers <a href="https://mkyong.com/computer-tips/how-to-view-http-headers-in-google-chrome/" target="_blank" rel="noopener">https://mkyong.com/computer-tips/how-to-view-http-headers-in-google-chrome/</a></p>
<p>找到最下面的User-Agent: Mozilla 。。。</p>
<h2 id="看到python非常全资料-python3爬虫实战-课时09"><a href="#看到python非常全资料-python3爬虫实战-课时09" class="headerlink" title="看到python非常全资料/python3爬虫实战/课时09"></a>看到python非常全资料/python3爬虫实战/课时09</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/26/linux5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/26/linux5/" class="post-title-link" itemprop="url">linux基础（81-100集）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 21:50:33 / Modified: 23:27:03" itemprop="dateCreated datePublished" datetime="2020-04-26T21:50:33-05:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P81-87（系统信息）"><a href="#P81-87（系统信息）" class="headerlink" title="P81-87（系统信息）"></a>P81-87（系统信息）</h2><h3 id="01-时间和日期"><a href="#01-时间和日期" class="headerlink" title="01.时间和日期"></a>01.时间和日期</h3><p>​    date：查看系统日期</p>
<p>​    cal：calendar查看日历，-y选项可以查看一年日历</p>
<h3 id="02-磁盘信息"><a href="#02-磁盘信息" class="headerlink" title="02.磁盘信息"></a>02.磁盘信息</h3><p>​    df -h：disk free显示磁盘剩余空间</p>
<p>​    du -h[目录名]：disk usage显示目录下文件大小（-h以人性化方式显示文件大小）</p>
<p>​    /看根目录</p>
<h3 id="03-进程信息"><a href="#03-进程信息" class="headerlink" title="03. 进程信息"></a>03. 进程信息</h3><p>当前正在执行的一个程序是进程</p>
<p>​    ps aux：process status查看进程的详细状况</p>
<p>​    top：动态显示运行中的进程并且排序</p>
<p>​    kill [-9] 进程代号：终止指定代号进程，-9是强制终止</p>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>Linux ps命令用于显示当前进程 (process) 的状态。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [options] [--help]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义</li>
<li>-A 列出所有的行程</li>
<li>-w 显示加宽可以显示较多的资讯</li>
<li>-au 显示较详细的资讯</li>
<li>-aux 显示所有包含其他使用者的行程（</li>
<li>au(x) 输出格式 :（常用）</li>
<li>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</li>
<li>USER: 行程拥有者</li>
<li>PID: pid</li>
<li>%CPU: 占用的 CPU 使用率</li>
<li>%MEM: 占用的记忆体使用率</li>
<li>VSZ: 占用的虚拟记忆体大小</li>
<li>RSS: 占用的记忆体大小</li>
<li>TTY: 终端的次要装置号码 (minor device number of tty)</li>
<li>STAT: 该行程的状态:</li>
<li>D: 无法中断的休眠状态 (通常 IO 的进程)</li>
<li>R: 正在执行中</li>
<li>S: 静止状态</li>
<li>T: 暂停执行</li>
<li>Z: 不存在但暂时无法消除</li>
<li>W: 没有足够的记忆体分页可分配</li>
<li>&lt;: 高优先序的行程</li>
<li>N: 低优先序的行程</li>
<li>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)</li>
<li>START: 行程开始时间</li>
<li>TIME: 执行的时间</li>
<li>COMMAND:所执行的指令</li>
<li>x：显示没有控制终端的进程（会显示很多）</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># ps -A 显示进程信息</span><br><span class="line">PID TTY     TIME CMD</span><br><span class="line">  1 ?    00:00:02 init</span><br><span class="line">  2 ?    00:00:00 kthreadd</span><br><span class="line">  3 ?    00:00:00 migration&#x2F;0</span><br><span class="line">  4 ?    00:00:00 ksoftirqd&#x2F;0</span><br><span class="line">  5 ?    00:00:00 watchdog&#x2F;0</span><br><span class="line">  6 ?    00:00:00 events&#x2F;0</span><br><span class="line">  7 ?    00:00:00 cpuset</span><br><span class="line">  8 ?    00:00:00 khelper</span><br><span class="line">  9 ?    00:00:00 netns</span><br><span class="line">  10 ?    00:00:00 async&#x2F;mgr</span><br><span class="line">  11 ?    00:00:00 pm</span><br><span class="line">  12 ?    00:00:00 sync_supers</span><br><span class="line">  13 ?    00:00:00 bdi-default</span><br><span class="line">  14 ?    00:00:00 kintegrityd&#x2F;0</span><br><span class="line">  15 ?    00:00:02 kblockd&#x2F;0</span><br><span class="line">  16 ?    00:00:00 kacpid</span><br><span class="line">  17 ?    00:00:00 kacpi_notify</span><br><span class="line">  18 ?    00:00:00 kacpi_hotplug</span><br><span class="line">  19 ?    00:00:27 ata&#x2F;0</span><br><span class="line">……省略部分结果</span><br><span class="line">30749 pts&#x2F;0  00:00:15 gedit</span><br><span class="line">30886 ?    00:01:10 qtcreator.bin</span><br><span class="line">30894 ?    00:00:00 qtcreator.bin </span><br><span class="line">31160 ?    00:00:00 dhclient</span><br><span class="line">31211 ?    00:00:00 aptd</span><br><span class="line">31302 ?    00:00:00 sshd</span><br><span class="line">31374 pts&#x2F;2  00:00:00 bash</span><br><span class="line">31396 pts&#x2F;2  00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>显示指定用户信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># ps -u root &#x2F;&#x2F;显示root进程用户信息</span><br><span class="line"> PID TTY     TIME CMD</span><br><span class="line">  1 ?    00:00:02 init</span><br><span class="line">  2 ?    00:00:00 kthreadd</span><br><span class="line">  3 ?    00:00:00 migration&#x2F;0</span><br><span class="line">  4 ?    00:00:00 ksoftirqd&#x2F;0</span><br><span class="line">  5 ?    00:00:00 watchdog&#x2F;0</span><br><span class="line">  6 ?    00:00:00 events&#x2F;0</span><br><span class="line">  7 ?    00:00:00 cpuset</span><br><span class="line">  8 ?    00:00:00 khelper</span><br><span class="line">  9 ?    00:00:00 netns</span><br><span class="line">  10 ?    00:00:00 async&#x2F;mgr</span><br><span class="line">  11 ?    00:00:00 pm</span><br><span class="line">  12 ?    00:00:00 sync_supers</span><br><span class="line">  13 ?    00:00:00 bdi-default</span><br><span class="line">  14 ?    00:00:00 kintegrityd&#x2F;0</span><br><span class="line">  15 ?    00:00:02 kblockd&#x2F;0</span><br><span class="line">  16 ?    00:00:00 kacpid</span><br><span class="line">……省略部分结果</span><br><span class="line">30487 ?    00:00:06 gnome-terminal</span><br><span class="line">30488 ?    00:00:00 gnome-pty-helpe</span><br><span class="line">30489 pts&#x2F;0  00:00:00 bash</span><br><span class="line">30670 ?    00:00:00 debconf-communi </span><br><span class="line">30749 pts&#x2F;0  00:00:15 gedit</span><br><span class="line">30886 ?    00:01:10 qtcreator.bin</span><br><span class="line">30894 ?    00:00:00 qtcreator.bin </span><br><span class="line">31160 ?    00:00:00 dhclient</span><br><span class="line">31211 ?    00:00:00 aptd</span><br><span class="line">31302 ?    00:00:00 sshd</span><br><span class="line">31374 pts&#x2F;2  00:00:00 bash</span><br><span class="line">31397 pts&#x2F;2  00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>显示所有进程信息，连同命令行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># ps -ef &#x2F;&#x2F;显示所有命令，连带命令行</span><br><span class="line">UID    PID PPID C STIME TTY     TIME CMD</span><br><span class="line">root     1   0 0 10:22 ?    00:00:02 &#x2F;sbin&#x2F;init</span><br><span class="line">root     2   0 0 10:22 ?    00:00:00 [kthreadd]</span><br><span class="line">root     3   2 0 10:22 ?    00:00:00 [migration&#x2F;0]</span><br><span class="line">root     4   2 0 10:22 ?    00:00:00 [ksoftirqd&#x2F;0]</span><br><span class="line">root     5   2 0 10:22 ?    00:00:00 [watchdog&#x2F;0]</span><br><span class="line">root     6   2 0 10:22 ?    &#x2F;usr&#x2F;lib&#x2F;NetworkManager</span><br><span class="line">……省略部分结果</span><br><span class="line">root   31302 2095 0 17:42 ?    00:00:00 sshd: root@pts&#x2F;2 </span><br><span class="line">root   31374 31302 0 17:42 pts&#x2F;2  00:00:00 -bash</span><br><span class="line">root   31400   1 0 17:46 ?    00:00:00 &#x2F;usr&#x2F;bin&#x2F;python &#x2F;usr&#x2F;sbin&#x2F;aptd</span><br><span class="line">root   31407 31374 0 17:48 pts&#x2F;2  00:00:00 ps -ef</span><br></pre></td></tr></table></figure>

<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>（Linux top命令用于实时显示 process 的动态。（好玩哪）</p>
<p>使用权限：所有使用者。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s</li>
<li>q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行</li>
<li>c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来</li>
<li>s : 安全模式，将交谈式指令取消, 避免潜在的危机</li>
<li>i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程</li>
<li>n : 更新的次数，完成后将会退出 top</li>
<li>b : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>显示进程信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># top</span><br></pre></td></tr></table></figure>

<p>显示完整命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># top -c</span><br></pre></td></tr></table></figure>

<p>以批处理模式显示程序信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># top -b</span><br></pre></td></tr></table></figure>

<p>以累积模式显示程序信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># top -S</span><br></pre></td></tr></table></figure>

<p>设置信息更新次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top -n 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;表示更新两次后终止更新显示</span><br></pre></td></tr></table></figure>

<p>设置信息更新时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># top -d 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;表示更新周期为3秒</span><br></pre></td></tr></table></figure>

<p>显示指定的进程信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># top -p 139</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示进程号为139的进程信息，CPU、内存占用率等</span><br></pre></td></tr></table></figure>

<p>显示更新十次后退出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -n 10</span><br></pre></td></tr></table></figure>

<p>使用者将不能利用交谈式指令来对行程下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -s</span><br></pre></td></tr></table></figure>

<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>Linux kill命令用于删除执行中的程序或工作。</p>
<p>kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或jobs指令查看。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [-s &lt;信息名称或编号&gt;][程序]　或　kill [-l &lt;信息编号&gt;]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-l &lt;信息编号&gt; 　若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称。</li>
<li>-s &lt;信息名称或编号&gt; 　指定要送出的信息。</li>
<li>[程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。</li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>杀死进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kill 12345</span><br></pre></td></tr></table></figure>

<p>强制杀死进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kill -KILL 123456</span><br></pre></td></tr></table></figure>

<p>发送SIGHUP信号，可以使用一下信号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kill -HUP pid</span><br></pre></td></tr></table></figure>

<p>彻底杀死进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kill -9 123456</span><br></pre></td></tr></table></figure>

<p>显示信号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># kill -l</span><br><span class="line">1) SIGHUP     2) SIGINT     3) SIGQUIT     4) SIGILL     5) SIGTRAP</span><br><span class="line">6) SIGABRT     7) SIGBUS     8) SIGFPE     9) SIGKILL    10) SIGUSR1</span><br><span class="line">11) SIGSEGV    12) SIGUSR2    13) SIGPIPE    14) SIGALRM    15) SIGTERM</span><br><span class="line">16) SIGSTKFLT    17) SIGCHLD    18) SIGCONT    19) SIGSTOP    20) SIGTSTP</span><br><span class="line">21) SIGTTIN    22) SIGTTOU    23) SIGURG    24) SIGXCPU    25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM    27) SIGPROF    28) SIGWINCH    29) SIGIO    30) SIGPWR</span><br><span class="line">31) SIGSYS    34) SIGRTMIN    35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9    44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1    64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>杀死指定用户所有进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#kill -9 $(ps -ef | grep hnlinux) &#x2F;&#x2F;方法一 过滤出hnlinux用户进程 </span><br><span class="line">#kill -u hnlinux &#x2F;&#x2F;方法二</span><br></pre></td></tr></table></figure>

<h2 id="P88-92（其他命令）"><a href="#P88-92（其他命令）" class="headerlink" title="P88-92（其他命令）"></a>P88-92（其他命令）</h2><h3 id="1-查找文件"><a href="#1-查找文件" class="headerlink" title="1.查找文件"></a>1.查找文件</h3><p>​    find</p>
<p>Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find   path   -option   [   -print ]   [ -exec   -ok   command ]   &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong> :</p>
<p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p>
<p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</p>
<p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p>
<p>-amin n : 在过去 n 分钟内被读取过</p>
<p>-anewer file : 比文件 file 更晚被读取过的文件</p>
<p>-atime n : 在过去n天内被读取过的文件</p>
<p>-cmin n : 在过去 n 分钟内被修改过</p>
<p>-cnewer file :比文件 file 更新的文件</p>
<p>-ctime n : 在过去n天内被修改过的文件</p>
<p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p>
<p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p>
<p>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写（常用）</p>
<p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。</p>
<p>d: 目录</p>
<p>c: 字型装置文件</p>
<p>b: 区块装置文件</p>
<p>p: 具名贮列</p>
<p>f: 一般文件</p>
<p>l: 符号连结</p>
<p>s: socket</p>
<p>-pid n : process id 是 n 的文件</p>
<p>你可以使用 ( ) 将运算式分隔，并使用下列运算。</p>
<p>exp1 -and exp2</p>
<p>! expr</p>
<p>-not expr</p>
<p>exp1 -or exp2</p>
<p>exp1, exp2</p>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>将目前目录及其子目录下所有延伸档名是 c 的文件列出来。（经典）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -name &quot;*.c&quot;</span><br></pre></td></tr></table></figure>

<p>将目前目录其其下子目录中所有一般文件列出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -type f</span><br></pre></td></tr></table></figure>

<p>将目前目录及其子目录下所有最近 20 天内更新过的文件列出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -ctime -20</span><br></pre></td></tr></table></figure>

<p>查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find &#x2F;var&#x2F;log -type f -mtime +7 -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -type f -perm 644 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find &#x2F; -type f -size 0 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h3 id="2-软链接（类似快捷方式）"><a href="#2-软链接（类似快捷方式）" class="headerlink" title="2. 软链接（类似快捷方式）"></a>2. 软链接（类似快捷方式）</h3><p>ln -s 被链接的源文件 起的文件名</p>
<p>ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。这个命令最常用的参数是-s,具体用法是：ln -s 源文件 目标文件。当 我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的 目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>
<p>例如：ln -s /bin/less /usr/local/bin/less </p>
<p>-s 是代号（symbolic）的意思。 </p>
<p>这 里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接又软链接 和硬链接两种，软链接就是ln -s ** *<em>,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln *</em> **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。<br>如果你用ls察看一个目录时，发现有的文件后面有一个@的符号，那就是一个用ln命令生成的文件，用ls -l命令去察看，就可以看到显示的link的路径了。 </p>
<p>不加-s是硬链接，ls -l可以查看硬链接数</p>
<p>ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同不的链接，这个命令最常用的参数是-s，具体用法是：ln –s 源文件 目标文件。<br>　　当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。例如：ln –s /bin/less /usr/local/bin/less<br>　　-s 是代号（symbolic）的意思。<br>　　这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接又 软链接和硬链接两种，软链接就是ln –s ** *<em>，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln *</em> **，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。<br>　　如果你用ls察看一个目录时，发现有的文件后面有一个@的符号，那就是一个用ln命令生成的文件，用ls –l命令去察看，就可以看到显示的link的路径了。<br>　　指令详细说明<br>　　指令名称 : ln<br>　　使用权限 : 所有使用者<br>　　使用方式 : ln [options] source dist，其中 option 的格式为 :<br>　　[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}]<br>　　[–help] [–version] [–]<br>　　说明 : Linux/Unix 档案系统中，有所谓的连结(link)，我们可以将其视为档案的别名，而连结又可分为两种 : 硬连结(hard link)与软连结(symbolic link)，硬连结的意思是一个档案可以有多个名称，而软连结的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬连结是存在同一个档 案系统中，而软连结却可以跨越不同的档案系统。<br>　　ln source dist 是产生一个连结(dist)到 source，至于使用硬连结或软链结则由参数决定。<br>　　不论是硬连结或软链结都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p>
<p>Linux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。</p>
<p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [参数][源文件或目录][目标文件或目录]</span><br></pre></td></tr></table></figure>

<p>其中参数的格式为</p>
<p>[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}]</p>
<p>[–help] [–version] [–]</p>
<p><strong>命令功能</strong> :<br>Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。</p>
<p>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p>
<p><strong>软链接</strong>：（用绝对路径）</p>
<ul>
<li>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</li>
<li>2.软链接可以 跨文件系统 ，硬链接不可以</li>
<li>3.软链接可以对一个不存在的文件名进行链接</li>
<li>4.软链接可以对目录进行链接</li>
</ul>
<p><strong>硬链接</strong>：</p>
<ul>
<li>1.硬链接，以文件副本的形式存在。但不占用实际空间。</li>
<li>2.不允许给目录创建硬链接</li>
<li>3.硬链接只有在同一个文件系统中才能创建</li>
</ul>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p><strong>必要参数</strong>：</p>
<ul>
<li>-b 删除，覆盖以前建立的链接</li>
<li>-d 允许超级用户制作目录的硬链接</li>
<li>-f 强制执行</li>
<li>-i 交互模式，文件存在则提示用户是否覆盖</li>
<li>-n 把符号链接视为一般目录</li>
<li>-s 软链接(符号链接)（常用）</li>
<li>-v 显示详细的处理过程</li>
</ul>
<p><strong>选择参数</strong>：</p>
<ul>
<li>-S “-S&lt;字尾备份字符串&gt; “或 “–suffix=&lt;字尾备份字符串&gt;”</li>
<li>-V “-V&lt;备份方式&gt;”或”–version-control=&lt;备份方式&gt;”</li>
<li>–help 显示帮助信息</li>
<li>–version 显示版本信息</li>
</ul>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>给文件创建软链接，为log2013.log文件创建软链接link2013，如果log2013.log丢失，link2013将失效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s log2013.log link2013</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ll</span><br><span class="line">-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log</span><br><span class="line">[root@localhost test]# ln -s log2013.log link2013</span><br><span class="line">[root@localhost test]# ll</span><br><span class="line">lrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -&gt; log2013.log</span><br><span class="line">-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log</span><br></pre></td></tr></table></figure>

<p>给文件创建硬链接，为log2013.log创建硬链接ln2013，log2013.log与ln2013的各项属性相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln log2013.log ln2013</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ll</span><br><span class="line">lrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -&gt; log2013.log</span><br><span class="line">-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log</span><br><span class="line">[root@localhost test]# ln log2013.log ln2013</span><br><span class="line">[root@localhost test]# ll</span><br><span class="line">lrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -&gt; log2013.log</span><br><span class="line">-rw-r--r-- 2 root bin      61 11-13 06:03 ln2013</span><br><span class="line">-rw-r--r-- 2 root bin      61 11-13 06:03 log2013.log</span><br></pre></td></tr></table></figure>

<h2 id="P93（软链接硬链接）"><a href="#P93（软链接硬链接）" class="headerlink" title="P93（软链接硬链接）"></a>P93（软链接硬链接）</h2><p>linux中文件名和文件数据分开存储</p>
<p>删除文件，软链接自动删除，文件数据自动删除，硬链接不会删除，文件数据还可以硬链接读取，几乎不会用硬链接。</p>
<h2 id="P94-97打包压缩"><a href="#P94-97打包压缩" class="headerlink" title="P94-97打包压缩"></a>P94-97打包压缩</h2><p>windows中：rar</p>
<p>mac中：zip</p>
<p>linux：tar.gz</p>
<p>Linux tar命令用于备份文件。</p>
<p>tar是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p>
<p>tar -cvf 打包文件.tar 被打包文件/路径… #打包</p>
<p>tar -xvf 打包文件.tar#解压</p>
<h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b &lt;区块数目&gt;][-C &lt;目的目录&gt;][-f &lt;备份文件&gt;][-F &lt;Script文件&gt;][-K &lt;文件&gt;][-L &lt;媒体容量&gt;][-N &lt;日期时间&gt;][-T &lt;范本文件&gt;][-V &lt;卷册名称&gt;][-X &lt;范本文件&gt;][-&lt;设备编号&gt;&lt;存储密度&gt;][--after-date&#x3D;&lt;日期时间&gt;][--atime-preserve][--backuup&#x3D;&lt;备份方式&gt;][--checkpoint][--concatenate][--confirmation][--delete][--exclude&#x3D;&lt;范本样式&gt;][--force-local][--group&#x3D;&lt;群组名称&gt;][--help][--ignore-failed-read][--new-volume-script&#x3D;&lt;Script文件&gt;][--newer-mtime][--no-recursion][--null][--numeric-owner][--owner&#x3D;&lt;用户名称&gt;][--posix][--erve][--preserve-order][--preserve-permissions][--record-size&#x3D;&lt;区块数目&gt;][--recursive-unlink][--remove-files][--rsh-command&#x3D;&lt;执行指令&gt;][--same-owner][--suffix&#x3D;&lt;备份字尾字符串&gt;][--totals][--use-compress-program&#x3D;&lt;执行指令&gt;][--version][--volno-file&#x3D;&lt;编号文件&gt;][文件或目录...]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-A或–catenate 新增文件到已存在的备份文件。</li>
<li>-b&lt;区块数目&gt;或–blocking-factor=&lt;区块数目&gt; 设置每笔记录的区块数目，每个区块大小为12Bytes。</li>
<li>-B或–read-full-records 读取数据时重设区块大小。</li>
<li>-c或–create 建立新的备份文件。</li>
<li>-C&lt;目的目录&gt;或–directory=&lt;目的目录&gt; 切换到指定的目录。</li>
<li>-d或–diff或–compare 对比备份文件内和文件系统上的文件的差异。</li>
<li>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt; 指定备份文件。</li>
<li>-F&lt;Script文件&gt;或–info-script=&lt;Script文件&gt; 每次更换磁带时，就执行指定的Script文件。</li>
<li>-g或–listed-incremental 处理GNU格式的大量备份。</li>
<li>-G或–incremental 处理旧的GNU格式的大量备份。</li>
<li>-h或–dereference 不建立符号连接，直接复制该连接所指向的原始文件。</li>
<li>-i或–ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。</li>
<li>-k或–keep-old-files 解开备份文件时，不覆盖已有的文件。</li>
<li>-K&lt;文件&gt;或–starting-file=&lt;文件&gt; 从指定的文件开始还原。</li>
<li>-l或–one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。</li>
<li>-L&lt;媒体容量&gt;或-tape-length=&lt;媒体容量&gt; 设置存放每体的容量，单位以1024 Bytes计算。</li>
<li>-m或–modification-time 还原文件时，不变更文件的更改时间。</li>
<li>-M或–multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li>
<li>-N&lt;日期格式&gt;或–newer=&lt;日期时间&gt; 只将较指定日期更新的文件保存到备份文件里。</li>
<li>-o或–old-archive或–portability 将资料写入备份文件时使用V7格式。</li>
<li>-O或–stdout 把从备份文件里还原的文件输出到标准输出设备。</li>
<li>-p或–same-permissions 用原来的文件权限还原文件。</li>
<li>-P或–absolute-names 文件名使用绝对名称，不移除文件名称前的”/“号。</li>
<li>-r或–append 新增文件到已存在的备份文件的结尾部分。</li>
<li>-R或–block-number 列出每个信息在备份文件中的区块编号。</li>
<li>-s或–same-order 还原文件的顺序和备份文件内的存放顺序相同。</li>
<li>-S或–sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。</li>
<li>-t或–list 列出备份文件的内容。</li>
<li>-T&lt;范本文件&gt;或–files-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。</li>
<li>-u或–update 仅置换较备份文件内的文件更新的文件。</li>
<li>-U或–unlink-first 解开压缩文件还原文件之前，先解除文件的连接。</li>
<li>-v或–verbose 显示指令执行过程。</li>
<li>-V&lt;卷册名称&gt;或–label=&lt;卷册名称&gt; 建立使用指定的卷册名称的备份文件。</li>
<li>-w或–interactive 遭遇问题时先询问用户。</li>
<li>-W或–verify 写入备份文件后，确认文件正确无误。</li>
<li>-x或–extract或–get 从备份文件中还原文件。</li>
<li>-X&lt;范本文件&gt;或–exclude-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。</li>
<li>-z或–gzip或–ungzip 通过gzip指令处理备份文件。</li>
<li>-Z或–compress或–uncompress 通过compress指令处理备份文件。</li>
<li>-&lt;设备编号&gt;&lt;存储密度&gt; 设置备份用的外围设备编号及存放数据的密度。</li>
<li>–after-date=&lt;日期时间&gt; 此参数的效果和指定”-N”参数相同。</li>
<li>–atime-preserve 不变更文件的存取时间。</li>
<li>–backup=&lt;备份方式&gt;或–backup 移除文件前先进行备份。</li>
<li>–checkpoint 读取备份文件时列出目录名称。</li>
<li>–concatenate 此参数的效果和指定”-A”参数相同。</li>
<li>–confirmation 此参数的效果和指定”-w”参数相同。</li>
<li>–delete 从备份文件中删除指定的文件。</li>
<li>–exclude=&lt;范本样式&gt; 排除符合范本样式的文件。</li>
<li>–group=&lt;群组名称&gt; 把加入设备文件中的文件的所属群组设成指定的群组。</li>
<li>–help 在线帮助。</li>
<li>–ignore-failed-read 忽略数据读取错误，不中断程序的执行。</li>
<li>–new-volume-script=&lt;Script文件&gt; 此参数的效果和指定”-F”参数相同。</li>
<li>–newer-mtime 只保存更改过的文件。</li>
<li>–no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</li>
<li>–null 从null设备读取文件名称。</li>
<li>–numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。</li>
<li>–owner=&lt;用户名称&gt; 把加入备份文件中的文件的拥有者设成指定的用户。</li>
<li>–posix 将数据写入备份文件时使用POSIX格式。</li>
<li>–preserve 此参数的效果和指定”-ps”参数相同。</li>
<li>–preserve-order 此参数的效果和指定”-A”参数相同。</li>
<li>–preserve-permissions 此参数的效果和指定”-p”参数相同。</li>
<li>–record-size=&lt;区块数目&gt; 此参数的效果和指定”-b”参数相同。</li>
<li>–recursive-unlink 解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</li>
<li>–remove-files 文件加入备份文件后，就将其删除。</li>
<li>–rsh-command=&lt;执行指令&gt; 设置要在远端主机上执行的指令，以取代rsh指令。</li>
<li>–same-owner 尝试以相同的文件拥有者还原文件。</li>
<li>–suffix=&lt;备份字尾字符串&gt; 移除文件前先行备份。</li>
<li>–totals 备份文件建立后，列出文件大小。</li>
<li>–use-compress-program=&lt;执行指令&gt; 通过指定的指令处理备份文件。</li>
<li>–version 显示版本信息。</li>
<li>–volno-file=&lt;编号文件&gt; 使用指定文件内的编号取代预设的卷册编号。</li>
</ul>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>压缩文件 非打包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># touch a.c       </span><br><span class="line"># tar -czvf test.tar.gz a.c   &#x2F;&#x2F;压缩 a.c文件为test.tar.gz</span><br><span class="line">a.c</span><br></pre></td></tr></table></figure>

<p>列出压缩文件内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># tar -tzvf test.tar.gz </span><br><span class="line">-rw-r--r-- root&#x2F;root     0 2010-05-24 16:51:59 a.c</span><br></pre></td></tr></table></figure>

<p>解压文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># tar -xzvf test.tar.gz </span><br><span class="line">a.c</span><br></pre></td></tr></table></figure>

<p>Linux 常用的压缩与解压缩命令有：tar、gzip、gunzip、bzip2、bunzip2、compress 、uncompress、 zip、 unzip、rar、unrar 等。</p>
<hr>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>最常用的打包命令是 tar，使用 tar 程序打出来的包我们常称为 tar 包，tar 包文件的命令通常都是以 .tar 结尾的。生成 tar 包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲 tar 命令的基本用法。</p>
<p>tar 命令的选项有很多(用 man tar 可以查看到)，但常用的就那么几个选项，下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -cf all.tar *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件打成一个名为 all.tar 的包。-c 是表示产生新的包，-f 指定包的文件名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -rf all.tar *.gif</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .gif 的文件增加到 all.tar 的包里面去，-r 是表示增加文件的意思。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -uf all.tar logo.gif</span><br></pre></td></tr></table></figure>

<p>这条命令是更新原来 tar 包 all.tar 中 logo.gif 文件，-u 是表示更新文件的意思。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -tf all.tar</span><br></pre></td></tr></table></figure>

<p>这条命令是列出 all.tar 包中所有文件，-t 是列出文件的意思。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -xf all.tar</span><br></pre></td></tr></table></figure>

<p>这条命令是解出 all.tar 包中所有文件，-x 是解开的意思。</p>
<p>以上就是 tar 的最基本的用法。为了方便用户在打包解包的同时可以压缩或解压文件，tar 提供了一种特殊的功能。这就是 tar 可以在打包或解包的同时调用其它的压缩程序，比如调用 gzip、bzip2 等。</p>
<h3 id="1-tar调用"><a href="#1-tar调用" class="headerlink" title="1) tar调用"></a>1) tar调用</h3><p>gzip 是 GNU 组织开发的一个压缩程序，.gz 结尾的文件就是 gzip 压缩的结果。与 gzip 相对的解压程序是 gunzip。tar 中使用 -z 这个参数来调用gzip。下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -czf all.tar.gz *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件打成一个 tar 包，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包，包名为 all.tar.gz。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -xzf all.tar.gz</span><br></pre></td></tr></table></figure>

<p>这条命令是将上面产生的包解开。</p>
<h3 id="2-tar-调用-bzip2"><a href="#2-tar-调用-bzip2" class="headerlink" title="2) tar 调用 bzip2"></a>2) tar 调用 bzip2</h3><p>bzip2 是一个压缩能力更强的压缩程序，.bz2 结尾的文件就是 bzip2 压缩的结果。</p>
<p>与 bzip2 相对的解压程序是 bunzip2。tar 中使用 -j 这个参数来调用 gzip。下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -cjf all.tar.bz2 *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件打成一个 tar 包，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，包名为 all.tar.bz2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -xjf all.tar.bz2</span><br></pre></td></tr></table></figure>

<p>这条命令是将上面产生的包解开。</p>
<h3 id="3-tar-调用-compress"><a href="#3-tar-调用-compress" class="headerlink" title="3)tar 调用 compress"></a>3)tar 调用 compress</h3><p>compress 也是一个压缩程序，但是好象使用 compress 的人不如 gzip 和 bzip2 的人多。.Z 结尾的文件就是 bzip2 压缩的结果。与 compress 相对的解压程序是 uncompress。tar 中使用 -Z 这个参数来调用 compress。下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -cZf all.tar.Z *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件打成一个 tar 包，并且将其用 compress 压缩，生成一个 uncompress 压缩过的包，包名为 all.tar.Z。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -xZf all.tar.Z</span><br></pre></td></tr></table></figure>

<p>这条命令是将上面产生的包解开。</p>
<p>有了上面的知识，你应该可以解开多种压缩文件了，下面对于 tar 系列的压缩文件作一个小结：</p>
<p><strong>1) 对于.tar结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf all.tar</span><br></pre></td></tr></table></figure>

<p><strong>2) 对于 .gz 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip -d all.gz</span><br><span class="line">gunzip all.gz</span><br></pre></td></tr></table></figure>

<p><strong>3)对于 .tgz 或 .tar.gz 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf all.tar.gz</span><br><span class="line">tar -xzf all.tgz</span><br></pre></td></tr></table></figure>

<p><strong>4) 对于 .bz2 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -d all.bz2</span><br><span class="line">bunzip2 all.bz2</span><br></pre></td></tr></table></figure>

<p><strong>5) 对于 tar.bz2 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xjf all.tar.bz2</span><br></pre></td></tr></table></figure>

<p><strong>6) 对于 .Z 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uncompress all.Z</span><br></pre></td></tr></table></figure>

<p><strong>7) 对于 .tar.Z 结尾的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xZf all.tar.z</span><br></pre></td></tr></table></figure>

<p>另外对于 Windows 下的常见压缩文件 .zip 和 .rar，Linux 也有相应的方法来解压它们：</p>
<p><strong>1) 对于 .zip</strong></p>
<p>linux 下提供了 zip 和 unzip 程序，zip 是压缩程序，unzip 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># zip all.zip *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件压缩成一个 zip 包:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># unzip all.zip</span><br></pre></td></tr></table></figure>

<p>这条命令是将 all.zip 中的所有文件解压出来。</p>
<p><strong>2) 对于 .rar</strong></p>
<p>要在 linux 下处理 .rar 文件，需要安装 RAR for Linux。下载地址：<a href="http://www.rarsoft.com/download.htm，下载后安装即可。" target="_blank" rel="noopener">http://www.rarsoft.com/download.htm，下载后安装即可。</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># tar -xzpvf rarlinux-x64-5.6.b5.tar.gz</span><br><span class="line"># cd rar </span><br><span class="line"># make</span><br></pre></td></tr></table></figure>

<p>这样就安装好了，安装后就有了 rar 和 unrar 这两个程序，rar 是压缩程序，unrar 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rar a all *.jpg</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .jpg 的文件压缩成一个 rar 包，名为 all.rar，该程序会将 .rar 扩展名将自动附加到包名后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># unrar e all.rar</span><br></pre></td></tr></table></figure>

<p>这条命令是将 all.rar 中的所有文件解压出来：</p>
<hr>
<h2 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h2><p><strong>tar</strong></p>
<p>-C 解压缩到指定目录，且目录必须存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c: 建立压缩档案 </span><br><span class="line">-x：解压 </span><br><span class="line">-t：查看内容 </span><br><span class="line">-r：向压缩归档文件末尾追加文件 </span><br><span class="line">-u：更新原压缩包中的文件</span><br></pre></td></tr></table></figure>

<p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-z：有gzip属性的 </span><br><span class="line">-j：有bz2属性的 </span><br><span class="line">-Z：有compress属性的 </span><br><span class="line">-v：显示所有过程 </span><br><span class="line">-O：将文件解开到标准输出</span><br></pre></td></tr></table></figure>

<p>下面的参数 -f 是必须的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</span><br></pre></td></tr></table></figure>

<p># tar -cf all.tar *.jpg </p>
<p>这条命令是将所有 .jpg 的文件打成一个名为 all.tar 的包。-c 是表示产生新的包，-f 指定包的文件名。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -rf all.tar *.gif</span><br></pre></td></tr></table></figure>

<p>这条命令是将所有 .gif 的文件增加到 all.tar 的包里面去。-r 是表示增加文件的意思。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -uf all.tar logo.gif</span><br></pre></td></tr></table></figure>

<p>这条命令是更新原来 tar 包 all.tar 中 logo.gif 文件，-u 是表示更新文件的意思。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -tf all.tar</span><br></pre></td></tr></table></figure>

<p>这条命令是列出 all.tar 包中所有文件，-t 是列出文件的意思。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -xf all.tar</span><br></pre></td></tr></table></figure>

<p>这条命令是解出 all.tar 包中所有文件，-x 是解开的意思。</p>
<p><strong>压缩</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar –cvf jpg.tar *.jpg       &#x2F;&#x2F; 将目录里所有jpg文件打包成 tar.jpg </span><br><span class="line">tar –czf jpg.tar.gz *.jpg    &#x2F;&#x2F; 将目录里所有jpg文件打包成 jpg.tar 后，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包，命名为 jpg.tar.gz </span><br><span class="line">tar –cjf jpg.tar.bz2 *.jpg   &#x2F;&#x2F; 将目录里所有jpg文件打包成 jpg.tar 后，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，命名为jpg.tar.bz2 </span><br><span class="line">tar –cZf jpg.tar.Z *.jpg     &#x2F;&#x2F; 将目录里所有 jpg 文件打包成 jpg.tar 后，并且将其用 compress 压缩，生成一个 umcompress 压缩过的包，命名为jpg.tar.Z </span><br><span class="line">rar a jpg.rar *.jpg          &#x2F;&#x2F; rar格式的压缩，需要先下载 rar for linux </span><br><span class="line">zip jpg.zip *.jpg            &#x2F;&#x2F; zip格式的压缩，需要先下载 zip for linux</span><br></pre></td></tr></table></figure>

<p><strong>解压</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar –xvf file.tar         &#x2F;&#x2F; 解压 tar 包 （常用）</span><br><span class="line">tar -xzvf file.tar.gz     &#x2F;&#x2F; 解压 tar.gz </span><br><span class="line">tar -xjvf file.tar.bz2    &#x2F;&#x2F; 解压 tar.bz2 </span><br><span class="line">tar –xZvf file.tar.Z      &#x2F;&#x2F; 解压 tar.Z </span><br><span class="line">unrar e file.rar          &#x2F;&#x2F; 解压 rar </span><br><span class="line">unzip file.zip            &#x2F;&#x2F; 解压 zip</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、*.tar 用 tar –xvf 解压 </span><br><span class="line">2、*.gz 用 gzip -d或者gunzip 解压 </span><br><span class="line">3、*.tar.gz和*.tgz 用 tar –xzf 解压 </span><br><span class="line">4、*.bz2 用 bzip2 -d或者用bunzip2 解压 </span><br><span class="line">5、*.tar.bz2用tar –xjf 解压 </span><br><span class="line">6、*.Z 用 uncompress 解压 </span><br><span class="line">7、*.tar.Z 用tar –xZf 解压 </span><br><span class="line">8、*.rar 用 unrar e解压 </span><br><span class="line">9、*.zip 用 unzip 解压</span><br></pre></td></tr></table></figure>

<h3 id="压缩-解压缩"><a href="#压缩-解压缩" class="headerlink" title="压缩/解压缩"></a>压缩/解压缩</h3><p>总结：tar -cvf tar -xvf（一对）（打包解压）</p>
<p>​            tar -zcvf tar-zxvf(一对) （压缩解压）</p>
<p>​            tar -zcvf 打包文件.tar.gz 被压缩文件/路径 #压缩</p>
<p>​            tar -zxvf 打包文件.tar.gz #压缩文件  </p>
<p>​            tar -zxvf 打包文件.tar.gz -C 目标路径 #解压到指定路径</p>
<p>gzip：压缩（和tar一起用：打包压缩）</p>
<p>Linux gzip命令用于压缩文件。</p>
<p>gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best&#x2F;fast][文件...] 或 gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best&#x2F;fast][目录]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-a或–ascii 　使用ASCII文字模式。</li>
<li>-c或–stdout或–to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。</li>
<li>-d或–decompress或—-uncompress 　解开压缩文件。</li>
<li>-f或–force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。</li>
<li>-h或–help 　在线帮助。</li>
<li>-l或–list 　列出压缩文件的相关信息。</li>
<li>-L或–license 　显示版本与版权信息。</li>
<li>-n或–no-name 　压缩文件时，不保存原来的文件名称及时间戳记。</li>
<li>-N或–name 　压缩文件时，保存原来的文件名称及时间戳记。</li>
<li>-q或–quiet 　不显示警告信息。</li>
<li>-r或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。</li>
<li>-S&lt;压缩字尾字符串&gt;或—-suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。</li>
<li>-t或–test 　测试压缩文件是否正确无误。</li>
<li>-v或–verbose 　显示指令执行过程。</li>
<li>-V或–version 　显示版本信息。</li>
<li>-&lt;压缩效率&gt; 　压缩效率是一个介于1－9的数值，预设值为”6”，指定愈大的数值，压缩效率就会愈高。</li>
<li>–best 　此参数的效果和指定”-9”参数相同。</li>
<li>–fast 　此参数的效果和指定”-1”参数相同。</li>
</ul>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>压缩文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@runoob.com a]# ls &#x2F;&#x2F;显示当前目录文件</span><br><span class="line">a.c b.h d.cpp</span><br><span class="line">[root@runoob.com a]# gzip * &#x2F;&#x2F;压缩目录下的所有文件</span><br><span class="line">[root@runoob.com a]# ls &#x2F;&#x2F;显示当前目录文件</span><br><span class="line">a.c.gz    b.h.gz    d.cpp.gz</span><br><span class="line">[root@runoob.com a]#</span><br></pre></td></tr></table></figure>

<p>接范例1， 列出详细的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@runoob.com a]# gzip -dv * &#x2F;&#x2F;解压文件，并列出详细信息</span><br><span class="line">a.c.gz:     0.0% -- replaced with a.c</span><br><span class="line">b.h.gz:     0.0% -- replaced with b.h</span><br><span class="line">d.cpp.gz:     0.0% -- replaced with d.cpp</span><br><span class="line">[root@runoob.com a]#</span><br></pre></td></tr></table></figure>

<p>接范例1，显示压缩文件的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@runoob.com a]# gzip -l *</span><br><span class="line">     compressed    uncompressed ratio uncompressed_name</span><br><span class="line">         24          0  0.0% a.c</span><br><span class="line">         24          0  0.0% b.h</span><br><span class="line">         26          0  0.0% d.cpp</span><br></pre></td></tr></table></figure>

<h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p>Linux bzip2命令是.bz2文件的压缩程序。</p>
<p>bzip2像gzip一样，tar打包，bzip2压缩tar后文件，扩展名 .tar.bz2</p>
<p>压缩文件 tar -jcvf 打包文件.tar.bz2 被压缩文件/路径</p>
<p>解压 tar -jxvf 打包文件.tar.bz2</p>
<p>-C 解压缩到指定目录，且目录必须存在</p>
<p>bzip2采用新的压缩演算法，压缩效果比传统的LZ77/LZ78压缩演算法来得好。若没有加上任何参数，bzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。</p>
<h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 [-cdfhkLstvVz][--repetitive-best][--repetitive-fast][- 压缩等级][要压缩的文件]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-c或–stdout 　将压缩与解压缩的结果送到标准输出。</li>
<li>-d或–decompress 　执行解压缩。</li>
<li>-f或–force 　bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖，请使用此参数。</li>
<li>-h或–help 　显示帮助。</li>
<li>-k或–keep 　bzip2在压缩或解压缩后，会删除原始的文件。若要保留原始文件，请使用此参数。</li>
<li>-s或–small 　降低程序执行时内存的使用量。</li>
<li>-t或–test 　测试.bz2压缩文件的完整性。</li>
<li>-v或–verbose 　压缩或解压缩文件时，显示详细的信息。</li>
<li>-z或–compress 　强制执行压缩。</li>
<li>-L,–license,</li>
<li>-V或–version 　显示版本信息。</li>
<li>–repetitive-best 　若文件中有重复出现的资料时，可利用此参数提高压缩效果。</li>
<li>–repetitive-fast 　若文件中有重复出现的资料时，可利用此参数加快执行速度。</li>
<li>-压缩等级 　压缩时的区块大小。</li>
</ul>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>解压.bz2文件 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@w3cschool.cc ~]# bzip2 -v temp.bz2 &#x2F;&#x2F;解压文件显示详细处理信息</span><br></pre></td></tr></table></figure>

<p>压缩文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@w3cschool.cc ~]# bzip2 -c a.c b.c c.c</span><br></pre></td></tr></table></figure>

<p>检查文件完整性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@w3cschool.cc ~]# bzip2 -t temp.bz2</span><br></pre></td></tr></table></figure>

<h2 id="P98-100软件安装"><a href="#P98-100软件安装" class="headerlink" title="P98-100软件安装"></a>P98-100软件安装</h2><p>apt是advanced packaging tool，linux下安装管理工具</p>
<p>sudo apt install 软件包#安装</p>
<p>sudo apt remove 软件包名#卸载</p>
<p>sudo apt upgrade#更新</p>
<p>sudo apt install htop#查看当前进程，输入htop即可</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/26/linux4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/26/linux4/" class="post-title-link" itemprop="url">linux基础（61-80集）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 17:38:19 / Modified: 21:50:42" itemprop="dateCreated datePublished" datetime="2020-04-26T17:38:19-05:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P60-61（用户文件权限）"><a href="#P60-61（用户文件权限）" class="headerlink" title="P60-61（用户文件权限）"></a>P60-61（用户文件权限）</h2><p>用户管理包括用户与组管理。</p>
<p> Linux操作系统对多用户的管理，是非常繁琐的，所以用组的概念来管理用户就变得简单，每个用户可以在一个独立的组，每个组也可以有零个用户或者多个用户。</p>
<p>Linux系统用户是根据用户ID来识别的，默认ID长度为32位，从默认ID编号从0开始，但是为了和老式系统兼容，用户ID限制在60000以下，Linux用户分总共分为三种，分别如下：</p>
<p> root用户  （ID 0）</p>
<p> 系统用户 （ID 1-499）</p>
<p>普通用户 （ID 500以上）</p>
<p>Linux系统中的每个文件或者文件夹，都有一个所属用户及所属组，使用id命令可以显示当前用户的信息，使用passwd命令可以修改当前用户密码。Linux操作系统用户的特点如下：</p>
<p>每个用户拥有一个UserID，操作系统实际读取的是UID，而非用户名；</p>
<p>每个用户属于一个主组，属于一个或多个附属组，一个用户最多有31个附属组；</p>
<p>每个组拥有一个GroupID；</p>
<p>每个进程以一个用户身份运行，该用户可对进程拥有资源控制权限；</p>
<p>每个可登陆用户拥有一个指定的Shell环境。</p>
<h2 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h2><p>Linux用户在操作系统可以进行日常管理和维护，涉及到的相关配置文件如下：</p>
<p>/etc/passwd   保存用户信息</p>
<p> /etc/shdaow   保存用户密码（以加密形式保存）</p>
<p> /etc/group    保存组信息</p>
<p> /etc/login.defs  用户属性限制,密码过期时间,密码最大长度等限制</p>
<p> /etc/default/useradd 显示或更改默认的useradd配置文件</p>
<p>如需创建新用户，可以使用命令useradd，执行命令useradd test1即可创建test1用户，同时会创建一个同名的组test1，默认该用户属于test1主组。</p>
<p>Useradd test1命令默认创建用户test1，会根据如下步骤进行操作：</p>
<p> 在/etc/passwd文件中添加用户信息；</p>
<p>如使用passwd命令创建密码，密码会被加密保存在/etc/shdaow中；</p>
<p> 为test1创建家目录：/home/test1；</p>
<p> 将/etc/skel中的.bash开头的文件复制至/home/test1家目录；</p>
<p> 创建与用户名相同的test1组，test1用户默认属于test1同名组；</p>
<p> test1组信息保存在/etc/group配置文件中。</p>
<p>在使用useradd命令创建用户时，可以支持如下参数：</p>
<p>用法：useradd [选项] 登录</p>
<p>useradd -D</p>
<p>useradd -D [选项]</p>
<p>选项：</p>
<p>-b, –base-dir BASE_DIR     指定新账户的家目录；</p>
<p>-c, –comment COMMENT      新账户的 GECOS 字段；</p>
<p>-d, –home-dir HOME_DIR     新账户的主目录；</p>
<p>-D, –defaults         显示或更改默认的 useradd 配置；</p>
<p>-e, –expiredate EXPIRE_DATE  新账户的过期日期；</p>
<p>-f, –inactive INACTIVE     新账户的密码不活动期；</p>
<p>-g, –gid GROUP         新账户主组的名称或ID；</p>
<p>-G, –groups GROUPS     新账户的附加组列表；</p>
<p>-h, –help           显示此帮助信息并推出；</p>
<p>-k, –skel SKEL_DIR       使用此目录作为骨架目录；</p>
<p>-K, –key KEY=VALUE       不使用 /etc/login.defs 中的默认值；</p>
<p>-l, –no-log-init      不要将此用户添加到最近登录和登录失败数据库；</p>
<p>-m, –create-home      创建用户的主目录；</p>
<p>-M, –no-create-home    不创建用户的主目录；</p>
<p>-N, –no-user-group     不创建同名的组；</p>
<p>-o, –non-unique        允许使用重复的 UID 创建用户；</p>
<p>-p, –password  PASSWORD     加密后的新账户密码；</p>
<p>-r, –system          创建一个系统账户；</p>
<p>-R, –root CHROOT_DIR      chroot 到的目录；</p>
<p>-s, –shell SHELL        新账户的登录 shell；</p>
<p>-u, –uid UID          新账户的用户 ID；</p>
<p>-U, –user-group        创建与用户同名的组；</p>
<p>-Z, –selinux-user SEUSER    为SELinux 用户映射使用指定 SEUSER。</p>
<h2 id="Linux组管理"><a href="#Linux组管理" class="headerlink" title="Linux组管理"></a>Linux组管理</h2><p> 所有的Linux或者Windows系统都有组的概念，通过组可以更加方便的管理用户，组的概念应用于各行行业，例如企业会使用部门、职能或地理区域的分类方式来管理成员，映射在Linux系统，同样可以创建用户，并用组的概念对其管理。</p>
<p>Linux组有如下特点：</p>
<p> 每个组有一个组ID；</p>
<p> 组信息保存在/etc/group中；</p>
<p> 每个用户至少拥有一个主组，同时还可以拥有31个附属组。</p>
<p>通过命令groupadd、groupdel、groupmod来对组进行管理，详细参数使用如下：</p>
<p>groupadd用法</p>
<p>-f, –force       如果组已经存在则成功退出；</p>
<p>并且如果 GID 已经存在则取消 –g；</p>
<p>-g, –gid GID       为新组使用 GID；</p>
<p>-h, –help         显示此帮助信息并推出；</p>
<p>-K, –key KEY=VALUE    不使用 /etc/login.defs 中的默认值；</p>
<p>-o, –non-unique      允许创建有重复 GID 的组；</p>
<p>-p, –password PASSWORD  为新组使用此加密过的密码；</p>
<p>-r, –system        创建一个系统账户；</p>
<p>groupmod用法</p>
<p>-g, –gid GID       将组 ID 改为 GID；</p>
<p>-h, –help         显示此帮助信息并推出；</p>
<p>-n, –new-name NEW_GROUP 改名为 NEW_GROUP；</p>
<p>-o, –non-unique      允许使用重复的 GID；</p>
<p>-p, –password PASSWORD  将密码更改为(加密过的) PASSWORD；</p>
<p>groupdel用法</p>
<p>groupdel admin         删除admin组；</p>
<h2 id="二、-Linux权限管理"><a href="#二、-Linux权限管理" class="headerlink" title="二、 Linux权限管理"></a>二、 Linux权限管理</h2><p>Linux权限是操作系统用来限制对资源访问的机制，权限一般分为读、写、执行。系统中每个文件都拥有特定的权限、所属用户及所属组，通过这样的机制来限制哪些用户或用户组可以对特定文件进行相应的操作。</p>
<p>Linux每个进程都是以某个用户身份运行，进程的权限与该用户的权限一样，用户的权限越大，则进程拥有的权限就越大。</p>
<p>Lnux中有的文件及文件夹都有至少权限三种权限，常见的权限如表5-1所示:</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>r（读取）</td>
<td>可读取文件内容</td>
<td>可列出目录内容</td>
</tr>
<tr>
<td>w（写入）</td>
<td>可修改文件内容</td>
<td>可在目录中创建删除内容</td>
</tr>
<tr>
<td>x（执行）</td>
<td>可作为命令执行</td>
<td>可访问目录内容</td>
</tr>
<tr>
<td>目录必须拥有 x 权限，否则无法查看其内容</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Linux权限授权，默认是授权给三种角色，分别是user、group、other，Linux权限与用户之间的关联如下：</p>
<p>U代表User，G代表Group，O代表Other；</p>
<p> 每个文件的权限基于UGO进行设置；</p>
<p>权限三位一组（rwx），同时需授权给三种角色，UGO；</p>
<p> 每个文件拥有一个所属用户和所属组，对应UGO，不属于该文件所属用户或所属组使用O来表示；</p>
<p>在Linux系统中，可以通过ls –l查看peter.net目录的详细属性，如图5-1所示：</p>
<p>drwxrwxr-x  2 peter1 peter1 4096 Dec 10 01:36 peter.net</p>
<p>peter.net目录属性参数详解如下：</p>
<p> d 表示目录，同一位置如果为-则表示普通文件；</p>
<p> rwxrwxr-x 表示三种角色的权限，每三位为一种角色，依次为u，g，o权限，如上则表示user的权限为rwx，group的权限为rwx，other的权限为r-x；</p>
<p> 2表示文件夹的链接数量，可理解为该目录下子目录的数量；</p>
<p> 从左到右，第一个peter1表示该用户名，第二个peter1则为组名，其他人角色默认不显示；</p>
<p> 4096表示该文件夹占据的字节数；</p>
<p> Dec 10 01:36 表示文件创建或者修改的时间；</p>
<p>peter.net 为目录的名，或者文件名。</p>
<p>peter.net目录属性参数详解如下：</p>
<p> d 表示目录，同一位置如果为-则表示普通文件；</p>
<p> rwxrwxr-x 表示三种角色的权限，每三位为一种角色，依次为u，g，o权限，如上则表示user的权限为rwx，group的权限为rwx，other的权限为r-x；</p>
<p> 2表示文件夹的链接数量，可理解为该目录下子目录的数量；</p>
<p> 从左到右，第一个peter1表示该用户名，第二个peter1则为组名，其他人角色默认不显示；</p>
<p> 4096表示该文件夹占据的字节数；</p>
<p> Dec 10 01:36 表示文件创建或者修改的时间；</p>
<p>peter.net 为目录的名，或者文件名。</p>
<h2 id="Chmod用户及组权限"><a href="#Chmod用户及组权限" class="headerlink" title="Chmod用户及组权限"></a>Chmod用户及组权限</h2><p>修改某个用户、组对文件夹的权限，用命令chmod实现，其中以代指ugo，、-、=代表加入、删除和等于对应权限，具体案例如下：</p>
<p>（1） 授予用户对peter.net目录拥有rwx权限</p>
<p>chmod  –R  u+rwx  peter.net</p>
<p>（2） 授予组对peter.net目录拥有rwx权限</p>
<p>chmod  –R  g+rwx  peter.net</p>
<p>（3） 授予用户、组、其他人对jpeter.net目录拥有rwx权限</p>
<p>chmod  –R  u+rwx,g+rwx,o+rwx  peter.net</p>
<p>（4） 撤销用户对peter.net目录拥有w权限</p>
<p>chmod  –R  u-w  peter.net</p>
<p>（5） 撤销用户、组、其他人对peter.net目录拥有x权限</p>
<p>chmod  –R  u-x,g-x,o-x peter.net</p>
<p>（6） 授予用户、组、其他人对jpeter.net目录只有rx权限</p>
<p>chmod  –R  u=rx,g=rx,o=rx  peter.net</p>
<h2 id="Chmod二进制权限"><a href="#Chmod二进制权限" class="headerlink" title="Chmod二进制权限"></a>Chmod二进制权限</h2><p>Linux权限默认使用rwx来表示，为了更简化在系统中对权限进行配置和修改，Linux权限引入二进制表示方法，如下代码：</p>
<p>Linux权限可以将rwx用二进制来表示，其中有权限用1表示，没有权限用0表示；Linux权限用二进制显示如下：rwx=111r-x=101rw-=110r–=100依次类推，转化为十进制，对应十进制结果显示如下：rwx=111=4+2+1=7r-x=101=4+0+1=5rw-=110=4+4+0=6r–=100=4+0+0=4得出结论，用r=4,w=2,x=1来表示权限。</p>
<p>使用二进制方式来修改权限案例演示如下，其中默认peter.nett目录权限为755：</p>
<p>（1） 授予用户对peter.net目录拥有rwx权限</p>
<p>chmod  –R  755 peter.net</p>
<p>（2） 授予组对peter.net目录拥有rwx权限</p>
<p>chmod  –R  775 peter.net</p>
<p>（3） 授予用户、组、其他人对peter.net目录拥有rwx权限</p>
<p>chmod  –R  777  peter.net</p>
<h2 id="Linux特殊权限及掩码"><a href="#Linux特殊权限及掩码" class="headerlink" title="Linux特殊权限及掩码"></a>Linux特殊权限及掩码</h2><p>Linux权限除了常见的rwx权限之外，还有很多特殊的权限，细心的读者会发现，为什么Linux目录默认权限755，而文件默认权限为644呢，这是因为Linux权限掩码umask导致。</p>
<p>每个Linux终端都拥有一个umask属性，umask熟悉可以用来确定新建文件、目录的默认权限，默认系统权限掩码为022。在系统中每创建一个文件或者目录，文件默认权限是666，而目录权限则为777，权限对外开放比较大，所以设置了权限掩码之后，默认的文件和目录权限减去umask值才是真实的文件和目录的权限。</p>
<p> 对应目录权限为：777-022=755；</p>
<p> 对应文件权限为：666-022=644；</p>
<p> 执行umask命令可以查看当前默认的掩码，umask -S 023可以设置默认的权限掩码。</p>
<p>在Linux权限中，除了普通权限外，还有如下表5-2所示，三个特殊权限：</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>Suid</td>
<td>以文件的所属用户身份执行，而非执行文件的用户</td>
<td>无</td>
</tr>
<tr>
<td>sgid</td>
<td>以文件所属组身份去执行</td>
<td>在该目录中创建任意新文件的所属组与该目录的所属组相同</td>
</tr>
<tr>
<td>sticky</td>
<td>无</td>
<td>对目录拥有写入权限的用户仅可以删除其拥有的文件，无法删除其他用户所拥有的文件</td>
</tr>
</tbody></table>
<p>表5-2 Linux三种特殊权限</p>
<p>Linux中设置特殊权限方法如下：</p>
<p>q 设置suid： chmod u+s peter.net</p>
<p>q 设置sgid： chmod g+s peter.net</p>
<p>q 设置sticky： chmod o+t peter.net</p>
<p>特殊权限与设置普通权限一样，可以使用数字方式表示：</p>
<p> SUID   = 4</p>
<p> SGID   = 2</p>
<p> Sticky = 1</p>
<p>可以通过chmod 4755 peter.net对该目录授予特殊权限为s的权限，Linux系统中s权限的应用常见包括：su、passwd、sudo，</p>
<h2 id="P62-63-ls-l"><a href="#P62-63-ls-l" class="headerlink" title="P62-63(ls -l)"></a>P62-63(ls -l)</h2><table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>r（读取）</td>
<td>可读取文件内容</td>
<td>可列出目录内容</td>
</tr>
<tr>
<td>w（写入）</td>
<td>可修改文件内容</td>
<td>可在目录中创建删除内容</td>
</tr>
<tr>
<td>x（执行）</td>
<td>可作为命令执行</td>
<td>可访问目录内容</td>
</tr>
<tr>
<td>目录必须拥有 x 权限，否则无法查看其内容</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>-rw-rw-r–: rw, rw, r</p>
<p>drwxrwxr-x:目录，rwx,rwx,r-x</p>
<p><em>d是目录，第一组是拥有者权限，第二组是组权限，第三组是其他用户权限，每3个一组。</em></p>
<p><em>”/“是根目录，”~“是家目录。Linux存储是以挂载的方式，相当于是树状的，源头就是”/“，也就是根目录。而每个用户都有”家“目录，也就是用户的个人目录，比如root用户的”家“目录就是/root,普通用户a的家目录就是/home/a</em></p>
<h3 id="ls常见命令参数"><a href="#ls常见命令参数" class="headerlink" title="ls常见命令参数"></a>ls常见命令参数</h3><p>ls: -F 给不同的文件添加不同表示,添加帽子</p>
<p>d/   l*  =s </p>
<p>-a: 显示隐藏文件  以.开头的文件</p>
<p>-p: 只给目录添加/</p>
<p>-t: 按照修改时间排序 time </p>
<p>   –time-style=long-iso: ls -l –time-style=long-iso  显示友好长格式时间</p>
<p>-r: 倒着排序 reverse</p>
<p>-S: 按照文件大小排序</p>
<p>-h: 以人类理解的范围显示</p>
<p>-i: 索引节点(inode==书的目录) print the index number of each file(内核根据此区别文件是否同一文件)</p>
<h3 id="ls-–l-文件显示内容分析"><a href="#ls-–l-文件显示内容分析" class="headerlink" title="ls –l 文件显示内容分析"></a>ls –l 文件显示内容分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第一列： 文件类型(共10个字符) + 权限  --&gt; &#96;&#96;man&#96; &#96;find&#96; &#96;搜索&#96;&#96;type&#96;&#96;可看</span><br><span class="line">      &#96;&#96;-:普通文件</span><br><span class="line">      &#96;&#96;d:目录</span><br><span class="line">      &#96;&#96;c:字符设备 --&gt; &#96;&#96;&#x2F;dev&#x2F;tty&#96;   &#96;例如 USB接口、猫等一些串行端口设备</span><br><span class="line">      &#96;&#96;b:块设备  --&gt; &#96;&#96;&#x2F;dev&#96;&#96;下查找 例如光驱，硬盘等属于块设备</span><br><span class="line">      &#96;&#96;.:SELINUX相关 </span><br><span class="line">      &#96;&#96;l:链接文件 --&gt; 软连接</span><br><span class="line">第二列：硬链接个数 默认从1开始 如果是目录，则默认是2(目录不做硬链接)：几种到达的方法</span><br><span class="line">第三列：文件属主</span><br><span class="line">第四列：文件属组</span><br><span class="line">第五列：文件大小</span><br><span class="line">第六-八列：创建时间&#x2F;最后一次修改时间</span><br><span class="line">第九列：文件名</span><br></pre></td></tr></table></figure>

<p><a href="https://images2018.cnblogs.com/blog/519608/201806/519608-20180630125442504-449878811.png" target="_blank" rel="noopener"><img src="https://images2018.cnblogs.com/blog/519608/201806/519608-20180630125442922-137320976.png" alt="image"></a></p>
<h2 id="P64-65-chmod"><a href="#P64-65-chmod" class="headerlink" title="P64-65(chmod)"></a>P64-65(chmod)</h2><p>Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。</p>
<p><strong>使用权限</strong> : 所有使用者</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-cfvR] [--help] [--version] mode file...</span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>mode : 权限设定字串，格式如下 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ugoa...][[+-&#x3D;][rwxX]...][,...]</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li>
<li>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li>
</ul>
<p>其他参数说明：</p>
<ul>
<li>-c : 若该文件权限确实已经更改，才显示其更改动作</li>
<li>-f : 若该文件权限无法被更改也不要显示错误讯息</li>
<li>-v : 显示权限变更的详细资料</li>
<li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>将文件 file1.txt 设为所有人皆可读取 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ugo+r file1.txt</span><br></pre></td></tr></table></figure>

<p>将文件 file1.txt 设为所有人皆可读取 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+r file1.txt</span><br></pre></td></tr></table></figure>

<p>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ug+w,o-w file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p>将 ex1.py 设定为只有该文件拥有者可以执行 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x ex1.py</span><br></pre></td></tr></table></figure>

<p>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R a+r *</span><br></pre></td></tr></table></figure>

<p>此外chmod也可以用数字来表示权限如 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure>

<p>语法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod abc file</span><br></pre></td></tr></table></figure>

<p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p>
<h4 id="r-4，w-2，x-1"><a href="#r-4，w-2，x-1" class="headerlink" title="r=4，w=2，x=1"></a>r=4，w=2，x=1</h4><ul>
<li>若要rwx属性则4+2+1=7；</li>
<li>若要rw-属性则4+2=6；</li>
<li>若要r-x属性则4+1=5。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a&#x3D;rwx file</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure>

<p>效果相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ug&#x3D;rwx,o&#x3D;x file</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 771 file</span><br></pre></td></tr></table></figure>

<p>效果相同</p>
<p>若用chmod 4755 filename可使此程序具有root的权限</p>
<h2 id="P65-66（超级用户）"><a href="#P65-66（超级用户）" class="headerlink" title="P65-66（超级用户）"></a>P65-66（超级用户）</h2><p>sudo的全称为Superuser do的意思</p>
<p>日常使用用标准用户administrator，root用户用来系统维护和管理，对所有资源都有访问权限</p>
<p>默认安装完成之后并不知道root用户的密码，那么如何应用root权限呢？</p>
<h3 id="1-sudo-命令"><a href="#1-sudo-命令" class="headerlink" title="(1)sudo 命令"></a>(1)sudo 命令</h3><p>xzm@ubuntu:~$ sudo</p>
<p>这样输入当前管理员用户密码就可以得到超级用户的权限。但默认的情况下5分钟root权限就失效了。</p>
<h3 id="2-sudo-i"><a href="#2-sudo-i" class="headerlink" title="(2)sudo -i"></a>(2)sudo -i</h3><p>xzm@ubuntu:~$ sudo -i</p>
<p>通过这种方法输入当前管理员用户的密码就可以进到root用户。</p>
<h3 id="3-如果想一直使用root权限，要通过su切换到root用户。"><a href="#3-如果想一直使用root权限，要通过su切换到root用户。" class="headerlink" title="(3)如果想一直使用root权限，要通过su切换到root用户。"></a>(3)如果想一直使用root权限，要通过su切换到root用户。</h3><p>那我们首先要重设置root用户的密码：</p>
<p>xzm@ubuntu:~$ sudo passwd root</p>
<p>这样就可以设置root用户的密码了。</p>
<h3 id="4-之后就可以自由的切换到root用户了"><a href="#4-之后就可以自由的切换到root用户了" class="headerlink" title="(4)之后就可以自由的切换到root用户了"></a>(4)之后就可以自由的切换到root用户了</h3><p>xzm@ubuntu:~$ su</p>
<p>输入root用户的密码即可。</p>
<p>su “king” 或者 exit回到用户权限</p>
<p>Linux su命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。</p>
<p>使用权限：所有使用者。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [-fmp] [-c command] [-s shell] [--help] [--version] [-] [USER [ARG]]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-f 或 –fast 不必读启动档（如 csh.cshrc 等），仅用于 csh 或 tcsh</li>
<li>-m -p 或 –preserve-environment 执行 su 时不改变环境变数</li>
<li>-c command 或 –command=command 变更为帐号为 USER 的使用者并执行指令（command）后再变回原来使用者</li>
<li>-s shell 或 –shell=shell 指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者（USER） shell</li>
<li>–help 显示说明文件</li>
<li>–version 显示版本资讯</li>
<li>- -l 或 –login 这个参数加了之后，就好像是重新 login 为该使用者一样，大部份环境变数（HOME SHELL USER等等）都是以该使用者（USER）为主，并且工作目录也会改变，如果没有指定 USER ，内定是 root</li>
<li>USER 欲变更的使用者帐号</li>
<li>ARG 传入新的 shell 参数</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>变更帐号为 root 并在执行 ls 指令后退出变回原使用者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -c ls root</span><br></pre></td></tr></table></figure>

<p>变更帐号为 root 并传入 -f 参数给新执行的 shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root -f</span><br></pre></td></tr></table></figure>

<p>变更帐号为 clsung 并改变工作目录至 clsung 的家目录（home dir）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - clsung</span><br></pre></td></tr></table></figure>

<p>切换用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hnlinux@runoob.com:~$ whoami &#x2F;&#x2F;显示当前用户</span><br><span class="line">hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ su root &#x2F;&#x2F;切换到root用户</span><br><span class="line">密码： </span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# whoami </span><br><span class="line">root</span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# pwd</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br></pre></td></tr></table></figure>

<p>切换用户，改变环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hnlinux@runoob.com:~$ whoami &#x2F;&#x2F;显示当前用户</span><br><span class="line">hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ su - root &#x2F;&#x2F;切换到root用户</span><br><span class="line">密码： </span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# whoami </span><br><span class="line">root</span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;root</span><br></pre></td></tr></table></figure>



<h2 id="P67-69（组管理）"><a href="#P67-69（组管理）" class="headerlink" title="P67-69（组管理）"></a>P67-69（组管理）</h2><p>sudo来创建删除组，不用sudo会permission denied</p>
<ol>
<li>groupadd 组名：添加组</li>
<li>groupdel 组名 ：删除组</li>
<li>cat /etc/group： 确认组信息</li>
<li>chgrp -R 组名 文件/目录名：递归修改文件/目录所属组</li>
</ol>
<p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 </p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。 </li>
<li>用户口令的管理。</li>
<li>用户组的管理。 </li>
</ul>
<hr>
<h2 id="一、Linux系统用户账号的管理"><a href="#一、Linux系统用户账号的管理" class="headerlink" title="一、Linux系统用户账号的管理"></a>一、Linux系统用户账号的管理</h2><p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p>
<p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。</p>
<h3 id="1、添加新的用户账号使用useradd命令，其语法如下："><a href="#1、添加新的用户账号使用useradd命令，其语法如下：" class="headerlink" title="1、添加新的用户账号使用useradd命令，其语法如下："></a>1、添加新的用户账号使用useradd命令，其语法如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><p>选项:</p>
<ul>
<li>-c comment 指定一段注释性描述。</li>
<li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li>
<li>-g 用户组 指定用户所属的用户组。</li>
<li>-G 用户组，用户组 指定用户所属的附加组。</li>
<li>-s Shell文件 指定用户的登录Shell。</li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
</ul>
</li>
<li><p>用户名: </p>
<p>指定新账号的登录名。</p>
</li>
</ul>
<h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># useradd –d  &#x2F;home&#x2F;sam -m sam</span><br></pre></td></tr></table></figure>

<p>此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）。</p>
<h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># useradd -s &#x2F;bin&#x2F;sh -g group –G adm,root gem</span><br></pre></td></tr></table></figure>

<p>此命令新建了一个用户gem，该用户的登录Shell是 <code>/bin/sh</code>，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。</p>
<p>这里可能新建组：<code>#groupadd group及groupadd adm</code></p>
<p>增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。</p>
<p>Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。</p>
<h3 id="2、删除帐号"><a href="#2、删除帐号" class="headerlink" title="2、删除帐号"></a>2、删除帐号</h3><p>如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p>
<p>删除一个已有的用户账号使用<code>userdel</code>命令，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项是 <strong>-r</strong>，它的作用是把用户的主目录一起删除。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># userdel -r sam</span><br></pre></td></tr></table></figure>

<p>此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p>
<h3 id="3、修改帐号"><a href="#3、修改帐号" class="headerlink" title="3、修改帐号"></a>3、修改帐号</h3><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p>
<p>修改已有用户的信息使用<code>usermod</code>命令，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项包括<code>-c, -d, -m, -g, -G, -s, -u以及-o等</code>，这些选项的意义与<code>useradd</code>命令中的选项一样，可以为用户指定新的资源值。</p>
<p>另外，有些系统可以使用选项：-l 新用户名</p>
<p>这个选项指定一个新的账号，即将原来的用户名改为新的用户名。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># usermod -s &#x2F;bin&#x2F;ksh -d &#x2F;home&#x2F;z –g developer sam</span><br></pre></td></tr></table></figure>

<p>此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。</p>
<h3 id="4、用户口令的管理"><a href="#4、用户口令的管理" class="headerlink" title="4、用户口令的管理"></a>4、用户口令的管理</h3><p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p>
<p>指定和修改用户口令的Shell命令是<code>passwd</code>。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>可使用的选项：</p>
<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。</li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
<p>如果默认用户名，则修改当前用户的口令。</p>
<p>例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ passwd </span><br><span class="line">Old password:****** </span><br><span class="line">New password:******* </span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>如果是超级用户，可以用下列形式指定任何用户的口令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># passwd sam </span><br><span class="line">New password:******* </span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p>
<p>为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。</p>
<p>为用户指定空口令时，执行下列形式的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># passwd -d sam</span><br></pre></td></tr></table></figure>

<p>此命令将用户 sam 的口令删除，这样用户 sam 下一次登录时，系统就不再允许该用户登录了。</p>
<p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># passwd -l sam</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、Linux系统用户组的管理"><a href="#二、Linux系统用户组的管理" class="headerlink" title="二、Linux系统用户组的管理"></a>二、Linux系统用户组的管理</h2><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p>
<h3 id="1、增加一个新的用户组使用groupadd命令。其格式如下："><a href="#1、增加一个新的用户组使用groupadd命令。其格式如下：" class="headerlink" title="1、增加一个新的用户组使用groupadd命令。其格式如下："></a>1、增加一个新的用户组使用groupadd命令。其格式如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd 选项 用户组</span><br></pre></td></tr></table></figure>

<p>可以使用的选项有：</p>
<ul>
<li>-g GID 指定新用户组的组标识号（GID）。</li>
<li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li>
</ul>
<h4 id="实例1："><a href="#实例1：" class="headerlink" title="实例1："></a>实例1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># groupadd group1</span><br></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p>
<h4 id="实例2："><a href="#实例2：" class="headerlink" title="实例2："></a>实例2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># groupadd -g 101 group2</span><br></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。</p>
<h3 id="2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下："><a href="#2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下：" class="headerlink" title="2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下："></a>2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure>

<h4 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># groupdel group1</span><br></pre></td></tr></table></figure>

<p>此命令从系统中删除组group1。</p>
<h3 id="3、修改用户组的属性使用groupmod命令。其语法如下："><a href="#3、修改用户组的属性使用groupmod命令。其语法如下：" class="headerlink" title="3、修改用户组的属性使用groupmod命令。其语法如下："></a>3、修改用户组的属性使用groupmod命令。其语法如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br></pre></td></tr></table></figure>

<p>常用的选项有：</p>
<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li>-n新用户组 将用户组的名字改为新名字</li>
</ul>
<h4 id="实例1：-1"><a href="#实例1：-1" class="headerlink" title="实例1："></a>实例1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># groupmod -g 102 group2</span><br></pre></td></tr></table></figure>

<p>此命令将组group2的组标识号修改为102。</p>
<h4 id="实例2：-1"><a href="#实例2：-1" class="headerlink" title="实例2："></a>实例2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># groupmod –g 10000 -n group3 group2</span><br></pre></td></tr></table></figure>

<p>此命令将组group2的标识号改为10000，组名修改为group3。</p>
<h3 id="4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。"><a href="#4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。" class="headerlink" title="4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。"></a>4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</h3><p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ newgrp root</span><br></pre></td></tr></table></figure>

<p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。</p>
<hr>
<h2 id="三、与用户账号有关的系统文件"><a href="#三、与用户账号有关的系统文件" class="headerlink" title="三、与用户账号有关的系统文件"></a>三、与用户账号有关的系统文件</h2><p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p>
<p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。</p>
<p>下面分别介绍这些文件的内容。</p>
<h3 id="1、-etc-passwd文件是用户管理工作涉及的最重要的一个文件。"><a href="#1、-etc-passwd文件是用户管理工作涉及的最重要的一个文件。" class="headerlink" title="1、/etc/passwd文件是用户管理工作涉及的最重要的一个文件。"></a>1、/etc/passwd文件是用户管理工作涉及的最重要的一个文件。</h3><p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p>
<p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">＃ cat &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">root:x:0:0:Superuser:&#x2F;:</span><br><span class="line">daemon:x:1:1:System daemons:&#x2F;etc:</span><br><span class="line">bin:x:2:2:Owner of system commands:&#x2F;bin:</span><br><span class="line">sys:x:3:3:Owner of system files:&#x2F;usr&#x2F;sys:</span><br><span class="line">adm:x:4:4:System accounting:&#x2F;usr&#x2F;adm:</span><br><span class="line">uucp:x:5:5:UUCP administrator:&#x2F;usr&#x2F;lib&#x2F;uucp:</span><br><span class="line">auth:x:7:21:Authentication administrator:&#x2F;tcb&#x2F;files&#x2F;auth:</span><br><span class="line">cron:x:9:16:Cron daemon:&#x2F;usr&#x2F;spool&#x2F;cron:</span><br><span class="line">listen:x:37:4:Network daemon:&#x2F;usr&#x2F;net&#x2F;nls:</span><br><span class="line">lp:x:71:18:Printer administrator:&#x2F;usr&#x2F;spool&#x2F;lp:</span><br><span class="line">sam:x:200:50:Sam san:&#x2F;home&#x2F;sam:&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>

<p>从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure>

<h3 id="1）”用户名”是代表用户账号的字符串。"><a href="#1）”用户名”是代表用户账号的字符串。" class="headerlink" title="1）”用户名”是代表用户账号的字符串。"></a>1）”用户名”是代表用户账号的字符串。</h3><p>通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</p>
<p>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p>
<h3 id="2）“口令”一些系统中，存放着加密后的用户口令字。"><a href="#2）“口令”一些系统中，存放着加密后的用户口令字。" class="headerlink" title="2）“口令”一些系统中，存放着加密后的用户口令字。"></a>2）“口令”一些系统中，存放着加密后的用户口令字。</h3><p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p>
<h3 id="3）“用户标识号”是一个整数，系统内部用它来标识用户。"><a href="#3）“用户标识号”是一个整数，系统内部用它来标识用户。" class="headerlink" title="3）“用户标识号”是一个整数，系统内部用它来标识用户。"></a>3）“用户标识号”是一个整数，系统内部用它来标识用户。</h3><p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p>
<p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p>
<h3 id="4）“组标识号”字段记录的是用户所属的用户组。"><a href="#4）“组标识号”字段记录的是用户所属的用户组。" class="headerlink" title="4）“组标识号”字段记录的是用户所属的用户组。"></a>4）“组标识号”字段记录的是用户所属的用户组。</h3><p>它对应着/etc/group文件中的一条记录。</p>
<h3 id="5-“注释性描述”字段记录着用户的一些个人情况。"><a href="#5-“注释性描述”字段记录着用户的一些个人情况。" class="headerlink" title="5)“注释性描述”字段记录着用户的一些个人情况。"></a>5)“注释性描述”字段记录着用户的一些个人情况。</h3><p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。</p>
<h3 id="6-“主目录”，也就是用户的起始工作目录。"><a href="#6-“主目录”，也就是用户的起始工作目录。" class="headerlink" title="6)“主目录”，也就是用户的起始工作目录。"></a>6)“主目录”，也就是用户的起始工作目录。</h3><p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p>
<h3 id="7-用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。"><a href="#7-用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。" class="headerlink" title="7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。"></a>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</h3><p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p>
<p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</p>
<p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p>
<p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p>
<h3 id="8-系统中有一类用户称为伪用户（pseudo-users）。"><a href="#8-系统中有一类用户称为伪用户（pseudo-users）。" class="headerlink" title="8)系统中有一类用户称为伪用户（pseudo users）。"></a>8)系统中有一类用户称为伪用户（pseudo users）。</h3><p>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p>
<p>常见的伪用户如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">伪 用 户 含 义 </span><br><span class="line">bin 拥有可执行的用户命令文件 </span><br><span class="line">sys 拥有系统文件 </span><br><span class="line">adm 拥有帐户文件 </span><br><span class="line">uucp UUCP使用 </span><br><span class="line">lp lp或lpd子系统使用 </span><br><span class="line">nobody NFS使用</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="拥有帐户文件"><a href="#拥有帐户文件" class="headerlink" title="拥有帐户文件"></a>拥有帐户文件</h2><p><strong>1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</strong></p>
<p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>
<p><strong>2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生</strong></p>
<p>它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></pre></td></tr></table></figure>

<ol>
<li>“登录名”是与/etc/passwd文件中的登录名相一致的用户账号</li>
<li>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</li>
<li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li>
<li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li>
<li>“最大时间间隔”指的是口令保持有效的最大天数。</li>
<li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li>
<li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li>
<li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li>
</ol>
<p>下面是/etc/shadow的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">＃ cat &#x2F;etc&#x2F;shadow</span><br><span class="line"></span><br><span class="line">root:Dnakfw28zf38w:8764:0:168:7:::</span><br><span class="line">daemon:*::0:0::::</span><br><span class="line">bin:*::0:0::::</span><br><span class="line">sys:*::0:0::::</span><br><span class="line">adm:*::0:0::::</span><br><span class="line">uucp:*::0:0::::</span><br><span class="line">nuucp:*::0:0::::</span><br><span class="line">auth:*::0:0::::</span><br><span class="line">cron:*::0:0::::</span><br><span class="line">listen:*::0:0::::</span><br><span class="line">lp:*::0:0::::</span><br><span class="line">sam:EkdiSECLWPdSa:9740:0:0::::</span><br></pre></td></tr></table></figure>

<h3 id="3、用户组的所有信息都存放在-etc-group文件中。"><a href="#3、用户组的所有信息都存放在-etc-group文件中。" class="headerlink" title="3、用户组的所有信息都存放在/etc/group文件中。"></a>3、用户组的所有信息都存放在/etc/group文件中。</h3><p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p>
<p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p>
<p>当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p>
<p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p>
<p>用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组名:口令:组标识号:组内用户列表</span><br></pre></td></tr></table></figure>

<ol>
<li>“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</li>
<li>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</li>
<li>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</li>
<li>“组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li>
</ol>
<p>/etc/group文件的一个例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root::0:root</span><br><span class="line">bin::2:root,bin</span><br><span class="line">sys::3:root,uucp</span><br><span class="line">adm::4:root,adm</span><br><span class="line">daemon::5:root,daemon</span><br><span class="line">lp::7:root,lp</span><br><span class="line">users::20:root,sam</span><br></pre></td></tr></table></figure>

<h3 id="四、添加批量用户"><a href="#四、添加批量用户" class="headerlink" title="四、添加批量用户"></a>四、添加批量用户</h3><p>添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：</p>
<h3 id="（1）先编辑一个文本用户文件。"><a href="#（1）先编辑一个文本用户文件。" class="headerlink" title="（1）先编辑一个文本用户文件。"></a>（1）先编辑一个文本用户文件。</h3><p>每一列按照<code>/etc/passwd</code>密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user001::600:100:user:&#x2F;home&#x2F;user001:&#x2F;bin&#x2F;bash</span><br><span class="line">user002::601:100:user:&#x2F;home&#x2F;user002:&#x2F;bin&#x2F;bash</span><br><span class="line">user003::602:100:user:&#x2F;home&#x2F;user003:&#x2F;bin&#x2F;bash</span><br><span class="line">user004::603:100:user:&#x2F;home&#x2F;user004:&#x2F;bin&#x2F;bash</span><br><span class="line">user005::604:100:user:&#x2F;home&#x2F;user005:&#x2F;bin&#x2F;bash</span><br><span class="line">user006::605:100:user:&#x2F;home&#x2F;user006:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<h3 id="（2）以root身份执行命令-usr-sbin-newusers，从刚创建的用户文件user-txt中导入数据，创建用户："><a href="#（2）以root身份执行命令-usr-sbin-newusers，从刚创建的用户文件user-txt中导入数据，创建用户：" class="headerlink" title="（2）以root身份执行命令 /usr/sbin/newusers，从刚创建的用户文件user.txt中导入数据，创建用户："></a>（2）以root身份执行命令 <code>/usr/sbin/newusers</code>，从刚创建的用户文件<code>user.txt</code>中导入数据，创建用户：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># newusers &lt; user.txt</span><br></pre></td></tr></table></figure>

<p>然后可以执行命令 <code>vipw</code> 或 <code>vi /etc/passwd</code> 检查 <code>/etc/passwd</code> 文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。</p>
<h3 id="（3）执行命令-usr-sbin-pwunconv。"><a href="#（3）执行命令-usr-sbin-pwunconv。" class="headerlink" title="（3）执行命令/usr/sbin/pwunconv。"></a>（3）执行命令/usr/sbin/pwunconv。</h3><p>将 <code>/etc/shadow</code> 产生的 <code>shadow</code> 密码解码，然后回写到 <code>/etc/passwd</code> 中，并将<code>/etc/shadow</code>的<code>shadow</code>密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 <code>shadow password</code> 功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pwunconv</span><br></pre></td></tr></table></figure>

<h3 id="（4）编辑每个用户的密码对照文件。"><a href="#（4）编辑每个用户的密码对照文件。" class="headerlink" title="（4）编辑每个用户的密码对照文件。"></a>（4）编辑每个用户的密码对照文件。</h3><p>格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:密码</span><br></pre></td></tr></table></figure>

<p>实例文件 <code>passwd.txt</code> 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user001:123456</span><br><span class="line">user002:123456</span><br><span class="line">user003:123456</span><br><span class="line">user004:123456</span><br><span class="line">user005:123456</span><br><span class="line">user006:123456</span><br></pre></td></tr></table></figure>

<h3 id="（5）以-root-身份执行命令-usr-sbin-chpasswd。"><a href="#（5）以-root-身份执行命令-usr-sbin-chpasswd。" class="headerlink" title="（5）以 root 身份执行命令 /usr/sbin/chpasswd。"></a>（5）以 root 身份执行命令 <code>/usr/sbin/chpasswd</code>。</h3><p>创建用户密码，<code>chpasswd</code> 会将经过 <code>/usr/bin/passwd</code> 命令编码过的密码写入 <code>/etc/passwd</code> 的密码栏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chpasswd &lt; passwd.txt</span><br></pre></td></tr></table></figure>

<h3 id="（6）确定密码经编码写入-etc-passwd的密码栏后。"><a href="#（6）确定密码经编码写入-etc-passwd的密码栏后。" class="headerlink" title="（6）确定密码经编码写入/etc/passwd的密码栏后。"></a>（6）确定密码经编码写入/etc/passwd的密码栏后。</h3><p>执行命令 <code>/usr/sbin/pwconv</code> 将密码编码为 <code>shadow password</code>，并将结果写入 <code>/etc/shadow</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pwconv</span><br></pre></td></tr></table></figure>

<p>这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。</p>
<h2 id="P70-71-用户管理"><a href="#P70-71-用户管理" class="headerlink" title="P70-71(用户管理)"></a>P70-71(用户管理)</h2><ol>
<li><p>useradd -m -g 组 新建用户名：添加新用户 -m自动建立用户加目录， -g指定用户所在组，否则会建立一个同名的组。</p>
<p>例： sudo useradd -m -g dev zhangsan </p>
<p>drwxr-xr-x  2 zhangsan     dev          4096 Apr 26 18:30 zhangsan</p>
</li>
<li><p>passwd 用户名： 设置用户密码，如果是普通用户，直接passwd可以修改密码</p>
</li>
<li><p>userdel -r 用户名；删除用户， -r会自动删除用户家目录</p>
</li>
<li><p>cat /etc/passwd | grep 用户名 ：确认用户信息，新建用户后，用户信息会保存在/etc/passwd文件中</p>
</li>
</ol>
<h2 id="P72-75（id，whoami，who）"><a href="#P72-75（id，whoami，who）" class="headerlink" title="P72-75（id，whoami，who）"></a>P72-75（id，whoami，who）</h2><h3 id="id-用户名：查看用户UID和GID信息"><a href="#id-用户名：查看用户UID和GID信息" class="headerlink" title="id 用户名：查看用户UID和GID信息"></a>id 用户名：查看用户UID和GID信息</h3><p>passwd文件：/etc/passwd文件存放用户信息，6个分号组成7个信息</p>
<p>信息说明<br>第一字段: 用户名(vampire)<br>第二字段: 密码位(x),只是一个占位符,真正的密码存放在/etc/shadow文件中（x，表示加密密码）<br>第三字段: UID(501)用户id,0为超级用户,1~499系统用户,一般不能登录系统,也叫做伪用户,500及以上普通用户,管理员创建的,一般可登录（用户标识）<br>第四字段: GID(501)用户初始组id,一般添加用户时,系统自动分配的（组标识）<br>第五字段: GECOS 用户的一些说明信息（用户全名或本地账号）<br>第六字段: $HOME(/home/vampire) 用户家目录,也叫做宿主目录,普通用户家目录在/home下,root用户在/下（家目录）</p>
<p>第七字段: shell(/bin/bash)用户登录后的shell，ubuntu默认是dash</p>
<p> UID，gid，组 依次打印</p>
<p>Linux id命令用于显示用户的ID，以及所属群组的ID。</p>
<p>id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id [-gGnru][--help][--version][用户名称]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-g或–group 　显示用户所属群组的ID。</li>
<li>-G或–groups 　显示用户所属附加群组的ID。</li>
<li>-n或–name 　显示用户，所属群组或附加群组的名称。</li>
<li>-r或–real 　显示实际ID。</li>
<li>-u或–user 　显示用户ID。</li>
<li>-help 　显示帮助。</li>
<li>-version 　显示版本信息。</li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>显示当前用户信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id &#x2F;&#x2F;显示当前用户ID</span><br><span class="line">uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel) context&#x3D;root:system_r:unconfined_t</span><br></pre></td></tr></table></figure>

<p>显示用户群组的ID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id -g</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>显示所有群组的ID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id -g</span><br><span class="line">0 1 2 3 4 5 6 10</span><br></pre></td></tr></table></figure>

<p>显示指定用户信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># id hnlinux</span><br></pre></td></tr></table></figure>

<h3 id="who：查看当前所有登录的用户列表"><a href="#who：查看当前所有登录的用户列表" class="headerlink" title="who：查看当前所有登录的用户列表"></a>who：查看当前所有登录的用户列表</h3><p>Linux who命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。</p>
<p>使用权限：所有使用者都可使用。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who - [husfV] [user]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-H 或 –heading：显示各栏位的标题信息列；</li>
<li>-i 或 -u 或 –idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成”.”号，如果该用户已超过24小时没有任何动作，则标示出”old”字符串；</li>
<li>-m：此参数的效果和指定”am i”字符串相同；</li>
<li>-q 或–count：只显示登入系统的帐号名称和总人数；</li>
<li>-s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题；</li>
<li>-w 或-T或–mesg或–message或–writable：显示用户的信息状态栏；</li>
<li>–help：在线帮助；</li>
<li>–version：显示版本信息。</li>
</ul>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>显示当前登录系统的用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># who  &#x2F;&#x2F;显示当前登录系统的用户</span><br><span class="line">root   tty7     2014-05-13 12:12 (:0)</span><br><span class="line">root   pts&#x2F;0    2014-05-14 17:09 (:0.0)</span><br><span class="line">root   pts&#x2F;1    2014-05-14 18:51 (192.168.1.17)</span><br><span class="line">root   pts&#x2F;2    2014-05-14 19:48 (192.168.1.17)</span><br></pre></td></tr></table></figure>

<p>显示标题栏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># who -H</span><br><span class="line">NAME   LINE     TIME       COMMENT</span><br><span class="line">root   tty7     2014-05-13 12:12 (:0)</span><br><span class="line">root   pts&#x2F;0    2014-05-14 17:09 (:0.0)</span><br><span class="line">root   pts&#x2F;1    2014-05-14 18:51 (192.168.1.17)</span><br><span class="line">root   pts&#x2F;2    2014-05-14 19:48 (192.168.1.17)</span><br></pre></td></tr></table></figure>

<p>显示用户登录来源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># who -l -H</span><br><span class="line">NAME   LINE     TIME       IDLE     PID COMMENT</span><br><span class="line">LOGIN  tty4     2014-05-13 12:11        852 id&#x3D;4</span><br><span class="line">LOGIN  tty5     2014-05-13 12:11        855 id&#x3D;5</span><br><span class="line">LOGIN  tty2     2014-05-13 12:11        862 id&#x3D;2</span><br><span class="line">LOGIN  tty3     2014-05-13 12:11        864 id&#x3D;3</span><br><span class="line">LOGIN  tty6     2014-05-13 12:11        867 id&#x3D;6</span><br><span class="line">LOGIN  tty1     2014-05-13 12:11       1021 id&#x3D;1</span><br></pre></td></tr></table></figure>

<p>显示终端属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># who -T -H</span><br><span class="line">NAME    LINE     TIME       COMMENT</span><br><span class="line">root   + tty7     2014-05-13 12:12 (:0)</span><br><span class="line">root   + pts&#x2F;0    2014-05-14 17:09 (:0.0)</span><br><span class="line">root   - pts&#x2F;1    2014-05-14 18:51 (192.168.1.17)</span><br><span class="line">root   - pts&#x2F;2    2014-05-14 19:48 (192.168.1.17)</span><br></pre></td></tr></table></figure>

<p>只显示当前用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># who -m -H</span><br><span class="line">NAME   LINE     TIME       COMMENT</span><br><span class="line">root   pts&#x2F;1    2014-05-14 18:51 (192.168.1.17)</span><br></pre></td></tr></table></figure>

<p>精简模式显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># who -q</span><br><span class="line">root root root root</span><br><span class="line"># users&#x3D;4</span><br></pre></td></tr></table></figure>

<h3 id="whoami：查看当前登录用户的账户名"><a href="#whoami：查看当前登录用户的账户名" class="headerlink" title="whoami：查看当前登录用户的账户名"></a>whoami：查看当前登录用户的账户名</h3><p>Linux whoami命令用于显示自身用户名称。</p>
<p>显示自身的用户名称，本指令相当于执行”id -un”指令。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami [--help][--version]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>–help 　在线帮助。</li>
<li>–version 　显示版本信息。</li>
</ul>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>显示用户名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># whoami </span><br><span class="line">root</span><br></pre></td></tr></table></figure>

<h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><p>用来设置用户主组/附加组 和登录shell</p>
<p>Linux系统以组Group方式管理用户，用户和组的对应关系为多对多，即某个用户可加入/属于一个或多个组，某个组可以有0个、1个或多个用户。</p>
<p>组的分类<br>从用户的角度，分为主组和附属组。<br>主组：也被称为primary group、first group或initial login group，用户的默认组，用户的gid所标识的组。<br>附属组：也被称为Secondary group或supplementary group，用户的附加组。</p>
<p>通过id命令可查看当前用户的主组和附属组</p>
<p>[root@localhost ~]# id root<br>uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel)</p>
<p>[root@localhost ~]# id gg<br>uid=503(gg) gid=503(gg) groups=503(gg)</p>
<p>[root@localhost ~]# id mm<br>uid=502(mm) gid=500(jww) groups=500(jww)</p>
<p>gid标识主组，groups表示用户所属的全部组（主组和附属组）</p>
<ol>
<li><p>用户必须有且只能有一个主组，可以有0个、1个或多个附属组，就如我们一定会有一个用来安家的房子（类同主组），还可以有n个用于投资或其他打算的房子（附属组）。</p>
</li>
<li><p>主组也为默认组，当用户own某个文件或目录时，默认该文件或目录的group owner为该用户的主组（当然，可以通过chgrp修改group owner）。</p>
</li>
<li><p>在/etc/passwd文件中，记录行第四个字段为gid，即用户的主组id。</p>
</li>
<li><p>在/etc/group文件中，记录行第四个字段为组的成员，不显示将该组作为主组的组成员，只显示将该组作为附属组的组成员，因此，/etc/group的记录行的第四个字段没有完整地列出该组的全部成员。</p>
</li>
<li><p>当通过useradd命令创建新用户时，可以通过-g参数指定已存在的某个组为其主组，若没有使用-g参数，<br>则系统自动创建名称和用户名相同的组作为该用户的主组（前提是variable in /etc/login.defs的USERGROUPS_ENAB属性值为yes），如命令手册的useradd关于-g参数的描述所示：<br>-g, –gid GROUP<br>The group name or number of the user′s initial login group. The<br>group name must exist. A group number must refer to an already<br>existing group.<br>If not specified, the bahavior of useradd will depend on the<br>USERGROUPS_ENAB variable in /etc/login.defs. If this variable is<br>set to yes (or -U/–user-group is specified on the command line), a<br>group will be created for the user, with the same name as her<br>loginname. If the variable is set to no (or -N/–no-user-group is<br>specified on the command line), useradd will set the primary group<br>of the new user to the value specified by the GROUP variable in<br>/etc/default/useradd, or 100 by default.</p>
</li>
</ol>
<p>另外，可通过usermod -g 将普通用户的主组/gid设置为系e799bee5baa6e79fa5e98193e4b893e5b19e31333337613161统中存在的任意某个组（永久性）；<br>也可以通过newgrp暂时性变更当前用户的主组/gid（只对于当前login session有效，非永久性）。<br>通过usermod -G 设置普通用户的附属组。</p>
<p>Linux usermod命令用于修改用户帐号。</p>
<p>usermod可用来修改用户帐号的各项设定。</p>
<p>usermod 命令通过修改系统帐户文件来修改用户账户信息<br>usermod [options] user_name<br>选项(options)<br>-a|–append ##把用户追加到某些组中，仅与-G选项一起使用<br>-c|–comment ##修改/etc/passwd文件第五段comment<br>-d|–home ##修改用户的家目录通常和-m选项一起使用<br>-e|–expiredate ##指定用户帐号禁用的日期，格式YY-MM-DD<br>-f|–inactive ##用户密码过期多少天后采用就禁用该帐号，0表示密码已过期就禁用帐号，-1表示禁用此功能，默认值是-1<br>-g|–gid ##修改用户的gid，改组一定存在<br>-G|–groups ##把用户追加到某些组中，仅与-a选项一起使用<br>-l|–login ##修改用户的登录名称<br>-L|–lock ##锁定用户的密码<br>-m|–move-home ##修改用户的家目录通常和-d选项一起使用<br>-s|–shell ##修改用户的shell<br>-u|–uid ##修改用户的uid，该uid必须唯一<br>-U|–unlock ##解锁用户的密码</p>
<h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod [-LU][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-l &lt;帐号名称&gt;][-s &lt;shell&gt;][-u &lt;uid&gt;][用户帐号]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li><p>-c&lt;备注&gt; 　修改用户帐号的备注文字。</p>
</li>
<li><p>-d登入目录&gt; 　修改用户登入时的目录。</p>
</li>
<li><p>-e&lt;有效期限&gt; 　修改帐号的有效期限。</p>
</li>
<li><p>-f&lt;缓冲天数&gt; 　修改在密码过期后多少天即关闭该帐号。</p>
</li>
<li><p>-g&lt;群组&gt; 　修改用户所属的群组。（常用）</p>
</li>
<li><p>-G&lt;群组&gt; 　修改用户所属的附加群组。（常用）</p>
</li>
<li><p>-l&lt;帐号名称&gt; 　修改用户帐号名称。</p>
</li>
<li><p>-L 　锁定用户密码，使密码无效。</p>
</li>
<li><p>-s<shell> 　修改用户登入后所使用的shell。（常用）</p>
<p>例：usermod -S /bin/bash 用户名</p>
</li>
<li><p>-u<uid> 　修改用户ID。</p>
</li>
<li><p>-U 　解除密码锁定。</p>
</li>
</ul>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>更改登录目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># usermod -d &#x2F;home&#x2F;hnlinux root</span><br></pre></td></tr></table></figure>

<p>改变用户的uid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># usermod -u 777 root</span><br></pre></td></tr></table></figure>



<h3 id="usermod-S-bin-bash-用户名"><a href="#usermod-S-bin-bash-用户名" class="headerlink" title="usermod -S /bin/bash 用户名"></a>usermod -S /bin/bash 用户名</h3><p>用户ubuntu默认是dash，而windows不是，想windows登录也是dash，需要上面的命令修改shell为dash</p>
<p>Bash(GNU Bourne-Again Shell)是许多Linux平台的内定Shell，事实上，还有许多传统UNIX上用的Shell，像tcsh、csh、ash、bsh、ksh等等。</p>
<p>GNU/Linux 操作系统中的 /bin/sh 本是 bash (Bourne-Again Shell) 的符号链接，但鉴于 bash 过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash (Debian Almquist Shell)，并建议将 /bin/sh 指向它，以获得更快的脚本执行速度。Dash Shell 比 Bash Shell 小的多，符合POSIX标准。</p>
<p>Debian和Ubuntu中，/bin/sh默认已经指向dash，这是一个不同于bash的shell，它主要是为了执行脚本而出现，而不是交互，它速度更快，但功能相比bash要少很多，语法严格遵守POSIX标准。</p>
<p>就是这个倒霉的dash解释器使得我按照bash语法写的shell 脚本不能运行。</p>
<p>要知道自己的/bin/sh指向何种解释器，可以用 <strong>ls /bin/sh -al</strong> 命令查看：</p>
<p>​    $ ls /bin/sh -al</p>
<p>​    lrwxrwxrwx 1 root root 4 11月 16 15:33 /bin/sh -&gt; bash</p>
<p>以上结果就表示当前系统用的是dash解释器。</p>
<p>切换到bash的方式其实挺简单的，关键是一直没找出这个原因……</p>
<p>修改默认的sh，可以采用命令<strong>sudo dpkg-reconfigure dash</strong></p>
<p>会出现一个图片状的配置菜单，选no就可以了</p>
<p>再次检查一下， <strong>ls /bin/sh -al</strong> 发现软链接指向/bin/bash</p>
<p>​     lrwxrwxrwx 1 root root 4 11月 16 15:33 /bin/sh -&gt; bash</p>
<h2 id="P76which"><a href="#P76which" class="headerlink" title="P76which"></a>P76which</h2><p>Linux which命令用于查找文件。可以查看指向命令所在位置</p>
<p>/etc/passwd: 用于保存用户信息的文件</p>
<p>/etc/bin/passwd:用于修改用户密码的程序</p>
<p>which指令会在环境变量$PATH设置的目录里查找符合条件的文件。</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which [文件...]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-n&lt;文件名长度&gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</li>
<li>-p&lt;文件名长度&gt; 　与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。</li>
<li>-w 　指定输出时栏位的宽度。</li>
<li>-V 　显示版本信息。</li>
</ul>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>使用指令”which”查看指令”bash”的绝对路径，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ which bash</span><br></pre></td></tr></table></figure>

<p>上面的指令执行后，输出信息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin&#x2F;bash                   #bash可执行程序的绝对路径</span><br></pre></td></tr></table></figure>

<p>我们经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：</p>
<p><strong>which</strong> 　查看可执行文件的位置。</p>
<p><strong>whereis</strong> 查看文件的位置。</p>
<p><strong>locate</strong> 　配合数据库查看文件位置。</p>
<p><strong>find</strong> 　　实际搜寻硬盘查询文件名称。</p>
<p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
<p><strong>1．命令格式：</strong></p>
<p>which 可执行文件名称</p>
<p><strong>2．命令功能：</strong></p>
<p>which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p>
<p><strong>3．命令参数：</strong></p>
<p><strong>-n</strong> 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</p>
<p><strong>-p</strong> 与-n参数相同，但此处的包括了文件的路径。</p>
<p><strong>-w</strong> 指定输出时栏位的宽度。</p>
<p><strong>-V</strong> 显示版本信息</p>
<p><strong>4．使用实例：</strong></p>
<p><strong>实例1：</strong>查找文件、显示命令路径</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which lsmod</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# which pwd</span><br><span class="line">&#x2F;bin&#x2F;pwd</span><br><span class="line">[root@localhost ~]# which adduser</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;adduser</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>which 是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！</p>
<p><strong>实例2：</strong>用 which 去找出 which</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which which</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# which which</span><br><span class="line">alias which&#x3D;&#39;alias | &#x2F;usr&#x2F;bin&#x2F;which --tty-only --read-alias --show-dot --show-tilde&#39;</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;which</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>竟然会有两个 which ，其中一个是 alias 这就是所谓的『命令别名』，意思是输入 which 会等於后面接的那串命令！</p>
<p><strong>实例3：</strong>找出 cd 这个命令</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which cd</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>cd 这个常用的命令竟然找不到啊！为什么呢？这是因为 cd 是bash 内建的命令！ 但是 which 默认是找 PATH 内所规范的目录，所以当然一定找不到的！</p>
<p>bin:<br>bin为binary的简写主要放置一些<strong>系统的必备执行</strong>档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。</p>
<p>/usr/bin:<br>主 要放置一些<strong>应用软体工具的必备执行</strong>档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome<em>、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb</em>、wget等。 </p>
<p>/sbin:<br>主 要放置一些<strong>系统管理的必备</strong>程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。</p>
<p>/usr/sbin: </p>
<p>放置一些<strong>网路管理的必备</strong>程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等</p>
<h2 id="P77（su切换用户）"><a href="#P77（su切换用户）" class="headerlink" title="P77（su切换用户）"></a>P77（su切换用户）</h2><p>Linux su命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。不安全，会返回root。然后无需sudo了，即可改系统等。</p>
<p>使用权限：所有使用者。</p>
<h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [-fmp] [-c command] [-s shell] [--help] [--version] [-] [USER [ARG]]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-f 或 –fast 不必读启动档（如 csh.cshrc 等），仅用于 csh 或 tcsh</li>
<li>-m -p 或 –preserve-environment 执行 su 时不改变环境变数</li>
<li>-c command 或 –command=command 变更为帐号为 USER 的使用者并执行指令（command）后再变回原来使用者</li>
<li>-s shell 或 –shell=shell 指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者（USER） shell</li>
<li>–help 显示说明文件</li>
<li>–version 显示版本资讯</li>
<li>- -l 或 –login 这个参数加了之后，就好像是重新 login 为该使用者一样，大部份环境变数（HOME SHELL USER等等）都是以该使用者（USER）为主，并且工作目录也会改变，如果没有指定 USER ，内定是 root</li>
<li>USER 欲变更的使用者帐号</li>
<li>ARG 传入新的 shell 参数</li>
</ul>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>变更帐号为 root 并在执行 ls 指令后退出变回原使用者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -c ls root</span><br></pre></td></tr></table></figure>

<p>变更帐号为 root 并传入 -f 参数给新执行的 shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root -f</span><br></pre></td></tr></table></figure>

<p>变更帐号为 clsung 并改变工作目录至 clsung 的家目录（home dir）（常用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - clsung</span><br></pre></td></tr></table></figure>

<p>切换用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hnlinux@runoob.com:~$ whoami &#x2F;&#x2F;显示当前用户</span><br><span class="line">hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ su root &#x2F;&#x2F;切换到root用户</span><br><span class="line">密码： </span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# whoami </span><br><span class="line">root</span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# pwd</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br></pre></td></tr></table></figure>

<p>切换用户，改变环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hnlinux@runoob.com:~$ whoami &#x2F;&#x2F;显示当前用户</span><br><span class="line">hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;home&#x2F;hnlinux</span><br><span class="line">hnlinux@runoob.com:~$ su - root &#x2F;&#x2F;切换到root用户</span><br><span class="line">密码： </span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# whoami </span><br><span class="line">root</span><br><span class="line">root@runoob.com:&#x2F;home&#x2F;hnlinux# pwd &#x2F;&#x2F;显示当前目录</span><br><span class="line">&#x2F;root</span><br></pre></td></tr></table></figure>

<h2 id="P78修改文件权限"><a href="#P78修改文件权限" class="headerlink" title="P78修改文件权限"></a>P78修改文件权限</h2><p>1。 chown: 修改拥有者</p>
<p>2。chgrp：修改组</p>
<p>3 。chmod：修改权限</p>
<p>想要改文件的权限，只有管理员root和所有者才能修改</p>
<p>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。</p>
<p>一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限把自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。</p>
<p><strong>使用权限</strong> : root</p>
<h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [-cfhvR] [--help] [--version] user[:group] file...</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong> :</p>
<ul>
<li>user : 新的文件拥有者的使用者 ID</li>
<li>group : 新的文件拥有者的使用者组(group)</li>
<li>-c : 显示更改的部分的信息</li>
<li>-f : 忽略错误信息</li>
<li>-h :修复符号链接</li>
<li>-v : 显示详细的处理信息</li>
<li>-R : 处理指定目录以及其子目录下的所有文件</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown runoob:runoobgroup file1.txt</span><br></pre></td></tr></table></figure>

<p>将目前目录下的所有文件与子目录的拥有者皆设为 runoob，群体的使用者 runoobgroup:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R runoob:runoobgroup *</span><br></pre></td></tr></table></figure>

<h3 id="1、chmod：更改文件9个属性"><a href="#1、chmod：更改文件9个属性" class="headerlink" title="1、chmod：更改文件9个属性"></a>1、chmod：更改文件9个属性</h3><p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626161252656-1763498520.png" alt="img"></p>
<p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p>
<h4 id="①-数字改变文件权限（常用）"><a href="#①-数字改变文件权限（常用）" class="headerlink" title="① 数字改变文件权限（常用）"></a>① 数字改变文件权限（常用）</h4><p>我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<ul>
<li>r:4</li>
<li>w:2</li>
<li>x:1</li>
</ul>
<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p>
<ul>
<li>owner = rwx = 4+2+1 = 7</li>
<li>group = rwx = 4+2+1 = 7</li>
<li>others= — = 0+0+0 = 0</li>
</ul>
<p>所以等我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure>

<ul>
<li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li>
<li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li>
</ul>
<h4 id="②-符号类型改变文件权限"><a href="#②-符号类型改变文件权限" class="headerlink" title="② 符号类型改变文件权限"></a>② 符号类型改变文件权限</h4><p> 我们就可以藉由u, g, o来代表三种身份的权限！</p>
<p>此外， a 则代表 all 亦即全部的身份！那么读写的权限就可以写成r, w, x！也就是可以使用底下的方式来看：</p>
<table>
<thead>
<tr>
<th>chmod</th>
<th>u g o a</th>
<th>+(加入) -(除去) =(设定)</th>
<th>r w x</th>
<th>文件或目录</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>如果我们需要将文件权限设置为 <strong>-rwxr-xr–</strong> ，可以使用 chmod u=rwx,g=rx,o=r 文件名 来设定。</p>
<p>注意：如果一个目录有写的权限，其他用户对于这个目录下的文件也可以删除。</p>
<h3 id="2、chown：更改文件属主，也可以同时更改文件属组"><a href="#2、chown：更改文件属主，也可以同时更改文件属组" class="headerlink" title="2、chown：更改文件属主，也可以同时更改文件属组"></a>2、chown：更改文件属主，也可以同时更改文件属组</h3><p>注意：这个命令只有管理员root才可以操作。而且系统里是必须存在这个用户。</p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626165146255-1650931601.png" alt="img"></p>
<p>语法：</p>
<p>chown [–R] 属主名： 文件名</p>
<p>chown [-R] 属主名：属组名 文件名</p>
<h3 id="3、chgrp：更改文件属组。"><a href="#3、chgrp：更改文件属组。" class="headerlink" title="3、chgrp：更改文件属组。"></a>3、chgrp：更改文件属组。</h3><p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626170509313-1815193220.png" alt="img"></p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] 属组名 文件名</span><br></pre></td></tr></table></figure>

<p>参数选项</p>
<ul>
<li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li>
</ul>
<h3 id="4、umask设置预设的权限掩码"><a href="#4、umask设置预设的权限掩码" class="headerlink" title="4、umask设置预设的权限掩码"></a><strong>4、umask设置预设的权限掩码</strong></h3><p>Linux umask命令指定在建立文件时预设的权限掩码，在学习这个命令之前，先了解一下默认的所有者和所属组是哪来的？</p>
<p>一个文件创建的时候所有者和所属组是哪来的？</p>
<p>所有者：谁创建的文件谁就是这个文件的所有者。</p>
<p>所属组：就是这个文件创建者的缺省组，每个用户只能有一个缺省组。</p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626172146490-1231316404.png" alt="img"></p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626172519622-446882410.png" alt="img">显示新建文件的缺省权限。</p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626173131946-156221821.png" alt="img"></p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626173426757-2120027575.png" alt="img"></p>
<p>创建一个目录的时候查看发现 权限跟缺省权限是一致的，但是在test目录里创建一个文件后，查看文件缺省权限跟默认缺省权限不一致，这个是为什么呢？</p>
<p>rwxr-xr-x</p>
<p>rw-r–r–  对比发现都少了一个x可执行权限，这是因为在Linux里缺省权限创建的文件是不可具有可执行权限的。</p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626174110254-908588857.png" alt="img"></p>
<p>单独执行  <strong>umask</strong>  发现现实出 <strong>0022</strong> ，这是什么意思呢？</p>
<p>022是权限掩码意思，真正的权限是777-022=755 写出来就是rwxr-xr-x.</p>
<p>如果我们自己要是想修改这个缺省权限，该怎么修改的。</p>
<p>先把想修改的权限格式表示出来，算出对应的数字，再用777-对应的数字就可以，例如：</p>
<p><img src="https://images2018.cnblogs.com/blog/1264413/201806/1264413-20180626174709974-11233329.png" alt="img"></p>
<h2 id="P79chmod详解"><a href="#P79chmod详解" class="headerlink" title="P79chmod详解"></a>P79chmod详解</h2><p>这是使用chmod命令时的正确语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [options] mode [，mode] file1 [file2 ...]</span><br></pre></td></tr></table></figure>

<p>以下是chmod使用的一些常用选项：</p>
<p>　●　-f， - silent， - quiet（抑制大多数错误消息）</p>
<p>　●　-v， - verbose（为每个处理的文件输出诊断信息）</p>
<p>　●　-c， - changes（类似于详细但仅在进行更改时报告）</p>
<p>　●　-R， - recursive（递归更改文件和目录）（常用）</p>
<p>　●　–help（显示帮助和退出）</p>
<p>　●　–version（输出版本信息和退出）</p>
<p>下面是可以为用户，组以及计算机上的其他所有人设置的几个数字权限的列表。数字旁边是读/写/执行字母等价物。</p>
<p>　●　7：表示rwx，拥有读、写和执行的权限</p>
<p>　●　6：表示rw-，拥有读和写的权限</p>
<p>　●　5：表示rx，拥有读取和执行的权限</p>
<p>　●　4：表示r–，拥有只读权限</p>
<p>　●　3：表示-wx，拥有写入和执行的权限</p>
<p>　●　2：表示-w-，拥有只写权限</p>
<p>　●　1：表示 - x，仅拥有执行权限</p>
<p>　●　0：表示—，无权限</p>
<p>注：如果需要列出文件的权限，需要使用ls命令。</p>
<p><strong>chmod命令示例</strong></p>
<p>如果用户想要更改文件“participants”的权限，以便所有人都可以完全访问该文件，需要输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 participants</span><br></pre></td></tr></table></figure>

<p>说明：第1个7设置用户的权限，第2个7设置组的权限，第3个7设置其他所有者的权限。</p>
<p>如果用户想成为唯一可以访问它的人，可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 participants</span><br></pre></td></tr></table></figure>

<p>用户想要为自己和其小组成员提供完全访问权限，可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 770 participants</span><br></pre></td></tr></table></figure>

<p>如果用户想为自己保留完全访问权限，但希望阻止其他人修改文件，可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 participants</span><br></pre></td></tr></table></figure>

<p>以下使用上面的字母来更改文件“participants”的权限，以便所有者可以读取和写入文件，但不会更改其他任何人的权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u&#x3D;rw participants</span><br></pre></td></tr></table></figure>

<p><strong>设置模式</strong> </p>
<p>使用chmod命令可以为文件和目录设置其他文件系统模式。例如，要设置粘滞位 - 这意味着只有文件所有者，目录所有者或超级用户可以删除该文件，而不管文件的读写组权限如何 - 在数字序列前加1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 1755 participants</span><br></pre></td></tr></table></figure>

<p>其他：</p>
<p>用户还可以使用chgrp命令更改现有文件和文件夹的组所有权，使用newgrp命令更改新文件和文件夹的默认组。</p>
<p>请记住，chmod命令中使用的符号链接将影响真实的目标对象。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/26/linux3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/hacker.png">
      <meta itemprop="name" content="Jackson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackson Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/26/linux3/" class="post-title-link" itemprop="url">linux基础（42-59集）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 00:03:11 / Modified: 19:03:49" itemprop="dateCreated datePublished" datetime="2020-04-26T00:03:11-05:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="P42远程管理常用命令"><a href="#P42远程管理常用命令" class="headerlink" title="P42远程管理常用命令"></a>P42远程管理常用命令</h2><h3 id="关机重启shutdown"><a href="#关机重启shutdown" class="headerlink" title="关机重启shutdown"></a>关机重启shutdown</h3><p>Linux shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。</p>
<p>使用权限：系统管理者。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown [-t seconds] [-rkhncfF] time [message]</span><br></pre></td></tr></table></figure>

<p>shutdown now 立即关机</p>
<p>shutdown +10 10分钟后关机</p>
<p><strong>参数说明</strong>：</p>
<ul>
<li>-t seconds : 设定在几秒钟之后进行关机程序。</li>
<li>-k : 并不会真的关机，只是将警告讯息传送给所有使用者。</li>
<li>-r : 关机后重新开机。（常用，一定要加，不加会启动不了了）</li>
<li>-h : 关机后停机。</li>
<li>-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。</li>
<li>-c : 取消目前已经进行中的关机动作。（常用，取消之前动作）</li>
<li>-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。</li>
<li>-F : 关机时，强迫进行 fsck 动作。</li>
<li>time : 设定关机的时间。</li>
<li>message : 传送给所有使用者的警告讯息。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>立即关机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># shutdown -h now</span><br></pre></td></tr></table></figure>

<p>指定 10 分钟后关机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># shutdown -h 10</span><br></pre></td></tr></table></figure>

<p>重新启动计算机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># shutdown -r now</span><br></pre></td></tr></table></figure>



<h3 id="查看或配置网卡信息"><a href="#查看或配置网卡信息" class="headerlink" title="查看或配置网卡信息"></a>查看或配置网卡信息</h3><h3 id="Ifconfig"><a href="#Ifconfig" class="headerlink" title="Ifconfig"></a>Ifconfig</h3><p>网卡：一个专门负责网络通讯的硬件设备。</p>
<p>Linux ifconfig命令用于显示或设置网络设备。</p>
<p>ifconfig可设置网络设备的状态，或是显示目前的设置。</p>
<p>ifconfig | grep inet： 查看网卡对应IP地址</p>
<p>ifconfig：查看网卡配置信息</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [网络设备][down up -allmulti -arp -promisc][add&lt;地址&gt;][del&lt;地址&gt;][&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;][io_addr&lt;I&#x2F;O地址&gt;][irq&lt;IRQ地址&gt;][media&lt;网络媒介类型&gt;][mem_start&lt;内存地址&gt;][metric&lt;数目&gt;][mtu&lt;字节&gt;][netmask&lt;子网掩码&gt;][tunnel&lt;地址&gt;][-broadcast&lt;地址&gt;][-pointopoint&lt;地址&gt;][IP地址]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>add&lt;地址&gt; 设置网络设备IPv6的IP地址。</li>
<li>del&lt;地址&gt; 删除网络设备IPv6的IP地址。</li>
<li>down 关闭指定的网络设备。</li>
<li>&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt; 设置网络设备的类型与硬件地址。</li>
<li>io_addr&lt;I/O地址&gt; 设置网络设备的I/O地址。</li>
<li>irq&lt;IRQ地址&gt; 设置网络设备的IRQ。</li>
<li>media&lt;网络媒介类型&gt; 设置网络设备的媒介类型。</li>
<li>mem_start&lt;内存地址&gt; 设置网络设备在主内存所占用的起始地址。</li>
<li>metric&lt;数目&gt; 指定在计算数据包的转送次数时，所要加上的数目。</li>
<li>mtu&lt;字节&gt; 设置网络设备的MTU。</li>
<li>netmask&lt;子网掩码&gt; 设置网络设备的子网掩码。</li>
<li>tunnel&lt;地址&gt; 建立IPv4与IPv6之间的隧道通信地址。</li>
<li>up 启动指定的网络设备。</li>
<li>-broadcast&lt;地址&gt; 将要送往指定地址的数据包当成广播数据包来处理。</li>
<li>-pointopoint&lt;地址&gt; 与指定地址的网络设备建立直接连线，此模式具有保密功能。</li>
<li>-promisc 关闭或启动指定网络设备的promiscuous模式。</li>
<li>[IP地址] 指定网络设备的IP地址。</li>
<li>[网络设备] 指定网络设备的名称。</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>显示网络设备信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig        </span><br><span class="line">eth0   Link encap:Ethernet HWaddr 00:50:56:0A:0B:0C </span><br><span class="line">     inet addr:192.168.0.3 Bcast:192.168.0.255 Mask:255.255.255.0</span><br><span class="line">     inet6 addr: fe80::250:56ff:fe0a:b0c&#x2F;64 Scope:Link</span><br><span class="line">     UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</span><br><span class="line">     RX packets:172220 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">     TX packets:132379 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">     collisions:0 txqueuelen:1000 </span><br><span class="line">     RX bytes:87101880 (83.0 MiB) TX bytes:41576123 (39.6 MiB)</span><br><span class="line">     Interrupt:185 Base address:0x2024 </span><br><span class="line"></span><br><span class="line">lo    Link encap:Local Loopback </span><br><span class="line">     inet addr:127.0.0.1 Mask:255.0.0.0</span><br><span class="line">     inet6 addr: ::1&#x2F;128 Scope:Host</span><br><span class="line">     UP LOOPBACK RUNNING MTU:16436 Metric:1</span><br><span class="line">     RX packets:2022 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">     TX packets:2022 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">     collisions:0 txqueuelen:0 </span><br><span class="line">     RX bytes:2459063 (2.3 MiB) TX bytes:2459063 (2.3 MiB)</span><br></pre></td></tr></table></figure>

<p>启动关闭指定网卡</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 down</span><br><span class="line"># ifconfig eth0 up</span><br></pre></td></tr></table></figure>

<p>为网卡配置和删除IPv6地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 add 33ffe:3240:800:1005::2&#x2F; 64 &#x2F;&#x2F;为网卡诶之IPv6地址</span><br><span class="line"></span><br><span class="line"># ifconfig eth0 del 33ffe:3240:800:1005::2&#x2F; 64 &#x2F;&#x2F;为网卡删除IPv6地址</span><br></pre></td></tr></table></figure>

<p>用ifconfig修改MAC地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 down &#x2F;&#x2F;关闭网卡</span><br><span class="line"># ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE &#x2F;&#x2F;修改MAC地址</span><br><span class="line"># ifconfig eth0 up &#x2F;&#x2F;启动网卡</span><br><span class="line"># ifconfig eth1 hw ether 00:1D:1C:1D:1E &#x2F;&#x2F;关闭网卡并修改MAC地址 </span><br><span class="line"># ifconfig eth1 up &#x2F;&#x2F;启动网卡</span><br></pre></td></tr></table></figure>

<p>配置IP地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 192.168.1.56 </span><br><span class="line">&#x2F;&#x2F;给eth0网卡配置IP地址</span><br><span class="line"># ifconfig eth0 192.168.1.56 netmask 255.255.255.0 </span><br><span class="line">&#x2F;&#x2F; 给eth0网卡配置IP地址,并加上子掩码</span><br><span class="line"># ifconfig eth0 192.168.1.56 netmask 255.255.255.0 broadcast 192.168.1.255</span><br><span class="line">&#x2F;&#x2F; 给eth0网卡配置IP地址,加上子掩码,加上个广播地址</span><br></pre></td></tr></table></figure>

<p>启用和关闭ARP协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 arp  &#x2F;&#x2F;开启</span><br><span class="line"># ifconfig eth0 -arp  &#x2F;&#x2F;关闭</span><br></pre></td></tr></table></figure>

<p>设置最大传输单元</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 mtu 1500 </span><br><span class="line">&#x2F;&#x2F;设置能通过的最大数据包大小为 1500 bytes</span><br></pre></td></tr></table></figure>

<h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h3><p>ping ip地址：检查目标主机连接是否正常</p>
<p>ping 本地ip：检查本地ip是否正常。（一般127.0.0.1是本地回环地址，用了检查本机网卡是否正常，localhost）</p>
<p>ping用来检查计算机间网络是否通畅，数值越大，速度越慢，ping一下计算机看是否开着</p>
<p>Linux ping命令用于检测主机。</p>
<p>执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [-dfnqrRv][-c&lt;完成次数&gt;][-i&lt;间隔秒数&gt;][-I&lt;网络界面&gt;][-l&lt;前置载入&gt;][-p&lt;范本样式&gt;][-s&lt;数据包大小&gt;][-t&lt;存活数值&gt;][主机名称或IP地址]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-d 使用Socket的SO_DEBUG功能。</li>
<li>-c&lt;完成次数&gt; 设置完成要求回应的次数。</li>
<li>-f 极限检测。</li>
<li>-i&lt;间隔秒数&gt; 指定收发信息的间隔时间。</li>
<li>-I&lt;网络界面&gt; 使用指定的网络接口送出数据包。</li>
<li>-l&lt;前置载入&gt; 设置在送出要求信息之前，先行发出的数据包。</li>
<li>-n 只输出数值。</li>
<li>-p&lt;范本样式&gt; 设置填满数据包的范本样式。</li>
<li>-q 不显示指令执行过程，开头和结尾的相关信息除外。</li>
<li>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。</li>
<li>-R 记录路由过程。</li>
<li>-s&lt;数据包大小&gt; 设置数据包的大小。</li>
<li>-t&lt;存活数值&gt; 设置存活数值TTL的大小。</li>
<li>-v 详细显示指令的执行过程。</li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>检测是否与主机连通</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># ping www.w3cschool.cc &#x2F;&#x2F;ping主机</span><br><span class="line">PING aries.m.alikunlun.com (114.80.174.110) 56(84) bytes of data.</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.025 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.036 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.034 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.034 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;5 ttl&#x3D;64 time&#x3D;0.028 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;6 ttl&#x3D;64 time&#x3D;0.028 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;7 ttl&#x3D;64 time&#x3D;0.034 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;8 ttl&#x3D;64 time&#x3D;0.034 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;9 ttl&#x3D;64 time&#x3D;0.036 ms</span><br><span class="line">64 bytes from 114.80.174.110: icmp_seq&#x3D;10 ttl&#x3D;64 time&#x3D;0.041 ms</span><br><span class="line"></span><br><span class="line">--- aries.m.alikunlun.com ping statistics ---</span><br><span class="line">10 packets transmitted, 30 received, 0% packet loss, time 29246ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.021&#x2F;0.035&#x2F;0.078&#x2F;0.011 ms</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;需要手动终止Ctrl+C</span><br></pre></td></tr></table></figure>

<p>指定接收包的次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ping -c 2 www.w3cschool.cc</span><br><span class="line">PING aries.m.alikunlun.com (114.80.174.120) 56(84) bytes of data.</span><br><span class="line">64 bytes from 114.80.174.120: icmp_seq&#x3D;1 ttl&#x3D;54 time&#x3D;6.18 ms</span><br><span class="line">64 bytes from 114.80.174.120: icmp_seq&#x3D;2 ttl&#x3D;54 time&#x3D;15.4 ms</span><br><span class="line"></span><br><span class="line">--- aries.m.alikunlun.com ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1016ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 6.185&#x2F;10.824&#x2F;15.464&#x2F;4.640 ms</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;收到两次包后，自动退出</span><br></pre></td></tr></table></figure>

<p>多参数使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ping -i 3 -s 1024 -t 255 g.cn &#x2F;&#x2F;ping主机</span><br><span class="line">PING g.cn (203.208.37.104) 1024(1052) bytes of data.</span><br><span class="line">1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq&#x3D;0 ttl&#x3D;243 time&#x3D;62.5 ms</span><br><span class="line">1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq&#x3D;1 ttl&#x3D;243 time&#x3D;63.9 ms</span><br><span class="line">1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq&#x3D;2 ttl&#x3D;243 time&#x3D;61.9 ms</span><br><span class="line"></span><br><span class="line">--- g.cn ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 6001ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 61.959&#x2F;62.843&#x2F;63.984&#x2F;0.894 ms, pipe 2</span><br><span class="line">[root@linux ~]# </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-i 3 发送周期为 3秒 -s 设置发送包的大小 -t 设置TTL值为 255</span><br></pre></td></tr></table></figure>

<h2 id="P47-52远程登录和复制文件（ssh）"><a href="#P47-52远程登录和复制文件（ssh）" class="headerlink" title="P47-52远程登录和复制文件（ssh）"></a>P47-52远程登录和复制文件（ssh）</h2><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh:"></a>ssh:</h3><p>Security shell, 数据传输加密，压缩</p>
<p>ssh [-p port] user@remote</p>
<p>user是远程机器上的用户名，如果不指定的话默认当前用户。</p>
<p>remote是远程机器的地址，可以是ip/域名，或者是后面会提到的别名。</p>
<p>port是ssh server的监听端口， 如果不指定，默认22.</p>
<p>windows下载：putty和xshell</p>
<p>使用exit退出用户登录</p>
<p><strong>ip：ip是是分配给网络上使用IP协议的设备的数字标签。</strong>我们现在经常使用的是 ipv4， 由32位二进制数字组成，常以XXX.XXX.XXX.XXX形式表现。</p>
<p><strong>域名：是由一串用“点”分隔的字符组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。</strong>如 i.cnblogs.com。</p>
<p>域名按域名系统（DNS）的规则流程组成。在DNS中注册的任何名称都是域名。域名用于各种网络环境和应用程序特定的命名和寻址目的。</p>
<p>域名和ip有区别也有联系，域名通常都会和IP绑定起来，通过访问域名来访问网络主机上的服务。ip地址通常是指主机，而域名通常表示一个网站。一个域名可以绑定到多个ip，多个域名也可以绑定到一个ip。</p>
<p><strong>域名系统（DNS）：因特网上作为域名和ip地址相互映射的分布式数据库，能使用户更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址。通过主机名，最终得到该主机名对应的ip地址的过程叫做域名解析。 DNS协议运行在UDP协议之上，端口号53。</strong></p>
<p><strong>端口号：端口，（英语：port），主要分为物理端口和逻辑端口。</strong>我们一般说的都是逻辑端口，用于区分不同的服务。因为网络中一台主机只有一个IP，但是一个主机可以提供多个服务，端口号就用于区分一个主机上的不同服务。一个IP地址的端口通过16bit进行编号，最多可以有65536个端口，标识是从0<del>65535。**端口号分为公认端口（0</del>1023）、注册端口（1024<del>49151）和动态端口（49152</del>65535）。**我们自己的服务一般都绑定在注册端口上。</p>
<p><strong>跨域：</strong>在 HTML 中，<code>,</code>, <code>,</code>, <code>,</code> 等标签以及 Ajax 都可以指向一个资源地址，<strong>而所谓的跨域请求就是指</strong>：当前发起请求的域与该请求指向的资源所在的域不一样。<strong>这里的域指的是这样的一个概念：我们认为若协议 + 域名 + 端口号均相同，那么就是同域。</strong></p>
<h3 id="常见的端口号及其用途"><a href="#常见的端口号及其用途" class="headerlink" title="常见的端口号及其用途"></a><a href="https://www.cnblogs.com/innershare/p/10749981.html" target="_blank" rel="noopener">常见的端口号及其用途</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">一些常见的端口号及其用途如下：</span><br><span class="line">21端口：FTP 文件传输服务（常用）</span><br><span class="line">22端口：SSH 端口（常用）</span><br><span class="line">23端口：TELNET 终端仿真服务</span><br><span class="line">25端口：SMTP 简单邮件传输服务</span><br><span class="line">53端口：DNS 域名解析服务</span><br><span class="line">80端口：HTTP 超文本传输服务，web端口（常用）</span><br><span class="line">110端口：POP3 “邮局协议版本3”使用的端口</span><br><span class="line">443端口：HTTPS 加密的超文本传输服务（常用）</span><br><span class="line">1433端口：MS SQL*SERVER数据库 默认端口号</span><br><span class="line">1521端口：Oracle数据库服务</span><br><span class="line">1863端口：MSN Messenger的文件传输功能所使用的端口</span><br><span class="line">3306端口：MYSQL 默认端口号（常用）</span><br><span class="line">3389端口：Microsoft RDP 微软远程桌面使用的端口</span><br><span class="line">5631端口：Symantec pcAnywhere 远程控制数据传输时使用的端口</span><br><span class="line">5632端口：Symantec pcAnywhere 主控端扫描被控端时使用的端口</span><br><span class="line">5000端口：MS SQL Server使用的端口</span><br><span class="line">8000端口：腾讯QQ</span><br></pre></td></tr></table></figure>

<p>   SSH(远程连接工具)连接原理：ssh服务是一个守护进程(demon)，系统后台监听客户端的连接，ssh服务端的进程名为sshd,负责实时监听客户端的请求(IP 22端口)，包括公共秘钥等交换等信息。</p>
<p>ssh服务端由2部分组成： openssh(提供ssh服务)  openssl(提供加密的程序)</p>
<p>ssh的客户端可以用 XSHELL，Securecrt, Mobaxterm等工具进行连接</p>
<h3 id="SSH的工作机制"><a href="#SSH的工作机制" class="headerlink" title="SSH的工作机制"></a>SSH的工作机制</h3><p>   服务器启动的时候自己产生一个密钥(768bit公钥)，本地的ssh客户端发送连接请求到ssh服务器，服务器检查连接点客户端发送的数据和IP地址，确认合法后发送密钥(768bits)给客户端，此时客户端将本地私钥(256bit)和服务器的公钥(768bit)结合成密钥对key(1024bit),发回给服务器端，建立连接通过key-pair数据传输。    </p>
<h3 id="SSH的加密技术"><a href="#SSH的加密技术" class="headerlink" title="SSH的加密技术"></a>SSH的加密技术</h3><p>加密技术：传输过程，数据加密。<br>1.SSH1没有对客户端的秘钥进行校验，很容易被植入恶意代码<br>2.SSH2增加了一个确认联机正确性的Diffe_Hellman机制，每次数据的传输，Server都会检查数据来源的正确性，避免黑客入侵。<br> SSH2支持RSA和DSA密钥<br>    DSA:digital signature Algorithm 数字签名<br>    RSA:既可以数字签名又可以加密    </p>
<h3 id="SSH知识小结"><a href="#SSH知识小结" class="headerlink" title="SSH知识小结"></a>SSH知识小结</h3><p>  1.SSH是安全的加密协议，用于远程连接Linux服务器<br>  2.SSH的默认端口是22，安全协议版本是SSH2<br>  3.SSH服务器端主要包含2个服务功能SSH连接和SFTP服务器<br>  4.SSH客户端包含ssh连接命令和远程拷贝scp命令等 </p>
<h3 id="如何防止SSH登录入侵"><a href="#如何防止SSH登录入侵" class="headerlink" title="如何防止SSH登录入侵"></a>如何防止SSH登录入侵</h3><p>  1.密钥登录,更改端口<br>  2.牤牛阵法<br>  3.监听本地内网IP(ListenAddress 192.168.25.*)</p>
<h3 id="SSH功能大全"><a href="#SSH功能大全" class="headerlink" title="SSH功能大全"></a>SSH功能大全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.登录          &#96;&#96;    &#96;&#96;ssh&#96; &#96;-p22 omd@192.168.25.137        &#96;&#96;  &#96;&#96;2.直接执行命令 --&gt;最好全路径          &#96;&#96;    &#96;&#96;ssh&#96; &#96;root@192.168.25.137 &#96;&#96;ls&#96; &#96;-ltr &#96;&#96;&#x2F;backup&#x2F;data&#96;            &#96;      &#96;&#96;&#x3D;&#x3D;&gt;&#96;&#96;ssh&#96; &#96;root@192.168.25.137 &#96;&#96;&#x2F;bin&#x2F;ls&#96; &#96;-ltr &#96;&#96;&#x2F;backup&#x2F;data&#96;        &#96;  &#96;&#96;3.查看已知主机           &#96;&#96;    &#96;&#96;cat&#96; &#96;&#x2F;root&#x2F;&#96;&#96;.&#96;&#96;ssh&#96;&#96;&#x2F;known_hosts&#96;&#96;  &#96;&#96;4.&#96;&#96;ssh&#96;&#96;远程执行&#96;&#96;sudo&#96;&#96;命令&#96;&#96;    &#96;&#96;ssh&#96; &#96;-t omd@192.168.25.137 &#96;&#96;sudo&#96; &#96;rsync&#96; &#96;hosts &#96;&#96;&#x2F;etc&#x2F;&#96; &#96;  &#96;&#96;5.&#96;&#96;scp&#96;        &#96;       &#96;&#96;1.功能  --&gt;远程文件的安全(加密)拷贝          &#96;&#96;         &#96;&#96;scp&#96; &#96;-P22 -r -p &#96;&#96;&#x2F;home&#x2F;omd&#x2F;h&#96;&#96;.txt omd@192.168.25.137:&#96;&#96;&#x2F;home&#x2F;omd&#x2F;&#96;        &#96;       &#96;&#96;2.&#96;&#96;scp&#96;&#96;知识小结          &#96;&#96;         &#96;&#96;scp&#96;&#96;是加密远程拷贝，&#96;&#96;cp&#96;&#96;为本地拷贝          &#96;&#96;         &#96;&#96;可以推送过去，也可以拉过来          &#96;&#96;         &#96;&#96;每次都是全量拷贝(效率不高，适合第一次)，增量拷贝用&#96;&#96;rsync&#96; &#96;  &#96;&#96;6.&#96;&#96;ssh&#96;&#96;自带的&#96;&#96;sftp&#96;&#96;功能        &#96;&#96;       &#96;&#96;1.Window和Linux的传输工具          &#96;&#96;         &#96;&#96;wincp  filezip          &#96;&#96;        &#96;&#96;sftp&#96; &#96;--&gt;基于&#96;&#96;ssh&#96;&#96;的安全加密传输          &#96;&#96;        &#96;&#96;samba  &#96;&#96;       &#96;&#96;2.&#96;&#96;sftp&#96;&#96;客户端连接          &#96;&#96;        &#96;&#96;sftp&#96; &#96;-oPort&#x3D;22 root@192.168.25.137          &#96;&#96;        &#96;&#96;put &#96;&#96;&#x2F;etc&#x2F;hosts&#96; &#96;&#x2F;tmp&#96;          &#96;        &#96;&#96;get &#96;&#96;&#x2F;etc&#x2F;hosts&#96; &#96;&#x2F;home&#x2F;omd&#96;  &#96;      &#96;&#96;3.&#96;&#96;sftp&#96;&#96;小结：          &#96;&#96;        &#96;&#96;1.linux下使用命令： &#96;&#96;sftp&#96; &#96;-oPort&#x3D;22 root@x.x.x.x          &#96;&#96;        &#96;&#96;2.put加客户端本地路径上传          &#96;&#96;        &#96;&#96;3.get下载服务器端内容到本地          &#96;&#96;        &#96;&#96;4.远程连接默认连接用户的家目录</span><br></pre></td></tr></table></figure>

<h3 id="ssh常见命令参数"><a href="#ssh常见命令参数" class="headerlink" title="ssh常见命令参数"></a>ssh常见命令参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usage: &#96;&#96;ssh&#96; &#96;[-1246AaCfgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]&#96;&#96;      &#96;&#96;[-D [bind_address:]port] [-e escape_char] [-F configfile]&#96;&#96;      &#96;&#96;[-i identity_file] [-L [bind_address:]port:host:hostport]&#96;&#96;      &#96;&#96;[-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]&#96;&#96;      &#96;&#96;[-R [bind_address:]port:host:hostport] [-S ctl_path]&#96;&#96;      &#96;&#96;[-W host:port] [-w local_tun[:remote_tun]]&#96;&#96;      &#96;&#96;[user@]&#96;&#96;hostname&#96; &#96;[&#96;&#96;command&#96;&#96;]</span><br></pre></td></tr></table></figure>

<h3 id="关于后台ssh服务的相关"><a href="#关于后台ssh服务的相关" class="headerlink" title="关于后台ssh服务的相关"></a>关于后台ssh服务的相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 查询openssl软件&#96;&#96;  &#96;&#96;rpm -qa openssh openssl&#96;&#96;# 查询sshd进程&#96;&#96;  &#96;&#96;ps&#96; &#96;-ef | &#96;&#96;grep&#96; &#96;ssh&#96;&#96;    &#96;&#96;--&gt; &#96;&#96;&#x2F;usr&#x2F;sbin&#x2F;sshd&#96;&#96;# 查看ssh端口&#96;&#96;  &#96;&#96;netstat&#96; &#96;-lntup | &#96;&#96;grep&#96; &#96;ssh&#96; &#96;  &#96;&#96;ss | &#96;&#96;grep&#96; &#96;ssh&#96;        &#96;(效果同上，同下，好用)&#96;&#96;  &#96;&#96;netstat&#96; &#96;-a | &#96;&#96;grep&#96; &#96;ssh&#96;&#96;(记住这个)&#96;&#96;  &#96;&#96;netstat&#96; &#96;-lnt | &#96;&#96;grep&#96; &#96;22  &#x3D;&#x3D;&gt; 查看22端口有没有开&#96;&#96;&#x2F;ssh&#96;&#96;服务有没有开启&#96;&#96;  &#96;&#96;技巧： &#96;&#96;netstat&#96; &#96;-lnt | &#96;&#96;grep&#96; &#96;ssh&#96; &#96;| &#96;&#96;wc&#96; &#96;-l --&gt;只要大于2个就是&#96;&#96;ssh&#96;&#96;服务就是好的&#96;&#96;# 查看ssh的秘钥目录&#96;&#96;  &#96;&#96;ll &#96;&#96;&#x2F;root&#x2F;&#96;&#96;.&#96;&#96;ssh&#96;&#96;&#x2F;known_hosts&#96; &#96;# 当前用户家目录的.ssh目录下&#96;&#96;# ssh的配置文件&#96;&#96;  &#96;&#96;cat&#96; &#96;&#x2F;etc&#x2F;ssh&#x2F;sshd_config&#96;  &#96;# ssh服务的关闭&#96;&#96;  &#96;&#96;service sshd stop&#96;&#96;# ssh服务的开启：&#96;&#96;  &#96;&#96;service sshd start&#96;&#96;# ssh服务的重启&#96;&#96;  &#96;&#96;service sshd reload  [停止进程后重启] &#x3D;&#x3D;&gt; 推荐&#96;&#96;  &#96;&#96;service sshd restart  [干掉进程后重启] &#x3D;&#x3D;&gt; 不推荐&#96;&#96;# ssh远程登录&#96;&#96;  &#96;&#96;ssh&#96; &#96;192.168.1.100   &#96;&#96;# 默认利用当前宿主用户的用户名登录&#96;&#96;  &#96;&#96;ssh&#96; &#96;omd@192.168.1.100 &#96;&#96;# 利用远程机的用户登录&#96;&#96;  &#96;&#96;ssh&#96; &#96;omd@192.168.1.100 -o stricthostkeychecking&#x3D;no &#96;&#96;# 首次登陆免输yes登录&#96;&#96;  &#96;&#96;ssh&#96; &#96;omd@192.168.1.100 &#96;&#96;&quot;ls &#x2F;home&#x2F;omd&quot;&#96; &#96;# 当前服务器A远程登录服务器B后执行某个命令&#96;&#96;  &#96;&#96;ssh&#96; &#96;omd@192.168.1.100 -t &#96;&#96;&quot;sh &#x2F;home&#x2F;omd&#x2F;ftl.sh&quot;&#96; &#96;# 当前服务器A远程登录服务器B后执行某个脚本</span><br></pre></td></tr></table></figure>



<p><a href="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235424314-1763487959.png" target="_blank" rel="noopener"><img src="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235425105-243399260.png" alt="image"></a></p>
<h3 id="ssh免密设置"><a href="#ssh免密设置" class="headerlink" title="ssh免密设置"></a>ssh免密设置</h3><p>1、进入用户的家目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]&#96;&#96;# cd &#x2F;root&#x2F;.ssh&#x2F;       【root用户就在root目录下的.ssh目录】&#96;&#96;[root@localhost ~]&#96;&#96;# cd &#x2F;home&#x2F;omd&#x2F;.ssh&#x2F;  【普通用户就是在家目录下的.ssh目录】</span><br></pre></td></tr></table></figure>

<p><a href="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235425480-983102625.png" target="_blank" rel="noopener"><img src="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235425878-2009080640.png" alt="image"></a></p>
<p>2、根据DSA算法生成私钥和公钥【默认建立在当前用户的家目录】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost .&#96;&#96;ssh&#96;&#96;]&#96;&#96;# ssh-keygen -t dsa   # 一路回车即可&#96;&#96;        &#96;&#96;id_dsa     --&gt;私钥(钥匙) &#96;&#96;        &#96;&#96;id_dsa.pub   --&gt;公钥(锁)</span><br></pre></td></tr></table></figure>

<p><a href="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235426240-141091905.png" target="_blank" rel="noopener"><img src="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235426686-779103595.png" alt="image"></a></p>
<p>3.拷贝公钥给目标服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost .&#96;&#96;ssh&#96;&#96;]&#96;&#96;# ssh-copy-id -i id_dsa.pub omd@192.168.25.110       【 使用ssh登录的默认端口22】&#96;&#96;[root@localhost .&#96;&#96;ssh&#96;&#96;]&#96;&#96;# ssh-copy-id -i id_dsa.pub –p 666 omd@192.168.25.120  【使用ssh登录设置的端口666】</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/519608/201808/519608-20180812120135470-239324972.png" alt="img"></p>
<p>\4. 查看目标服务器生成的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[omd@localhost .&#96;&#96;ssh&#96;&#96;]$ ll &#96;&#96;&#x2F;home&#x2F;omd&#x2F;&#96;&#96;.&#96;&#96;ssh&#96;&#96;&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>

<p><a href="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235427845-1655006958.png" target="_blank" rel="noopener"><img src="https://images2018.cnblogs.com/blog/519608/201807/519608-20180705235428167-614741798.png" alt="image"></a></p>
<p>\5. 免密码登录目标服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh&#96; &#96;omd@192.168.25.110</span><br></pre></td></tr></table></figure>

<p>\6. 总结一下钥匙和锁的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.多个钥匙开一把锁&#96;&#96;   &#96;&#96;把id_dsa.pub 复制给各个服务器&#96; &#96;2.一个钥匙开duobasuo&#96;&#96;   &#96;&#96;把id_dsa 传给各个服务器&#96;&#96;   &#96;&#96;把id_dsa 传给自己</span><br></pre></td></tr></table></figure>

<h3 id="ssh排查问题"><a href="#ssh排查问题" class="headerlink" title="ssh排查问题"></a>ssh排查问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.判断物理链路是否通 &#96;&#96;ping&#96; &#96;192.168.25.130   线路 | 防火墙 | 是否同一个网的&#96;&#96;      &#96;&#96;ping&#96;  &#96;本身是icmp协议&#96;&#96;2.判断服务是否正常</span><br><span class="line">telnet 192.168.25.130 22</span><br><span class="line">3.Linux防火墙</span><br><span class="line">service iptables status &#x3D;&#x3D;&gt; &#96;&#96;&#x2F;etc&#x2F;init&#96;&#96;.d&#96;&#96;&#x2F;iptables&#96; &#96;status　　</span><br><span class="line">4.打开&#96;&#96;ssh&#96;&#96;的调测进行观察</span><br><span class="line">ssh&#96; &#96;-vvv omd@192.168.1.100</span><br></pre></td></tr></table></figure>

<h3 id="SSH批量分发与管理方案小结"><a href="#SSH批量分发与管理方案小结" class="headerlink" title="SSH批量分发与管理方案小结"></a>SSH批量分发与管理方案小结</h3><p>1.利用root做ssh key验证</p>
<blockquote>
<p>优点：简单，易用<br>  缺点：安全性能差，无法禁止root远程连接</p>
</blockquote>
<p>2.利用普通用户omd        –&gt;推荐</p>
<blockquote>
<p>  思路：把要分发的文件拷贝到服务器用户的家目录，然后利用sudo提权拷贝分发的文件和对应目录<br>  优点：安全<br>  缺点：复杂，配置麻烦<br>  1.sudo提权<br>    echo ‘omd   All=(All)   NOPASSWD:/usr/bin/rsync’ &gt;&gt; /etc/sudoers<br>    visudo -c<br>    grep omd /etc/sudoers<br>  2.ssh分发到服务器的家目录<br>    ssh -p22 -r /etc/hosts <a href="mailto:omd@192.168.25.137">omd@192.168.25.137</a>:~<br>  3.ssh使用sudo复制到目标服务器的/etc<br>    ssh -t <a href="mailto:omd@192.168.25.137">omd@192.168.25.137</a> sudo rsync hosts /etc/</p>
</blockquote>
<p>3.拓展方案2，不用sudo，而是设置suid对固定命令提权</p>
<blockquote>
<p> 优点：相当安全<br>    缺点：复杂，安全性较差，任何人都可以处理带有suid权限的命令<br>    1.which rsync<br>    2.chmod 4755 /usr/bin/rsync    </p>
</blockquote>
<h3 id="ssh章节小结"><a href="#ssh章节小结" class="headerlink" title="ssh章节小结"></a>ssh章节小结</h3><p>  1.ssh远程的加密连接协议，相关软件openssh,openssl<br>  2.默认端口22<br>  3.ssh版本协议<br>  4.服务器ssh连接，ftp连接，sshd守护进程，开机启动<br>  5.ssh客户端重要命令：ssh(用户登录&amp;&amp;远程命令),scp,sftp,<br>  6.安全验证方式：口令，密钥 学习原理<br>  7.ssh服务优化：改端口，改监听，no root,no empty,no DNS,<br>  8.ssh密钥对，公钥在服务器端，私钥在客户端</p>
<h3 id="修改ssh服务的启动文件sshd的几个点"><a href="#修改ssh服务的启动文件sshd的几个点" class="headerlink" title="修改ssh服务的启动文件sshd的几个点"></a>修改ssh服务的启动文件sshd的几个点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-1修改 &#96;&#96;&#x2F;etc&#x2F;ssh&#x2F;sshd_config&#96;&#96;     GSSAPIAuthentication &#96;&#96;yes&#96;  &#96;解决一台服务器管理多个&#96;&#96;ssh&#96;&#96;服务&#96;&#96;  &#96;&#96;UseDNS no 加快响应速度因为在内网环境下&#96;&#96;  &#96;&#96;PermitRootLogin no 不运行root用户直接登录&#96;&#96;  &#96;&#96;Port 11544 更改访问端口号&#96;&#96;  &#96;&#96;ListenAddress 192.168.25.130 只监听内网的IP&#96;&#96;  &#96;&#96;Match User anoncvs   当前环境允许登录的用户&#96;&#96;  &#96;&#96;PermitRootLogin no   是否允许root用户登录，一般不允许开&#96;&#96;1-2重启服务&#96;&#96;  &#96;&#96;service sshd restart    写入命令进内存&#96;&#96;  &#96;&#96;service sshd reload(优先) reload是一个平滑的访问，不影响用户使用&#96;&#96;1-3查看连接端口&#96;&#96;  &#96;&#96;netstat&#96; &#96;-an | &#96;&#96;grep&#96; &#96;EST</span><br></pre></td></tr></table></figure>

<h3 id="SSH跳过HostKeyChecking，不用输入yes"><a href="#SSH跳过HostKeyChecking，不用输入yes" class="headerlink" title="SSH跳过HostKeyChecking，不用输入yes"></a><strong>SSH跳过</strong>HostKeyChecking，不用输入yes</h3><p>SSH跳过输入ssh跳过RSA key fingerprint输入yes/no</p>
<p>在配置大量的节点之间需要ssh连通的时候，如果自动复制很多节点，都需要输入yes，两两节点之间都要互通一次，这样会造成很大的麻烦</p>
<p><strong>解决1；</strong>修改配置文件/etc/ssh/ssh_config</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找 到 # StrictHostKeyChecking ask &#96;&#96;修改为：StrictHostKeyChecking &#96;&#96;no</span><br></pre></td></tr></table></figure>

<p><strong>解决2：</strong> 添加参数 –o 【o=option】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.25.133 -o &#96;&#96;&quot;StrictHostKeyChecking no&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/519608/201808/519608-20180811164712431-1409487808.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -o &#96;&#96;&quot;StrictHostKeyChecking no&quot;&#96; &#96;newfile.txt &#96;&quot;mailto:root@192.168.25.133:&#x2F;root&quot;&#96;&#96;&gt;root@192.168.25.133:&#x2F;root</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/519608/201808/519608-20180811164724290-117606623.png" alt="img"></p>
<h2 id="P53-55远程登录和复制文件（scp）"><a href="#P53-55远程登录和复制文件（scp）" class="headerlink" title="P53-55远程登录和复制文件（scp）"></a>P53-55远程登录和复制文件（scp）</h2><p>scp：secure copy </p>
<p>指定端口-P port：注意是大写的P, port是指定数据传输用到的端口号（常用）</p>
<p>Linux scp 命令用于 Linux 之间复制文件和目录。</p>
<p>scp 是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。</p>
<p>scp 是加密的，<a href="https://www.runoob.com/linux/linux-comm-rcp.html" target="_blank" rel="noopener">rcp</a> 是不加密的，scp 是 rcp 的加强版。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]</span><br><span class="line">[-l limit] [-o ssh_option] [-P port] [-S program]</span><br><span class="line">[[user@]host1:]file1 [...] [[user@]host2:]file2</span><br></pre></td></tr></table></figure>

<p>简易写法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [可选参数] file_source file_target</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li>-1： 强制scp命令使用协议ssh1</li>
<li>-2： 强制scp命令使用协议ssh2</li>
<li>-4： 强制scp命令只使用IPv4寻址</li>
<li>-6： 强制scp命令只使用IPv6寻址</li>
<li>-B： 使用批处理模式（传输过程中不询问传输口令或短语）</li>
<li>-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li>
<li>-p：保留原文件的修改时间，访问时间和访问权限。</li>
<li>-q： 不显示传输进度条。</li>
<li>-r： 递归复制整个目录。(常用)</li>
<li>-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li>
<li>-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li>
<li>-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li>
<li>-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li>
<li>-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。</li>
<li>-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，</li>
<li>-P port：注意是大写的P, port是指定数据传输用到的端口号（常用）</li>
<li>-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li>
</ul>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><h4 id="1、从本地复制到远程"><a href="#1、从本地复制到远程" class="headerlink" title="1、从本地复制到远程"></a>1、从本地复制到远程</h4><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_username@remote_ip:remote_file </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_ip:remote_file</span><br></pre></td></tr></table></figure>



<ul>
<li>第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名； </li>
<li>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；</li>
</ul>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3 </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3</span><br></pre></td></tr></table></figure>

<p>复制目录命令格式： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp -r local_folder remote_ip:remote_folder</span><br></pre></td></tr></table></figure>

<ul>
<li>第1个指定了用户名，命令执行后需要再输入密码；</li>
<li>第2个没有指定用户名，命令执行后需要输入用户名和密码；</li>
</ul>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; </span><br><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;</span><br></pre></td></tr></table></figure>

<p>上面命令将本地 music 目录复制到远程 others 目录下。</p>
<h4 id="2、从远程复制到本地"><a href="#2、从远程复制到本地" class="headerlink" title="2、从远程复制到本地"></a>2、从远程复制到本地</h4><p>从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例 </p>
<p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 </span><br><span class="line">scp -r www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; &#x2F;home&#x2F;space&#x2F;music&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>1.如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#scp 命令使用端口号 4588</span><br><span class="line">scp -P 4588 remote@www.runoob.com:&#x2F;usr&#x2F;local&#x2F;sin.sh &#x2F;home&#x2F;administrator</span><br></pre></td></tr></table></figure>

<p>2.使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。</p>
<h2 id="（scp-remote-to-local）："><a href="#（scp-remote-to-local）：" class="headerlink" title="（scp remote to local）："></a>（scp remote to local）：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r XXX@atlas.cselabs.umn.edu:~&#x2F;Desktop&#x2F;p3-code ~&#x2F;Desktop：</span><br></pre></td></tr></table></figure>



<h2 id="（scp-local-to-remote）"><a href="#（scp-local-to-remote）" class="headerlink" title="（scp local to remote）:"></a>（scp local to remote）:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r  ~&#x2F;Desktop&#x2F;C++CODE xxx@ipaddress: ~&#x2F;Desktop</span><br></pre></td></tr></table></figure>

<p>df -h:查看磁盘容量</p>
<p>Windows没有scp命令，需要安装PuTTy，用pscp命令或者安装FileZilla使用FTP进行文件传输。</p>
<h2 id="P56-59（ssh高级）"><a href="#P56-59（ssh高级）" class="headerlink" title="P56-59（ssh高级）"></a>P56-59（ssh高级）</h2><h3 id="免密码登录和配置别名"><a href="#免密码登录和配置别名" class="headerlink" title="免密码登录和配置别名"></a>免密码登录和配置别名</h3><p>ssh配置都在用户家目录下的.ssh目录下</p>
<p>ls -alh, 找到.ssh隐藏文件，如何cd进入，然后ls -alh看known_hosts，可以看到已经有的连接。</p>
<h3 id="免密码登录："><a href="#免密码登录：" class="headerlink" title="免密码登录："></a>免密码登录：</h3><p>步骤：1. 配置公钥: ssh-keygen即可生成ssh钥匙，一路回车即可</p>
<p>​            2.上传公钥到服务器：ssh-copy-id -p port user@remote, 可以让服务器记住公钥。</p>
<p>ssh是什么？ssh (SSH client) is a program for logging into a remote machine and for executing commands on a remote machine. （自己翻译哈）</p>
<p>讲ssh服务的用法之前得需要知道这个服务是否已经开启</p>
<p>查看ssh服务是否开启的命令:systemctl status sshd。输入这个命令之后，会得到如下的一个提示</p>
<p><img src="https://img-blog.csdn.net/20150118231938468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHh1cWlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>第二行最后一个单词disabled表示sshd服务开机不自动启动</p>
<p>第三行inactive（dead）表示sshd服务当前是关闭的</p>
<p>现在我们来开启sshd服务，输入systemctl start sshd，然后再输入systemctl status sshd查看结果</p>
<p><img src="https://img-blog.csdn.net/20150118232419468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHh1cWlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>现在我们可以看到第三行是active（running），这表示sshd服务当前是开启的，但仍然是开机不启动。不过，这并不影响我们使用sshd，至于如何管理这些服务，并不在我们本节讨论范围内。</p>
<p>ssh可以干什么，举个例子，我现在有个朋友电脑出了点问题，但是现在他在北京，我在西安 ，为给他修个电脑，我不划算去北京吧，怎么办？用ssh。</p>
<p>首先得知道他的ip地址，然后登录他的root用户，用命令：ssh root@<strong><em>.</em></strong>.<em>.**</em>  星号代表ip</p>
<p><img src="https://img-blog.csdn.net/20150118234218989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHh1cWlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>输入完命令后，会有一个提示，问你是否确信连接？输入yes，再然后输入他root的密码，就进入他的电脑了。但这样有个不好的地方，我知道了他root的密码，那以后岂不是可以在他的电脑上为所欲为了，这样他肯定是不愿意的，我要是不小心删掉了他珍藏多年的种子，他肯定会杀了我。</p>
<p>######我现在是他的身份#####</p>
<p>  那在这种情况下，他应该怎么办？（ps：我现在以他的身份来做）可以先给自己的电脑上一把锁，然后需要进入你电脑的人一把钥匙，你不想让别人进的时候把锁删掉就行了。那具体怎么做呢？</p>
<p>第一步：删除/root/.ssh/下的所有东西，如果没有.shh文件夹，建立一个。</p>
<p>第二步：在.ssh文件夹下，建立钥匙，使用命令ssh-keygen</p>
<p><img src="https://img-blog.csdn.net/20150119000500906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHh1cWlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>输入命令后，第一个提示问你存在哪里，默认就好，直接回车。第二个问题让你输入一个密码，这个密码就是以后别人在拥有私钥的情况下，进入你主机需要的密码。输入完再输入一次，就会生成一个钥匙跟一把锁。</p>
<p><img src="https://img-blog.csdn.net/20150119000931595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHh1cWlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>id_rsa叫私钥，也就是钥匙，id_rsa.pub叫公钥。</p>
<p>第三步：用锁来锁定本机的哪个用户，以root为例，命令是ssh-copy-id root@<strong><em>.</em></strong>.<em>.**</em>  id为本机的id。回车之后会提示你是否连接？回答yes就行，然后会提示你输入要锁定用户的密码，现在要锁定root ，那就输入root密码就行。</p>
<p>第四步：谁想连本机，把私钥发给谁就行，比如说，我发给一个叫playsand的用户。命令是：</p>
<p> scp id_rsa playsand@<strong><em>.</em></strong>.<em>.**</em>:/home/playsand/.ssh 这个星号代表的是playsand用户的id，后面代表的是存储路径，一定要在playsand下建立一个.ssh目录，如果有，则将里面内容清空。</p>
<p>#####现在我是playsand用户#####</p>
<p>在自己的.ssh目录下，输入ssh root@<strong><em>.</em></strong>.<em>.**</em> id是root的id，回车之后会提示你是否连接？回答yes，然后会提示输入密码，这个密码就是上面第二步设定的密码，输入之后，就进入了。如果输入错了，系统会提示你输入root的密码，同样，输入root密码也可以进入，这就跟刚开始一样。</p>
<p>#####现在我是root用户####</p>
<p>在这里有几个小小的设置：</p>
<p>1.让别人登录自己的root用户是件很危险的事，怎么能让别人怎么都登录不了自己的root用户呢；</p>
<p>编辑ssh_config文件(vim /etc/ssh/ssh_config),将#PermitRootLogin yes改成PermitRootLogin no(大约在48行)，推出保存之后，重启以下ssh服务（systemctl reload sshd）</p>
<p>2.要是不认识的人或者有恶意的人不小心得到了私钥和密码，对于本机来说很危险，可以设置白名单，让指定的人可以登录；</p>
<p>同样vim /etc/ssh/ssh_config,找一个空行写下：allowusers 指定用户名，这样只有指定的用户可以登录本机。e.g：allowusers playsand  就是允许playsand用户登录，其他用户都登录不了，同理，重启下ssh服务。</p>
<p>3.让别人知道登录自己的root密码或者用户密码总是不安全的，怎样让别人只能通过私钥密码登录？</p>
<p>同样vim /etc/ssh/ssh_config,将passwordAuthentication yes 改成passwordAuthentication no ，这样，别人只能通过私钥密码登录本机。修改完重启ssh服务。</p>
<p>使用ssh登录服务器的时候，需要输入ip地址、端口、用户名、密码等信息，比较麻烦，容易输错。还好，通过客户端和服务器的配置参数，可实现免密码快速登录。服务器可通过保存客户端的公钥，用于验证客户端的身份，从而省去输入密码的步骤。客户端也可通过配置服务器参数来简化登录命令。<br>本文主要是记录了ssh面密码快速登录的配置过程，主要分为以下几个步骤。</p>
<ol>
<li>客户端生成密钥，包括私钥和公钥。</li>
<li>在服务器中配置客户端的公钥。</li>
<li>在客户端配置服务器登录相关参数。</li>
</ol>
<p>本文示例中的服务器ip地址为192.168.1.1，ssh端口为22。</p>
<h2 id="客户端生成密钥"><a href="#客户端生成密钥" class="headerlink" title="客户端生成密钥"></a>客户端生成密钥</h2><p>客户端生成密钥的方法很简单，只需要使用ssh-keygen命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>生成密钥过程中，建议采用默认值，只需要按三次回车之后，就会再～/.ssh目录下生成密钥文件，其中，id_rsa为私钥，id_rsa.pub为公钥。 </p>
<h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>服务器的~/.ssh/authorized_keys文件保存可快速连接的客户端的公钥。只需把客户端生成的id_rsa.pub文件的内容拷贝到authorized_keys文件的末尾。拷贝的方法有：</p>
<ol>
<li>直接拷贝。由于id_rsa.pub和authorized_keys都是文本文件，可通过拷贝命令直接拷贝。</li>
<li>把id_rsa.pub上传到服务器，然后再把内容添加到authorized_keys文件中。<br>在客户端把文件上传到服务器的用户目录的操作命令如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~&#x2F;.ssh&#x2F;id_rsa.pub root@192.168.1.1:</span><br></pre></td></tr></table></figure>

<p>在服务器操作的命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>


<p>配置好之后，登录服务器就不再需要密码了。 </p>
<h2 id="在客户端配置服务器登录相关参数"><a href="#在客户端配置服务器登录相关参数" class="headerlink" title="在客户端配置服务器登录相关参数"></a>在客户端配置服务器登录相关参数</h2><p>除了密码之外，登录时，还需要配置ip地址、端口、用户等信息，也比较繁琐。可通过客户端的~/.ssh/config配置服务器的相关参数简化登录命令。<br>config文件的配置内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host server</span><br><span class="line">Hostname 192.168.1.1</span><br><span class="line">Port 22</span><br><span class="line">User bingoli</span><br></pre></td></tr></table></figure>


<p>其中，Host为服务器的名称，输入登录命令时使用，后续登录只需要记住这个名字就可以；Hostname为服务器的ip地址；Port为ssh的端口；User为服务器的用户名。配置好相关参数之后，就可以使用简化的命令登录服务器了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh server</span><br></pre></td></tr></table></figure>

<h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>在本地.ssh文件夹下vi config，然后</p>
<p>Host school</p>
<p>​    HostName ip地址</p>
<p>​    User xxxx</p>
<p>​    Port 22</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jackson"
      src="/uploads/hacker.png">
  <p class="site-author-name" itemprop="name">Jackson</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jackson</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
